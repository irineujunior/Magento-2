require.config({"config": {
        "jsbuild":{"Magento_Tinymce3/tiny_mce/tiny_mce_src.js":"(function(win) {\r\n\tvar whiteSpaceRe = /^\\s*|\\s*$/g,\r\n\t\tundefined, isRegExpBroken = 'B'.replace(/A(.)|B/, '$1') === '$1';\r\n\r\n\tvar tinymce = {\r\n\t\tmajorVersion : '3',\r\n\r\n\t\tminorVersion : '4.7',\r\n\r\n\t\treleaseDate : '2011-11-03',\r\n\r\n\t\t_init : function() {\r\n\t\t\tvar t = this, d = document, na = navigator, ua = na.userAgent, i, nl, n, base, p, v;\r\n\r\n\t\t\tt.isOpera = win.opera && opera.buildNumber;\r\n\r\n\t\t\tt.isWebKit = /WebKit/.test(ua);\r\n\r\n\t\t\tt.isIE = !t.isWebKit && !t.isOpera && (/MSIE/gi).test(ua) && (/Explorer/gi).test(na.appName);\r\n\r\n\t\t\tt.isIE6 = t.isIE && /MSIE [56]/.test(ua);\r\n\r\n\t\t\tt.isIE7 = t.isIE && /MSIE [7]/.test(ua);\r\n\r\n\t\t\tt.isIE8 = t.isIE && /MSIE [8]/.test(ua);\r\n\r\n\t\t\tt.isIE9 = t.isIE && /MSIE [9]/.test(ua);\r\n\r\n\t\t\tt.isGecko = !t.isWebKit && /Gecko/.test(ua);\r\n\r\n\t\t\tt.isMac = ua.indexOf('Mac') != -1;\r\n\r\n\t\t\tt.isAir = /adobeair/i.test(ua);\r\n\r\n\t\t\tt.isIDevice = /(iPad|iPhone)/.test(ua);\r\n\r\n\t\t\tt.isIOS5 = t.isIDevice && ua.match(/AppleWebKit\\/(\\d*)/)[1]>=534;\r\n\r\n\t\t\t// TinyMCE .NET webcontrol might be setting the values for TinyMCE\r\n\t\t\tif (win.tinyMCEPreInit) {\r\n\t\t\t\tt.suffix = tinyMCEPreInit.suffix;\r\n\t\t\t\tt.baseURL = tinyMCEPreInit.base;\r\n\t\t\t\tt.query = tinyMCEPreInit.query;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// Get suffix and base\r\n\t\t\tt.suffix = '';\r\n\r\n\t\t\t// If base element found, add that infront of baseURL\r\n\t\t\tnl = d.getElementsByTagName('base');\r\n\t\t\tfor (i=0; i<nl.length; i++) {\r\n\t\t\t\tif (v = nl[i].href) {\r\n\t\t\t\t\t// Host only value like http://site.com or http://site.com:8008\r\n\t\t\t\t\tif (/^https?:\\/\\/[^\\/]+$/.test(v))\r\n\t\t\t\t\t\tv += '/';\r\n\r\n\t\t\t\t\tbase = v ? v.match(/.*\\//)[0] : ''; // Get only directory\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tfunction getBase(n) {\r\n\t\t\t\tif (n.src && /tiny_mce(|_gzip|_jquery|_prototype|_full)(_dev|_src)?.js/.test(n.src)) {\r\n\t\t\t\t\tif (/_(src|dev)\\.js/g.test(n.src))\r\n\t\t\t\t\t\tt.suffix = '_src';\r\n\r\n\t\t\t\t\tif ((p = n.src.indexOf('?')) != -1)\r\n\t\t\t\t\t\tt.query = n.src.substring(p + 1);\r\n\r\n\t\t\t\t\tt.baseURL = n.src.substring(0, n.src.lastIndexOf('/'));\r\n\r\n\t\t\t\t\t// If path to script is relative and a base href was found add that one infront\r\n\t\t\t\t\t// the src property will always be an absolute one on non IE browsers and IE 8\r\n\t\t\t\t\t// so this logic will basically only be executed on older IE versions\r\n\t\t\t\t\tif (base && t.baseURL.indexOf('://') == -1 && t.baseURL.indexOf('/') !== 0)\r\n\t\t\t\t\t\tt.baseURL = base + t.baseURL;\r\n\r\n\t\t\t\t\treturn t.baseURL;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn null;\r\n\t\t\t};\r\n\r\n\t\t\t// Check document\r\n\t\t\tnl = d.getElementsByTagName('script');\r\n\t\t\tfor (i=0; i<nl.length; i++) {\r\n\t\t\t\tif (getBase(nl[i]))\r\n\t\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// Check head\r\n\t\t\tn = d.getElementsByTagName('head')[0];\r\n\t\t\tif (n) {\r\n\t\t\t\tnl = n.getElementsByTagName('script');\r\n\t\t\t\tfor (i=0; i<nl.length; i++) {\r\n\t\t\t\t\tif (getBase(nl[i]))\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn;\r\n\t\t},\r\n\r\n\t\tis : function(o, t) {\r\n\t\t\tif (!t)\r\n\t\t\t\treturn o !== undefined;\r\n\r\n\t\t\tif (t == 'array' && (o.hasOwnProperty && o instanceof Array))\r\n\t\t\t\treturn true;\r\n\r\n\t\t\treturn typeof(o) == t;\r\n\t\t},\r\n\r\n\t\tmakeMap : function(items, delim, map) {\r\n\t\t\tvar i;\r\n\r\n\t\t\titems = items || [];\r\n\t\t\tdelim = delim || ',';\r\n\r\n\t\t\tif (typeof(items) == \"string\")\r\n\t\t\t\titems = items.split(delim);\r\n\r\n\t\t\tmap = map || {};\r\n\r\n\t\t\ti = items.length;\r\n\t\t\twhile (i--)\r\n\t\t\t\tmap[items[i]] = {};\r\n\r\n\t\t\treturn map;\r\n\t\t},\r\n\r\n\t\teach : function(o, cb, s) {\r\n\t\t\tvar n, l;\r\n\r\n\t\t\tif (!o)\r\n\t\t\t\treturn 0;\r\n\r\n\t\t\ts = s || o;\r\n\r\n\t\t\tif (o.length !== undefined) {\r\n\t\t\t\t// Indexed arrays, needed for Safari\r\n\t\t\t\tfor (n=0, l = o.length; n < l; n++) {\r\n\t\t\t\t\tif (cb.call(s, o[n], n, o) === false)\r\n\t\t\t\t\t\treturn 0;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t// Hashtables\r\n\t\t\t\tfor (n in o) {\r\n\t\t\t\t\tif (o.hasOwnProperty(n)) {\r\n\t\t\t\t\t\tif (cb.call(s, o[n], n, o) === false)\r\n\t\t\t\t\t\t\treturn 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn 1;\r\n\t\t},\r\n\r\n\r\n\t\tmap : function(a, f) {\r\n\t\t\tvar o = [];\r\n\r\n\t\t\ttinymce.each(a, function(v) {\r\n\t\t\t\to.push(f(v));\r\n\t\t\t});\r\n\r\n\t\t\treturn o;\r\n\t\t},\r\n\r\n\t\tgrep : function(a, f) {\r\n\t\t\tvar o = [];\r\n\r\n\t\t\ttinymce.each(a, function(v) {\r\n\t\t\t\tif (!f || f(v))\r\n\t\t\t\t\to.push(v);\r\n\t\t\t});\r\n\r\n\t\t\treturn o;\r\n\t\t},\r\n\r\n\t\tinArray : function(a, v) {\r\n\t\t\tvar i, l;\r\n\r\n\t\t\tif (a) {\r\n\t\t\t\tfor (i = 0, l = a.length; i < l; i++) {\r\n\t\t\t\t\tif (a[i] === v)\r\n\t\t\t\t\t\treturn i;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn -1;\r\n\t\t},\r\n\r\n\t\textend : function(o, e) {\r\n\t\t\tvar i, l, a = arguments;\r\n\r\n\t\t\tfor (i = 1, l = a.length; i < l; i++) {\r\n\t\t\t\te = a[i];\r\n\r\n\t\t\t\ttinymce.each(e, function(v, n) {\r\n\t\t\t\t\tif (v !== undefined)\r\n\t\t\t\t\t\to[n] = v;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\treturn o;\r\n\t\t},\r\n\r\n\r\n\t\ttrim : function(s) {\r\n\t\t\treturn (s ? '' + s : '').replace(whiteSpaceRe, '');\r\n\t\t},\r\n\r\n\t\tcreate : function(s, p, root) {\r\n\t\t\tvar t = this, sp, ns, cn, scn, c, de = 0;\r\n\r\n\t\t\t// Parse : <prefix> <class>:<super class>\r\n\t\t\ts = /^((static) )?([\\w.]+)(:([\\w.]+))?/.exec(s);\r\n\t\t\tcn = s[3].match(/(^|\\.)(\\w+)$/i)[2]; // Class name\r\n\r\n\t\t\t// Create namespace for new class\r\n\t\t\tns = t.createNS(s[3].replace(/\\.\\w+$/, ''), root);\r\n\r\n\t\t\t// Class already exists\r\n\t\t\tif (ns[cn])\r\n\t\t\t\treturn;\r\n\r\n\t\t\t// Make pure static class\r\n\t\t\tif (s[2] == 'static') {\r\n\t\t\t\tns[cn] = p;\r\n\r\n\t\t\t\tif (this.onCreate)\r\n\t\t\t\t\tthis.onCreate(s[2], s[3], ns[cn]);\r\n\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// Create default constructor\r\n\t\t\tif (!p[cn]) {\r\n\t\t\t\tp[cn] = function() {};\r\n\t\t\t\tde = 1;\r\n\t\t\t}\r\n\r\n\t\t\t// Add constructor and methods\r\n\t\t\tns[cn] = p[cn];\r\n\t\t\tt.extend(ns[cn].prototype, p);\r\n\r\n\t\t\t// Extend\r\n\t\t\tif (s[5]) {\r\n\t\t\t\tsp = t.resolve(s[5]).prototype;\r\n\t\t\t\tscn = s[5].match(/\\.(\\w+)$/i)[1]; // Class name\r\n\r\n\t\t\t\t// Extend constructor\r\n\t\t\t\tc = ns[cn];\r\n\t\t\t\tif (de) {\r\n\t\t\t\t\t// Add passthrough constructor\r\n\t\t\t\t\tns[cn] = function() {\r\n\t\t\t\t\t\treturn sp[scn].apply(this, arguments);\r\n\t\t\t\t\t};\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Add inherit constructor\r\n\t\t\t\t\tns[cn] = function() {\r\n\t\t\t\t\t\tthis.parent = sp[scn];\r\n\t\t\t\t\t\treturn c.apply(this, arguments);\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t\tns[cn].prototype[cn] = ns[cn];\r\n\r\n\t\t\t\t// Add super methods\r\n\t\t\t\tt.each(sp, function(f, n) {\r\n\t\t\t\t\tns[cn].prototype[n] = sp[n];\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// Add overridden methods\r\n\t\t\t\tt.each(p, function(f, n) {\r\n\t\t\t\t\t// Extend methods if needed\r\n\t\t\t\t\tif (sp[n]) {\r\n\t\t\t\t\t\tns[cn].prototype[n] = function() {\r\n\t\t\t\t\t\t\tthis.parent = sp[n];\r\n\t\t\t\t\t\t\treturn f.apply(this, arguments);\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (n != cn)\r\n\t\t\t\t\t\t\tns[cn].prototype[n] = f;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// Add static methods\r\n\t\t\tt.each(p['static'], function(f, n) {\r\n\t\t\t\tns[cn][n] = f;\r\n\t\t\t});\r\n\r\n\t\t\tif (this.onCreate)\r\n\t\t\t\tthis.onCreate(s[2], s[3], ns[cn].prototype);\r\n\t\t},\r\n\r\n\t\twalk : function(o, f, n, s) {\r\n\t\t\ts = s || this;\r\n\r\n\t\t\tif (o) {\r\n\t\t\t\tif (n)\r\n\t\t\t\t\to = o[n];\r\n\r\n\t\t\t\ttinymce.each(o, function(o, i) {\r\n\t\t\t\t\tif (f.call(s, o, i, n) === false)\r\n\t\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t\ttinymce.walk(o, f, n, s);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tcreateNS : function(n, o) {\r\n\t\t\tvar i, v;\r\n\r\n\t\t\to = o || win;\r\n\r\n\t\t\tn = n.split('.');\r\n\t\t\tfor (i=0; i<n.length; i++) {\r\n\t\t\t\tv = n[i];\r\n\r\n\t\t\t\tif (!o[v])\r\n\t\t\t\t\to[v] = {};\r\n\r\n\t\t\t\to = o[v];\r\n\t\t\t}\r\n\r\n\t\t\treturn o;\r\n\t\t},\r\n\r\n\t\tresolve : function(n, o) {\r\n\t\t\tvar i, l;\r\n\r\n\t\t\to = o || win;\r\n\r\n\t\t\tn = n.split('.');\r\n\t\t\tfor (i = 0, l = n.length; i < l; i++) {\r\n\t\t\t\to = o[n[i]];\r\n\r\n\t\t\t\tif (!o)\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\treturn o;\r\n\t\t},\r\n\r\n\t\taddUnload : function(f, s) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\tf = {func : f, scope : s || this};\r\n\r\n\t\t\tif (!t.unloads) {\r\n\t\t\t\tfunction unload() {\r\n\t\t\t\t\tvar li = t.unloads, o, n;\r\n\r\n\t\t\t\t\tif (li) {\r\n\t\t\t\t\t\t// Call unload handlers\r\n\t\t\t\t\t\tfor (n in li) {\r\n\t\t\t\t\t\t\to = li[n];\r\n\r\n\t\t\t\t\t\t\tif (o && o.func)\r\n\t\t\t\t\t\t\t\to.func.call(o.scope, 1); // Send in one arg to distinct unload and user destroy\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Detach unload function\r\n\t\t\t\t\t\tif (win.detachEvent) {\r\n\t\t\t\t\t\t\twin.detachEvent('onbeforeunload', fakeUnload);\r\n\t\t\t\t\t\t\twin.detachEvent('onunload', unload);\r\n\t\t\t\t\t\t} else if (win.removeEventListener)\r\n\t\t\t\t\t\t\twin.removeEventListener('unload', unload, false);\r\n\r\n\t\t\t\t\t\t// Destroy references\r\n\t\t\t\t\t\tt.unloads = o = li = w = unload = 0;\r\n\r\n\t\t\t\t\t\t// Run garbarge collector on IE\r\n\t\t\t\t\t\tif (win.CollectGarbage)\r\n\t\t\t\t\t\t\tCollectGarbage();\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\r\n\t\t\t\tfunction fakeUnload() {\r\n\t\t\t\t\tvar d = document;\r\n\r\n\t\t\t\t\t// Is there things still loading, then do some magic\r\n\t\t\t\t\tif (d.readyState == 'interactive') {\r\n\t\t\t\t\t\tfunction stop() {\r\n\t\t\t\t\t\t\t// Prevent memory leak\r\n\t\t\t\t\t\t\td.detachEvent('onstop', stop);\r\n\r\n\t\t\t\t\t\t\t// Call unload handler\r\n\t\t\t\t\t\t\tif (unload)\r\n\t\t\t\t\t\t\t\tunload();\r\n\r\n\t\t\t\t\t\t\td = 0;\r\n\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\t// Fire unload when the currently loading page is stopped\r\n\t\t\t\t\t\tif (d)\r\n\t\t\t\t\t\t\td.attachEvent('onstop', stop);\r\n\r\n\t\t\t\t\t\t// Remove onstop listener after a while to prevent the unload function\r\n\t\t\t\t\t\t// to execute if the user presses cancel in an onbeforeunload\r\n\t\t\t\t\t\t// confirm dialog and then presses the browser stop button\r\n\t\t\t\t\t\twin.setTimeout(function() {\r\n\t\t\t\t\t\t\tif (d)\r\n\t\t\t\t\t\t\t\td.detachEvent('onstop', stop);\r\n\t\t\t\t\t\t}, 0);\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\r\n\t\t\t\t// Attach unload handler\r\n\t\t\t\tif (win.attachEvent) {\r\n\t\t\t\t\twin.attachEvent('onunload', unload);\r\n\t\t\t\t\twin.attachEvent('onbeforeunload', fakeUnload);\r\n\t\t\t\t} else if (win.addEventListener)\r\n\t\t\t\t\twin.addEventListener('unload', unload, false);\r\n\r\n\t\t\t\t// Setup initial unload handler array\r\n\t\t\t\tt.unloads = [f];\r\n\t\t\t} else\r\n\t\t\t\tt.unloads.push(f);\r\n\r\n\t\t\treturn f;\r\n\t\t},\r\n\r\n\t\tremoveUnload : function(f) {\r\n\t\t\tvar u = this.unloads, r = null;\r\n\r\n\t\t\ttinymce.each(u, function(o, i) {\r\n\t\t\t\tif (o && o.func == f) {\r\n\t\t\t\t\tu.splice(i, 1);\r\n\t\t\t\t\tr = f;\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\treturn r;\r\n\t\t},\r\n\r\n\t\texplode : function(s, d) {\r\n\t\t\treturn s ? tinymce.map(s.split(d || ','), tinymce.trim) : s;\r\n\t\t},\r\n\r\n\t\t_addVer : function(u) {\r\n\t\t\tvar v;\r\n\r\n\t\t\tif (!this.query)\r\n\t\t\t\treturn u;\r\n\r\n\t\t\tv = (u.indexOf('?') == -1 ? '?' : '&') + this.query;\r\n\r\n\t\t\tif (u.indexOf('#') == -1)\r\n\t\t\t\treturn u + v;\r\n\r\n\t\t\treturn u.replace('#', v + '#');\r\n\t\t},\r\n\r\n\t\t// Fix function for IE 9 where regexps isn't working correctly\r\n\t\t// Todo: remove me once MS fixes the bug\r\n\t\t_replace : function(find, replace, str) {\r\n\t\t\t// On IE9 we have to fake $x replacement\r\n\t\t\tif (isRegExpBroken) {\r\n\t\t\t\treturn str.replace(find, function() {\r\n\t\t\t\t\tvar val = replace, args = arguments, i;\r\n\r\n\t\t\t\t\tfor (i = 0; i < args.length - 2; i++) {\r\n\t\t\t\t\t\tif (args[i] === undefined) {\r\n\t\t\t\t\t\t\tval = val.replace(new RegExp('\\\\$' + i, 'g'), '');\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tval = val.replace(new RegExp('\\\\$' + i, 'g'), args[i]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn val;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\treturn str.replace(find, replace);\r\n\t\t}\r\n\r\n\t\t};\r\n\r\n\t// Initialize the API\r\n\ttinymce._init();\r\n\r\n\t// Expose tinymce namespace to the global namespace (window)\r\n\twin.tinymce = win.tinyMCE = tinymce;\r\n\r\n\t// Describe the different namespaces\r\n\r\n\t})(window);\r\n\r\n\r\n\r\ntinymce.create('tinymce.util.Dispatcher', {\r\n\tscope : null,\r\n\tlisteners : null,\r\n\r\n\tDispatcher : function(s) {\r\n\t\tthis.scope = s || this;\r\n\t\tthis.listeners = [];\r\n\t},\r\n\r\n\tadd : function(cb, s) {\r\n\t\tthis.listeners.push({cb : cb, scope : s || this.scope});\r\n\r\n\t\treturn cb;\r\n\t},\r\n\r\n\taddToTop : function(cb, s) {\r\n\t\tthis.listeners.unshift({cb : cb, scope : s || this.scope});\r\n\r\n\t\treturn cb;\r\n\t},\r\n\r\n\tremove : function(cb) {\r\n\t\tvar l = this.listeners, o = null;\r\n\r\n\t\ttinymce.each(l, function(c, i) {\r\n\t\t\tif (cb == c.cb) {\r\n\t\t\t\to = cb;\r\n\t\t\t\tl.splice(i, 1);\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn o;\r\n\t},\r\n\r\n\tdispatch : function() {\r\n\t\tvar s, a = arguments, i, li = this.listeners, c;\r\n\r\n\t\t// Needs to be a real loop since the listener count might change while looping\r\n\t\t// And this is also more efficient\r\n\t\tfor (i = 0; i<li.length; i++) {\r\n\t\t\tc = li[i];\r\n\t\t\ts = c.cb.apply(c.scope, a);\r\n\r\n\t\t\tif (s === false)\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\treturn s;\r\n\t}\r\n\r\n\t});\r\n\r\n(function() {\r\n\tvar each = tinymce.each;\r\n\r\n\ttinymce.create('tinymce.util.URI', {\r\n\t\tURI : function(u, s) {\r\n\t\t\tvar t = this, o, a, b, base_url;\r\n\r\n\t\t\t// Trim whitespace\r\n\t\t\tu = tinymce.trim(u);\r\n\r\n\t\t\t// Default settings\r\n\t\t\ts = t.settings = s || {};\r\n\r\n\t\t\t// Strange app protocol that isn't http/https or local anchor\r\n\t\t\t// For example: mailto,skype,tel etc.\r\n\t\t\tif (/^([\\w\\-]+):([^\\/]{2})/i.test(u) || /^\\s*#/.test(u)) {\r\n\t\t\t\tt.source = u;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// Absolute path with no host, fake host and protocol\r\n\t\t\tif (u.indexOf('/') === 0 && u.indexOf('//') !== 0)\r\n\t\t\t\tu = (s.base_uri ? s.base_uri.protocol || 'http' : 'http') + '://mce_host' + u;\r\n\r\n\t\t\t// Relative path http:// or protocol relative //path\r\n\t\t\tif (!/^[\\w-]*:?\\/\\//.test(u)) {\r\n\t\t\t\tbase_url = s.base_uri ? s.base_uri.path : new tinymce.util.URI(location.href).directory;\r\n\t\t\t\tu = ((s.base_uri && s.base_uri.protocol) || 'http') + '://mce_host' + t.toAbsPath(base_url, u);\r\n\t\t\t}\r\n\r\n\t\t\t// Parse URL (Credits goes to Steave, http://blog.stevenlevithan.com/archives/parseuri)\r\n\t\t\tu = u.replace(/@@/g, '(mce_at)'); // Zope 3 workaround, they use @@something\r\n\t\t\tu = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*):?([^:@]*))?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/.exec(u);\r\n\t\t\teach([\"source\",\"protocol\",\"authority\",\"userInfo\",\"user\",\"password\",\"host\",\"port\",\"relative\",\"path\",\"directory\",\"file\",\"query\",\"anchor\"], function(v, i) {\r\n\t\t\t\tvar s = u[i];\r\n\r\n\t\t\t\t// Zope 3 workaround, they use @@something\r\n\t\t\t\tif (s)\r\n\t\t\t\t\ts = s.replace(/\\(mce_at\\)/g, '@@');\r\n\r\n\t\t\t\tt[v] = s;\r\n\t\t\t});\r\n\r\n\t\t\tif (b = s.base_uri) {\r\n\t\t\t\tif (!t.protocol)\r\n\t\t\t\t\tt.protocol = b.protocol;\r\n\r\n\t\t\t\tif (!t.userInfo)\r\n\t\t\t\t\tt.userInfo = b.userInfo;\r\n\r\n\t\t\t\tif (!t.port && t.host == 'mce_host')\r\n\t\t\t\t\tt.port = b.port;\r\n\r\n\t\t\t\tif (!t.host || t.host == 'mce_host')\r\n\t\t\t\t\tt.host = b.host;\r\n\r\n\t\t\t\tt.source = '';\r\n\t\t\t}\r\n\r\n\t\t\t//t.path = t.path || '/';\r\n\t\t},\r\n\r\n\t\tsetPath : function(p) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\tp = /^(.*?)\\/?(\\w+)?$/.exec(p);\r\n\r\n\t\t\t// Update path parts\r\n\t\t\tt.path = p[0];\r\n\t\t\tt.directory = p[1];\r\n\t\t\tt.file = p[2];\r\n\r\n\t\t\t// Rebuild source\r\n\t\t\tt.source = '';\r\n\t\t\tt.getURI();\r\n\t\t},\r\n\r\n\t\ttoRelative : function(u) {\r\n\t\t\tvar t = this, o;\r\n\r\n\t\t\tif (u === \"./\")\r\n\t\t\t\treturn u;\r\n\r\n\t\t\tu = new tinymce.util.URI(u, {base_uri : t});\r\n\r\n\t\t\t// Not on same domain/port or protocol\r\n\t\t\tif ((u.host != 'mce_host' && t.host != u.host && u.host) || t.port != u.port || t.protocol != u.protocol)\r\n\t\t\t\treturn u.getURI();\r\n\r\n\t\t\to = t.toRelPath(t.path, u.path);\r\n\r\n\t\t\t// Add query\r\n\t\t\tif (u.query)\r\n\t\t\t\to += '?' + u.query;\r\n\r\n\t\t\t// Add anchor\r\n\t\t\tif (u.anchor)\r\n\t\t\t\to += '#' + u.anchor;\r\n\r\n\t\t\treturn o;\r\n\t\t},\r\n\r\n\t\ttoAbsolute : function(u, nh) {\r\n\t\t\tvar u = new tinymce.util.URI(u, {base_uri : this});\r\n\r\n\t\t\treturn u.getURI(this.host == u.host && this.protocol == u.protocol ? nh : 0);\r\n\t\t},\r\n\r\n\t\ttoRelPath : function(base, path) {\r\n\t\t\tvar items, bp = 0, out = '', i, l;\r\n\r\n\t\t\t// Split the paths\r\n\t\t\tbase = base.substring(0, base.lastIndexOf('/'));\r\n\t\t\tbase = base.split('/');\r\n\t\t\titems = path.split('/');\r\n\r\n\t\t\tif (base.length >= items.length) {\r\n\t\t\t\tfor (i = 0, l = base.length; i < l; i++) {\r\n\t\t\t\t\tif (i >= items.length || base[i] != items[i]) {\r\n\t\t\t\t\t\tbp = i + 1;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (base.length < items.length) {\r\n\t\t\t\tfor (i = 0, l = items.length; i < l; i++) {\r\n\t\t\t\t\tif (i >= base.length || base[i] != items[i]) {\r\n\t\t\t\t\t\tbp = i + 1;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (bp == 1)\r\n\t\t\t\treturn path;\r\n\r\n\t\t\tfor (i = 0, l = base.length - (bp - 1); i < l; i++)\r\n\t\t\t\tout += \"../\";\r\n\r\n\t\t\tfor (i = bp - 1, l = items.length; i < l; i++) {\r\n\t\t\t\tif (i != bp - 1)\r\n\t\t\t\t\tout += \"/\" + items[i];\r\n\t\t\t\telse\r\n\t\t\t\t\tout += items[i];\r\n\t\t\t}\r\n\r\n\t\t\treturn out;\r\n\t\t},\r\n\r\n\t\ttoAbsPath : function(base, path) {\r\n\t\t\tvar i, nb = 0, o = [], tr, outPath;\r\n\r\n\t\t\t// Split paths\r\n\t\t\ttr = /\\/$/.test(path) ? '/' : '';\r\n\t\t\tbase = base.split('/');\r\n\t\t\tpath = path.split('/');\r\n\r\n\t\t\t// Remove empty chunks\r\n\t\t\teach(base, function(k) {\r\n\t\t\t\tif (k)\r\n\t\t\t\t\to.push(k);\r\n\t\t\t});\r\n\r\n\t\t\tbase = o;\r\n\r\n\t\t\t// Merge relURLParts chunks\r\n\t\t\tfor (i = path.length - 1, o = []; i >= 0; i--) {\r\n\t\t\t\t// Ignore empty or .\r\n\t\t\t\tif (path[i].length == 0 || path[i] == \".\")\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t// Is parent\r\n\t\t\t\tif (path[i] == '..') {\r\n\t\t\t\t\tnb++;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Move up\r\n\t\t\t\tif (nb > 0) {\r\n\t\t\t\t\tnb--;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\to.push(path[i]);\r\n\t\t\t}\r\n\r\n\t\t\ti = base.length - nb;\r\n\r\n\t\t\t// If /a/b/c or /\r\n\t\t\tif (i <= 0)\r\n\t\t\t\toutPath = o.reverse().join('/');\r\n\t\t\telse\r\n\t\t\t\toutPath = base.slice(0, i).join('/') + '/' + o.reverse().join('/');\r\n\r\n\t\t\t// Add front / if it's needed\r\n\t\t\tif (outPath.indexOf('/') !== 0)\r\n\t\t\t\toutPath = '/' + outPath;\r\n\r\n\t\t\t// Add traling / if it's needed\r\n\t\t\tif (tr && outPath.lastIndexOf('/') !== outPath.length - 1)\r\n\t\t\t\toutPath += tr;\r\n\r\n\t\t\treturn outPath;\r\n\t\t},\r\n\r\n\t\tgetURI : function(nh) {\r\n\t\t\tvar s, t = this;\r\n\r\n\t\t\t// Rebuild source\r\n\t\t\tif (!t.source || nh) {\r\n\t\t\t\ts = '';\r\n\r\n\t\t\t\tif (!nh) {\r\n\t\t\t\t\tif (t.protocol)\r\n\t\t\t\t\t\ts += t.protocol + '://';\r\n\r\n\t\t\t\t\tif (t.userInfo)\r\n\t\t\t\t\t\ts += t.userInfo + '@';\r\n\r\n\t\t\t\t\tif (t.host)\r\n\t\t\t\t\t\ts += t.host;\r\n\r\n\t\t\t\t\tif (t.port)\r\n\t\t\t\t\t\ts += ':' + t.port;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (t.path)\r\n\t\t\t\t\ts += t.path;\r\n\r\n\t\t\t\tif (t.query)\r\n\t\t\t\t\ts += '?' + t.query;\r\n\r\n\t\t\t\tif (t.anchor)\r\n\t\t\t\t\ts += '#' + t.anchor;\r\n\r\n\t\t\t\tt.source = s;\r\n\t\t\t}\r\n\r\n\t\t\treturn t.source;\r\n\t\t}\r\n\t});\r\n})();\r\n\r\n(function() {\r\n\tvar each = tinymce.each;\r\n\r\n\ttinymce.create('static tinymce.util.Cookie', {\r\n\t\tgetHash : function(n) {\r\n\t\t\tvar v = this.get(n), h;\r\n\r\n\t\t\tif (v) {\r\n\t\t\t\teach(v.split('&'), function(v) {\r\n\t\t\t\t\tv = v.split('=');\r\n\t\t\t\t\th = h || {};\r\n\t\t\t\t\th[unescape(v[0])] = unescape(v[1]);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\treturn h;\r\n\t\t},\r\n\r\n\t\tsetHash : function(n, v, e, p, d, s) {\r\n\t\t\tvar o = '';\r\n\r\n\t\t\teach(v, function(v, k) {\r\n\t\t\t\to += (!o ? '' : '&') + escape(k) + '=' + escape(v);\r\n\t\t\t});\r\n\r\n\t\t\tthis.set(n, o, e, p, d, s);\r\n\t\t},\r\n\r\n\t\tget : function(n) {\r\n\t\t\tvar c = document.cookie, e, p = n + \"=\", b;\r\n\r\n\t\t\t// Strict mode\r\n\t\t\tif (!c)\r\n\t\t\t\treturn;\r\n\r\n\t\t\tb = c.indexOf(\"; \" + p);\r\n\r\n\t\t\tif (b == -1) {\r\n\t\t\t\tb = c.indexOf(p);\r\n\r\n\t\t\t\tif (b != 0)\r\n\t\t\t\t\treturn null;\r\n\t\t\t} else\r\n\t\t\t\tb += 2;\r\n\r\n\t\t\te = c.indexOf(\";\", b);\r\n\r\n\t\t\tif (e == -1)\r\n\t\t\t\te = c.length;\r\n\r\n\t\t\treturn unescape(c.substring(b + p.length, e));\r\n\t\t},\r\n\r\n\t\tset : function(n, v, e, p, d, s) {\r\n\t\t\tdocument.cookie = n + \"=\" + escape(v) +\r\n\t\t\t\t((e) ? \"; expires=\" + e.toUTCString() : \"\") +\r\n\t\t\t\t((p) ? \"; path=\" + escape(p) : \"\") +\r\n\t\t\t\t((d) ? \"; domain=\" + d : \"\") +\r\n\t\t\t\t((s) ? \"; secure\" : \"\");\r\n\t\t},\r\n\r\n\t\tremove : function(n, p) {\r\n\t\t\tvar d = new Date();\r\n\r\n\t\t\td.setTime(d.getTime() - 1000);\r\n\r\n\t\t\tthis.set(n, '', d, p, d);\r\n\t\t}\r\n\t});\r\n})();\r\n\r\n(function() {\r\n\tfunction serialize(o, quote) {\r\n\t\tvar i, v, t;\r\n\r\n\t\tquote = quote || '\"';\r\n\r\n\t\tif (o == null)\r\n\t\t\treturn 'null';\r\n\r\n\t\tt = typeof o;\r\n\r\n\t\tif (t == 'string') {\r\n\t\t\tv = '\\bb\\tt\\nn\\ff\\rr\\\"\"\\'\\'\\\\\\\\';\r\n\r\n\t\t\treturn quote + o.replace(/([\\u0080-\\uFFFF\\x00-\\x1f\\\"\\'\\\\])/g, function(a, b) {\r\n\t\t\t\t// Make sure single quotes never get encoded inside double quotes for JSON compatibility\r\n\t\t\t\tif (quote === '\"' && a === \"'\")\r\n\t\t\t\t\treturn a;\r\n\r\n\t\t\t\ti = v.indexOf(b);\r\n\r\n\t\t\t\tif (i + 1)\r\n\t\t\t\t\treturn '\\\\' + v.charAt(i + 1);\r\n\r\n\t\t\t\ta = b.charCodeAt().toString(16);\r\n\r\n\t\t\t\treturn '\\\\u' + '0000'.substring(a.length) + a;\r\n\t\t\t}) + quote;\r\n\t\t}\r\n\r\n\t\tif (t == 'object') {\r\n\t\t\tif (o.hasOwnProperty && o instanceof Array) {\r\n\t\t\t\t\tfor (i=0, v = '['; i<o.length; i++)\r\n\t\t\t\t\t\tv += (i > 0 ? ',' : '') + serialize(o[i], quote);\r\n\r\n\t\t\t\t\treturn v + ']';\r\n\t\t\t\t}\r\n\r\n\t\t\t\tv = '{';\r\n\r\n\t\t\t\tfor (i in o) {\r\n\t\t\t\t\tif (o.hasOwnProperty(i)) {\r\n\t\t\t\t\t\tv += typeof o[i] != 'function' ? (v.length > 1 ? ',' + quote : quote) + i + quote +':' + serialize(o[i], quote) : '';\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn v + '}';\r\n\t\t}\r\n\r\n\t\treturn '' + o;\r\n\t};\r\n\r\n\ttinymce.util.JSON = {\r\n\t\tserialize: serialize,\r\n\r\n\t\tparse: function(s) {\r\n\t\t\ttry {\r\n\t\t\t\treturn JSON.parse(s);\r\n\t\t\t} catch (ex) {\r\n\t\t\t\t// Ignore\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t};\r\n})();\r\n\r\ntinymce.create('static tinymce.util.XHR', {\r\n\tsend : function(o) {\r\n\t\tvar x, t, w = window, c = 0;\r\n\r\n\t\t// Default settings\r\n\t\to.scope = o.scope || this;\r\n\t\to.success_scope = o.success_scope || o.scope;\r\n\t\to.error_scope = o.error_scope || o.scope;\r\n\t\to.async = o.async === false ? false : true;\r\n\t\to.data = o.data || '';\r\n\r\n\t\tfunction get(s) {\r\n\t\t\tx = 0;\r\n\r\n\t\t\ttry {\r\n\t\t\t\tx = new ActiveXObject(s);\r\n\t\t\t} catch (ex) {\r\n\t\t\t}\r\n\r\n\t\t\treturn x;\r\n\t\t};\r\n\r\n\t\tx = w.XMLHttpRequest ? new XMLHttpRequest() : get('Microsoft.XMLHTTP') || get('Msxml2.XMLHTTP');\r\n\r\n\t\tif (x) {\r\n\t\t\tif (x.overrideMimeType)\r\n\t\t\t\tx.overrideMimeType(o.content_type);\r\n\r\n\t\t\tx.open(o.type || (o.data ? 'POST' : 'GET'), o.url, o.async);\r\n\r\n\t\t\tif (o.content_type)\r\n\t\t\t\tx.setRequestHeader('Content-Type', o.content_type);\r\n\r\n\t\t\tx.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\r\n\r\n\t\t\tx.send(o.data);\r\n\r\n\t\t\tfunction ready() {\r\n\t\t\t\tif (!o.async || x.readyState == 4 || c++ > 10000) {\r\n\t\t\t\t\tif (o.success && c < 10000 && x.status == 200)\r\n\t\t\t\t\t\to.success.call(o.success_scope, '' + x.responseText, x, o);\r\n\t\t\t\t\telse if (o.error)\r\n\t\t\t\t\t\to.error.call(o.error_scope, c > 10000 ? 'TIMED_OUT' : 'GENERAL', x, o);\r\n\r\n\t\t\t\t\tx = null;\r\n\t\t\t\t} else\r\n\t\t\t\t\tw.setTimeout(ready, 10);\r\n\t\t\t};\r\n\r\n\t\t\t// Syncronous request\r\n\t\t\tif (!o.async)\r\n\t\t\t\treturn ready();\r\n\r\n\t\t\t// Wait for response, onReadyStateChange can not be used since it leaks memory in IE\r\n\t\t\tt = w.setTimeout(ready, 10);\r\n\t\t}\r\n\t}\r\n});\r\n\r\n(function() {\r\n\tvar extend = tinymce.extend, JSON = tinymce.util.JSON, XHR = tinymce.util.XHR;\r\n\r\n\ttinymce.create('tinymce.util.JSONRequest', {\r\n\t\tJSONRequest : function(s) {\r\n\t\t\tthis.settings = extend({\r\n\t\t\t}, s);\r\n\t\t\tthis.count = 0;\r\n\t\t},\r\n\r\n\t\tsend : function(o) {\r\n\t\t\tvar ecb = o.error, scb = o.success;\r\n\r\n\t\t\to = extend(this.settings, o);\r\n\r\n\t\t\to.success = function(c, x) {\r\n\t\t\t\tc = JSON.parse(c);\r\n\r\n\t\t\t\tif (typeof(c) == 'undefined') {\r\n\t\t\t\t\tc = {\r\n\t\t\t\t\t\terror : 'JSON Parse error.'\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (c.error)\r\n\t\t\t\t\tecb.call(o.error_scope || o.scope, c.error, x);\r\n\t\t\t\telse\r\n\t\t\t\t\tscb.call(o.success_scope || o.scope, c.result);\r\n\t\t\t};\r\n\r\n\t\t\to.error = function(ty, x) {\r\n\t\t\t\tif (ecb)\r\n\t\t\t\t\tecb.call(o.error_scope || o.scope, ty, x);\r\n\t\t\t};\r\n\r\n\t\t\to.data = JSON.serialize({\r\n\t\t\t\tid : o.id || 'c' + (this.count++),\r\n\t\t\t\tmethod : o.method,\r\n\t\t\t\tparams : o.params\r\n\t\t\t});\r\n\r\n\t\t\t// JSON content type for Ruby on rails. Bug: #1883287\r\n\t\t\to.content_type = 'application/json';\r\n\r\n\t\t\tXHR.send(o);\r\n\t\t},\r\n\r\n\t\t'static' : {\r\n\t\t\tsendRPC : function(o) {\r\n\t\t\t\treturn new tinymce.util.JSONRequest().send(o);\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n}());\r\n(function(tinymce){\r\n\ttinymce.VK = {\r\n\t\tDELETE: 46,\r\n\t\tBACKSPACE: 8,\r\n\t\tENTER: 13,\r\n\t\tTAB: 9,\r\n        SPACEBAR: 32,\r\n\t\tUP: 38,\r\n\t\tDOWN: 40\r\n\t}\r\n})(tinymce);\r\n\r\n(function(tinymce) {\r\n\tvar VK = tinymce.VK, BACKSPACE = VK.BACKSPACE, DELETE = VK.DELETE;\r\n\r\n\tfunction cleanupStylesWhenDeleting(ed) {\r\n\t\tvar dom = ed.dom, selection = ed.selection;\r\n\r\n\t\ted.onKeyDown.add(function(ed, e) {\r\n\t\t\tvar rng, blockElm, node, clonedSpan, isDelete;\r\n\r\n\t\t\tisDelete = e.keyCode == DELETE;\r\n\t\t\tif (isDelete || e.keyCode == BACKSPACE) {\r\n\t\t\t\te.preventDefault();\r\n\t\t\t\trng = selection.getRng();\r\n\r\n\t\t\t\t// Find root block\r\n\t\t\t\tblockElm = dom.getParent(rng.startContainer, dom.isBlock);\r\n\r\n\t\t\t\t// On delete clone the root span of the next block element\r\n\t\t\t\tif (isDelete)\r\n\t\t\t\t\tblockElm = dom.getNext(blockElm, dom.isBlock);\r\n\r\n\t\t\t\t// Locate root span element and clone it since it would otherwise get merged by the \"apple-style-span\" on delete/backspace\r\n\t\t\t\tif (blockElm) {\r\n\t\t\t\t\tnode = blockElm.firstChild;\r\n\r\n\t\t\t\t\t// Ignore empty text nodes\r\n\t\t\t\t\twhile (node && node.nodeType == 3 && node.nodeValue.length == 0)\r\n\t\t\t\t\t\tnode = node.nextSibling;\r\n\r\n\t\t\t\t\tif (node && node.nodeName === 'SPAN') {\r\n\t\t\t\t\t\tclonedSpan = node.cloneNode(false);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Do the backspace/delete actiopn\r\n\t\t\t\ted.getDoc().execCommand(isDelete ? 'ForwardDelete' : 'Delete', false, null);\r\n\r\n\t\t\t\t// Find all odd apple-style-spans\r\n\t\t\t\tblockElm = dom.getParent(rng.startContainer, dom.isBlock);\r\n\t\t\t\ttinymce.each(dom.select('span.Apple-style-span,font.Apple-style-span', blockElm), function(span) {\r\n\t\t\t\t\tvar bm = selection.getBookmark();\r\n\r\n\t\t\t\t\tif (clonedSpan) {\r\n\t\t\t\t\t\tdom.replace(clonedSpan.cloneNode(false), span, true);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tdom.remove(span, true);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Restore the selection\r\n\t\t\t\t\tselection.moveToBookmark(bm);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\t};\r\n\r\n\tfunction emptyEditorWhenDeleting(ed) {\r\n\t\ted.onKeyUp.add(function(ed, e) {\r\n\t\t\tvar keyCode = e.keyCode;\r\n\r\n\t\t\tif (keyCode == DELETE || keyCode == BACKSPACE) {\r\n\t\t\t\tif (ed.dom.isEmpty(ed.getBody())) {\r\n\t\t\t\t\ted.setContent('', {format : 'raw'});\r\n\t\t\t\t\ted.nodeChanged();\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t};\r\n\r\n\tfunction inputMethodFocus(ed) {\r\n\t\ted.dom.bind(ed.getDoc(), 'focusin', function() {\r\n\t\t\ted.selection.setRng(ed.selection.getRng());\r\n\t\t});\r\n\t};\r\n\r\n\tfunction removeHrOnBackspace(ed) {\r\n\t\ted.onKeyDown.add(function(ed, e) {\r\n\t\t\tif (e.keyCode === BACKSPACE) {\r\n\t\t\t\tif (ed.selection.isCollapsed() && ed.selection.getRng(true).startOffset === 0) {\r\n\t\t\t\t\tvar node = ed.selection.getNode();\r\n\t\t\t\t\tvar previousSibling = node.previousSibling;\r\n\t\t\t\t\tif (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === \"hr\") {\r\n\t\t\t\t\t\ted.dom.remove(previousSibling);\r\n\t\t\t\t\t\ttinymce.dom.Event.cancel(e);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n\r\n\tfunction focusBody(ed) {\r\n\t\t// Fix for a focus bug in FF 3.x where the body element\r\n\t\t// wouldn't get proper focus if the user clicked on the HTML element\r\n\t\tif (!Range.prototype.getClientRects) { // Detect getClientRects got introduced in FF 4\r\n\t\t\ted.onMouseDown.add(function(ed, e) {\r\n\t\t\t\tif (e.target.nodeName === \"HTML\") {\r\n\t\t\t\t\tvar body = ed.getBody();\r\n\r\n\t\t\t\t\t// Blur the body it's focused but not correctly focused\r\n\t\t\t\t\tbody.blur();\r\n\r\n\t\t\t\t\t// Refocus the body after a little while\r\n\t\t\t\t\tsetTimeout(function() {\r\n\t\t\t\t\t\tbody.focus();\r\n\t\t\t\t\t}, 0);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t};\r\n\r\n\tfunction selectControlElements(ed) {\r\n\t\ted.onClick.add(function(ed, e) {\r\n\t\t\te = e.target;\r\n\r\n\t\t\tif (/^(IMG|HR)$/.test(e.nodeName))\r\n\t\t\t\ted.selection.select(e);\r\n\r\n\t\t\tif (e.nodeName == 'A' && ed.dom.hasClass(e, 'mceItemAnchor'))\r\n\t\t\t\ted.selection.select(e);\r\n\r\n\t\t\ted.nodeChanged();\r\n\t\t});\r\n\t};\r\n\r\n\tfunction selectionChangeNodeChanged(ed) {\r\n\t\tvar lastRng, selectionTimer;\r\n\r\n\t\ted.dom.bind(ed.getDoc(), 'selectionchange', function() {\r\n\t\t\tif (selectionTimer) {\r\n\t\t\t\tclearTimeout(selectionTimer);\r\n\t\t\t\tselectionTimer = 0;\r\n\t\t\t}\r\n\r\n\t\t\tselectionTimer = window.setTimeout(function() {\r\n\t\t\t\tvar rng = ed.selection.getRng();\r\n\r\n\t\t\t\t// Compare the ranges to see if it was a real change or not\r\n\t\t\t\tif (!lastRng || !tinymce.dom.RangeUtils.compareRanges(rng, lastRng)) {\r\n\t\t\t\t\ted.nodeChanged();\r\n\t\t\t\t\tlastRng = rng;\r\n\t\t\t\t}\r\n\t\t\t}, 50);\r\n\t\t});\r\n\t}\r\n\r\n\tfunction ensureBodyHasRoleApplication(ed) {\r\n\t\tdocument.body.setAttribute(\"role\", \"application\");\r\n\t}\r\n\r\n\ttinymce.create('tinymce.util.Quirks', {\r\n\t\tQuirks: function(ed) {\r\n\t\t\t// WebKit\r\n\t\t\tif (tinymce.isWebKit) {\r\n\t\t\t\tcleanupStylesWhenDeleting(ed);\r\n\t\t\t\temptyEditorWhenDeleting(ed);\r\n\t\t\t\tinputMethodFocus(ed);\r\n\t\t\t\tselectControlElements(ed);\r\n\r\n\t\t\t\t// iOS\r\n\t\t\t\tif (tinymce.isIDevice) {\r\n\t\t\t\t\tselectionChangeNodeChanged(ed);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// IE\r\n\t\t\tif (tinymce.isIE) {\r\n\t\t\t\tremoveHrOnBackspace(ed);\r\n\t\t\t\temptyEditorWhenDeleting(ed);\r\n\t\t\t\tensureBodyHasRoleApplication(ed);\r\n\t\t\t}\r\n\r\n\t\t\t// Gecko\r\n\t\t\tif (tinymce.isGecko) {\r\n\t\t\t\tremoveHrOnBackspace(ed);\r\n\t\t\t\tfocusBody(ed);\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n})(tinymce);\r\n\r\n(function(tinymce) {\r\n\tvar namedEntities, baseEntities, reverseEntities,\r\n\t\tattrsCharsRegExp = /[&<>\\\"\\u007E-\\uD7FF\\uE000-\\uFFEF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g,\r\n\t\ttextCharsRegExp = /[<>&\\u007E-\\uD7FF\\uE000-\\uFFEF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g,\r\n\t\trawCharsRegExp = /[<>&\\\"\\']/g,\r\n\t\tentityRegExp = /&(#x|#)?([\\w]+);/g,\r\n\t\tasciiMap = {\r\n\t\t\t\t128 : \"\\u20AC\", 130 : \"\\u201A\", 131 : \"\\u0192\", 132 : \"\\u201E\", 133 : \"\\u2026\", 134 : \"\\u2020\",\r\n\t\t\t\t135 : \"\\u2021\", 136 : \"\\u02C6\", 137 : \"\\u2030\", 138 : \"\\u0160\", 139 : \"\\u2039\", 140 : \"\\u0152\",\r\n\t\t\t\t142 : \"\\u017D\", 145 : \"\\u2018\", 146 : \"\\u2019\", 147 : \"\\u201C\", 148 : \"\\u201D\", 149 : \"\\u2022\",\r\n\t\t\t\t150 : \"\\u2013\", 151 : \"\\u2014\", 152 : \"\\u02DC\", 153 : \"\\u2122\", 154 : \"\\u0161\", 155 : \"\\u203A\",\r\n\t\t\t\t156 : \"\\u0153\", 158 : \"\\u017E\", 159 : \"\\u0178\"\r\n\t\t};\r\n\r\n\t// Raw entities\r\n\tbaseEntities = {\r\n\t\t'\\\"' : '&quot;', // Needs to be escaped since the YUI compressor would otherwise break the code\r\n\t\t\"'\" : '&#39;',\r\n\t\t'<' : '&lt;',\r\n\t\t'>' : '&gt;',\r\n\t\t'&' : '&amp;'\r\n\t};\r\n\r\n\t// Reverse lookup table for raw entities\r\n\treverseEntities = {\r\n\t\t'&lt;' : '<',\r\n\t\t'&gt;' : '>',\r\n\t\t'&amp;' : '&',\r\n\t\t'&quot;' : '\"',\r\n\t\t'&apos;' : \"'\"\r\n\t};\r\n\r\n\t// Decodes text by using the browser\r\n\tfunction nativeDecode(text) {\r\n\t\tvar elm;\r\n\r\n\t\telm = document.createElement(\"div\");\r\n\t\telm.innerHTML = text;\r\n\r\n\t\treturn elm.textContent || elm.innerText || text;\r\n\t};\r\n\r\n\t// Build a two way lookup table for the entities\r\n\tfunction buildEntitiesLookup(items, radix) {\r\n\t\tvar i, chr, entity, lookup = {};\r\n\r\n\t\tif (items) {\r\n\t\t\titems = items.split(',');\r\n\t\t\tradix = radix || 10;\r\n\r\n\t\t\t// Build entities lookup table\r\n\t\t\tfor (i = 0; i < items.length; i += 2) {\r\n\t\t\t\tchr = String.fromCharCode(parseInt(items[i], radix));\r\n\r\n\t\t\t\t// Only add non base entities\r\n\t\t\t\tif (!baseEntities[chr]) {\r\n\t\t\t\t\tentity = '&' + items[i + 1] + ';';\r\n\t\t\t\t\tlookup[chr] = entity;\r\n\t\t\t\t\tlookup[entity] = chr;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn lookup;\r\n\t\t}\r\n\t};\r\n\r\n\t// Unpack entities lookup where the numbers are in radix 32 to reduce the size\r\n\tnamedEntities = buildEntitiesLookup(\r\n\t\t'50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,' +\r\n\t\t'5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,' +\r\n\t\t'5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,' +\r\n\t\t'5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,' +\r\n\t\t'68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,' +\r\n\t\t'6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,' +\r\n\t\t'6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,' +\r\n\t\t'75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,' +\r\n\t\t'7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,' +\r\n\t\t'7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,' +\r\n\t\t'sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,' +\r\n\t\t'st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,' +\r\n\t\t't9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,' +\r\n\t\t'tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,' +\r\n\t\t'u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,' +\r\n\t\t'81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,' +\r\n\t\t'8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,' +\r\n\t\t'8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,' +\r\n\t\t'8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,' +\r\n\t\t'8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,' +\r\n\t\t'nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,' +\r\n\t\t'rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,' +\r\n\t\t'Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,' +\r\n\t\t'80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,' +\r\n\t\t'811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro'\r\n\t, 32);\r\n\r\n\ttinymce.html = tinymce.html || {};\r\n\r\n\ttinymce.html.Entities = {\r\n\t\tencodeRaw : function(text, attr) {\r\n\t\t\treturn text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function(chr) {\r\n\t\t\t\treturn baseEntities[chr] || chr;\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\tencodeAllRaw : function(text) {\r\n\t\t\treturn ('' + text).replace(rawCharsRegExp, function(chr) {\r\n\t\t\t\treturn baseEntities[chr] || chr;\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\tencodeNumeric : function(text, attr) {\r\n\t\t\treturn text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function(chr) {\r\n\t\t\t\t// Multi byte sequence convert it to a single entity\r\n\t\t\t\tif (chr.length > 1)\r\n\t\t\t\t\treturn '&#' + (((chr.charCodeAt(0) - 0xD800) * 0x400) + (chr.charCodeAt(1) - 0xDC00) + 0x10000) + ';';\r\n\r\n\t\t\t\treturn baseEntities[chr] || '&#' + chr.charCodeAt(0) + ';';\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\tencodeNamed : function(text, attr, entities) {\r\n\t\t\tentities = entities || namedEntities;\r\n\r\n\t\t\treturn text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function(chr) {\r\n\t\t\t\treturn baseEntities[chr] || entities[chr] || chr;\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\tgetEncodeFunc : function(name, entities) {\r\n\t\t\tvar Entities = tinymce.html.Entities;\r\n\r\n\t\t\tentities = buildEntitiesLookup(entities) || namedEntities;\r\n\r\n\t\t\tfunction encodeNamedAndNumeric(text, attr) {\r\n\t\t\t\treturn text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function(chr) {\r\n\t\t\t\t\treturn baseEntities[chr] || entities[chr] || '&#' + chr.charCodeAt(0) + ';' || chr;\r\n\t\t\t\t});\r\n\t\t\t};\r\n\r\n\t\t\tfunction encodeCustomNamed(text, attr) {\r\n\t\t\t\treturn Entities.encodeNamed(text, attr, entities);\r\n\t\t\t};\r\n\r\n\t\t\t// Replace + with , to be compatible with previous TinyMCE versions\r\n\t\t\tname = tinymce.makeMap(name.replace(/\\+/g, ','));\r\n\r\n\t\t\t// Named and numeric encoder\r\n\t\t\tif (name.named && name.numeric)\r\n\t\t\t\treturn encodeNamedAndNumeric;\r\n\r\n\t\t\t// Named encoder\r\n\t\t\tif (name.named) {\r\n\t\t\t\t// Custom names\r\n\t\t\t\tif (entities)\r\n\t\t\t\t\treturn encodeCustomNamed;\r\n\r\n\t\t\t\treturn Entities.encodeNamed;\r\n\t\t\t}\r\n\r\n\t\t\t// Numeric\r\n\t\t\tif (name.numeric)\r\n\t\t\t\treturn Entities.encodeNumeric;\r\n\r\n\t\t\t// Raw encoder\r\n\t\t\treturn Entities.encodeRaw;\r\n\t\t},\r\n\r\n\t\tdecode : function(text) {\r\n\t\t\treturn text.replace(entityRegExp, function(all, numeric, value) {\r\n\t\t\t\tif (numeric) {\r\n\t\t\t\t\tvalue = parseInt(value, numeric.length === 2 ? 16 : 10);\r\n\r\n\t\t\t\t\t// Support upper UTF\r\n\t\t\t\t\tif (value > 0xFFFF) {\r\n\t\t\t\t\t\tvalue -= 0x10000;\r\n\r\n\t\t\t\t\t\treturn String.fromCharCode(0xD800 + (value >> 10), 0xDC00 + (value & 0x3FF));\r\n\t\t\t\t\t} else\r\n\t\t\t\t\t\treturn asciiMap[value] || String.fromCharCode(value);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn reverseEntities[all] || namedEntities[all] || nativeDecode(all);\r\n\t\t\t});\r\n\t\t}\r\n\t};\r\n})(tinymce);\r\n\r\ntinymce.html.Styles = function(settings, schema) {\r\n\tvar rgbRegExp = /rgb\\s*\\(\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*\\)/gi,\r\n\t\turlOrStrRegExp = /(?:url(?:(?:\\(\\s*\\\"([^\\\"]+)\\\"\\s*\\))|(?:\\(\\s*\\'([^\\']+)\\'\\s*\\))|(?:\\(\\s*([^)\\s]+)\\s*\\))))|(?:\\'([^\\']+)\\')|(?:\\\"([^\\\"]+)\\\")/gi,\r\n\t\tstyleRegExp = /\\s*([^:]+):\\s*([^;]+);?/g,\r\n\t\ttrimRightRegExp = /\\s+$/,\r\n\t\turlColorRegExp = /rgb/,\r\n\t\tundef, i, encodingLookup = {}, encodingItems;\r\n\r\n\tsettings = settings || {};\r\n\r\n\tencodingItems = '\\\\\" \\\\\\' \\\\; \\\\: ; : \\uFEFF'.split(' ');\r\n\tfor (i = 0; i < encodingItems.length; i++) {\r\n\t\tencodingLookup[encodingItems[i]] = '\\uFEFF' + i;\r\n\t\tencodingLookup['\\uFEFF' + i] = encodingItems[i];\r\n\t}\r\n\r\n\tfunction toHex(match, r, g, b) {\r\n\t\tfunction hex(val) {\r\n\t\t\tval = parseInt(val).toString(16);\r\n\r\n\t\t\treturn val.length > 1 ? val : '0' + val; // 0 -> 00\r\n\t\t};\r\n\r\n\t\treturn '#' + hex(r) + hex(g) + hex(b);\r\n\t};\r\n\r\n\treturn {\r\n\t\ttoHex : function(color) {\r\n\t\t\treturn color.replace(rgbRegExp, toHex);\r\n\t\t},\r\n\r\n\t\tparse : function(css) {\r\n\t\t\tvar styles = {}, matches, name, value, isEncoded, urlConverter = settings.url_converter, urlConverterScope = settings.url_converter_scope || this;\r\n\r\n\t\t\tfunction compress(prefix, suffix) {\r\n\t\t\t\tvar top, right, bottom, left;\r\n\r\n\t\t\t\t// Get values and check it needs compressing\r\n\t\t\t\ttop = styles[prefix + '-top' + suffix];\r\n\t\t\t\tif (!top)\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\tright = styles[prefix + '-right' + suffix];\r\n\t\t\t\tif (top != right)\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\tbottom = styles[prefix + '-bottom' + suffix];\r\n\t\t\t\tif (right != bottom)\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\tleft = styles[prefix + '-left' + suffix];\r\n\t\t\t\tif (bottom != left)\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t// Compress\r\n\t\t\t\tstyles[prefix + suffix] = left;\r\n\t\t\t\tdelete styles[prefix + '-top' + suffix];\r\n\t\t\t\tdelete styles[prefix + '-right' + suffix];\r\n\t\t\t\tdelete styles[prefix + '-bottom' + suffix];\r\n\t\t\t\tdelete styles[prefix + '-left' + suffix];\r\n\t\t\t};\r\n\r\n\t\t\tfunction canCompress(key) {\r\n\t\t\t\tvar value = styles[key], i;\r\n\r\n\t\t\t\tif (!value || value.indexOf(' ') < 0)\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\tvalue = value.split(' ');\r\n\t\t\t\ti = value.length;\r\n\t\t\t\twhile (i--) {\r\n\t\t\t\t\tif (value[i] !== value[0])\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tstyles[key] = value[0];\r\n\r\n\t\t\t\treturn true;\r\n\t\t\t};\r\n\r\n\t\t\tfunction compress2(target, a, b, c) {\r\n\t\t\t\tif (!canCompress(a))\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\tif (!canCompress(b))\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\tif (!canCompress(c))\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t// Compress\r\n\t\t\t\tstyles[target] = styles[a] + ' ' + styles[b] + ' ' + styles[c];\r\n\t\t\t\tdelete styles[a];\r\n\t\t\t\tdelete styles[b];\r\n\t\t\t\tdelete styles[c];\r\n\t\t\t};\r\n\r\n\t\t\t// Encodes the specified string by replacing all \\\" \\' ; : with _<num>\r\n\t\t\tfunction encode(str) {\r\n\t\t\t\tisEncoded = true;\r\n\r\n\t\t\t\treturn encodingLookup[str];\r\n\t\t\t};\r\n\r\n\t\t\t// Decodes the specified string by replacing all _<num> with it's original value \\\" \\' etc\r\n\t\t\t// It will also decode the \\\" \\' if keep_slashes is set to fale or omitted\r\n\t\t\tfunction decode(str, keep_slashes) {\r\n\t\t\t\tif (isEncoded) {\r\n\t\t\t\t\tstr = str.replace(/\\uFEFF[0-9]/g, function(str) {\r\n\t\t\t\t\t\treturn encodingLookup[str];\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!keep_slashes)\r\n\t\t\t\t\tstr = str.replace(/\\\\([\\'\\\";:])/g, \"$1\");\r\n\r\n\t\t\t\treturn str;\r\n\t\t\t}\r\n\r\n\t\t\tif (css) {\r\n\t\t\t\t// Encode \\\" \\' % and ; and : inside strings so they don't interfere with the style parsing\r\n\t\t\t\tcss = css.replace(/\\\\[\\\"\\';:\\uFEFF]/g, encode).replace(/\\\"[^\\\"]+\\\"|\\'[^\\']+\\'/g, function(str) {\r\n\t\t\t\t\treturn str.replace(/[;:]/g, encode);\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// Parse styles\r\n\t\t\t\twhile (matches = styleRegExp.exec(css)) {\r\n\t\t\t\t\tname = matches[1].replace(trimRightRegExp, '').toLowerCase();\r\n\t\t\t\t\tvalue = matches[2].replace(trimRightRegExp, '');\r\n\r\n\t\t\t\t\tif (name && value.length > 0) {\r\n\t\t\t\t\t\t// Opera will produce 700 instead of bold in their style values\r\n\t\t\t\t\t\tif (name === 'font-weight' && value === '700')\r\n\t\t\t\t\t\t\tvalue = 'bold';\r\n\t\t\t\t\t\telse if (name === 'color' || name === 'background-color') // Lowercase colors like RED\r\n\t\t\t\t\t\t\tvalue = value.toLowerCase();\r\n\r\n\t\t\t\t\t\t// Convert RGB colors to HEX\r\n\t\t\t\t\t\tvalue = value.replace(rgbRegExp, toHex);\r\n\r\n\t\t\t\t\t\t// Convert URLs and force them into url('value') format\r\n\t\t\t\t\t\tvalue = value.replace(urlOrStrRegExp, function(match, url, url2, url3, str, str2) {\r\n\t\t\t\t\t\t\tstr = str || str2;\r\n\r\n\t\t\t\t\t\t\tif (str) {\r\n\t\t\t\t\t\t\t\tstr = decode(str);\r\n\r\n\t\t\t\t\t\t\t\t// Force strings into single quote format\r\n\t\t\t\t\t\t\t\treturn \"'\" + str.replace(/\\'/g, \"\\\\'\") + \"'\";\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\turl = decode(url || url2 || url3);\r\n\r\n\t\t\t\t\t\t\t// Convert the URL to relative/absolute depending on config\r\n\t\t\t\t\t\t\tif (urlConverter)\r\n\t\t\t\t\t\t\t\turl = urlConverter.call(urlConverterScope, url, 'style');\r\n\r\n\t\t\t\t\t\t\t// Output new URL format\r\n\t\t\t\t\t\t\treturn \"url('\" + url.replace(/\\'/g, \"\\\\'\") + \"')\";\r\n\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\tstyles[name] = isEncoded ? decode(value, true) : value;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tstyleRegExp.lastIndex = matches.index + matches[0].length;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Compress the styles to reduce it's size for example IE will expand styles\r\n\t\t\t\tcompress(\"border\", \"\");\r\n\t\t\t\tcompress(\"border\", \"-width\");\r\n\t\t\t\tcompress(\"border\", \"-color\");\r\n\t\t\t\tcompress(\"border\", \"-style\");\r\n\t\t\t\tcompress(\"padding\", \"\");\r\n\t\t\t\tcompress(\"margin\", \"\");\r\n\t\t\t\tcompress2('border', 'border-width', 'border-style', 'border-color');\r\n\r\n\t\t\t\t// Remove pointless border, IE produces these\r\n\t\t\t\tif (styles.border === 'medium none')\r\n\t\t\t\t\tdelete styles.border;\r\n\t\t\t}\r\n\r\n\t\t\treturn styles;\r\n\t\t},\r\n\r\n\t\tserialize : function(styles, element_name) {\r\n\t\t\tvar css = '', name, value;\r\n\r\n\t\t\tfunction serializeStyles(name) {\r\n\t\t\t\tvar styleList, i, l, value;\r\n\r\n\t\t\t\tstyleList = schema.styles[name];\r\n\t\t\t\tif (styleList) {\r\n\t\t\t\t\tfor (i = 0, l = styleList.length; i < l; i++) {\r\n\t\t\t\t\t\tname = styleList[i];\r\n\t\t\t\t\t\tvalue = styles[name];\r\n\r\n\t\t\t\t\t\tif (value !== undef && value.length > 0)\r\n\t\t\t\t\t\t\tcss += (css.length > 0 ? ' ' : '') + name + ': ' + value + ';';\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\t// Serialize styles according to schema\r\n\t\t\tif (element_name && schema && schema.styles) {\r\n\t\t\t\t// Serialize global styles and element specific styles\r\n\t\t\t\tserializeStyles('*');\r\n\t\t\t\tserializeStyles(element_name);\r\n\t\t\t} else {\r\n\t\t\t\t// Output the styles in the order they are inside the object\r\n\t\t\t\tfor (name in styles) {\r\n\t\t\t\t\tvalue = styles[name];\r\n\r\n\t\t\t\t\tif (value !== undef && value.length > 0)\r\n\t\t\t\t\t\tcss += (css.length > 0 ? ' ' : '') + name + ': ' + value + ';';\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn css;\r\n\t\t}\r\n\t};\r\n};\r\n\r\n(function(tinymce) {\r\n\tvar transitional = {}, boolAttrMap, blockElementsMap, shortEndedElementsMap, nonEmptyElementsMap, customElementsMap = {},\r\n\t\tdefaultWhiteSpaceElementsMap, selfClosingElementsMap, makeMap = tinymce.makeMap, each = tinymce.each;\r\n\r\n\tfunction split(str, delim) {\r\n\t\treturn str.split(delim || ',');\r\n\t};\r\n\r\n\tfunction unpack(lookup, data) {\r\n\t\tvar key, elements = {};\r\n\r\n\t\tfunction replace(value) {\r\n\t\t\treturn value.replace(/[A-Z]+/g, function(key) {\r\n\t\t\t\treturn replace(lookup[key]);\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t\t// Unpack lookup\r\n\t\tfor (key in lookup) {\r\n\t\t\tif (lookup.hasOwnProperty(key))\r\n\t\t\t\tlookup[key] = replace(lookup[key]);\r\n\t\t}\r\n\r\n\t\t// Unpack and parse data into object map\r\n\t\treplace(data).replace(/#/g, '#text').replace(/(\\w+)\\[([^\\]]+)\\]\\[([^\\]]*)\\]/g, function(str, name, attributes, children) {\r\n\t\t\tattributes = split(attributes, '|');\r\n\r\n\t\t\telements[name] = {\r\n\t\t\t\tattributes : makeMap(attributes),\r\n\t\t\t\tattributesOrder : attributes,\r\n\t\t\t\tchildren : makeMap(children, '|', {'#comment' : {}})\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn elements;\r\n\t};\r\n\r\n\t// Build a lookup table for block elements both lowercase and uppercase\r\n\tblockElementsMap = 'h1,h2,h3,h4,h5,h6,hr,p,div,address,pre,form,table,tbody,thead,tfoot,' +\r\n\t\t\t\t\t\t'th,tr,td,li,ol,ul,caption,blockquote,center,dl,dt,dd,dir,fieldset,' +\r\n\t\t\t\t\t\t'noscript,menu,isindex,samp,header,footer,article,section,hgroup';\r\n\tblockElementsMap = makeMap(blockElementsMap, ',', makeMap(blockElementsMap.toUpperCase()));\r\n\r\n\t// This is the XHTML 1.0 transitional elements with it's attributes and children packed to reduce it's size\r\n\ttransitional = unpack({\r\n\t\tZ : 'H|K|N|O|P',\r\n\t\tY : 'X|form|R|Q',\r\n\t\tZG : 'E|span|width|align|char|charoff|valign',\r\n\t\tX : 'p|T|div|U|W|isindex|fieldset|table',\r\n\t\tZF : 'E|align|char|charoff|valign',\r\n\t\tW : 'pre|hr|blockquote|address|center|noframes',\r\n\t\tZE : 'abbr|axis|headers|scope|rowspan|colspan|align|char|charoff|valign|nowrap|bgcolor|width|height',\r\n\t\tZD : '[E][S]',\r\n\t\tU : 'ul|ol|dl|menu|dir',\r\n\t\tZC : 'p|Y|div|U|W|table|br|span|bdo|object|applet|img|map|K|N|Q',\r\n\t\tT : 'h1|h2|h3|h4|h5|h6',\r\n\t\tZB : 'X|S|Q',\r\n\t\tS : 'R|P',\r\n\t\tZA : 'a|G|J|M|O|P',\r\n\t\tR : 'a|H|K|N|O',\r\n\t\tQ : 'noscript|P',\r\n\t\tP : 'ins|del|script',\r\n\t\tO : 'input|select|textarea|label|button',\r\n\t\tN : 'M|L',\r\n\t\tM : 'em|strong|dfn|code|q|samp|kbd|var|cite|abbr|acronym',\r\n\t\tL : 'sub|sup',\r\n\t\tK : 'J|I',\r\n\t\tJ : 'tt|i|b|u|s|strike',\r\n\t\tI : 'big|small|font|basefont',\r\n\t\tH : 'G|F',\r\n\t\tG : 'br|span|bdo',\r\n\t\tF : 'object|applet|img|map|iframe',\r\n\t\tE : 'A|B|C',\r\n\t\tD : 'accesskey|tabindex|onfocus|onblur',\r\n\t\tC : 'onclick|ondblclick|onmousedown|onmouseup|onmouseover|onmousemove|onmouseout|onkeypress|onkeydown|onkeyup',\r\n\t\tB : 'lang|xml:lang|dir',\r\n\t\tA : 'id|class|style|title'\r\n\t}, 'script[id|charset|type|language|src|defer|xml:space][]' +\r\n\t\t'style[B|id|type|media|title|xml:space][]' +\r\n\t\t'object[E|declare|classid|codebase|data|type|codetype|archive|standby|width|height|usemap|name|tabindex|align|border|hspace|vspace][#|param|Y]' +\r\n\t\t'param[id|name|value|valuetype|type][]' +\r\n\t\t'p[E|align][#|S]' +\r\n\t\t'a[E|D|charset|type|name|href|hreflang|rel|rev|shape|coords|target][#|Z]' +\r\n\t\t'br[A|clear][]' +\r\n\t\t'span[E][#|S]' +\r\n\t\t'bdo[A|C|B][#|S]' +\r\n\t\t'applet[A|codebase|archive|code|object|alt|name|width|height|align|hspace|vspace][#|param|Y]' +\r\n\t\t'h1[E|align][#|S]' +\r\n\t\t'img[E|src|alt|name|longdesc|width|height|usemap|ismap|align|border|hspace|vspace][]' +\r\n\t\t'map[B|C|A|name][X|form|Q|area]' +\r\n\t\t'h2[E|align][#|S]' +\r\n\t\t'iframe[A|longdesc|name|src|frameborder|marginwidth|marginheight|scrolling|align|width|height][#|Y]' +\r\n\t\t'h3[E|align][#|S]' +\r\n\t\t'tt[E][#|S]' +\r\n\t\t'i[E][#|S]' +\r\n\t\t'b[E][#|S]' +\r\n\t\t'u[E][#|S]' +\r\n\t\t's[E][#|S]' +\r\n\t\t'strike[E][#|S]' +\r\n\t\t'big[E][#|S]' +\r\n\t\t'small[E][#|S]' +\r\n\t\t'font[A|B|size|color|face][#|S]' +\r\n\t\t'basefont[id|size|color|face][]' +\r\n\t\t'em[E][#|S]' +\r\n\t\t'strong[E][#|S]' +\r\n\t\t'dfn[E][#|S]' +\r\n\t\t'code[E][#|S]' +\r\n\t\t'q[E|cite][#|S]' +\r\n\t\t'samp[E][#|S]' +\r\n\t\t'kbd[E][#|S]' +\r\n\t\t'var[E][#|S]' +\r\n\t\t'cite[E][#|S]' +\r\n\t\t'abbr[E][#|S]' +\r\n\t\t'acronym[E][#|S]' +\r\n\t\t'sub[E][#|S]' +\r\n\t\t'sup[E][#|S]' +\r\n\t\t'input[E|D|type|name|value|checked|disabled|readonly|size|maxlength|src|alt|usemap|onselect|onchange|accept|align][]' +\r\n\t\t'select[E|name|size|multiple|disabled|tabindex|onfocus|onblur|onchange][optgroup|option]' +\r\n\t\t'optgroup[E|disabled|label][option]' +\r\n\t\t'option[E|selected|disabled|label|value][]' +\r\n\t\t'textarea[E|D|name|rows|cols|disabled|readonly|onselect|onchange][]' +\r\n\t\t'label[E|for|accesskey|onfocus|onblur][#|S]' +\r\n\t\t'button[E|D|name|value|type|disabled][#|p|T|div|U|W|table|G|object|applet|img|map|K|N|Q]' +\r\n\t\t'h4[E|align][#|S]' +\r\n\t\t'ins[E|cite|datetime][#|Y]' +\r\n\t\t'h5[E|align][#|S]' +\r\n\t\t'del[E|cite|datetime][#|Y]' +\r\n\t\t'h6[E|align][#|S]' +\r\n\t\t'div[E|align][#|Y]' +\r\n\t\t'ul[E|type|compact][li]' +\r\n\t\t'li[E|type|value][#|Y]' +\r\n\t\t'ol[E|type|compact|start][li]' +\r\n\t\t'dl[E|compact][dt|dd]' +\r\n\t\t'dt[E][#|S]' +\r\n\t\t'dd[E][#|Y]' +\r\n\t\t'menu[E|compact][li]' +\r\n\t\t'dir[E|compact][li]' +\r\n\t\t'pre[E|width|xml:space][#|ZA]' +\r\n\t\t'hr[E|align|noshade|size|width][]' +\r\n\t\t'blockquote[E|cite][#|Y]' +\r\n\t\t'address[E][#|S|p]' +\r\n\t\t'center[E][#|Y]' +\r\n\t\t'noframes[E][#|Y]' +\r\n\t\t'isindex[A|B|prompt][]' +\r\n\t\t'fieldset[E][#|legend|Y]' +\r\n\t\t'legend[E|accesskey|align][#|S]' +\r\n\t\t'table[E|summary|width|border|frame|rules|cellspacing|cellpadding|align|bgcolor][caption|col|colgroup|thead|tfoot|tbody|tr]' +\r\n\t\t'caption[E|align][#|S]' +\r\n\t\t'col[ZG][]' +\r\n\t\t'colgroup[ZG][col]' +\r\n\t\t'thead[ZF][tr]' +\r\n\t\t'tr[ZF|bgcolor][th|td]' +\r\n\t\t'th[E|ZE][#|Y]' +\r\n\t\t'form[E|action|method|name|enctype|onsubmit|onreset|accept|accept-charset|target][#|X|R|Q]' +\r\n\t\t'noscript[E][#|Y]' +\r\n\t\t'td[E|ZE][#|Y]' +\r\n\t\t'tfoot[ZF][tr]' +\r\n\t\t'tbody[ZF][tr]' +\r\n\t\t'area[E|D|shape|coords|href|nohref|alt|target][]' +\r\n\t\t'base[id|href|target][]' +\r\n\t\t'body[E|onload|onunload|background|bgcolor|text|link|vlink|alink][#|Y]'\r\n\t);\r\n\r\n\tboolAttrMap = makeMap('checked,compact,declare,defer,disabled,ismap,multiple,nohref,noresize,noshade,nowrap,readonly,selected,autoplay,loop,controls');\r\n\tshortEndedElementsMap = makeMap('area,base,basefont,br,col,frame,hr,img,input,isindex,link,meta,param,embed,source');\r\n\tnonEmptyElementsMap = tinymce.extend(makeMap('td,th,iframe,video,audio,object'), shortEndedElementsMap);\r\n\tdefaultWhiteSpaceElementsMap = makeMap('pre,script,style,textarea');\r\n\tselfClosingElementsMap = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr');\r\n\r\n\ttinymce.html.Schema = function(settings) {\r\n\t\tvar self = this, elements = {}, children = {}, patternElements = [], validStyles, whiteSpaceElementsMap;\r\n\r\n\t\tsettings = settings || {};\r\n\r\n\t\t// Allow all elements and attributes if verify_html is set to false\r\n\t\tif (settings.verify_html === false)\r\n\t\t\tsettings.valid_elements = '*[*]';\r\n\r\n\t\t// Build styles list\r\n\t\tif (settings.valid_styles) {\r\n\t\t\tvalidStyles = {};\r\n\r\n\t\t\t// Convert styles into a rule list\r\n\t\t\teach(settings.valid_styles, function(value, key) {\r\n\t\t\t\tvalidStyles[key] = tinymce.explode(value);\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\twhiteSpaceElementsMap = settings.whitespace_elements ? makeMap(settings.whitespace_elements) : defaultWhiteSpaceElementsMap;\r\n\r\n\t\t// Converts a wildcard expression string to a regexp for example *a will become /.*a/.\r\n\t\tfunction patternToRegExp(str) {\r\n\t\t\treturn new RegExp('^' + str.replace(/([?+*])/g, '.$1') + '$');\r\n\t\t};\r\n\r\n\t\t// Parses the specified valid_elements string and adds to the current rules\r\n\t\t// This function is a bit hard to read since it's heavily optimized for speed\r\n\t\tfunction addValidElements(valid_elements) {\r\n\t\t\tvar ei, el, ai, al, yl, matches, element, attr, attrData, elementName, attrName, attrType, attributes, attributesOrder,\r\n\t\t\t\tprefix, outputName, globalAttributes, globalAttributesOrder, transElement, key, childKey, value,\r\n\t\t\t\telementRuleRegExp = /^([#+-])?([^\\[\\/]+)(?:\\/([^\\[]+))?(?:\\[([^\\]]+)\\])?$/,\r\n\t\t\t\tattrRuleRegExp = /^([!\\-])?(\\w+::\\w+|[^=:<]+)?(?:([=:<])(.*))?$/,\r\n\t\t\t\thasPatternsRegExp = /[*?+]/;\r\n\r\n\t\t\tif (valid_elements) {\r\n\t\t\t\t// Split valid elements into an array with rules\r\n\t\t\t\tvalid_elements = split(valid_elements);\r\n\r\n\t\t\t\tif (elements['@']) {\r\n\t\t\t\t\tglobalAttributes = elements['@'].attributes;\r\n\t\t\t\t\tglobalAttributesOrder = elements['@'].attributesOrder;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Loop all rules\r\n\t\t\t\tfor (ei = 0, el = valid_elements.length; ei < el; ei++) {\r\n\t\t\t\t\t// Parse element rule\r\n\t\t\t\t\tmatches = elementRuleRegExp.exec(valid_elements[ei]);\r\n\t\t\t\t\tif (matches) {\r\n\t\t\t\t\t\t// Setup local names for matches\r\n\t\t\t\t\t\tprefix = matches[1];\r\n\t\t\t\t\t\telementName = matches[2];\r\n\t\t\t\t\t\toutputName = matches[3];\r\n\t\t\t\t\t\tattrData = matches[4];\r\n\r\n\t\t\t\t\t\t// Create new attributes and attributesOrder\r\n\t\t\t\t\t\tattributes = {};\r\n\t\t\t\t\t\tattributesOrder = [];\r\n\r\n\t\t\t\t\t\t// Create the new element\r\n\t\t\t\t\t\telement = {\r\n\t\t\t\t\t\t\tattributes : attributes,\r\n\t\t\t\t\t\t\tattributesOrder : attributesOrder\r\n\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\t// Padd empty elements prefix\r\n\t\t\t\t\t\tif (prefix === '#')\r\n\t\t\t\t\t\t\telement.paddEmpty = true;\r\n\r\n\t\t\t\t\t\t// Remove empty elements prefix\r\n\t\t\t\t\t\tif (prefix === '-')\r\n\t\t\t\t\t\t\telement.removeEmpty = true;\r\n\r\n\t\t\t\t\t\t// Copy attributes from global rule into current rule\r\n\t\t\t\t\t\tif (globalAttributes) {\r\n\t\t\t\t\t\t\tfor (key in globalAttributes)\r\n\t\t\t\t\t\t\t\tattributes[key] = globalAttributes[key];\r\n\r\n\t\t\t\t\t\t\tattributesOrder.push.apply(attributesOrder, globalAttributesOrder);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Attributes defined\r\n\t\t\t\t\t\tif (attrData) {\r\n\t\t\t\t\t\t\tattrData = split(attrData, '|');\r\n\t\t\t\t\t\t\tfor (ai = 0, al = attrData.length; ai < al; ai++) {\r\n\t\t\t\t\t\t\t\tmatches = attrRuleRegExp.exec(attrData[ai]);\r\n\t\t\t\t\t\t\t\tif (matches) {\r\n\t\t\t\t\t\t\t\t\tattr = {};\r\n\t\t\t\t\t\t\t\t\tattrType = matches[1];\r\n\t\t\t\t\t\t\t\t\tattrName = matches[2].replace(/::/g, ':');\r\n\t\t\t\t\t\t\t\t\tprefix = matches[3];\r\n\t\t\t\t\t\t\t\t\tvalue = matches[4];\r\n\r\n\t\t\t\t\t\t\t\t\t// Required\r\n\t\t\t\t\t\t\t\t\tif (attrType === '!') {\r\n\t\t\t\t\t\t\t\t\t\telement.attributesRequired = element.attributesRequired || [];\r\n\t\t\t\t\t\t\t\t\t\telement.attributesRequired.push(attrName);\r\n\t\t\t\t\t\t\t\t\t\tattr.required = true;\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t// Denied from global\r\n\t\t\t\t\t\t\t\t\tif (attrType === '-') {\r\n\t\t\t\t\t\t\t\t\t\tdelete attributes[attrName];\r\n\t\t\t\t\t\t\t\t\t\tattributesOrder.splice(tinymce.inArray(attributesOrder, attrName), 1);\r\n\t\t\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t// Default value\r\n\t\t\t\t\t\t\t\t\tif (prefix) {\r\n\t\t\t\t\t\t\t\t\t\t// Default value\r\n\t\t\t\t\t\t\t\t\t\tif (prefix === '=') {\r\n\t\t\t\t\t\t\t\t\t\t\telement.attributesDefault = element.attributesDefault || [];\r\n\t\t\t\t\t\t\t\t\t\t\telement.attributesDefault.push({name: attrName, value: value});\r\n\t\t\t\t\t\t\t\t\t\t\tattr.defaultValue = value;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Forced value\r\n\t\t\t\t\t\t\t\t\t\tif (prefix === ':') {\r\n\t\t\t\t\t\t\t\t\t\t\telement.attributesForced = element.attributesForced || [];\r\n\t\t\t\t\t\t\t\t\t\t\telement.attributesForced.push({name: attrName, value: value});\r\n\t\t\t\t\t\t\t\t\t\t\tattr.forcedValue = value;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Required values\r\n\t\t\t\t\t\t\t\t\t\tif (prefix === '<')\r\n\t\t\t\t\t\t\t\t\t\t\tattr.validValues = makeMap(value, '?');\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t// Check for attribute patterns\r\n\t\t\t\t\t\t\t\t\tif (hasPatternsRegExp.test(attrName)) {\r\n\t\t\t\t\t\t\t\t\t\telement.attributePatterns = element.attributePatterns || [];\r\n\t\t\t\t\t\t\t\t\t\tattr.pattern = patternToRegExp(attrName);\r\n\t\t\t\t\t\t\t\t\t\telement.attributePatterns.push(attr);\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t// Add attribute to order list if it doesn't already exist\r\n\t\t\t\t\t\t\t\t\t\tif (!attributes[attrName])\r\n\t\t\t\t\t\t\t\t\t\t\tattributesOrder.push(attrName);\r\n\r\n\t\t\t\t\t\t\t\t\t\tattributes[attrName] = attr;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Global rule, store away these for later usage\r\n\t\t\t\t\t\tif (!globalAttributes && elementName == '@') {\r\n\t\t\t\t\t\t\tglobalAttributes = attributes;\r\n\t\t\t\t\t\t\tglobalAttributesOrder = attributesOrder;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Handle substitute elements such as b/strong\r\n\t\t\t\t\t\tif (outputName) {\r\n\t\t\t\t\t\t\telement.outputName = elementName;\r\n\t\t\t\t\t\t\telements[outputName] = element;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Add pattern or exact element\r\n\t\t\t\t\t\tif (hasPatternsRegExp.test(elementName)) {\r\n\t\t\t\t\t\t\telement.pattern = patternToRegExp(elementName);\r\n\t\t\t\t\t\t\tpatternElements.push(element);\r\n\t\t\t\t\t\t} else\r\n\t\t\t\t\t\t\telements[elementName] = element;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tfunction setValidElements(valid_elements) {\r\n\t\t\telements = {};\r\n\t\t\tpatternElements = [];\r\n\r\n\t\t\taddValidElements(valid_elements);\r\n\r\n\t\t\teach(transitional, function(element, name) {\r\n\t\t\t\tchildren[name] = element.children;\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t\t// Adds custom non HTML elements to the schema\r\n\t\tfunction addCustomElements(custom_elements) {\r\n\t\t\tvar customElementRegExp = /^(~)?(.+)$/;\r\n\r\n\t\t\tif (custom_elements) {\r\n\t\t\t\teach(split(custom_elements), function(rule) {\r\n\t\t\t\t\tvar matches = customElementRegExp.exec(rule),\r\n\t\t\t\t\t\tinline = matches[1] === '~',\r\n\t\t\t\t\t\tcloneName = inline ? 'span' : 'div',\r\n\t\t\t\t\t\tname = matches[2];\r\n\r\n\t\t\t\t\tchildren[name] = children[cloneName];\r\n\t\t\t\t\tcustomElementsMap[name] = cloneName;\r\n\r\n\t\t\t\t\t// If it's not marked as inline then add it to valid block elements\r\n\t\t\t\t\tif (!inline)\r\n\t\t\t\t\t\tblockElementsMap[name] = {};\r\n\r\n\t\t\t\t\t// Add custom elements at span/div positions\r\n\t\t\t\t\teach(children, function(element, child) {\r\n\t\t\t\t\t\tif (element[cloneName])\r\n\t\t\t\t\t\t\telement[name] = element[cloneName];\r\n\t\t\t\t\t});\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t// Adds valid children to the schema object\r\n\t\tfunction addValidChildren(valid_children) {\r\n\t\t\tvar childRuleRegExp = /^([+\\-]?)(\\w+)\\[([^\\]]+)\\]$/;\r\n\r\n\t\t\tif (valid_children) {\r\n\t\t\t\teach(split(valid_children), function(rule) {\r\n\t\t\t\t\tvar matches = childRuleRegExp.exec(rule), parent, prefix;\r\n\r\n\t\t\t\t\tif (matches) {\r\n\t\t\t\t\t\tprefix = matches[1];\r\n\r\n\t\t\t\t\t\t// Add/remove items from default\r\n\t\t\t\t\t\tif (prefix)\r\n\t\t\t\t\t\t\tparent = children[matches[2]];\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tparent = children[matches[2]] = {'#comment' : {}};\r\n\r\n\t\t\t\t\t\tparent = children[matches[2]];\r\n\r\n\t\t\t\t\t\teach(split(matches[3], '|'), function(child) {\r\n\t\t\t\t\t\t\tif (prefix === '-')\r\n\t\t\t\t\t\t\t\tdelete parent[child];\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\tparent[child] = {};\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tfunction getElementRule(name) {\r\n\t\t\tvar element = elements[name], i;\r\n\r\n\t\t\t// Exact match found\r\n\t\t\tif (element)\r\n\t\t\t\treturn element;\r\n\r\n\t\t\t// No exact match then try the patterns\r\n\t\t\ti = patternElements.length;\r\n\t\t\twhile (i--) {\r\n\t\t\t\telement = patternElements[i];\r\n\r\n\t\t\t\tif (element.pattern.test(name))\r\n\t\t\t\t\treturn element;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tif (!settings.valid_elements) {\r\n\t\t\t// No valid elements defined then clone the elements from the transitional spec\r\n\t\t\teach(transitional, function(element, name) {\r\n\t\t\t\telements[name] = {\r\n\t\t\t\t\tattributes : element.attributes,\r\n\t\t\t\t\tattributesOrder : element.attributesOrder\r\n\t\t\t\t};\r\n\r\n\t\t\t\tchildren[name] = element.children;\r\n\t\t\t});\r\n\r\n\t\t\t// Switch these\r\n\t\t\teach(split('strong/b,em/i'), function(item) {\r\n\t\t\t\titem = split(item, '/');\r\n\t\t\t\telements[item[1]].outputName = item[0];\r\n\t\t\t});\r\n\r\n\t\t\t// Add default alt attribute for images\r\n\t\t\telements.img.attributesDefault = [{name: 'alt', value: ''}];\r\n\r\n\t\t\t// Remove these if they are empty by default\r\n\t\t\teach(split('ol,ul,sub,sup,blockquote,span,font,a,table,tbody,tr'), function(name) {\r\n\t\t\t\telements[name].removeEmpty = true;\r\n\t\t\t});\r\n\r\n\t\t\t// Padd these by default\r\n\t\t\teach(split('p,h1,h2,h3,h4,h5,h6,th,td,pre,div,address,caption'), function(name) {\r\n\t\t\t\telements[name].paddEmpty = true;\r\n\t\t\t});\r\n\t\t} else\r\n\t\t\tsetValidElements(settings.valid_elements);\r\n\r\n\t\taddCustomElements(settings.custom_elements);\r\n\t\taddValidChildren(settings.valid_children);\r\n\t\taddValidElements(settings.extended_valid_elements);\r\n\r\n\t\t// Todo: Remove this when we fix list handling to be valid\r\n\t\taddValidChildren('+ol[ul|ol],+ul[ul|ol]');\r\n\r\n\t\t// If the user didn't allow span only allow internal spans\r\n\t\tif (!getElementRule('span'))\r\n\t\t\taddValidElements('span[!data-mce-type|*]');\r\n\r\n\t\t// Delete invalid elements\r\n\t\tif (settings.invalid_elements) {\r\n\t\t\ttinymce.each(tinymce.explode(settings.invalid_elements), function(item) {\r\n\t\t\t\tif (elements[item])\r\n\t\t\t\t\tdelete elements[item];\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tself.children = children;\r\n\r\n\t\tself.styles = validStyles;\r\n\r\n\t\tself.getBoolAttrs = function() {\r\n\t\t\treturn boolAttrMap;\r\n\t\t};\r\n\r\n\t\tself.getBlockElements = function() {\r\n\t\t\treturn blockElementsMap;\r\n\t\t};\r\n\r\n\t\tself.getShortEndedElements = function() {\r\n\t\t\treturn shortEndedElementsMap;\r\n\t\t};\r\n\r\n\t\tself.getSelfClosingElements = function() {\r\n\t\t\treturn selfClosingElementsMap;\r\n\t\t};\r\n\r\n\t\tself.getNonEmptyElements = function() {\r\n\t\t\treturn nonEmptyElementsMap;\r\n\t\t};\r\n\r\n\t\tself.getWhiteSpaceElements = function() {\r\n\t\t\treturn whiteSpaceElementsMap;\r\n\t\t};\r\n\r\n\t\tself.isValidChild = function(name, child) {\r\n\t\t\tvar parent = children[name];\r\n\r\n\t\t\treturn !!(parent && parent[child]);\r\n\t\t};\r\n\r\n\t\tself.getElementRule = getElementRule;\r\n\r\n\t\tself.getCustomElements = function() {\r\n\t\t\treturn customElementsMap;\r\n\t\t};\r\n\r\n\t\tself.addValidElements = addValidElements;\r\n\r\n\t\tself.setValidElements = setValidElements;\r\n\r\n\t\tself.addCustomElements = addCustomElements;\r\n\r\n\t\tself.addValidChildren = addValidChildren;\r\n\t};\r\n\r\n\t// Expose boolMap and blockElementMap as static properties for usage in DOMUtils\r\n\ttinymce.html.Schema.boolAttrMap = boolAttrMap;\r\n\ttinymce.html.Schema.blockElementsMap = blockElementsMap;\r\n})(tinymce);\r\n\r\n(function(tinymce) {\r\n\ttinymce.html.SaxParser = function(settings, schema) {\r\n\t\tvar self = this, noop = function() {};\r\n\r\n\t\tsettings = settings || {};\r\n\t\tself.schema = schema = schema || new tinymce.html.Schema();\r\n\r\n\t\tif (settings.fix_self_closing !== false)\r\n\t\t\tsettings.fix_self_closing = true;\r\n\r\n\t\t// Add handler functions from settings and setup default handlers\r\n\t\ttinymce.each('comment cdata text start end pi doctype'.split(' '), function(name) {\r\n\t\t\tif (name)\r\n\t\t\t\tself[name] = settings[name] || noop;\r\n\t\t});\r\n\r\n\t\tself.parse = function(html) {\r\n\t\t\tvar self = this, matches, index = 0, value, endRegExp, stack = [], attrList, i, text, name, isInternalElement, removeInternalElements,\r\n\t\t\t\tshortEndedElements, fillAttrsMap, isShortEnded, validate, elementRule, isValidElement, attr, attribsValue, invalidPrefixRegExp,\r\n\t\t\t\tvalidAttributesMap, validAttributePatterns, attributesRequired, attributesDefault, attributesForced, selfClosing,\r\n\t\t\t\ttokenRegExp, attrRegExp, specialElements, attrValue, idCount = 0, decode = tinymce.html.Entities.decode, fixSelfClosing, isIE;\r\n\r\n\t\t\tfunction processEndTag(name) {\r\n\t\t\t\tvar pos, i;\r\n\r\n\t\t\t\t// Find position of parent of the same type\r\n\t\t\t\tpos = stack.length;\r\n\t\t\t\twhile (pos--) {\r\n\t\t\t\t\tif (stack[pos].name === name)\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Found parent\r\n\t\t\t\tif (pos >= 0) {\r\n\t\t\t\t\t// Close all the open elements\r\n\t\t\t\t\tfor (i = stack.length - 1; i >= pos; i--) {\r\n\t\t\t\t\t\tname = stack[i];\r\n\r\n\t\t\t\t\t\tif (name.valid)\r\n\t\t\t\t\t\t\tself.end(name.name);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Remove the open elements from the stack\r\n\t\t\t\t\tstack.length = pos;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\t// Precompile RegExps and map objects\r\n\t\t\ttokenRegExp = new RegExp('<(?:' +\r\n\t\t\t\t'(?:!--([\\\\w\\\\W]*?)-->)|' + // Comment\r\n\t\t\t\t'(?:!\\\\[CDATA\\\\[([\\\\w\\\\W]*?)\\\\]\\\\]>)|' + // CDATA\r\n\t\t\t\t'(?:!DOCTYPE([\\\\w\\\\W]*?)>)|' + // DOCTYPE\r\n\t\t\t\t'(?:\\\\?([^\\\\s\\\\/<>]+) ?([\\\\w\\\\W]*?)[?/]>)|' + // PI\r\n\t\t\t\t'(?:\\\\/([^>]+)>)|' + // End element\r\n\t\t\t\t'(?:([^\\\\s\\\\/<>]+)((?:\\\\s+[^\"\\'>]+(?:(?:\"[^\"]*\")|(?:\\'[^\\']*\\')|[^>]*))*|\\\\/)>)' + // Start element\r\n\t\t\t')', 'g');\r\n\r\n\t\t\tattrRegExp = /([\\w:\\-]+)(?:\\s*=\\s*(?:(?:\\\"((?:\\\\.|[^\\\"])*)\\\")|(?:\\'((?:\\\\.|[^\\'])*)\\')|([^>\\s]+)))?/g;\r\n\t\t\tspecialElements = {\r\n\t\t\t\t'script' : /<\\/script[^>]*>/gi,\r\n\t\t\t\t'style' : /<\\/style[^>]*>/gi,\r\n\t\t\t\t'noscript' : /<\\/noscript[^>]*>/gi\r\n\t\t\t};\r\n\r\n\t\t\t// Setup lookup tables for empty elements and boolean attributes\r\n\t\t\tshortEndedElements = schema.getShortEndedElements();\r\n\t\t\tselfClosing = schema.getSelfClosingElements();\r\n\t\t\tfillAttrsMap = schema.getBoolAttrs();\r\n\t\t\tvalidate = settings.validate;\r\n\t\t\tremoveInternalElements = settings.remove_internals;\r\n\t\t\tfixSelfClosing = settings.fix_self_closing;\r\n\t\t\tisIE = tinymce.isIE;\r\n\t\t\tinvalidPrefixRegExp = /^:/;\r\n\r\n\t\t\twhile (matches = tokenRegExp.exec(html)) {\r\n\t\t\t\t// Text\r\n\t\t\t\tif (index < matches.index)\r\n\t\t\t\t\tself.text(decode(html.substr(index, matches.index - index)));\r\n\r\n\t\t\t\tif (value = matches[6]) { // End element\r\n\t\t\t\t\tvalue = value.toLowerCase();\r\n\r\n\t\t\t\t\t// IE will add a \":\" in front of elements it doesn't understand like custom elements or HTML5 elements\r\n\t\t\t\t\tif (isIE && invalidPrefixRegExp.test(value))\r\n\t\t\t\t\t\tvalue = value.substr(1);\r\n\r\n\t\t\t\t\tprocessEndTag(value);\r\n\t\t\t\t} else if (value = matches[7]) { // Start element\r\n\t\t\t\t\tvalue = value.toLowerCase();\r\n\r\n\t\t\t\t\t// IE will add a \":\" in front of elements it doesn't understand like custom elements or HTML5 elements\r\n\t\t\t\t\tif (isIE && invalidPrefixRegExp.test(value))\r\n\t\t\t\t\t\tvalue = value.substr(1);\r\n\r\n\t\t\t\t\tisShortEnded = value in shortEndedElements;\r\n\r\n\t\t\t\t\t// Is self closing tag for example an <li> after an open <li>\r\n\t\t\t\t\tif (fixSelfClosing && selfClosing[value] && stack.length > 0 && stack[stack.length - 1].name === value)\r\n\t\t\t\t\t\tprocessEndTag(value);\r\n\r\n\t\t\t\t\t// Validate element\r\n\t\t\t\t\tif (!validate || (elementRule = schema.getElementRule(value))) {\r\n\t\t\t\t\t\tisValidElement = true;\r\n\r\n\t\t\t\t\t\t// Grab attributes map and patters when validation is enabled\r\n\t\t\t\t\t\tif (validate) {\r\n\t\t\t\t\t\t\tvalidAttributesMap = elementRule.attributes;\r\n\t\t\t\t\t\t\tvalidAttributePatterns = elementRule.attributePatterns;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Parse attributes\r\n\t\t\t\t\t\tif (attribsValue = matches[8]) {\r\n\t\t\t\t\t\t\tisInternalElement = attribsValue.indexOf('data-mce-type') !== -1; // Check if the element is an internal element\r\n\r\n\t\t\t\t\t\t\t// If the element has internal attributes then remove it if we are told to do so\r\n\t\t\t\t\t\t\tif (isInternalElement && removeInternalElements)\r\n\t\t\t\t\t\t\t\tisValidElement = false;\r\n\r\n\t\t\t\t\t\t\tattrList = [];\r\n\t\t\t\t\t\t\tattrList.map = {};\r\n\r\n\t\t\t\t\t\t\tattribsValue.replace(attrRegExp, function(match, name, value, val2, val3) {\r\n\t\t\t\t\t\t\t\tvar attrRule, i;\r\n\r\n\t\t\t\t\t\t\t\tname = name.toLowerCase();\r\n\t\t\t\t\t\t\t\tvalue = name in fillAttrsMap ? name : decode(value || val2 || val3 || ''); // Handle boolean attribute than value attribute\r\n\r\n\t\t\t\t\t\t\t\t// Validate name and value\r\n\t\t\t\t\t\t\t\tif (validate && !isInternalElement && name.indexOf('data-') !== 0) {\r\n\t\t\t\t\t\t\t\t\tattrRule = validAttributesMap[name];\r\n\r\n\t\t\t\t\t\t\t\t\t// Find rule by pattern matching\r\n\t\t\t\t\t\t\t\t\tif (!attrRule && validAttributePatterns) {\r\n\t\t\t\t\t\t\t\t\t\ti = validAttributePatterns.length;\r\n\t\t\t\t\t\t\t\t\t\twhile (i--) {\r\n\t\t\t\t\t\t\t\t\t\t\tattrRule = validAttributePatterns[i];\r\n\t\t\t\t\t\t\t\t\t\t\tif (attrRule.pattern.test(name))\r\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t// No rule matched\r\n\t\t\t\t\t\t\t\t\t\tif (i === -1)\r\n\t\t\t\t\t\t\t\t\t\t\tattrRule = null;\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t// No attribute rule found\r\n\t\t\t\t\t\t\t\t\tif (!attrRule)\r\n\t\t\t\t\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t\t\t\t\t// Validate value\r\n\t\t\t\t\t\t\t\t\tif (attrRule.validValues && !(value in attrRule.validValues))\r\n\t\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t// Add attribute to list and map\r\n\t\t\t\t\t\t\t\tattrList.map[name] = value;\r\n\t\t\t\t\t\t\t\tattrList.push({\r\n\t\t\t\t\t\t\t\t\tname: name,\r\n\t\t\t\t\t\t\t\t\tvalue: value\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tattrList = [];\r\n\t\t\t\t\t\t\tattrList.map = {};\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Process attributes if validation is enabled\r\n\t\t\t\t\t\tif (validate && !isInternalElement) {\r\n\t\t\t\t\t\t\tattributesRequired = elementRule.attributesRequired;\r\n\t\t\t\t\t\t\tattributesDefault = elementRule.attributesDefault;\r\n\t\t\t\t\t\t\tattributesForced = elementRule.attributesForced;\r\n\r\n\t\t\t\t\t\t\t// Handle forced attributes\r\n\t\t\t\t\t\t\tif (attributesForced) {\r\n\t\t\t\t\t\t\t\ti = attributesForced.length;\r\n\t\t\t\t\t\t\t\twhile (i--) {\r\n\t\t\t\t\t\t\t\t\tattr = attributesForced[i];\r\n\t\t\t\t\t\t\t\t\tname = attr.name;\r\n\t\t\t\t\t\t\t\t\tattrValue = attr.value;\r\n\r\n\t\t\t\t\t\t\t\t\tif (attrValue === '{$uid}')\r\n\t\t\t\t\t\t\t\t\t\tattrValue = 'mce_' + idCount++;\r\n\r\n\t\t\t\t\t\t\t\t\tattrList.map[name] = attrValue;\r\n\t\t\t\t\t\t\t\t\tattrList.push({name: name, value: attrValue});\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// Handle default attributes\r\n\t\t\t\t\t\t\tif (attributesDefault) {\r\n\t\t\t\t\t\t\t\ti = attributesDefault.length;\r\n\t\t\t\t\t\t\t\twhile (i--) {\r\n\t\t\t\t\t\t\t\t\tattr = attributesDefault[i];\r\n\t\t\t\t\t\t\t\t\tname = attr.name;\r\n\r\n\t\t\t\t\t\t\t\t\tif (!(name in attrList.map)) {\r\n\t\t\t\t\t\t\t\t\t\tattrValue = attr.value;\r\n\r\n\t\t\t\t\t\t\t\t\t\tif (attrValue === '{$uid}')\r\n\t\t\t\t\t\t\t\t\t\t\tattrValue = 'mce_' + idCount++;\r\n\r\n\t\t\t\t\t\t\t\t\t\tattrList.map[name] = attrValue;\r\n\t\t\t\t\t\t\t\t\t\tattrList.push({name: name, value: attrValue});\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// Handle required attributes\r\n\t\t\t\t\t\t\tif (attributesRequired) {\r\n\t\t\t\t\t\t\t\ti = attributesRequired.length;\r\n\t\t\t\t\t\t\t\twhile (i--) {\r\n\t\t\t\t\t\t\t\t\tif (attributesRequired[i] in attrList.map)\r\n\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t// None of the required attributes where found\r\n\t\t\t\t\t\t\t\tif (i === -1)\r\n\t\t\t\t\t\t\t\t\tisValidElement = false;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// Invalidate element if it's marked as bogus\r\n\t\t\t\t\t\t\tif (attrList.map['data-mce-bogus'])\r\n\t\t\t\t\t\t\t\tisValidElement = false;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (isValidElement)\r\n\t\t\t\t\t\t\tself.start(value, attrList, isShortEnded);\r\n\t\t\t\t\t} else\r\n\t\t\t\t\t\tisValidElement = false;\r\n\r\n\t\t\t\t\t// Treat script, noscript and style a bit different since they may include code that looks like elements\r\n\t\t\t\t\tif (endRegExp = specialElements[value]) {\r\n\t\t\t\t\t\tendRegExp.lastIndex = index = matches.index + matches[0].length;\r\n\r\n\t\t\t\t\t\tif (matches = endRegExp.exec(html)) {\r\n\t\t\t\t\t\t\tif (isValidElement)\r\n\t\t\t\t\t\t\t\ttext = html.substr(index, matches.index - index);\r\n\r\n\t\t\t\t\t\t\tindex = matches.index + matches[0].length;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\ttext = html.substr(index);\r\n\t\t\t\t\t\t\tindex = html.length;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (isValidElement && text.length > 0)\r\n\t\t\t\t\t\t\tself.text(text, true);\r\n\r\n\t\t\t\t\t\tif (isValidElement)\r\n\t\t\t\t\t\t\tself.end(value);\r\n\r\n\t\t\t\t\t\ttokenRegExp.lastIndex = index;\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Push value on to stack\r\n\t\t\t\t\tif (!isShortEnded) {\r\n\t\t\t\t\t\tif (!attribsValue || attribsValue.indexOf('/') != attribsValue.length - 1)\r\n\t\t\t\t\t\t\tstack.push({name: value, valid: isValidElement});\r\n\t\t\t\t\t\telse if (isValidElement)\r\n\t\t\t\t\t\t\tself.end(value);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (value = matches[1]) { // Comment\r\n\t\t\t\t\tself.comment(value);\r\n\t\t\t\t} else if (value = matches[2]) { // CDATA\r\n\t\t\t\t\tself.cdata(value);\r\n\t\t\t\t} else if (value = matches[3]) { // DOCTYPE\r\n\t\t\t\t\tself.doctype(value);\r\n\t\t\t\t} else if (value = matches[4]) { // PI\r\n\t\t\t\t\tself.pi(value, matches[5]);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tindex = matches.index + matches[0].length;\r\n\t\t\t}\r\n\r\n\t\t\t// Text\r\n\t\t\tif (index < html.length)\r\n\t\t\t\tself.text(decode(html.substr(index)));\r\n\r\n\t\t\t// Close any open elements\r\n\t\t\tfor (i = stack.length - 1; i >= 0; i--) {\r\n\t\t\t\tvalue = stack[i];\r\n\r\n\t\t\t\tif (value.valid)\r\n\t\t\t\t\tself.end(value.name);\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n})(tinymce);\r\n\r\n(function(tinymce) {\r\n\tvar whiteSpaceRegExp = /^[ \\t\\r\\n]*$/, typeLookup = {\r\n\t\t'#text' : 3,\r\n\t\t'#comment' : 8,\r\n\t\t'#cdata' : 4,\r\n\t\t'#pi' : 7,\r\n\t\t'#doctype' : 10,\r\n\t\t'#document-fragment' : 11\r\n\t};\r\n\r\n\t// Walks the tree left/right\r\n\tfunction walk(node, root_node, prev) {\r\n\t\tvar sibling, parent, startName = prev ? 'lastChild' : 'firstChild', siblingName = prev ? 'prev' : 'next';\r\n\r\n\t\t// Walk into nodes if it has a start\r\n\t\tif (node[startName])\r\n\t\t\treturn node[startName];\r\n\r\n\t\t// Return the sibling if it has one\r\n\t\tif (node !== root_node) {\r\n\t\t\tsibling = node[siblingName];\r\n\r\n\t\t\tif (sibling)\r\n\t\t\t\treturn sibling;\r\n\r\n\t\t\t// Walk up the parents to look for siblings\r\n\t\t\tfor (parent = node.parent; parent && parent !== root_node; parent = parent.parent) {\r\n\t\t\t\tsibling = parent[siblingName];\r\n\r\n\t\t\t\tif (sibling)\r\n\t\t\t\t\treturn sibling;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tfunction Node(name, type) {\r\n\t\tthis.name = name;\r\n\t\tthis.type = type;\r\n\r\n\t\tif (type === 1) {\r\n\t\t\tthis.attributes = [];\r\n\t\t\tthis.attributes.map = {};\r\n\t\t}\r\n\t}\r\n\r\n\ttinymce.extend(Node.prototype, {\r\n\t\treplace : function(node) {\r\n\t\t\tvar self = this;\r\n\r\n\t\t\tif (node.parent)\r\n\t\t\t\tnode.remove();\r\n\r\n\t\t\tself.insert(node, self);\r\n\t\t\tself.remove();\r\n\r\n\t\t\treturn self;\r\n\t\t},\r\n\r\n\t\tattr : function(name, value) {\r\n\t\t\tvar self = this, attrs, i, undef;\r\n\r\n\t\t\tif (typeof name !== \"string\") {\r\n\t\t\t\tfor (i in name)\r\n\t\t\t\t\tself.attr(i, name[i]);\r\n\r\n\t\t\t\treturn self;\r\n\t\t\t}\r\n\r\n\t\t\tif (attrs = self.attributes) {\r\n\t\t\t\tif (value !== undef) {\r\n\t\t\t\t\t// Remove attribute\r\n\t\t\t\t\tif (value === null) {\r\n\t\t\t\t\t\tif (name in attrs.map) {\r\n\t\t\t\t\t\t\tdelete attrs.map[name];\r\n\r\n\t\t\t\t\t\t\ti = attrs.length;\r\n\t\t\t\t\t\t\twhile (i--) {\r\n\t\t\t\t\t\t\t\tif (attrs[i].name === name) {\r\n\t\t\t\t\t\t\t\t\tattrs = attrs.splice(i, 1);\r\n\t\t\t\t\t\t\t\t\treturn self;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn self;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Set attribute\r\n\t\t\t\t\tif (name in attrs.map) {\r\n\t\t\t\t\t\t// Set attribute\r\n\t\t\t\t\t\ti = attrs.length;\r\n\t\t\t\t\t\twhile (i--) {\r\n\t\t\t\t\t\t\tif (attrs[i].name === name) {\r\n\t\t\t\t\t\t\t\tattrs[i].value = value;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else\r\n\t\t\t\t\t\tattrs.push({name: name, value: value});\r\n\r\n\t\t\t\t\tattrs.map[name] = value;\r\n\r\n\t\t\t\t\treturn self;\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn attrs.map[name];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tclone : function() {\r\n\t\t\tvar self = this, clone = new Node(self.name, self.type), i, l, selfAttrs, selfAttr, cloneAttrs;\r\n\r\n\t\t\t// Clone element attributes\r\n\t\t\tif (selfAttrs = self.attributes) {\r\n\t\t\t\tcloneAttrs = [];\r\n\t\t\t\tcloneAttrs.map = {};\r\n\r\n\t\t\t\tfor (i = 0, l = selfAttrs.length; i < l; i++) {\r\n\t\t\t\t\tselfAttr = selfAttrs[i];\r\n\r\n\t\t\t\t\t// Clone everything except id\r\n\t\t\t\t\tif (selfAttr.name !== 'id') {\r\n\t\t\t\t\t\tcloneAttrs[cloneAttrs.length] = {name: selfAttr.name, value: selfAttr.value};\r\n\t\t\t\t\t\tcloneAttrs.map[selfAttr.name] = selfAttr.value;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tclone.attributes = cloneAttrs;\r\n\t\t\t}\r\n\r\n\t\t\tclone.value = self.value;\r\n\t\t\tclone.shortEnded = self.shortEnded;\r\n\r\n\t\t\treturn clone;\r\n\t\t},\r\n\r\n\t\twrap : function(wrapper) {\r\n\t\t\tvar self = this;\r\n\r\n\t\t\tself.parent.insert(wrapper, self);\r\n\t\t\twrapper.append(self);\r\n\r\n\t\t\treturn self;\r\n\t\t},\r\n\r\n\t\tunwrap : function() {\r\n\t\t\tvar self = this, node, next;\r\n\r\n\t\t\tfor (node = self.firstChild; node; ) {\r\n\t\t\t\tnext = node.next;\r\n\t\t\t\tself.insert(node, self, true);\r\n\t\t\t\tnode = next;\r\n\t\t\t}\r\n\r\n\t\t\tself.remove();\r\n\t\t},\r\n\r\n\t\tremove : function() {\r\n\t\t\tvar self = this, parent = self.parent, next = self.next, prev = self.prev;\r\n\r\n\t\t\tif (parent) {\r\n\t\t\t\tif (parent.firstChild === self) {\r\n\t\t\t\t\tparent.firstChild = next;\r\n\r\n\t\t\t\t\tif (next)\r\n\t\t\t\t\t\tnext.prev = null;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tprev.next = next;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (parent.lastChild === self) {\r\n\t\t\t\t\tparent.lastChild = prev;\r\n\r\n\t\t\t\t\tif (prev)\r\n\t\t\t\t\t\tprev.next = null;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tnext.prev = prev;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tself.parent = self.next = self.prev = null;\r\n\t\t\t}\r\n\r\n\t\t\treturn self;\r\n\t\t},\r\n\r\n\t\tappend : function(node) {\r\n\t\t\tvar self = this, last;\r\n\r\n\t\t\tif (node.parent)\r\n\t\t\t\tnode.remove();\r\n\r\n\t\t\tlast = self.lastChild;\r\n\t\t\tif (last) {\r\n\t\t\t\tlast.next = node;\r\n\t\t\t\tnode.prev = last;\r\n\t\t\t\tself.lastChild = node;\r\n\t\t\t} else\r\n\t\t\t\tself.lastChild = self.firstChild = node;\r\n\r\n\t\t\tnode.parent = self;\r\n\r\n\t\t\treturn node;\r\n\t\t},\r\n\r\n\t\tinsert : function(node, ref_node, before) {\r\n\t\t\tvar parent;\r\n\r\n\t\t\tif (node.parent)\r\n\t\t\t\tnode.remove();\r\n\r\n\t\t\tparent = ref_node.parent || this;\r\n\r\n\t\t\tif (before) {\r\n\t\t\t\tif (ref_node === parent.firstChild)\r\n\t\t\t\t\tparent.firstChild = node;\r\n\t\t\t\telse\r\n\t\t\t\t\tref_node.prev.next = node;\r\n\r\n\t\t\t\tnode.prev = ref_node.prev;\r\n\t\t\t\tnode.next = ref_node;\r\n\t\t\t\tref_node.prev = node;\r\n\t\t\t} else {\r\n\t\t\t\tif (ref_node === parent.lastChild)\r\n\t\t\t\t\tparent.lastChild = node;\r\n\t\t\t\telse\r\n\t\t\t\t\tref_node.next.prev = node;\r\n\r\n\t\t\t\tnode.next = ref_node.next;\r\n\t\t\t\tnode.prev = ref_node;\r\n\t\t\t\tref_node.next = node;\r\n\t\t\t}\r\n\r\n\t\t\tnode.parent = parent;\r\n\r\n\t\t\treturn node;\r\n\t\t},\r\n\r\n\t\tgetAll : function(name) {\r\n\t\t\tvar self = this, node, collection = [];\r\n\r\n\t\t\tfor (node = self.firstChild; node; node = walk(node, self)) {\r\n\t\t\t\tif (node.name === name)\r\n\t\t\t\t\tcollection.push(node);\r\n\t\t\t}\r\n\r\n\t\t\treturn collection;\r\n\t\t},\r\n\r\n\t\tempty : function() {\r\n\t\t\tvar self = this, nodes, i, node;\r\n\r\n\t\t\t// Remove all children\r\n\t\t\tif (self.firstChild) {\r\n\t\t\t\tnodes = [];\r\n\r\n\t\t\t\t// Collect the children\r\n\t\t\t\tfor (node = self.firstChild; node; node = walk(node, self))\r\n\t\t\t\t\tnodes.push(node);\r\n\r\n\t\t\t\t// Remove the children\r\n\t\t\t\ti = nodes.length;\r\n\t\t\t\twhile (i--) {\r\n\t\t\t\t\tnode = nodes[i];\r\n\t\t\t\t\tnode.parent = node.firstChild = node.lastChild = node.next = node.prev = null;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tself.firstChild = self.lastChild = null;\r\n\r\n\t\t\treturn self;\r\n\t\t},\r\n\r\n\t\tisEmpty : function(elements) {\r\n\t\t\tvar self = this, node = self.firstChild, i, name;\r\n\r\n\t\t\tif (node) {\r\n\t\t\t\tdo {\r\n\t\t\t\t\tif (node.type === 1) {\r\n\t\t\t\t\t\t// Ignore bogus elements\r\n\t\t\t\t\t\tif (node.attributes.map['data-mce-bogus'])\r\n\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\t// Keep empty elements like <img />\r\n\t\t\t\t\t\tif (elements[node.name])\r\n\t\t\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t\t\t// Keep elements with data attributes or name attribute like <a name=\"1\"></a>\r\n\t\t\t\t\t\ti = node.attributes.length;\r\n\t\t\t\t\t\twhile (i--) {\r\n\t\t\t\t\t\t\tname = node.attributes[i].name;\r\n\t\t\t\t\t\t\tif (name === \"name\" || name.indexOf('data-') === 0)\r\n\t\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Keep non whitespace text nodes\r\n\t\t\t\t\tif ((node.type === 3 && !whiteSpaceRegExp.test(node.value)))\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t} while (node = walk(node, self));\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\t\t},\r\n\r\n\t\twalk : function(prev) {\r\n\t\t\treturn walk(this, null, prev);\r\n\t\t}\r\n\t});\r\n\r\n\ttinymce.extend(Node, {\r\n\t\tcreate : function(name, attrs) {\r\n\t\t\tvar node, attrName;\r\n\r\n\t\t\t// Create node\r\n\t\t\tnode = new Node(name, typeLookup[name] || 1);\r\n\r\n\t\t\t// Add attributes if needed\r\n\t\t\tif (attrs) {\r\n\t\t\t\tfor (attrName in attrs)\r\n\t\t\t\t\tnode.attr(attrName, attrs[attrName]);\r\n\t\t\t}\r\n\r\n\t\t\treturn node;\r\n\t\t}\r\n\t});\r\n\r\n\ttinymce.html.Node = Node;\r\n})(tinymce);\r\n\r\n(function(tinymce) {\r\n\tvar Node = tinymce.html.Node;\r\n\r\n\ttinymce.html.DomParser = function(settings, schema) {\r\n\t\tvar self = this, nodeFilters = {}, attributeFilters = [], matchedNodes = {}, matchedAttributes = {};\r\n\r\n\t\tsettings = settings || {};\r\n\t\tsettings.validate = \"validate\" in settings ? settings.validate : true;\r\n\t\tsettings.root_name = settings.root_name || 'body';\r\n\t\tself.schema = schema = schema || new tinymce.html.Schema();\r\n\r\n\t\tfunction fixInvalidChildren(nodes) {\r\n\t\t\tvar ni, node, parent, parents, newParent, currentNode, tempNode, childNode, i,\r\n\t\t\t\tchildClone, nonEmptyElements, nonSplitableElements, sibling, nextNode;\r\n\r\n\t\t\tnonSplitableElements = tinymce.makeMap('tr,td,th,tbody,thead,tfoot,table');\r\n\t\t\tnonEmptyElements = schema.getNonEmptyElements();\r\n\r\n\t\t\tfor (ni = 0; ni < nodes.length; ni++) {\r\n\t\t\t\tnode = nodes[ni];\r\n\r\n\t\t\t\t// Already removed\r\n\t\t\t\tif (!node.parent)\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t// Get list of all parent nodes until we find a valid parent to stick the child into\r\n\t\t\t\tparents = [node];\r\n\t\t\t\tfor (parent = node.parent; parent && !schema.isValidChild(parent.name, node.name) && !nonSplitableElements[parent.name]; parent = parent.parent)\r\n\t\t\t\t\tparents.push(parent);\r\n\r\n\t\t\t\t// Found a suitable parent\r\n\t\t\t\tif (parent && parents.length > 1) {\r\n\t\t\t\t\t// Reverse the array since it makes looping easier\r\n\t\t\t\t\tparents.reverse();\r\n\r\n\t\t\t\t\t// Clone the related parent and insert that after the moved node\r\n\t\t\t\t\tnewParent = currentNode = self.filterNode(parents[0].clone());\r\n\r\n\t\t\t\t\t// Start cloning and moving children on the left side of the target node\r\n\t\t\t\t\tfor (i = 0; i < parents.length - 1; i++) {\r\n\t\t\t\t\t\tif (schema.isValidChild(currentNode.name, parents[i].name)) {\r\n\t\t\t\t\t\t\ttempNode = self.filterNode(parents[i].clone());\r\n\t\t\t\t\t\t\tcurrentNode.append(tempNode);\r\n\t\t\t\t\t\t} else\r\n\t\t\t\t\t\t\ttempNode = currentNode;\r\n\r\n\t\t\t\t\t\tfor (childNode = parents[i].firstChild; childNode && childNode != parents[i + 1]; ) {\r\n\t\t\t\t\t\t\tnextNode = childNode.next;\r\n\t\t\t\t\t\t\ttempNode.append(childNode);\r\n\t\t\t\t\t\t\tchildNode = nextNode;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tcurrentNode = tempNode;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (!newParent.isEmpty(nonEmptyElements)) {\r\n\t\t\t\t\t\tparent.insert(newParent, parents[0], true);\r\n\t\t\t\t\t\tparent.insert(node, newParent);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tparent.insert(node, parents[0], true);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Check if the element is empty by looking through it's contents and special treatment for <p><br /></p>\r\n\t\t\t\t\tparent = parents[0];\r\n\t\t\t\t\tif (parent.isEmpty(nonEmptyElements) || parent.firstChild === parent.lastChild && parent.firstChild.name === 'br') {\r\n\t\t\t\t\t\tparent.empty().remove();\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (node.parent) {\r\n\t\t\t\t\t// If it's an LI try to find a UL/OL for it or wrap it\r\n\t\t\t\t\tif (node.name === 'li') {\r\n\t\t\t\t\t\tsibling = node.prev;\r\n\t\t\t\t\t\tif (sibling && (sibling.name === 'ul' || sibling.name === 'ul')) {\r\n\t\t\t\t\t\t\tsibling.append(node);\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tsibling = node.next;\r\n\t\t\t\t\t\tif (sibling && (sibling.name === 'ul' || sibling.name === 'ul')) {\r\n\t\t\t\t\t\t\tsibling.insert(node, sibling.firstChild, true);\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tnode.wrap(self.filterNode(new Node('ul', 1)));\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Try wrapping the element in a DIV\r\n\t\t\t\t\tif (schema.isValidChild(node.parent.name, 'div') && schema.isValidChild('div', node.name)) {\r\n\t\t\t\t\t\tnode.wrap(self.filterNode(new Node('div', 1)));\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// We failed wrapping it, then remove or unwrap it\r\n\t\t\t\t\t\tif (node.name === 'style' || node.name === 'script')\r\n\t\t\t\t\t\t\tnode.empty().remove();\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tnode.unwrap();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tself.filterNode = function(node) {\r\n\t\t\tvar i, name, list;\r\n\r\n\t\t\t// Run element filters\r\n\t\t\tif (name in nodeFilters) {\r\n\t\t\t\tlist = matchedNodes[name];\r\n\r\n\t\t\t\tif (list)\r\n\t\t\t\t\tlist.push(node);\r\n\t\t\t\telse\r\n\t\t\t\t\tmatchedNodes[name] = [node];\r\n\t\t\t}\r\n\r\n\t\t\t// Run attribute filters\r\n\t\t\ti = attributeFilters.length;\r\n\t\t\twhile (i--) {\r\n\t\t\t\tname = attributeFilters[i].name;\r\n\r\n\t\t\t\tif (name in node.attributes.map) {\r\n\t\t\t\t\tlist = matchedAttributes[name];\r\n\r\n\t\t\t\t\tif (list)\r\n\t\t\t\t\t\tlist.push(node);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tmatchedAttributes[name] = [node];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn node;\r\n\t\t};\r\n\r\n\t\tself.addNodeFilter = function(name, callback) {\r\n\t\t\ttinymce.each(tinymce.explode(name), function(name) {\r\n\t\t\t\tvar list = nodeFilters[name];\r\n\r\n\t\t\t\tif (!list)\r\n\t\t\t\t\tnodeFilters[name] = list = [];\r\n\r\n\t\t\t\tlist.push(callback);\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t\tself.addAttributeFilter = function(name, callback) {\r\n\t\t\ttinymce.each(tinymce.explode(name), function(name) {\r\n\t\t\t\tvar i;\r\n\r\n\t\t\t\tfor (i = 0; i < attributeFilters.length; i++) {\r\n\t\t\t\t\tif (attributeFilters[i].name === name) {\r\n\t\t\t\t\t\tattributeFilters[i].callbacks.push(callback);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tattributeFilters.push({name: name, callbacks: [callback]});\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t\tself.parse = function(html, args) {\r\n\t\t\tvar parser, rootNode, node, nodes, i, l, fi, fl, list, name, validate,\r\n\t\t\t\tblockElements, startWhiteSpaceRegExp, invalidChildren = [],\r\n\t\t\t\tendWhiteSpaceRegExp, allWhiteSpaceRegExp, whiteSpaceElements, children, nonEmptyElements, rootBlockName;\r\n\r\n\t\t\targs = args || {};\r\n\t\t\tmatchedNodes = {};\r\n\t\t\tmatchedAttributes = {};\r\n\t\t\tblockElements = tinymce.extend(tinymce.makeMap('script,style,head,html,body,title,meta,param'), schema.getBlockElements());\r\n\t\t\tnonEmptyElements = schema.getNonEmptyElements();\r\n\t\t\tchildren = schema.children;\r\n\t\t\tvalidate = settings.validate;\r\n\t\t\trootBlockName = \"forced_root_block\" in args ? args.forced_root_block : settings.forced_root_block;\r\n\r\n\t\t\twhiteSpaceElements = schema.getWhiteSpaceElements();\r\n\t\t\tstartWhiteSpaceRegExp = /^[ \\t\\r\\n]+/;\r\n\t\t\tendWhiteSpaceRegExp = /[ \\t\\r\\n]+$/;\r\n\t\t\tallWhiteSpaceRegExp = /[ \\t\\r\\n]+/g;\r\n\r\n\t\t\tfunction addRootBlocks() {\r\n\t\t\t\tvar node = rootNode.firstChild, next, rootBlockNode;\r\n\r\n\t\t\t\twhile (node) {\r\n\t\t\t\t\tnext = node.next;\r\n\r\n\t\t\t\t\tif (node.type == 3 || (node.type == 1 && node.name !== 'p' && !blockElements[node.name] && !node.attr('data-mce-type'))) {\r\n\t\t\t\t\t\tif (!rootBlockNode) {\r\n\t\t\t\t\t\t\t// Create a new root block element\r\n\t\t\t\t\t\t\trootBlockNode = createNode(rootBlockName, 1);\r\n\t\t\t\t\t\t\trootNode.insert(rootBlockNode, node);\r\n\t\t\t\t\t\t\trootBlockNode.append(node);\r\n\t\t\t\t\t\t} else\r\n\t\t\t\t\t\t\trootBlockNode.append(node);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\trootBlockNode = null;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tnode = next;\r\n\t\t\t\t};\r\n\t\t\t};\r\n\r\n\t\t\tfunction createNode(name, type) {\r\n\t\t\t\tvar node = new Node(name, type), list;\r\n\r\n\t\t\t\tif (name in nodeFilters) {\r\n\t\t\t\t\tlist = matchedNodes[name];\r\n\r\n\t\t\t\t\tif (list)\r\n\t\t\t\t\t\tlist.push(node);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tmatchedNodes[name] = [node];\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn node;\r\n\t\t\t};\r\n\r\n\t\t\tfunction removeWhitespaceBefore(node) {\r\n\t\t\t\tvar textNode, textVal, sibling;\r\n\r\n\t\t\t\tfor (textNode = node.prev; textNode && textNode.type === 3; ) {\r\n\t\t\t\t\ttextVal = textNode.value.replace(endWhiteSpaceRegExp, '');\r\n\r\n\t\t\t\t\tif (textVal.length > 0) {\r\n\t\t\t\t\t\ttextNode.value = textVal;\r\n\t\t\t\t\t\ttextNode = textNode.prev;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tsibling = textNode.prev;\r\n\t\t\t\t\t\ttextNode.remove();\r\n\t\t\t\t\t\ttextNode = sibling;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tparser = new tinymce.html.SaxParser({\r\n\t\t\t\tvalidate : validate,\r\n\t\t\t\tfix_self_closing : !validate, // Let the DOM parser handle <li> in <li> or <p> in <p> for better results\r\n\r\n\t\t\t\tcdata: function(text) {\r\n\t\t\t\t\tnode.append(createNode('#cdata', 4)).value = text;\r\n\t\t\t\t},\r\n\r\n\t\t\t\ttext: function(text, raw) {\r\n\t\t\t\t\tvar textNode;\r\n\r\n\t\t\t\t\t// Trim all redundant whitespace on non white space elements\r\n\t\t\t\t\tif (!whiteSpaceElements[node.name]) {\r\n\t\t\t\t\t\ttext = text.replace(allWhiteSpaceRegExp, ' ');\r\n\r\n\t\t\t\t\t\tif (node.lastChild && blockElements[node.lastChild.name])\r\n\t\t\t\t\t\t\ttext = text.replace(startWhiteSpaceRegExp, '');\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Do we need to create the node\r\n\t\t\t\t\tif (text.length !== 0) {\r\n\t\t\t\t\t\ttextNode = createNode('#text', 3);\r\n\t\t\t\t\t\ttextNode.raw = !!raw;\r\n\t\t\t\t\t\tnode.append(textNode).value = text;\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\r\n\t\t\t\tcomment: function(text) {\r\n\t\t\t\t\tnode.append(createNode('#comment', 8)).value = text;\r\n\t\t\t\t},\r\n\r\n\t\t\t\tpi: function(name, text) {\r\n\t\t\t\t\tnode.append(createNode(name, 7)).value = text;\r\n\t\t\t\t\tremoveWhitespaceBefore(node);\r\n\t\t\t\t},\r\n\r\n\t\t\t\tdoctype: function(text) {\r\n\t\t\t\t\tvar newNode;\r\n\r\n\t\t\t\t\tnewNode = node.append(createNode('#doctype', 10));\r\n\t\t\t\t\tnewNode.value = text;\r\n\t\t\t\t\tremoveWhitespaceBefore(node);\r\n\t\t\t\t},\r\n\r\n\t\t\t\tstart: function(name, attrs, empty) {\r\n\t\t\t\t\tvar newNode, attrFiltersLen, elementRule, textNode, attrName, text, sibling, parent;\r\n\r\n\t\t\t\t\telementRule = validate ? schema.getElementRule(name) : {};\r\n\t\t\t\t\tif (elementRule) {\r\n\t\t\t\t\t\tnewNode = createNode(elementRule.outputName || name, 1);\r\n\t\t\t\t\t\tnewNode.attributes = attrs;\r\n\t\t\t\t\t\tnewNode.shortEnded = empty;\r\n\r\n\t\t\t\t\t\tnode.append(newNode);\r\n\r\n\t\t\t\t\t\t// Check if node is valid child of the parent node is the child is\r\n\t\t\t\t\t\t// unknown we don't collect it since it's probably a custom element\r\n\t\t\t\t\t\tparent = children[node.name];\r\n\t\t\t\t\t\tif (parent && children[newNode.name] && !parent[newNode.name])\r\n\t\t\t\t\t\t\tinvalidChildren.push(newNode);\r\n\r\n\t\t\t\t\t\tattrFiltersLen = attributeFilters.length;\r\n\t\t\t\t\t\twhile (attrFiltersLen--) {\r\n\t\t\t\t\t\t\tattrName = attributeFilters[attrFiltersLen].name;\r\n\r\n\t\t\t\t\t\t\tif (attrName in attrs.map) {\r\n\t\t\t\t\t\t\t\tlist = matchedAttributes[attrName];\r\n\r\n\t\t\t\t\t\t\t\tif (list)\r\n\t\t\t\t\t\t\t\t\tlist.push(newNode);\r\n\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\tmatchedAttributes[attrName] = [newNode];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Trim whitespace before block\r\n\t\t\t\t\t\tif (blockElements[name])\r\n\t\t\t\t\t\t\tremoveWhitespaceBefore(newNode);\r\n\r\n\t\t\t\t\t\t// Change current node if the element wasn't empty i.e not <br /> or <img />\r\n\t\t\t\t\t\tif (!empty)\r\n\t\t\t\t\t\t\tnode = newNode;\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\r\n\t\t\t\tend: function(name) {\r\n\t\t\t\t\tvar textNode, elementRule, text, sibling, tempNode;\r\n\r\n\t\t\t\t\telementRule = validate ? schema.getElementRule(name) : {};\r\n\t\t\t\t\tif (elementRule) {\r\n\t\t\t\t\t\tif (blockElements[name]) {\r\n\t\t\t\t\t\t\tif (!whiteSpaceElements[node.name]) {\r\n\t\t\t\t\t\t\t\t// Trim whitespace at beginning of block\r\n\t\t\t\t\t\t\t\tfor (textNode = node.firstChild; textNode && textNode.type === 3; ) {\r\n\t\t\t\t\t\t\t\t\ttext = textNode.value.replace(startWhiteSpaceRegExp, '');\r\n\r\n\t\t\t\t\t\t\t\t\tif (text.length > 0) {\r\n\t\t\t\t\t\t\t\t\t\ttextNode.value = text;\r\n\t\t\t\t\t\t\t\t\t\ttextNode = textNode.next;\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\tsibling = textNode.next;\r\n\t\t\t\t\t\t\t\t\t\ttextNode.remove();\r\n\t\t\t\t\t\t\t\t\t\ttextNode = sibling;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t// Trim whitespace at end of block\r\n\t\t\t\t\t\t\t\tfor (textNode = node.lastChild; textNode && textNode.type === 3; ) {\r\n\t\t\t\t\t\t\t\t\ttext = textNode.value.replace(endWhiteSpaceRegExp, '');\r\n\r\n\t\t\t\t\t\t\t\t\tif (text.length > 0) {\r\n\t\t\t\t\t\t\t\t\t\ttextNode.value = text;\r\n\t\t\t\t\t\t\t\t\t\ttextNode = textNode.prev;\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\tsibling = textNode.prev;\r\n\t\t\t\t\t\t\t\t\t\ttextNode.remove();\r\n\t\t\t\t\t\t\t\t\t\ttextNode = sibling;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// Trim start white space\r\n\t\t\t\t\t\t\ttextNode = node.prev;\r\n\t\t\t\t\t\t\tif (textNode && textNode.type === 3) {\r\n\t\t\t\t\t\t\t\ttext = textNode.value.replace(startWhiteSpaceRegExp, '');\r\n\r\n\t\t\t\t\t\t\t\tif (text.length > 0)\r\n\t\t\t\t\t\t\t\t\ttextNode.value = text;\r\n\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\ttextNode.remove();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Handle empty nodes\r\n\t\t\t\t\t\tif (elementRule.removeEmpty || elementRule.paddEmpty) {\r\n\t\t\t\t\t\t\tif (node.isEmpty(nonEmptyElements)) {\r\n\t\t\t\t\t\t\t\tif (elementRule.paddEmpty)\r\n\t\t\t\t\t\t\t\t\tnode.empty().append(new Node('#text', '3')).value = '\\u00a0';\r\n\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\t// Leave nodes that have a name like <a name=\"name\">\r\n\t\t\t\t\t\t\t\t\tif (!node.attributes.map.name) {\r\n\t\t\t\t\t\t\t\t\t\ttempNode = node.parent;\r\n\t\t\t\t\t\t\t\t\t\tnode.empty().remove();\r\n\t\t\t\t\t\t\t\t\t\tnode = tempNode;\r\n\t\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tnode = node.parent;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}, schema);\r\n\r\n\t\t\trootNode = node = new Node(args.context || settings.root_name, 11);\r\n\r\n\t\t\tparser.parse(html);\r\n\r\n\t\t\t// Fix invalid children or report invalid children in a contextual parsing\r\n\t\t\tif (validate && invalidChildren.length) {\r\n\t\t\t\tif (!args.context)\r\n\t\t\t\t\tfixInvalidChildren(invalidChildren);\r\n\t\t\t\telse\r\n\t\t\t\t\targs.invalid = true;\r\n\t\t\t}\r\n\r\n\t\t\t// Wrap nodes in the root into block elements if the root is body\r\n\t\t\tif (rootBlockName && rootNode.name == 'body')\r\n\t\t\t\taddRootBlocks();\r\n\r\n\t\t\t// Run filters only when the contents is valid\r\n\t\t\tif (!args.invalid) {\r\n\t\t\t\t// Run node filters\r\n\t\t\t\tfor (name in matchedNodes) {\r\n\t\t\t\t\tlist = nodeFilters[name];\r\n\t\t\t\t\tnodes = matchedNodes[name];\r\n\r\n\t\t\t\t\t// Remove already removed children\r\n\t\t\t\t\tfi = nodes.length;\r\n\t\t\t\t\twhile (fi--) {\r\n\t\t\t\t\t\tif (!nodes[fi].parent)\r\n\t\t\t\t\t\t\tnodes.splice(fi, 1);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfor (i = 0, l = list.length; i < l; i++)\r\n\t\t\t\t\t\tlist[i](nodes, name, args);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Run attribute filters\r\n\t\t\t\tfor (i = 0, l = attributeFilters.length; i < l; i++) {\r\n\t\t\t\t\tlist = attributeFilters[i];\r\n\r\n\t\t\t\t\tif (list.name in matchedAttributes) {\r\n\t\t\t\t\t\tnodes = matchedAttributes[list.name];\r\n\r\n\t\t\t\t\t\t// Remove already removed children\r\n\t\t\t\t\t\tfi = nodes.length;\r\n\t\t\t\t\t\twhile (fi--) {\r\n\t\t\t\t\t\t\tif (!nodes[fi].parent)\r\n\t\t\t\t\t\t\t\tnodes.splice(fi, 1);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tfor (fi = 0, fl = list.callbacks.length; fi < fl; fi++)\r\n\t\t\t\t\t\t\tlist.callbacks[fi](nodes, list.name, args);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn rootNode;\r\n\t\t};\r\n\r\n\t\t// Remove <br> at end of block elements Gecko and WebKit injects BR elements to\r\n\t\t// make it possible to place the caret inside empty blocks. This logic tries to remove\r\n\t\t// these elements and keep br elements that where intended to be there intact\r\n\t\tif (settings.remove_trailing_brs) {\r\n\t\t\tself.addNodeFilter('br', function(nodes, name) {\r\n\t\t\t\tvar i, l = nodes.length, node, blockElements = schema.getBlockElements(),\r\n\t\t\t\t\tnonEmptyElements = schema.getNonEmptyElements(), parent, prev, prevName;\r\n\r\n\t\t\t\t// Remove brs from body element as well\r\n\t\t\t\tblockElements.body = 1;\r\n\r\n\t\t\t\t// Must loop forwards since it will otherwise remove all brs in <p>a<br><br><br></p>\r\n\t\t\t\tfor (i = 0; i < l; i++) {\r\n\t\t\t\t\tnode = nodes[i];\r\n\t\t\t\t\tparent = node.parent;\r\n\r\n\t\t\t\t\tif (blockElements[node.parent.name] && node === parent.lastChild) {\r\n\t\t\t\t\t\t// Loop all nodes to the right of the current node and check for other BR elements\r\n\t\t\t\t\t\t// excluding bookmarks since they are invisible\r\n\t\t\t\t\t\tprev = node.prev;\r\n\t\t\t\t\t\twhile (prev) {\r\n\t\t\t\t\t\t\tprevName = prev.name;\r\n\r\n\t\t\t\t\t\t\t// Ignore bookmarks\r\n\t\t\t\t\t\t\tif (prevName !== \"span\" || prev.attr('data-mce-type') !== 'bookmark') {\r\n\t\t\t\t\t\t\t\t// Found a non BR element\r\n\t\t\t\t\t\t\t\tif (prevName !== \"br\")\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t// Found another br it's a <br><br> structure then don't remove anything\r\n\t\t\t\t\t\t\t\tif (prevName === 'br') {\r\n\t\t\t\t\t\t\t\t\tnode = null;\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tprev = prev.prev;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (node) {\r\n\t\t\t\t\t\t\tnode.remove();\r\n\r\n\t\t\t\t\t\t\t// Is the parent to be considered empty after we removed the BR\r\n\t\t\t\t\t\t\tif (parent.isEmpty(nonEmptyElements)) {\r\n\t\t\t\t\t\t\t\telementRule = schema.getElementRule(parent.name);\r\n\r\n\t\t\t\t\t\t\t\t// Remove or padd the element depending on schema rule\r\n\t\t\t\t\t\t\t\tif (elementRule) {\r\n\t\t\t\t\t\t\t\t  if (elementRule.removeEmpty)\r\n\t\t\t\t\t\t\t\t\t  parent.remove();\r\n\t\t\t\t\t\t\t\t  else if (elementRule.paddEmpty)\r\n\t\t\t\t\t\t\t\t\t  parent.empty().append(new tinymce.html.Node('#text', 3)).value = '\\u00a0';\r\n\t\t\t\t\t\t\t  }\r\n              }\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n})(tinymce);\r\n\r\ntinymce.html.Writer = function(settings) {\r\n\tvar html = [], indent, indentBefore, indentAfter, encode, htmlOutput;\r\n\r\n\tsettings = settings || {};\r\n\tindent = settings.indent;\r\n\tindentBefore = tinymce.makeMap(settings.indent_before || '');\r\n\tindentAfter = tinymce.makeMap(settings.indent_after || '');\r\n\tencode = tinymce.html.Entities.getEncodeFunc(settings.entity_encoding || 'raw', settings.entities);\r\n\thtmlOutput = settings.element_format == \"html\";\r\n\r\n\treturn {\r\n\t\tstart: function(name, attrs, empty) {\r\n\t\t\tvar i, l, attr, value;\r\n\r\n\t\t\tif (indent && indentBefore[name] && html.length > 0) {\r\n\t\t\t\tvalue = html[html.length - 1];\r\n\r\n\t\t\t\tif (value.length > 0 && value !== '\\n')\r\n\t\t\t\t\thtml.push('\\n');\r\n\t\t\t}\r\n\r\n\t\t\thtml.push('<', name);\r\n\r\n\t\t\tif (attrs) {\r\n\t\t\t\tfor (i = 0, l = attrs.length; i < l; i++) {\r\n\t\t\t\t\tattr = attrs[i];\r\n\t\t\t\t\thtml.push(' ', attr.name, '=\"', encode(attr.value, true), '\"');\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (!empty || htmlOutput)\r\n\t\t\t\thtml[html.length] = '>';\r\n\t\t\telse\r\n\t\t\t\thtml[html.length] = ' />';\r\n\r\n\t\t\tif (empty && indent && indentAfter[name] && html.length > 0) {\r\n\t\t\t\tvalue = html[html.length - 1];\r\n\r\n\t\t\t\tif (value.length > 0 && value !== '\\n')\r\n\t\t\t\t\thtml.push('\\n');\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tend: function(name) {\r\n\t\t\tvar value;\r\n\r\n\t\t\t/*if (indent && indentBefore[name] && html.length > 0) {\r\n\t\t\t\tvalue = html[html.length - 1];\r\n\r\n\t\t\t\tif (value.length > 0 && value !== '\\n')\r\n\t\t\t\t\thtml.push('\\n');\r\n\t\t\t}*/\r\n\r\n\t\t\thtml.push('</', name, '>');\r\n\r\n\t\t\tif (indent && indentAfter[name] && html.length > 0) {\r\n\t\t\t\tvalue = html[html.length - 1];\r\n\r\n\t\t\t\tif (value.length > 0 && value !== '\\n')\r\n\t\t\t\t\thtml.push('\\n');\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\ttext: function(text, raw) {\r\n\t\t\tif (text.length > 0)\r\n\t\t\t\thtml[html.length] = raw ? text : encode(text);\r\n\t\t},\r\n\r\n\t\tcdata: function(text) {\r\n\t\t\thtml.push('<![CDATA[', text, ']]>');\r\n\t\t},\r\n\r\n\t\tcomment: function(text) {\r\n\t\t\thtml.push('<!--', text, '-->');\r\n\t\t},\r\n\r\n\t\tpi: function(name, text) {\r\n\t\t\tif (text)\r\n\t\t\t\thtml.push('<?', name, ' ', text, '?>');\r\n\t\t\telse\r\n\t\t\t\thtml.push('<?', name, '?>');\r\n\r\n\t\t\tif (indent)\r\n\t\t\t\thtml.push('\\n');\r\n\t\t},\r\n\r\n\t\tdoctype: function(text) {\r\n\t\t\thtml.push('<!DOCTYPE', text, '>', indent ? '\\n' : '');\r\n\t\t},\r\n\r\n\t\treset: function() {\r\n\t\t\thtml.length = 0;\r\n\t\t},\r\n\r\n\t\tgetContent: function() {\r\n\t\t\treturn html.join('').replace(/\\n$/, '');\r\n\t\t}\r\n\t};\r\n};\r\n\r\n(function(tinymce) {\r\n\ttinymce.html.Serializer = function(settings, schema) {\r\n\t\tvar self = this, writer = new tinymce.html.Writer(settings);\r\n\r\n\t\tsettings = settings || {};\r\n\t\tsettings.validate = \"validate\" in settings ? settings.validate : true;\r\n\r\n\t\tself.schema = schema = schema || new tinymce.html.Schema();\r\n\t\tself.writer = writer;\r\n\r\n\t\tself.serialize = function(node) {\r\n\t\t\tvar handlers, validate;\r\n\r\n\t\t\tvalidate = settings.validate;\r\n\r\n\t\t\thandlers = {\r\n\t\t\t\t// #text\r\n\t\t\t\t3: function(node, raw) {\r\n\t\t\t\t\twriter.text(node.value, node.raw);\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// #comment\r\n\t\t\t\t8: function(node) {\r\n\t\t\t\t\twriter.comment(node.value);\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// Processing instruction\r\n\t\t\t\t7: function(node) {\r\n\t\t\t\t\twriter.pi(node.name, node.value);\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// Doctype\r\n\t\t\t\t10: function(node) {\r\n\t\t\t\t\twriter.doctype(node.value);\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// CDATA\r\n\t\t\t\t4: function(node) {\r\n\t\t\t\t\twriter.cdata(node.value);\r\n\t\t\t\t},\r\n\r\n \t\t\t\t// Document fragment\r\n\t\t\t\t11: function(node) {\r\n\t\t\t\t\tif ((node = node.firstChild)) {\r\n\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\twalk(node);\r\n\t\t\t\t\t\t} while (node = node.next);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\twriter.reset();\r\n\r\n\t\t\tfunction walk(node) {\r\n\t\t\t\tvar handler = handlers[node.type], name, isEmpty, attrs, attrName, attrValue, sortedAttrs, i, l, elementRule;\r\n\r\n\t\t\t\tif (!handler) {\r\n\t\t\t\t\tname = node.name;\r\n\t\t\t\t\tisEmpty = node.shortEnded;\r\n\t\t\t\t\tattrs = node.attributes;\r\n\r\n\t\t\t\t\t// Sort attributes\r\n\t\t\t\t\tif (validate && attrs && attrs.length > 1) {\r\n\t\t\t\t\t\tsortedAttrs = [];\r\n\t\t\t\t\t\tsortedAttrs.map = {};\r\n\r\n\t\t\t\t\t\telementRule = schema.getElementRule(node.name);\r\n\t\t\t\t\t\tfor (i = 0, l = elementRule.attributesOrder.length; i < l; i++) {\r\n\t\t\t\t\t\t\tattrName = elementRule.attributesOrder[i];\r\n\r\n\t\t\t\t\t\t\tif (attrName in attrs.map) {\r\n\t\t\t\t\t\t\t\tattrValue = attrs.map[attrName];\r\n\t\t\t\t\t\t\t\tsortedAttrs.map[attrName] = attrValue;\r\n\t\t\t\t\t\t\t\tsortedAttrs.push({name: attrName, value: attrValue});\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tfor (i = 0, l = attrs.length; i < l; i++) {\r\n\t\t\t\t\t\t\tattrName = attrs[i].name;\r\n\r\n\t\t\t\t\t\t\tif (!(attrName in sortedAttrs.map)) {\r\n\t\t\t\t\t\t\t\tattrValue = attrs.map[attrName];\r\n\t\t\t\t\t\t\t\tsortedAttrs.map[attrName] = attrValue;\r\n\t\t\t\t\t\t\t\tsortedAttrs.push({name: attrName, value: attrValue});\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tattrs = sortedAttrs;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\twriter.start(node.name, attrs, isEmpty);\r\n\r\n\t\t\t\t\tif (!isEmpty) {\r\n\t\t\t\t\t\tif ((node = node.firstChild)) {\r\n\t\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\t\twalk(node);\r\n\t\t\t\t\t\t\t} while (node = node.next);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\twriter.end(name);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else\r\n\t\t\t\t\thandler(node);\r\n\t\t\t}\r\n\r\n\t\t\t// Serialize element and treat all non elements as fragments\r\n\t\t\tif (node.type == 1 && !settings.inner)\r\n\t\t\t\twalk(node);\r\n\t\t\telse\r\n\t\t\t\thandlers[11](node);\r\n\r\n\t\t\treturn writer.getContent();\r\n\t\t};\r\n\t}\r\n})(tinymce);\r\n\r\n(function(tinymce) {\r\n\t// Shorten names\r\n\tvar each = tinymce.each,\r\n\t\tis = tinymce.is,\r\n\t\tisWebKit = tinymce.isWebKit,\r\n\t\tisIE = tinymce.isIE,\r\n\t\tEntities = tinymce.html.Entities,\r\n\t\tsimpleSelectorRe = /^([a-z0-9],?)+$/i,\r\n\t\tblockElementsMap = tinymce.html.Schema.blockElementsMap,\r\n\t\twhiteSpaceRegExp = /^[ \\t\\r\\n]*$/;\r\n\r\n\ttinymce.create('tinymce.dom.DOMUtils', {\r\n\t\tdoc : null,\r\n\t\troot : null,\r\n\t\tfiles : null,\r\n\t\tpixelStyles : /^(top|left|bottom|right|width|height|borderWidth)$/,\r\n\t\tprops : {\r\n\t\t\t\"for\" : \"htmlFor\",\r\n\t\t\t\"class\" : \"className\",\r\n\t\t\tclassName : \"className\",\r\n\t\t\tchecked : \"checked\",\r\n\t\t\tdisabled : \"disabled\",\r\n\t\t\tmaxlength : \"maxLength\",\r\n\t\t\treadonly : \"readOnly\",\r\n\t\t\tselected : \"selected\",\r\n\t\t\tvalue : \"value\",\r\n\t\t\tid : \"id\",\r\n\t\t\tname : \"name\",\r\n\t\t\ttype : \"type\"\r\n\t\t},\r\n\r\n\t\tDOMUtils : function(d, s) {\r\n\t\t\tvar t = this, globalStyle, name;\r\n\r\n\t\t\tt.doc = d;\r\n\t\t\tt.win = window;\r\n\t\t\tt.files = {};\r\n\t\t\tt.cssFlicker = false;\r\n\t\t\tt.counter = 0;\r\n\t\t\tt.stdMode = !tinymce.isIE || d.documentMode >= 8;\r\n\t\t\tt.boxModel = !tinymce.isIE || d.compatMode == \"CSS1Compat\" || t.stdMode;\r\n\t\t\tt.hasOuterHTML = \"outerHTML\" in d.createElement(\"a\");\r\n\r\n\t\t\tt.settings = s = tinymce.extend({\r\n\t\t\t\tkeep_values : false,\r\n\t\t\t\thex_colors : 1\r\n\t\t\t}, s);\r\n\r\n\t\t\tt.schema = s.schema;\r\n\t\t\tt.styles = new tinymce.html.Styles({\r\n\t\t\t\turl_converter : s.url_converter,\r\n\t\t\t\turl_converter_scope : s.url_converter_scope\r\n\t\t\t}, s.schema);\r\n\r\n\t\t\t// Fix IE6SP2 flicker and check it failed for pre SP2\r\n\t\t\tif (tinymce.isIE6) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\td.execCommand('BackgroundImageCache', false, true);\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tt.cssFlicker = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (isIE && s.schema) {\r\n\t\t\t\t// Add missing HTML 4/5 elements to IE\r\n\t\t\t\t('abbr article aside audio canvas ' +\r\n\t\t\t\t'details figcaption figure footer ' +\r\n\t\t\t\t'header hgroup mark menu meter nav ' +\r\n\t\t\t\t'output progress section summary ' +\r\n\t\t\t\t'time video').replace(/\\w+/g, function(name) {\r\n\t\t\t\t\td.createElement(name);\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// Create all custom elements\r\n\t\t\t\tfor (name in s.schema.getCustomElements()) {\r\n\t\t\t\t\td.createElement(name);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\ttinymce.addUnload(t.destroy, t);\r\n\t\t},\r\n\r\n\t\tgetRoot : function() {\r\n\t\t\tvar t = this, s = t.settings;\r\n\r\n\t\t\treturn (s && t.get(s.root_element)) || t.doc.body;\r\n\t\t},\r\n\r\n\t\tgetViewPort : function(w) {\r\n\t\t\tvar d, b;\r\n\r\n\t\t\tw = !w ? this.win : w;\r\n\t\t\td = w.document;\r\n\t\t\tb = this.boxModel ? d.documentElement : d.body;\r\n\r\n\t\t\t// Returns viewport size excluding scrollbars\r\n\t\t\treturn {\r\n\t\t\t\tx : w.pageXOffset || b.scrollLeft,\r\n\t\t\t\ty : w.pageYOffset || b.scrollTop,\r\n\t\t\t\tw : w.innerWidth || b.clientWidth,\r\n\t\t\t\th : w.innerHeight || b.clientHeight\r\n\t\t\t};\r\n\t\t},\r\n\r\n\t\tgetRect : function(e) {\r\n\t\t\tvar p, t = this, sr;\r\n\r\n\t\t\te = t.get(e);\r\n\t\t\tp = t.getPos(e);\r\n\t\t\tsr = t.getSize(e);\r\n\r\n\t\t\treturn {\r\n\t\t\t\tx : p.x,\r\n\t\t\t\ty : p.y,\r\n\t\t\t\tw : sr.w,\r\n\t\t\t\th : sr.h\r\n\t\t\t};\r\n\t\t},\r\n\r\n\t\tgetSize : function(e) {\r\n\t\t\tvar t = this, w, h;\r\n\r\n\t\t\te = t.get(e);\r\n\t\t\tw = t.getStyle(e, 'width');\r\n\t\t\th = t.getStyle(e, 'height');\r\n\r\n\t\t\t// Non pixel value, then force offset/clientWidth\r\n\t\t\tif (w.indexOf('px') === -1)\r\n\t\t\t\tw = 0;\r\n\r\n\t\t\t// Non pixel value, then force offset/clientWidth\r\n\t\t\tif (h.indexOf('px') === -1)\r\n\t\t\t\th = 0;\r\n\r\n\t\t\treturn {\r\n\t\t\t\tw : parseInt(w) || e.offsetWidth || e.clientWidth,\r\n\t\t\t\th : parseInt(h) || e.offsetHeight || e.clientHeight\r\n\t\t\t};\r\n\t\t},\r\n\r\n\t\tgetParent : function(n, f, r) {\r\n\t\t\treturn this.getParents(n, f, r, false);\r\n\t\t},\r\n\r\n\t\tgetParents : function(n, f, r, c) {\r\n\t\t\tvar t = this, na, se = t.settings, o = [];\r\n\r\n\t\t\tn = t.get(n);\r\n\t\t\tc = c === undefined;\r\n\r\n\t\t\tif (se.strict_root)\r\n\t\t\t\tr = r || t.getRoot();\r\n\r\n\t\t\t// Wrap node name as func\r\n\t\t\tif (is(f, 'string')) {\r\n\t\t\t\tna = f;\r\n\r\n\t\t\t\tif (f === '*') {\r\n\t\t\t\t\tf = function(n) {return n.nodeType == 1;};\r\n\t\t\t\t} else {\r\n\t\t\t\t\tf = function(n) {\r\n\t\t\t\t\t\treturn t.is(n, na);\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\twhile (n) {\r\n\t\t\t\tif (n == r || !n.nodeType || n.nodeType === 9)\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tif (!f || f(n)) {\r\n\t\t\t\t\tif (c)\r\n\t\t\t\t\t\to.push(n);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\treturn n;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tn = n.parentNode;\r\n\t\t\t}\r\n\r\n\t\t\treturn c ? o : null;\r\n\t\t},\r\n\r\n\t\tget : function(e) {\r\n\t\t\tvar n;\r\n\r\n\t\t\tif (e && this.doc && typeof(e) == 'string') {\r\n\t\t\t\tn = e;\r\n\t\t\t\te = this.doc.getElementById(e);\r\n\r\n\t\t\t\t// IE and Opera returns meta elements when they match the specified input ID, but getElementsByName seems to do the trick\r\n\t\t\t\tif (e && e.id !== n)\r\n\t\t\t\t\treturn this.doc.getElementsByName(n)[1];\r\n\t\t\t}\r\n\r\n\t\t\treturn e;\r\n\t\t},\r\n\r\n\t\tgetNext : function(node, selector) {\r\n\t\t\treturn this._findSib(node, selector, 'nextSibling');\r\n\t\t},\r\n\r\n\t\tgetPrev : function(node, selector) {\r\n\t\t\treturn this._findSib(node, selector, 'previousSibling');\r\n\t\t},\r\n\r\n\r\n\t\tselect : function(pa, s) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\treturn tinymce.dom.Sizzle(pa, t.get(s) || t.get(t.settings.root_element) || t.doc, []);\r\n\t\t},\r\n\r\n\t\tis : function(n, selector) {\r\n\t\t\tvar i;\r\n\r\n\t\t\t// If it isn't an array then try to do some simple selectors instead of Sizzle for to boost performance\r\n\t\t\tif (n.length === undefined) {\r\n\t\t\t\t// Simple all selector\r\n\t\t\t\tif (selector === '*')\r\n\t\t\t\t\treturn n.nodeType == 1;\r\n\r\n\t\t\t\t// Simple selector just elements\r\n\t\t\t\tif (simpleSelectorRe.test(selector)) {\r\n\t\t\t\t\tselector = selector.toLowerCase().split(/,/);\r\n\t\t\t\t\tn = n.nodeName.toLowerCase();\r\n\r\n\t\t\t\t\tfor (i = selector.length - 1; i >= 0; i--) {\r\n\t\t\t\t\t\tif (selector[i] == n)\r\n\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn tinymce.dom.Sizzle.matches(selector, n.nodeType ? [n] : n).length > 0;\r\n\t\t},\r\n\r\n\r\n\t\tadd : function(p, n, a, h, c) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\treturn this.run(p, function(p) {\r\n\t\t\t\tvar e, k;\r\n\r\n\t\t\t\te = is(n, 'string') ? t.doc.createElement(n) : n;\r\n\t\t\t\tt.setAttribs(e, a);\r\n\r\n\t\t\t\tif (h) {\r\n\t\t\t\t\tif (h.nodeType)\r\n\t\t\t\t\t\te.appendChild(h);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tt.setHTML(e, h);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn !c ? p.appendChild(e) : e;\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\tcreate : function(n, a, h) {\r\n\t\t\treturn this.add(this.doc.createElement(n), n, a, h, 1);\r\n\t\t},\r\n\r\n\t\tcreateHTML : function(n, a, h) {\r\n\t\t\tvar o = '', t = this, k;\r\n\r\n\t\t\to += '<' + n;\r\n\r\n\t\t\tfor (k in a) {\r\n\t\t\t\tif (a.hasOwnProperty(k))\r\n\t\t\t\t\to += ' ' + k + '=\"' + t.encode(a[k]) + '\"';\r\n\t\t\t}\r\n\r\n\t\t\t// A call to tinymce.is doesn't work for some odd reason on IE9 possible bug inside their JS runtime\r\n\t\t\tif (typeof(h) != \"undefined\")\r\n\t\t\t\treturn o + '>' + h + '</' + n + '>';\r\n\r\n\t\t\treturn o + ' />';\r\n\t\t},\r\n\r\n\t\tremove : function(node, keep_children) {\r\n\t\t\treturn this.run(node, function(node) {\r\n\t\t\t\tvar child, parent = node.parentNode;\r\n\r\n\t\t\t\tif (!parent)\r\n\t\t\t\t\treturn null;\r\n\r\n\t\t\t\tif (keep_children) {\r\n\t\t\t\t\twhile (child = node.firstChild) {\r\n\t\t\t\t\t\t// IE 8 will crash if you don't remove completely empty text nodes\r\n\t\t\t\t\t\tif (!tinymce.isIE || child.nodeType !== 3 || child.nodeValue)\r\n\t\t\t\t\t\t\tparent.insertBefore(child, node);\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tnode.removeChild(child);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn parent.removeChild(node);\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\tsetStyle : function(n, na, v) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\treturn t.run(n, function(e) {\r\n\t\t\t\tvar s, i;\r\n\r\n\t\t\t\ts = e.style;\r\n\r\n\t\t\t\t// Camelcase it, if needed\r\n\t\t\t\tna = na.replace(/-(\\D)/g, function(a, b){\r\n\t\t\t\t\treturn b.toUpperCase();\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// Default px suffix on these\r\n\t\t\t\tif (t.pixelStyles.test(na) && (tinymce.is(v, 'number') || /^[\\-0-9\\.]+$/.test(v)))\r\n\t\t\t\t\tv += 'px';\r\n\r\n\t\t\t\tswitch (na) {\r\n\t\t\t\t\tcase 'opacity':\r\n\t\t\t\t\t\t// IE specific opacity\r\n\t\t\t\t\t\tif (isIE) {\r\n\t\t\t\t\t\t\ts.filter = v === '' ? '' : \"alpha(opacity=\" + (v * 100) + \")\";\r\n\r\n\t\t\t\t\t\t\tif (!n.currentStyle || !n.currentStyle.hasLayout)\r\n\t\t\t\t\t\t\t\ts.display = 'inline-block';\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Fix for older browsers\r\n\t\t\t\t\t\ts[na] = s['-moz-opacity'] = s['-khtml-opacity'] = v || '';\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'float':\r\n\t\t\t\t\t\tisIE ? s.styleFloat = v : s.cssFloat = v;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\ts[na] = v || '';\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Force update of the style data\r\n\t\t\t\tif (t.settings.update_styles)\r\n\t\t\t\t\tt.setAttrib(e, 'data-mce-style');\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\tgetStyle : function(n, na, c) {\r\n\t\t\tn = this.get(n);\r\n\r\n\t\t\tif (!n)\r\n\t\t\t\treturn;\r\n\r\n\t\t\t// Gecko\r\n\t\t\tif (this.doc.defaultView && c) {\r\n\t\t\t\t// Remove camelcase\r\n\t\t\t\tna = na.replace(/[A-Z]/g, function(a){\r\n\t\t\t\t\treturn '-' + a;\r\n\t\t\t\t});\r\n\r\n\t\t\t\ttry {\r\n\t\t\t\t\treturn this.doc.defaultView.getComputedStyle(n, null).getPropertyValue(na);\r\n\t\t\t\t} catch (ex) {\r\n\t\t\t\t\t// Old safari might fail\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Camelcase it, if needed\r\n\t\t\tna = na.replace(/-(\\D)/g, function(a, b){\r\n\t\t\t\treturn b.toUpperCase();\r\n\t\t\t});\r\n\r\n\t\t\tif (na == 'float')\r\n\t\t\t\tna = isIE ? 'styleFloat' : 'cssFloat';\r\n\r\n\t\t\t// IE & Opera\r\n\t\t\tif (n.currentStyle && c)\r\n\t\t\t\treturn n.currentStyle[na];\r\n\r\n\t\t\treturn n.style ? n.style[na] : undefined;\r\n\t\t},\r\n\r\n\t\tsetStyles : function(e, o) {\r\n\t\t\tvar t = this, s = t.settings, ol;\r\n\r\n\t\t\tol = s.update_styles;\r\n\t\t\ts.update_styles = 0;\r\n\r\n\t\t\teach(o, function(v, n) {\r\n\t\t\t\tt.setStyle(e, n, v);\r\n\t\t\t});\r\n\r\n\t\t\t// Update style info\r\n\t\t\ts.update_styles = ol;\r\n\t\t\tif (s.update_styles)\r\n\t\t\t\tt.setAttrib(e, s.cssText);\r\n\t\t},\r\n\r\n\t\tremoveAllAttribs: function(e) {\r\n\t\t\treturn this.run(e, function(e) {\r\n\t\t\t\tvar i, attrs = e.attributes;\r\n\t\t\t\tfor (i = attrs.length - 1; i >= 0; i--) {\r\n\t\t\t\t\te.removeAttributeNode(attrs.item(i));\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\tsetAttrib : function(e, n, v) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\t// Whats the point\r\n\t\t\tif (!e || !n)\r\n\t\t\t\treturn;\r\n\r\n\t\t\t// Strict XML mode\r\n\t\t\tif (t.settings.strict)\r\n\t\t\t\tn = n.toLowerCase();\r\n\r\n\t\t\treturn this.run(e, function(e) {\r\n\t\t\t\tvar s = t.settings;\r\n\t\t\t\tif (v !== null) {\r\n\t\t\t\t\tswitch (n) {\r\n\t\t\t\t\t\tcase \"style\":\r\n\t\t\t\t\t\t\tif (!is(v, 'string')) {\r\n\t\t\t\t\t\t\t\teach(v, function(v, n) {\r\n\t\t\t\t\t\t\t\t\tt.setStyle(e, n, v);\r\n\t\t\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// No mce_style for elements with these since they might get resized by the user\r\n\t\t\t\t\t\t\tif (s.keep_values) {\r\n\t\t\t\t\t\t\t\tif (v && !t._isRes(v))\r\n\t\t\t\t\t\t\t\t\te.setAttribute('data-mce-style', v, 2);\r\n\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\te.removeAttribute('data-mce-style', 2);\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\te.style.cssText = v;\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase \"class\":\r\n\t\t\t\t\t\t\te.className = v || ''; // Fix IE null bug\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase \"src\":\r\n\t\t\t\t\t\tcase \"href\":\r\n\t\t\t\t\t\t\tif (s.keep_values) {\r\n\t\t\t\t\t\t\t\tif (s.url_converter)\r\n\t\t\t\t\t\t\t\t\tv = s.url_converter.call(s.url_converter_scope || t, v, n, e);\r\n\r\n\t\t\t\t\t\t\t\tt.setAttrib(e, 'data-mce-' + n, v, 2);\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase \"shape\":\r\n\t\t\t\t\t\t\te.setAttribute('data-mce-style', v);\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (is(v) && v !== null && v.length !== 0)\r\n\t\t\t\t\te.setAttribute(n, '' + v, 2);\r\n\t\t\t\telse\r\n\t\t\t\t\te.removeAttribute(n, 2);\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\tsetAttribs : function(e, o) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\treturn this.run(e, function(e) {\r\n\t\t\t\teach(o, function(v, n) {\r\n\t\t\t\t\tt.setAttrib(e, n, v);\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\tgetAttrib : function(e, n, dv) {\r\n\t\t\tvar v, t = this, undef;\r\n\r\n\t\t\te = t.get(e);\r\n\r\n\t\t\tif (!e || e.nodeType !== 1)\r\n\t\t\t\treturn dv === undef ? false : dv;\r\n\r\n\t\t\tif (!is(dv))\r\n\t\t\t\tdv = '';\r\n\r\n\t\t\t// Try the mce variant for these\r\n\t\t\tif (/^(src|href|style|coords|shape)$/.test(n)) {\r\n\t\t\t\tv = e.getAttribute(\"data-mce-\" + n);\r\n\r\n\t\t\t\tif (v)\r\n\t\t\t\t\treturn v;\r\n\t\t\t}\r\n\r\n\t\t\tif (isIE && t.props[n]) {\r\n\t\t\t\tv = e[t.props[n]];\r\n\t\t\t\tv = v && v.nodeValue ? v.nodeValue : v;\r\n\t\t\t}\r\n\r\n\t\t\tif (!v)\r\n\t\t\t\tv = e.getAttribute(n, 2);\r\n\r\n\t\t\t// Check boolean attribs\r\n\t\t\tif (/^(checked|compact|declare|defer|disabled|ismap|multiple|nohref|noshade|nowrap|readonly|selected)$/.test(n)) {\r\n\t\t\t\tif (e[t.props[n]] === true && v === '')\r\n\t\t\t\t\treturn n;\r\n\r\n\t\t\t\treturn v ? n : '';\r\n\t\t\t}\r\n\r\n\t\t\t// Inner input elements will override attributes on form elements\r\n\t\t\tif (e.nodeName === \"FORM\" && e.getAttributeNode(n))\r\n\t\t\t\treturn e.getAttributeNode(n).nodeValue;\r\n\r\n\t\t\tif (n === 'style') {\r\n\t\t\t\tv = v || e.style.cssText;\r\n\r\n\t\t\t\tif (v) {\r\n\t\t\t\t\tv = t.serializeStyle(t.parseStyle(v), e.nodeName);\r\n\r\n\t\t\t\t\tif (t.settings.keep_values && !t._isRes(v))\r\n\t\t\t\t\t\te.setAttribute('data-mce-style', v);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Remove Apple and WebKit stuff\r\n\t\t\tif (isWebKit && n === \"class\" && v)\r\n\t\t\t\tv = v.replace(/(apple|webkit)\\-[a-z\\-]+/gi, '');\r\n\r\n\t\t\t// Handle IE issues\r\n\t\t\tif (isIE) {\r\n\t\t\t\tswitch (n) {\r\n\t\t\t\t\tcase 'rowspan':\r\n\t\t\t\t\tcase 'colspan':\r\n\t\t\t\t\t\t// IE returns 1 as default value\r\n\t\t\t\t\t\tif (v === 1)\r\n\t\t\t\t\t\t\tv = '';\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'size':\r\n\t\t\t\t\t\t// IE returns +0 as default value for size\r\n\t\t\t\t\t\tif (v === '+0' || v === 20 || v === 0)\r\n\t\t\t\t\t\t\tv = '';\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'width':\r\n\t\t\t\t\tcase 'height':\r\n\t\t\t\t\tcase 'vspace':\r\n\t\t\t\t\tcase 'checked':\r\n\t\t\t\t\tcase 'disabled':\r\n\t\t\t\t\tcase 'readonly':\r\n\t\t\t\t\t\tif (v === 0)\r\n\t\t\t\t\t\t\tv = '';\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'hspace':\r\n\t\t\t\t\t\t// IE returns -1 as default value\r\n\t\t\t\t\t\tif (v === -1)\r\n\t\t\t\t\t\t\tv = '';\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'maxlength':\r\n\t\t\t\t\tcase 'tabindex':\r\n\t\t\t\t\t\t// IE returns default value\r\n\t\t\t\t\t\tif (v === 32768 || v === 2147483647 || v === '32768')\r\n\t\t\t\t\t\t\tv = '';\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'multiple':\r\n\t\t\t\t\tcase 'compact':\r\n\t\t\t\t\tcase 'noshade':\r\n\t\t\t\t\tcase 'nowrap':\r\n\t\t\t\t\t\tif (v === 65535)\r\n\t\t\t\t\t\t\treturn n;\r\n\r\n\t\t\t\t\t\treturn dv;\r\n\r\n\t\t\t\t\tcase 'shape':\r\n\t\t\t\t\t\tv = v.toLowerCase();\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t// IE has odd anonymous function for event attributes\r\n\t\t\t\t\t\tif (n.indexOf('on') === 0 && v)\r\n\t\t\t\t\t\t\tv = tinymce._replace(/^function\\s+\\w+\\(\\)\\s+\\{\\s+(.*)\\s+\\}$/, '$1', '' + v);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn (v !== undef && v !== null && v !== '') ? '' + v : dv;\r\n\t\t},\r\n\r\n\t\tgetPos : function(n, ro) {\r\n\t\t\tvar t = this, x = 0, y = 0, e, d = t.doc, r;\r\n\r\n\t\t\tn = t.get(n);\r\n\t\t\tro = ro || d.body;\r\n\r\n\t\t\tif (n) {\r\n\t\t\t\t// Use getBoundingClientRect if it exists since it's faster than looping offset nodes\r\n\t\t\t\tif (n.getBoundingClientRect) {\r\n\t\t\t\t\tn = n.getBoundingClientRect();\r\n\t\t\t\t\te = t.boxModel ? d.documentElement : d.body;\r\n\r\n\t\t\t\t\t// Add scroll offsets from documentElement or body since IE with the wrong box model will use d.body and so do WebKit\r\n\t\t\t\t\t// Also remove the body/documentelement clientTop/clientLeft on IE 6, 7 since they offset the position\r\n\t\t\t\t\tx = n.left + (d.documentElement.scrollLeft || d.body.scrollLeft) - e.clientTop;\r\n\t\t\t\t\ty = n.top + (d.documentElement.scrollTop || d.body.scrollTop) - e.clientLeft;\r\n\r\n\t\t\t\t\treturn {x : x, y : y};\r\n\t\t\t\t}\r\n\r\n\t\t\t\tr = n;\r\n\t\t\t\twhile (r && r != ro && r.nodeType) {\r\n\t\t\t\t\tx += r.offsetLeft || 0;\r\n\t\t\t\t\ty += r.offsetTop || 0;\r\n\t\t\t\t\tr = r.offsetParent;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tr = n.parentNode;\r\n\t\t\t\twhile (r && r != ro && r.nodeType) {\r\n\t\t\t\t\tx -= r.scrollLeft || 0;\r\n\t\t\t\t\ty -= r.scrollTop || 0;\r\n\t\t\t\t\tr = r.parentNode;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn {x : x, y : y};\r\n\t\t},\r\n\r\n\t\tparseStyle : function(st) {\r\n\t\t\treturn this.styles.parse(st);\r\n\t\t},\r\n\r\n\t\tserializeStyle : function(o, name) {\r\n\t\t\treturn this.styles.serialize(o, name);\r\n\t\t},\r\n\r\n\t\tloadCSS : function(u) {\r\n\t\t\tvar t = this, d = t.doc, head;\r\n\r\n\t\t\tif (!u)\r\n\t\t\t\tu = '';\r\n\r\n\t\t\thead = t.select('head')[0];\r\n\r\n\t\t\teach(u.split(','), function(u) {\r\n\t\t\t\tvar link;\r\n\r\n\t\t\t\tif (t.files[u])\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\tt.files[u] = true;\r\n\t\t\t\tlink = t.create('link', {rel : 'stylesheet', href : tinymce._addVer(u)});\r\n\r\n\t\t\t\t// IE 8 has a bug where dynamically loading stylesheets would produce a 1 item remaining bug\r\n\t\t\t\t// This fix seems to resolve that issue by realcing the document ones a stylesheet finishes loading\r\n\t\t\t\t// It's ugly but it seems to work fine.\r\n\t\t\t\tif (isIE && d.documentMode && d.recalc) {\r\n\t\t\t\t\tlink.onload = function() {\r\n\t\t\t\t\t\tif (d.recalc)\r\n\t\t\t\t\t\t\td.recalc();\r\n\r\n\t\t\t\t\t\tlink.onload = null;\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\r\n\t\t\t\thead.appendChild(link);\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\taddClass : function(e, c) {\r\n\t\t\treturn this.run(e, function(e) {\r\n\t\t\t\tvar o;\r\n\r\n\t\t\t\tif (!c)\r\n\t\t\t\t\treturn 0;\r\n\r\n\t\t\t\tif (this.hasClass(e, c))\r\n\t\t\t\t\treturn e.className;\r\n\r\n\t\t\t\to = this.removeClass(e, c);\r\n\r\n\t\t\t\treturn e.className = (o != '' ? (o + ' ') : '') + c;\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\tremoveClass : function(e, c) {\r\n\t\t\tvar t = this, re;\r\n\r\n\t\t\treturn t.run(e, function(e) {\r\n\t\t\t\tvar v;\r\n\r\n\t\t\t\tif (t.hasClass(e, c)) {\r\n\t\t\t\t\tif (!re)\r\n\t\t\t\t\t\tre = new RegExp(\"(^|\\\\s+)\" + c + \"(\\\\s+|$)\", \"g\");\r\n\r\n\t\t\t\t\tv = e.className.replace(re, ' ');\r\n\t\t\t\t\tv = tinymce.trim(v != ' ' ? v : '');\r\n\r\n\t\t\t\t\te.className = v;\r\n\r\n\t\t\t\t\t// Empty class attr\r\n\t\t\t\t\tif (!v) {\r\n\t\t\t\t\t\te.removeAttribute('class');\r\n\t\t\t\t\t\te.removeAttribute('className');\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn v;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn e.className;\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\thasClass : function(n, c) {\r\n\t\t\tn = this.get(n);\r\n\r\n\t\t\tif (!n || !c)\r\n\t\t\t\treturn false;\r\n\r\n\t\t\treturn (' ' + n.className + ' ').indexOf(' ' + c + ' ') !== -1;\r\n\t\t},\r\n\r\n\t\tshow : function(e) {\r\n\t\t\treturn this.setStyle(e, 'display', 'block');\r\n\t\t},\r\n\r\n\t\thide : function(e) {\r\n\t\t\treturn this.setStyle(e, 'display', 'none');\r\n\t\t},\r\n\r\n\t\tisHidden : function(e) {\r\n\t\t\te = this.get(e);\r\n\r\n\t\t\treturn !e || e.style.display == 'none' || this.getStyle(e, 'display') == 'none';\r\n\t\t},\r\n\r\n\t\tuniqueId : function(p) {\r\n\t\t\treturn (!p ? 'mce_' : p) + (this.counter++);\r\n\t\t},\r\n\r\n\t\tsetHTML : function(element, html) {\r\n\t\t\tvar self = this;\r\n\r\n\t\t\treturn self.run(element, function(element) {\r\n\t\t\t\tif (isIE) {\r\n\t\t\t\t\t// Remove all child nodes, IE keeps empty text nodes in DOM\r\n\t\t\t\t\twhile (element.firstChild)\r\n\t\t\t\t\t\telement.removeChild(element.firstChild);\r\n\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\t// IE will remove comments from the beginning\r\n\t\t\t\t\t\t// unless you padd the contents with something\r\n\t\t\t\t\t\telement.innerHTML = '<br />' + html;\r\n\t\t\t\t\t\telement.removeChild(element.firstChild);\r\n\t\t\t\t\t} catch (ex) {\r\n\t\t\t\t\t\t// IE sometimes produces an unknown runtime error on innerHTML if it's an block element within a block element for example a div inside a p\r\n\t\t\t\t\t\t// This seems to fix this problem\r\n\r\n\t\t\t\t\t\t// Create new div with HTML contents and a BR infront to keep comments\r\n\t\t\t\t\t\telement = self.create('div');\r\n\t\t\t\t\t\telement.innerHTML = '<br />' + html;\r\n\r\n\t\t\t\t\t\t// Add all children from div to target\r\n\t\t\t\t\t\teach (element.childNodes, function(node, i) {\r\n\t\t\t\t\t\t\t// Skip br element\r\n\t\t\t\t\t\t\tif (i)\r\n\t\t\t\t\t\t\t\telement.appendChild(node);\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t} else\r\n\t\t\t\t\telement.innerHTML = html;\r\n\r\n\t\t\t\treturn html;\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\tgetOuterHTML : function(elm) {\r\n\t\t\tvar doc, self = this;\r\n\r\n\t\t\telm = self.get(elm);\r\n\r\n\t\t\tif (!elm)\r\n\t\t\t\treturn null;\r\n\r\n\t\t\tif (elm.nodeType === 1 && self.hasOuterHTML)\r\n\t\t\t\treturn elm.outerHTML;\r\n\r\n\t\t\tdoc = (elm.ownerDocument || self.doc).createElement(\"body\");\r\n\t\t\tdoc.appendChild(elm.cloneNode(true));\r\n\r\n\t\t\treturn doc.innerHTML;\r\n\t\t},\r\n\r\n\t\tsetOuterHTML : function(e, h, d) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\tfunction setHTML(e, h, d) {\r\n\t\t\t\tvar n, tp;\r\n\r\n\t\t\t\ttp = d.createElement(\"body\");\r\n\t\t\t\ttp.innerHTML = h;\r\n\r\n\t\t\t\tn = tp.lastChild;\r\n\t\t\t\twhile (n) {\r\n\t\t\t\t\tt.insertAfter(n.cloneNode(true), e);\r\n\t\t\t\t\tn = n.previousSibling;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tt.remove(e);\r\n\t\t\t};\r\n\r\n\t\t\treturn this.run(e, function(e) {\r\n\t\t\t\te = t.get(e);\r\n\r\n\t\t\t\t// Only set HTML on elements\r\n\t\t\t\tif (e.nodeType == 1) {\r\n\t\t\t\t\td = d || e.ownerDocument || t.doc;\r\n\r\n\t\t\t\t\tif (isIE) {\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t// Try outerHTML for IE it sometimes produces an unknown runtime error\r\n\t\t\t\t\t\t\tif (isIE && e.nodeType == 1)\r\n\t\t\t\t\t\t\t\te.outerHTML = h;\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\tsetHTML(e, h, d);\r\n\t\t\t\t\t\t} catch (ex) {\r\n\t\t\t\t\t\t\t// Fix for unknown runtime error\r\n\t\t\t\t\t\t\tsetHTML(e, h, d);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else\r\n\t\t\t\t\t\tsetHTML(e, h, d);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\tdecode : Entities.decode,\r\n\r\n\t\tencode : Entities.encodeAllRaw,\r\n\r\n\t\tinsertAfter : function(node, reference_node) {\r\n\t\t\treference_node = this.get(reference_node);\r\n\r\n\t\t\treturn this.run(node, function(node) {\r\n\t\t\t\tvar parent, nextSibling;\r\n\r\n\t\t\t\tparent = reference_node.parentNode;\r\n\t\t\t\tnextSibling = reference_node.nextSibling;\r\n\r\n\t\t\t\tif (nextSibling)\r\n\t\t\t\t\tparent.insertBefore(node, nextSibling);\r\n\t\t\t\telse\r\n\t\t\t\t\tparent.appendChild(node);\r\n\r\n\t\t\t\treturn node;\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\tisBlock : function(node) {\r\n\t\t\tvar type = node.nodeType;\r\n\r\n\t\t\t// If it's a node then check the type and use the nodeName\r\n\t\t\tif (type)\r\n\t\t\t\treturn !!(type === 1 && blockElementsMap[node.nodeName]);\r\n\r\n\t\t\treturn !!blockElementsMap[node];\r\n\t\t},\r\n\r\n\t\treplace : function(n, o, k) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\tif (is(o, 'array'))\r\n\t\t\t\tn = n.cloneNode(true);\r\n\r\n\t\t\treturn t.run(o, function(o) {\r\n\t\t\t\tif (k) {\r\n\t\t\t\t\teach(tinymce.grep(o.childNodes), function(c) {\r\n\t\t\t\t\t\tn.appendChild(c);\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn o.parentNode.replaceChild(n, o);\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\trename : function(elm, name) {\r\n\t\t\tvar t = this, newElm;\r\n\r\n\t\t\tif (elm.nodeName != name.toUpperCase()) {\r\n\t\t\t\t// Rename block element\r\n\t\t\t\tnewElm = t.create(name);\r\n\r\n\t\t\t\t// Copy attribs to new block\r\n\t\t\t\teach(t.getAttribs(elm), function(attr_node) {\r\n\t\t\t\t\tt.setAttrib(newElm, attr_node.nodeName, t.getAttrib(elm, attr_node.nodeName));\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// Replace block\r\n\t\t\t\tt.replace(newElm, elm, 1);\r\n\t\t\t}\r\n\r\n\t\t\treturn newElm || elm;\r\n\t\t},\r\n\r\n\t\tfindCommonAncestor : function(a, b) {\r\n\t\t\tvar ps = a, pe;\r\n\r\n\t\t\twhile (ps) {\r\n\t\t\t\tpe = b;\r\n\r\n\t\t\t\twhile (pe && ps != pe)\r\n\t\t\t\t\tpe = pe.parentNode;\r\n\r\n\t\t\t\tif (ps == pe)\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tps = ps.parentNode;\r\n\t\t\t}\r\n\r\n\t\t\tif (!ps && a.ownerDocument)\r\n\t\t\t\treturn a.ownerDocument.documentElement;\r\n\r\n\t\t\treturn ps;\r\n\t\t},\r\n\r\n\t\ttoHex : function(s) {\r\n\t\t\tvar c = /^\\s*rgb\\s*?\\(\\s*?([0-9]+)\\s*?,\\s*?([0-9]+)\\s*?,\\s*?([0-9]+)\\s*?\\)\\s*$/i.exec(s);\r\n\r\n\t\t\tfunction hex(s) {\r\n\t\t\t\ts = parseInt(s).toString(16);\r\n\r\n\t\t\t\treturn s.length > 1 ? s : '0' + s; // 0 -> 00\r\n\t\t\t};\r\n\r\n\t\t\tif (c) {\r\n\t\t\t\ts = '#' + hex(c[1]) + hex(c[2]) + hex(c[3]);\r\n\r\n\t\t\t\treturn s;\r\n\t\t\t}\r\n\r\n\t\t\treturn s;\r\n\t\t},\r\n\r\n\t\tgetClasses : function() {\r\n\t\t\tvar t = this, cl = [], i, lo = {}, f = t.settings.class_filter, ov;\r\n\r\n\t\t\tif (t.classes)\r\n\t\t\t\treturn t.classes;\r\n\r\n\t\t\tfunction addClasses(s) {\r\n\t\t\t\t// IE style imports\r\n\t\t\t\teach(s.imports, function(r) {\r\n\t\t\t\t\taddClasses(r);\r\n\t\t\t\t});\r\n\r\n\t\t\t\teach(s.cssRules || s.rules, function(r) {\r\n\t\t\t\t\t// Real type or fake it on IE\r\n\t\t\t\t\tswitch (r.type || 1) {\r\n\t\t\t\t\t\t// Rule\r\n\t\t\t\t\t\tcase 1:\r\n\t\t\t\t\t\t\tif (r.selectorText) {\r\n\t\t\t\t\t\t\t\teach(r.selectorText.split(','), function(v) {\r\n\t\t\t\t\t\t\t\t\tv = v.replace(/^\\s*|\\s*$|^\\s\\./g, \"\");\r\n\r\n\t\t\t\t\t\t\t\t\t// Is internal or it doesn't contain a class\r\n\t\t\t\t\t\t\t\t\tif (/\\.mce/.test(v) || !/\\.[\\w\\-]+$/.test(v))\r\n\t\t\t\t\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t\t\t\t\t// Remove everything but class name\r\n\t\t\t\t\t\t\t\t\tov = v;\r\n\t\t\t\t\t\t\t\t\tv = tinymce._replace(/.*\\.([a-z0-9_\\-]+).*/i, '$1', v);\r\n\r\n\t\t\t\t\t\t\t\t\t// Filter classes\r\n\t\t\t\t\t\t\t\t\tif (f && !(v = f(v, ov)))\r\n\t\t\t\t\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t\t\t\t\tif (!lo[v]) {\r\n\t\t\t\t\t\t\t\t\t\tcl.push({'class' : v});\r\n\t\t\t\t\t\t\t\t\t\tlo[v] = 1;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t// Import\r\n\t\t\t\t\t\tcase 3:\r\n\t\t\t\t\t\t\taddClasses(r.styleSheet);\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t};\r\n\r\n\t\t\ttry {\r\n\t\t\t\teach(t.doc.styleSheets, addClasses);\r\n\t\t\t} catch (ex) {\r\n\t\t\t\t// Ignore\r\n\t\t\t}\r\n\r\n\t\t\tif (cl.length > 0)\r\n\t\t\t\tt.classes = cl;\r\n\r\n\t\t\treturn cl;\r\n\t\t},\r\n\r\n\t\trun : function(e, f, s) {\r\n\t\t\tvar t = this, o;\r\n\r\n\t\t\tif (t.doc && typeof(e) === 'string')\r\n\t\t\t\te = t.get(e);\r\n\r\n\t\t\tif (!e)\r\n\t\t\t\treturn false;\r\n\r\n\t\t\ts = s || this;\r\n\t\t\tif (!e.nodeType && (e.length || e.length === 0)) {\r\n\t\t\t\to = [];\r\n\r\n\t\t\t\teach(e, function(e, i) {\r\n\t\t\t\t\tif (e) {\r\n\t\t\t\t\t\tif (typeof(e) == 'string')\r\n\t\t\t\t\t\t\te = t.doc.getElementById(e);\r\n\r\n\t\t\t\t\t\to.push(f.call(s, e, i));\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\treturn o;\r\n\t\t\t}\r\n\r\n\t\t\treturn f.call(s, e);\r\n\t\t},\r\n\r\n\t\tgetAttribs : function(n) {\r\n\t\t\tvar o;\r\n\r\n\t\t\tn = this.get(n);\r\n\r\n\t\t\tif (!n)\r\n\t\t\t\treturn [];\r\n\r\n\t\t\tif (isIE) {\r\n\t\t\t\to = [];\r\n\r\n\t\t\t\t// Object will throw exception in IE\r\n\t\t\t\tif (n.nodeName == 'OBJECT')\r\n\t\t\t\t\treturn n.attributes;\r\n\r\n\t\t\t\t// IE doesn't keep the selected attribute if you clone option elements\r\n\t\t\t\tif (n.nodeName === 'OPTION' && this.getAttrib(n, 'selected'))\r\n\t\t\t\t\to.push({specified : 1, nodeName : 'selected'});\r\n\r\n\t\t\t\t// It's crazy that this is faster in IE but it's because it returns all attributes all the time\r\n\t\t\t\tn.cloneNode(false).outerHTML.replace(/<\\/?[\\w:\\-]+ ?|=[\\\"][^\\\"]+\\\"|=\\'[^\\']+\\'|=[\\w\\-]+|>/gi, '').replace(/[\\w:\\-]+/gi, function(a) {\r\n\t\t\t\t\to.push({specified : 1, nodeName : a});\r\n\t\t\t\t});\r\n\r\n\t\t\t\treturn o;\r\n\t\t\t}\r\n\r\n\t\t\treturn n.attributes;\r\n\t\t},\r\n\r\n\t\tisEmpty : function(node, elements) {\r\n\t\t\tvar self = this, i, attributes, type, walker, name, parentNode;\r\n\r\n\t\t\tnode = node.firstChild;\r\n\t\t\tif (node) {\r\n\t\t\t\twalker = new tinymce.dom.TreeWalker(node);\r\n\t\t\t\telements = elements || self.schema ? self.schema.getNonEmptyElements() : null;\r\n\r\n\t\t\t\tdo {\r\n\t\t\t\t\ttype = node.nodeType;\r\n\r\n\t\t\t\t\tif (type === 1) {\r\n\t\t\t\t\t\t// Ignore bogus elements\r\n\t\t\t\t\t\tif (node.getAttribute('data-mce-bogus'))\r\n\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\t// Keep empty elements like <img />\r\n\t\t\t\t\t\tname = node.nodeName.toLowerCase();\r\n\t\t\t\t\t\tif (elements && elements[name]) {\r\n\t\t\t\t\t\t\t// Ignore single BR elements in blocks like <p><br /></p>\r\n\t\t\t\t\t\t\tparentNode = node.parentNode;\r\n\t\t\t\t\t\t\tif (name === 'br' && self.isBlock(parentNode) && parentNode.firstChild === node && parentNode.lastChild === node) {\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Keep elements with data-bookmark attributes or name attribute like <a name=\"1\"></a>\r\n\t\t\t\t\t\tattributes = self.getAttribs(node);\r\n\t\t\t\t\t\ti = node.attributes.length;\r\n\t\t\t\t\t\twhile (i--) {\r\n\t\t\t\t\t\t\tname = node.attributes[i].nodeName;\r\n\t\t\t\t\t\t\tif (name === \"name\" || name === 'data-mce-bookmark')\r\n\t\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Keep non whitespace text nodes\r\n\t\t\t\t\tif ((type === 3 && !whiteSpaceRegExp.test(node.nodeValue)))\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t} while (node = walker.next());\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\t\t},\r\n\r\n\t\tdestroy : function(s) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\tif (t.events)\r\n\t\t\t\tt.events.destroy();\r\n\r\n\t\t\tt.win = t.doc = t.root = t.events = null;\r\n\r\n\t\t\t// Manual destroy then remove unload handler\r\n\t\t\tif (!s)\r\n\t\t\t\ttinymce.removeUnload(t.destroy);\r\n\t\t},\r\n\r\n\t\tcreateRng : function() {\r\n\t\t\tvar d = this.doc;\r\n\r\n\t\t\treturn d.createRange ? d.createRange() : new tinymce.dom.Range(this);\r\n\t\t},\r\n\r\n\t\tnodeIndex : function(node, normalized) {\r\n\t\t\tvar idx = 0, lastNodeType, lastNode, nodeType;\r\n\r\n\t\t\tif (node) {\r\n\t\t\t\tfor (lastNodeType = node.nodeType, node = node.previousSibling, lastNode = node; node; node = node.previousSibling) {\r\n\t\t\t\t\tnodeType = node.nodeType;\r\n\r\n\t\t\t\t\t// Normalize text nodes\r\n\t\t\t\t\tif (normalized && nodeType == 3) {\r\n\t\t\t\t\t\tif (nodeType == lastNodeType || !node.nodeValue.length)\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tidx++;\r\n\t\t\t\t\tlastNodeType = nodeType;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn idx;\r\n\t\t},\r\n\r\n\t\tsplit : function(pe, e, re) {\r\n\t\t\tvar t = this, r = t.createRng(), bef, aft, pa;\r\n\r\n\t\t\t// W3C valid browsers tend to leave empty nodes to the left/right side of the contents, this makes sense\r\n\t\t\t// but we don't want that in our code since it serves no purpose for the end user\r\n\t\t\t// For example if this is chopped:\r\n\t\t\t//   <p>text 1<span><b>CHOP</b></span>text 2</p>\r\n\t\t\t// would produce:\r\n\t\t\t//   <p>text 1<span></span></p><b>CHOP</b><p><span></span>text 2</p>\r\n\t\t\t// this function will then trim of empty edges and produce:\r\n\t\t\t//   <p>text 1</p><b>CHOP</b><p>text 2</p>\r\n\t\t\tfunction trim(node) {\r\n\t\t\t\tvar i, children = node.childNodes, type = node.nodeType;\r\n\r\n\t\t\t\tif (type == 1 && node.getAttribute('data-mce-type') == 'bookmark')\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\tfor (i = children.length - 1; i >= 0; i--)\r\n\t\t\t\t\ttrim(children[i]);\r\n\r\n\t\t\t\tif (type != 9) {\r\n\t\t\t\t\t// Keep non whitespace text nodes\r\n\t\t\t\t\tif (type == 3 && node.nodeValue.length > 0) {\r\n\t\t\t\t\t\t// If parent element isn't a block or there isn't any useful contents for example \"<p>   </p>\"\r\n\t\t\t\t\t\tif (!t.isBlock(node.parentNode) || tinymce.trim(node.nodeValue).length > 0)\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t} else if (type == 1) {\r\n\t\t\t\t\t\t// If the only child is a bookmark then move it up\r\n\t\t\t\t\t\tchildren = node.childNodes;\r\n\t\t\t\t\t\tif (children.length == 1 && children[0] && children[0].nodeType == 1 && children[0].getAttribute('data-mce-type') == 'bookmark')\r\n\t\t\t\t\t\t\tnode.parentNode.insertBefore(children[0], node);\r\n\r\n\t\t\t\t\t\t// Keep non empty elements or img, hr etc\r\n\t\t\t\t\t\tif (children.length || /^(br|hr|input|img)$/i.test(node.nodeName))\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tt.remove(node);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn node;\r\n\t\t\t};\r\n\r\n\t\t\tif (pe && e) {\r\n\t\t\t\t// Get before chunk\r\n\t\t\t\tr.setStart(pe.parentNode, t.nodeIndex(pe));\r\n\t\t\t\tr.setEnd(e.parentNode, t.nodeIndex(e));\r\n\t\t\t\tbef = r.extractContents();\r\n\r\n\t\t\t\t// Get after chunk\r\n\t\t\t\tr = t.createRng();\r\n\t\t\t\tr.setStart(e.parentNode, t.nodeIndex(e) + 1);\r\n\t\t\t\tr.setEnd(pe.parentNode, t.nodeIndex(pe) + 1);\r\n\t\t\t\taft = r.extractContents();\r\n\r\n\t\t\t\t// Insert before chunk\r\n\t\t\t\tpa = pe.parentNode;\r\n\t\t\t\tpa.insertBefore(trim(bef), pe);\r\n\r\n\t\t\t\t// Insert middle chunk\r\n\t\t\t\tif (re)\r\n\t\t\t\t\tpa.replaceChild(re, e);\r\n\t\t\t\telse\r\n\t\t\t\t\tpa.insertBefore(e, pe);\r\n\r\n\t\t\t\t// Insert after chunk\r\n\t\t\t\tpa.insertBefore(trim(aft), pe);\r\n\t\t\t\tt.remove(pe);\r\n\r\n\t\t\t\treturn re || e;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tbind : function(target, name, func, scope) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\tif (!t.events)\r\n\t\t\t\tt.events = new tinymce.dom.EventUtils();\r\n\r\n\t\t\treturn t.events.add(target, name, func, scope || this);\r\n\t\t},\r\n\r\n\t\tunbind : function(target, name, func) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\tif (!t.events)\r\n\t\t\t\tt.events = new tinymce.dom.EventUtils();\r\n\r\n\t\t\treturn t.events.remove(target, name, func);\r\n\t\t},\r\n\r\n\r\n\t\t_findSib : function(node, selector, name) {\r\n\t\t\tvar t = this, f = selector;\r\n\r\n\t\t\tif (node) {\r\n\t\t\t\t// If expression make a function of it using is\r\n\t\t\t\tif (is(f, 'string')) {\r\n\t\t\t\t\tf = function(node) {\r\n\t\t\t\t\t\treturn t.is(node, selector);\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Loop all siblings\r\n\t\t\t\tfor (node = node[name]; node; node = node[name]) {\r\n\t\t\t\t\tif (f(node))\r\n\t\t\t\t\t\treturn node;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn null;\r\n\t\t},\r\n\r\n\t\t_isRes : function(c) {\r\n\t\t\t// Is live resizble element\r\n\t\t\treturn /^(top|left|bottom|right|width|height)/i.test(c) || /;\\s*(top|left|bottom|right|width|height)/i.test(c);\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\twalk : function(n, f, s) {\r\n\t\t\tvar d = this.doc, w;\r\n\r\n\t\t\tif (d.createTreeWalker) {\r\n\t\t\t\tw = d.createTreeWalker(n, NodeFilter.SHOW_TEXT, null, false);\r\n\r\n\t\t\t\twhile ((n = w.nextNode()) != null)\r\n\t\t\t\t\tf.call(s || this, n);\r\n\t\t\t} else\r\n\t\t\t\ttinymce.walk(n, f, 'childNodes', s);\r\n\t\t}\r\n\t\t*/\r\n\r\n\t\t/*\r\n\t\ttoRGB : function(s) {\r\n\t\t\tvar c = /^\\s*?#([0-9A-F]{2})([0-9A-F]{1,2})([0-9A-F]{2})?\\s*?$/.exec(s);\r\n\r\n\t\t\tif (c) {\r\n\t\t\t\t// #FFF -> #FFFFFF\r\n\t\t\t\tif (!is(c[3]))\r\n\t\t\t\t\tc[3] = c[2] = c[1];\r\n\r\n\t\t\t\treturn \"rgb(\" + parseInt(c[1], 16) + \",\" + parseInt(c[2], 16) + \",\" + parseInt(c[3], 16) + \")\";\r\n\t\t\t}\r\n\r\n\t\t\treturn s;\r\n\t\t}\r\n\t\t*/\r\n\t});\r\n\r\n\ttinymce.DOM = new tinymce.dom.DOMUtils(document, {process_html : 0});\r\n})(tinymce);\r\n\r\n(function(ns) {\r\n\t// Range constructor\r\n\tfunction Range(dom) {\r\n\t\tvar t = this,\r\n\t\t\tdoc = dom.doc,\r\n\t\t\tEXTRACT = 0,\r\n\t\t\tCLONE = 1,\r\n\t\t\tDELETE = 2,\r\n\t\t\tTRUE = true,\r\n\t\t\tFALSE = false,\r\n\t\t\tSTART_OFFSET = 'startOffset',\r\n\t\t\tSTART_CONTAINER = 'startContainer',\r\n\t\t\tEND_CONTAINER = 'endContainer',\r\n\t\t\tEND_OFFSET = 'endOffset',\r\n\t\t\textend = tinymce.extend,\r\n\t\t\tnodeIndex = dom.nodeIndex;\r\n\r\n\t\textend(t, {\r\n\t\t\t// Inital states\r\n\t\t\tstartContainer : doc,\r\n\t\t\tstartOffset : 0,\r\n\t\t\tendContainer : doc,\r\n\t\t\tendOffset : 0,\r\n\t\t\tcollapsed : TRUE,\r\n\t\t\tcommonAncestorContainer : doc,\r\n\r\n\t\t\t// Range constants\r\n\t\t\tSTART_TO_START : 0,\r\n\t\t\tSTART_TO_END : 1,\r\n\t\t\tEND_TO_END : 2,\r\n\t\t\tEND_TO_START : 3,\r\n\r\n\t\t\t// Public methods\r\n\t\t\tsetStart : setStart,\r\n\t\t\tsetEnd : setEnd,\r\n\t\t\tsetStartBefore : setStartBefore,\r\n\t\t\tsetStartAfter : setStartAfter,\r\n\t\t\tsetEndBefore : setEndBefore,\r\n\t\t\tsetEndAfter : setEndAfter,\r\n\t\t\tcollapse : collapse,\r\n\t\t\tselectNode : selectNode,\r\n\t\t\tselectNodeContents : selectNodeContents,\r\n\t\t\tcompareBoundaryPoints : compareBoundaryPoints,\r\n\t\t\tdeleteContents : deleteContents,\r\n\t\t\textractContents : extractContents,\r\n\t\t\tcloneContents : cloneContents,\r\n\t\t\tinsertNode : insertNode,\r\n\t\t\tsurroundContents : surroundContents,\r\n\t\t\tcloneRange : cloneRange\r\n\t\t});\r\n\r\n\t\tfunction setStart(n, o) {\r\n\t\t\t_setEndPoint(TRUE, n, o);\r\n\t\t};\r\n\r\n\t\tfunction setEnd(n, o) {\r\n\t\t\t_setEndPoint(FALSE, n, o);\r\n\t\t};\r\n\r\n\t\tfunction setStartBefore(n) {\r\n\t\t\tsetStart(n.parentNode, nodeIndex(n));\r\n\t\t};\r\n\r\n\t\tfunction setStartAfter(n) {\r\n\t\t\tsetStart(n.parentNode, nodeIndex(n) + 1);\r\n\t\t};\r\n\r\n\t\tfunction setEndBefore(n) {\r\n\t\t\tsetEnd(n.parentNode, nodeIndex(n));\r\n\t\t};\r\n\r\n\t\tfunction setEndAfter(n) {\r\n\t\t\tsetEnd(n.parentNode, nodeIndex(n) + 1);\r\n\t\t};\r\n\r\n\t\tfunction collapse(ts) {\r\n\t\t\tif (ts) {\r\n\t\t\t\tt[END_CONTAINER] = t[START_CONTAINER];\r\n\t\t\t\tt[END_OFFSET] = t[START_OFFSET];\r\n\t\t\t} else {\r\n\t\t\t\tt[START_CONTAINER] = t[END_CONTAINER];\r\n\t\t\t\tt[START_OFFSET] = t[END_OFFSET];\r\n\t\t\t}\r\n\r\n\t\t\tt.collapsed = TRUE;\r\n\t\t};\r\n\r\n\t\tfunction selectNode(n) {\r\n\t\t\tsetStartBefore(n);\r\n\t\t\tsetEndAfter(n);\r\n\t\t};\r\n\r\n\t\tfunction selectNodeContents(n) {\r\n\t\t\tsetStart(n, 0);\r\n\t\t\tsetEnd(n, n.nodeType === 1 ? n.childNodes.length : n.nodeValue.length);\r\n\t\t};\r\n\r\n\t\tfunction compareBoundaryPoints(h, r) {\r\n\t\t\tvar sc = t[START_CONTAINER], so = t[START_OFFSET], ec = t[END_CONTAINER], eo = t[END_OFFSET],\r\n\t\t\trsc = r.startContainer, rso = r.startOffset, rec = r.endContainer, reo = r.endOffset;\r\n\r\n\t\t\t// Check START_TO_START\r\n\t\t\tif (h === 0)\r\n\t\t\t\treturn _compareBoundaryPoints(sc, so, rsc, rso);\r\n\r\n\t\t\t// Check START_TO_END\r\n\t\t\tif (h === 1)\r\n\t\t\t\treturn _compareBoundaryPoints(ec, eo, rsc, rso);\r\n\r\n\t\t\t// Check END_TO_END\r\n\t\t\tif (h === 2)\r\n\t\t\t\treturn _compareBoundaryPoints(ec, eo, rec, reo);\r\n\r\n\t\t\t// Check END_TO_START\r\n\t\t\tif (h === 3)\r\n\t\t\t\treturn _compareBoundaryPoints(sc, so, rec, reo);\r\n\t\t};\r\n\r\n\t\tfunction deleteContents() {\r\n\t\t\t_traverse(DELETE);\r\n\t\t};\r\n\r\n\t\tfunction extractContents() {\r\n\t\t\treturn _traverse(EXTRACT);\r\n\t\t};\r\n\r\n\t\tfunction cloneContents() {\r\n\t\t\treturn _traverse(CLONE);\r\n\t\t};\r\n\r\n\t\tfunction insertNode(n) {\r\n\t\t\tvar startContainer = this[START_CONTAINER],\r\n\t\t\t\tstartOffset = this[START_OFFSET], nn, o;\r\n\r\n\t\t\t// Node is TEXT_NODE or CDATA\r\n\t\t\tif ((startContainer.nodeType === 3 || startContainer.nodeType === 4) && startContainer.nodeValue) {\r\n\t\t\t\tif (!startOffset) {\r\n\t\t\t\t\t// At the start of text\r\n\t\t\t\t\tstartContainer.parentNode.insertBefore(n, startContainer);\r\n\t\t\t\t} else if (startOffset >= startContainer.nodeValue.length) {\r\n\t\t\t\t\t// At the end of text\r\n\t\t\t\t\tdom.insertAfter(n, startContainer);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Middle, need to split\r\n\t\t\t\t\tnn = startContainer.splitText(startOffset);\r\n\t\t\t\t\tstartContainer.parentNode.insertBefore(n, nn);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t// Insert element node\r\n\t\t\t\tif (startContainer.childNodes.length > 0)\r\n\t\t\t\t\to = startContainer.childNodes[startOffset];\r\n\r\n\t\t\t\tif (o)\r\n\t\t\t\t\tstartContainer.insertBefore(n, o);\r\n\t\t\t\telse\r\n\t\t\t\t\tstartContainer.appendChild(n);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tfunction surroundContents(n) {\r\n\t\t\tvar f = t.extractContents();\r\n\r\n\t\t\tt.insertNode(n);\r\n\t\t\tn.appendChild(f);\r\n\t\t\tt.selectNode(n);\r\n\t\t};\r\n\r\n\t\tfunction cloneRange() {\r\n\t\t\treturn extend(new Range(dom), {\r\n\t\t\t\tstartContainer : t[START_CONTAINER],\r\n\t\t\t\tstartOffset : t[START_OFFSET],\r\n\t\t\t\tendContainer : t[END_CONTAINER],\r\n\t\t\t\tendOffset : t[END_OFFSET],\r\n\t\t\t\tcollapsed : t.collapsed,\r\n\t\t\t\tcommonAncestorContainer : t.commonAncestorContainer\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t\t// Private methods\r\n\r\n\t\tfunction _getSelectedNode(container, offset) {\r\n\t\t\tvar child;\r\n\r\n\t\t\tif (container.nodeType == 3 /* TEXT_NODE */)\r\n\t\t\t\treturn container;\r\n\r\n\t\t\tif (offset < 0)\r\n\t\t\t\treturn container;\r\n\r\n\t\t\tchild = container.firstChild;\r\n\t\t\twhile (child && offset > 0) {\r\n\t\t\t\t--offset;\r\n\t\t\t\tchild = child.nextSibling;\r\n\t\t\t}\r\n\r\n\t\t\tif (child)\r\n\t\t\t\treturn child;\r\n\r\n\t\t\treturn container;\r\n\t\t};\r\n\r\n\t\tfunction _isCollapsed() {\r\n\t\t\treturn (t[START_CONTAINER] == t[END_CONTAINER] && t[START_OFFSET] == t[END_OFFSET]);\r\n\t\t};\r\n\r\n\t\tfunction _compareBoundaryPoints(containerA, offsetA, containerB, offsetB) {\r\n\t\t\tvar c, offsetC, n, cmnRoot, childA, childB;\r\n\r\n\t\t\t// In the first case the boundary-points have the same container. A is before B\r\n\t\t\t// if its offset is less than the offset of B, A is equal to B if its offset is\r\n\t\t\t// equal to the offset of B, and A is after B if its offset is greater than the\r\n\t\t\t// offset of B.\r\n\t\t\tif (containerA == containerB) {\r\n\t\t\t\tif (offsetA == offsetB)\r\n\t\t\t\t\treturn 0; // equal\r\n\r\n\t\t\t\tif (offsetA < offsetB)\r\n\t\t\t\t\treturn -1; // before\r\n\r\n\t\t\t\treturn 1; // after\r\n\t\t\t}\r\n\r\n\t\t\t// In the second case a child node C of the container of A is an ancestor\r\n\t\t\t// container of B. In this case, A is before B if the offset of A is less than or\r\n\t\t\t// equal to the index of the child node C and A is after B otherwise.\r\n\t\t\tc = containerB;\r\n\t\t\twhile (c && c.parentNode != containerA)\r\n\t\t\t\tc = c.parentNode;\r\n\r\n\t\t\tif (c) {\r\n\t\t\t\toffsetC = 0;\r\n\t\t\t\tn = containerA.firstChild;\r\n\r\n\t\t\t\twhile (n != c && offsetC < offsetA) {\r\n\t\t\t\t\toffsetC++;\r\n\t\t\t\t\tn = n.nextSibling;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (offsetA <= offsetC)\r\n\t\t\t\t\treturn -1; // before\r\n\r\n\t\t\t\treturn 1; // after\r\n\t\t\t}\r\n\r\n\t\t\t// In the third case a child node C of the container of B is an ancestor container\r\n\t\t\t// of A. In this case, A is before B if the index of the child node C is less than\r\n\t\t\t// the offset of B and A is after B otherwise.\r\n\t\t\tc = containerA;\r\n\t\t\twhile (c && c.parentNode != containerB) {\r\n\t\t\t\tc = c.parentNode;\r\n\t\t\t}\r\n\r\n\t\t\tif (c) {\r\n\t\t\t\toffsetC = 0;\r\n\t\t\t\tn = containerB.firstChild;\r\n\r\n\t\t\t\twhile (n != c && offsetC < offsetB) {\r\n\t\t\t\t\toffsetC++;\r\n\t\t\t\t\tn = n.nextSibling;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (offsetC < offsetB)\r\n\t\t\t\t\treturn -1; // before\r\n\r\n\t\t\t\treturn 1; // after\r\n\t\t\t}\r\n\r\n\t\t\t// In the fourth case, none of three other cases hold: the containers of A and B\r\n\t\t\t// are siblings or descendants of sibling nodes. In this case, A is before B if\r\n\t\t\t// the container of A is before the container of B in a pre-order traversal of the\r\n\t\t\t// Ranges' context tree and A is after B otherwise.\r\n\t\t\tcmnRoot = dom.findCommonAncestor(containerA, containerB);\r\n\t\t\tchildA = containerA;\r\n\r\n\t\t\twhile (childA && childA.parentNode != cmnRoot)\r\n\t\t\t\tchildA = childA.parentNode;\r\n\r\n\t\t\tif (!childA)\r\n\t\t\t\tchildA = cmnRoot;\r\n\r\n\t\t\tchildB = containerB;\r\n\t\t\twhile (childB && childB.parentNode != cmnRoot)\r\n\t\t\t\tchildB = childB.parentNode;\r\n\r\n\t\t\tif (!childB)\r\n\t\t\t\tchildB = cmnRoot;\r\n\r\n\t\t\tif (childA == childB)\r\n\t\t\t\treturn 0; // equal\r\n\r\n\t\t\tn = cmnRoot.firstChild;\r\n\t\t\twhile (n) {\r\n\t\t\t\tif (n == childA)\r\n\t\t\t\t\treturn -1; // before\r\n\r\n\t\t\t\tif (n == childB)\r\n\t\t\t\t\treturn 1; // after\r\n\r\n\t\t\t\tn = n.nextSibling;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tfunction _setEndPoint(st, n, o) {\r\n\t\t\tvar ec, sc;\r\n\r\n\t\t\tif (st) {\r\n\t\t\t\tt[START_CONTAINER] = n;\r\n\t\t\t\tt[START_OFFSET] = o;\r\n\t\t\t} else {\r\n\t\t\t\tt[END_CONTAINER] = n;\r\n\t\t\t\tt[END_OFFSET] = o;\r\n\t\t\t}\r\n\r\n\t\t\t// If one boundary-point of a Range is set to have a root container\r\n\t\t\t// other than the current one for the Range, the Range is collapsed to\r\n\t\t\t// the new position. This enforces the restriction that both boundary-\r\n\t\t\t// points of a Range must have the same root container.\r\n\t\t\tec = t[END_CONTAINER];\r\n\t\t\twhile (ec.parentNode)\r\n\t\t\t\tec = ec.parentNode;\r\n\r\n\t\t\tsc = t[START_CONTAINER];\r\n\t\t\twhile (sc.parentNode)\r\n\t\t\t\tsc = sc.parentNode;\r\n\r\n\t\t\tif (sc == ec) {\r\n\t\t\t\t// The start position of a Range is guaranteed to never be after the\r\n\t\t\t\t// end position. To enforce this restriction, if the start is set to\r\n\t\t\t\t// be at a position after the end, the Range is collapsed to that\r\n\t\t\t\t// position.\r\n\t\t\t\tif (_compareBoundaryPoints(t[START_CONTAINER], t[START_OFFSET], t[END_CONTAINER], t[END_OFFSET]) > 0)\r\n\t\t\t\t\tt.collapse(st);\r\n\t\t\t} else\r\n\t\t\t\tt.collapse(st);\r\n\r\n\t\t\tt.collapsed = _isCollapsed();\r\n\t\t\tt.commonAncestorContainer = dom.findCommonAncestor(t[START_CONTAINER], t[END_CONTAINER]);\r\n\t\t};\r\n\r\n\t\tfunction _traverse(how) {\r\n\t\t\tvar c, endContainerDepth = 0, startContainerDepth = 0, p, depthDiff, startNode, endNode, sp, ep;\r\n\r\n\t\t\tif (t[START_CONTAINER] == t[END_CONTAINER])\r\n\t\t\t\treturn _traverseSameContainer(how);\r\n\r\n\t\t\tfor (c = t[END_CONTAINER], p = c.parentNode; p; c = p, p = p.parentNode) {\r\n\t\t\t\tif (p == t[START_CONTAINER])\r\n\t\t\t\t\treturn _traverseCommonStartContainer(c, how);\r\n\r\n\t\t\t\t++endContainerDepth;\r\n\t\t\t}\r\n\r\n\t\t\tfor (c = t[START_CONTAINER], p = c.parentNode; p; c = p, p = p.parentNode) {\r\n\t\t\t\tif (p == t[END_CONTAINER])\r\n\t\t\t\t\treturn _traverseCommonEndContainer(c, how);\r\n\r\n\t\t\t\t++startContainerDepth;\r\n\t\t\t}\r\n\r\n\t\t\tdepthDiff = startContainerDepth - endContainerDepth;\r\n\r\n\t\t\tstartNode = t[START_CONTAINER];\r\n\t\t\twhile (depthDiff > 0) {\r\n\t\t\t\tstartNode = startNode.parentNode;\r\n\t\t\t\tdepthDiff--;\r\n\t\t\t}\r\n\r\n\t\t\tendNode = t[END_CONTAINER];\r\n\t\t\twhile (depthDiff < 0) {\r\n\t\t\t\tendNode = endNode.parentNode;\r\n\t\t\t\tdepthDiff++;\r\n\t\t\t}\r\n\r\n\t\t\t// ascend the ancestor hierarchy until we have a common parent.\r\n\t\t\tfor (sp = startNode.parentNode, ep = endNode.parentNode; sp != ep; sp = sp.parentNode, ep = ep.parentNode) {\r\n\t\t\t\tstartNode = sp;\r\n\t\t\t\tendNode = ep;\r\n\t\t\t}\r\n\r\n\t\t\treturn _traverseCommonAncestors(startNode, endNode, how);\r\n\t\t};\r\n\r\n\t\t function _traverseSameContainer(how) {\r\n\t\t\tvar frag, s, sub, n, cnt, sibling, xferNode;\r\n\r\n\t\t\tif (how != DELETE)\r\n\t\t\t\tfrag = doc.createDocumentFragment();\r\n\r\n\t\t\t// If selection is empty, just return the fragment\r\n\t\t\tif (t[START_OFFSET] == t[END_OFFSET])\r\n\t\t\t\treturn frag;\r\n\r\n\t\t\t// Text node needs special case handling\r\n\t\t\tif (t[START_CONTAINER].nodeType == 3 /* TEXT_NODE */) {\r\n\t\t\t\t// get the substring\r\n\t\t\t\ts = t[START_CONTAINER].nodeValue;\r\n\t\t\t\tsub = s.substring(t[START_OFFSET], t[END_OFFSET]);\r\n\r\n\t\t\t\t// set the original text node to its new value\r\n\t\t\t\tif (how != CLONE) {\r\n\t\t\t\t\tt[START_CONTAINER].deleteData(t[START_OFFSET], t[END_OFFSET] - t[START_OFFSET]);\r\n\r\n\t\t\t\t\t// Nothing is partially selected, so collapse to start point\r\n\t\t\t\t\tt.collapse(TRUE);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (how == DELETE)\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\tfrag.appendChild(doc.createTextNode(sub));\r\n\t\t\t\treturn frag;\r\n\t\t\t}\r\n\r\n\t\t\t// Copy nodes between the start/end offsets.\r\n\t\t\tn = _getSelectedNode(t[START_CONTAINER], t[START_OFFSET]);\r\n\t\t\tcnt = t[END_OFFSET] - t[START_OFFSET];\r\n\r\n\t\t\twhile (cnt > 0) {\r\n\t\t\t\tsibling = n.nextSibling;\r\n\t\t\t\txferNode = _traverseFullySelected(n, how);\r\n\r\n\t\t\t\tif (frag)\r\n\t\t\t\t\tfrag.appendChild( xferNode );\r\n\r\n\t\t\t\t--cnt;\r\n\t\t\t\tn = sibling;\r\n\t\t\t}\r\n\r\n\t\t\t// Nothing is partially selected, so collapse to start point\r\n\t\t\tif (how != CLONE)\r\n\t\t\t\tt.collapse(TRUE);\r\n\r\n\t\t\treturn frag;\r\n\t\t};\r\n\r\n\t\tfunction _traverseCommonStartContainer(endAncestor, how) {\r\n\t\t\tvar frag, n, endIdx, cnt, sibling, xferNode;\r\n\r\n\t\t\tif (how != DELETE)\r\n\t\t\t\tfrag = doc.createDocumentFragment();\r\n\r\n\t\t\tn = _traverseRightBoundary(endAncestor, how);\r\n\r\n\t\t\tif (frag)\r\n\t\t\t\tfrag.appendChild(n);\r\n\r\n\t\t\tendIdx = nodeIndex(endAncestor);\r\n\t\t\tcnt = endIdx - t[START_OFFSET];\r\n\r\n\t\t\tif (cnt <= 0) {\r\n\t\t\t\t// Collapse to just before the endAncestor, which\r\n\t\t\t\t// is partially selected.\r\n\t\t\t\tif (how != CLONE) {\r\n\t\t\t\t\tt.setEndBefore(endAncestor);\r\n\t\t\t\t\tt.collapse(FALSE);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn frag;\r\n\t\t\t}\r\n\r\n\t\t\tn = endAncestor.previousSibling;\r\n\t\t\twhile (cnt > 0) {\r\n\t\t\t\tsibling = n.previousSibling;\r\n\t\t\t\txferNode = _traverseFullySelected(n, how);\r\n\r\n\t\t\t\tif (frag)\r\n\t\t\t\t\tfrag.insertBefore(xferNode, frag.firstChild);\r\n\r\n\t\t\t\t--cnt;\r\n\t\t\t\tn = sibling;\r\n\t\t\t}\r\n\r\n\t\t\t// Collapse to just before the endAncestor, which\r\n\t\t\t// is partially selected.\r\n\t\t\tif (how != CLONE) {\r\n\t\t\t\tt.setEndBefore(endAncestor);\r\n\t\t\t\tt.collapse(FALSE);\r\n\t\t\t}\r\n\r\n\t\t\treturn frag;\r\n\t\t};\r\n\r\n\t\tfunction _traverseCommonEndContainer(startAncestor, how) {\r\n\t\t\tvar frag, startIdx, n, cnt, sibling, xferNode;\r\n\r\n\t\t\tif (how != DELETE)\r\n\t\t\t\tfrag = doc.createDocumentFragment();\r\n\r\n\t\t\tn = _traverseLeftBoundary(startAncestor, how);\r\n\t\t\tif (frag)\r\n\t\t\t\tfrag.appendChild(n);\r\n\r\n\t\t\tstartIdx = nodeIndex(startAncestor);\r\n\t\t\t++startIdx; // Because we already traversed it\r\n\r\n\t\t\tcnt = t[END_OFFSET] - startIdx;\r\n\t\t\tn = startAncestor.nextSibling;\r\n\t\t\twhile (cnt > 0) {\r\n\t\t\t\tsibling = n.nextSibling;\r\n\t\t\t\txferNode = _traverseFullySelected(n, how);\r\n\r\n\t\t\t\tif (frag)\r\n\t\t\t\t\tfrag.appendChild(xferNode);\r\n\r\n\t\t\t\t--cnt;\r\n\t\t\t\tn = sibling;\r\n\t\t\t}\r\n\r\n\t\t\tif (how != CLONE) {\r\n\t\t\t\tt.setStartAfter(startAncestor);\r\n\t\t\t\tt.collapse(TRUE);\r\n\t\t\t}\r\n\r\n\t\t\treturn frag;\r\n\t\t};\r\n\r\n\t\tfunction _traverseCommonAncestors(startAncestor, endAncestor, how) {\r\n\t\t\tvar n, frag, commonParent, startOffset, endOffset, cnt, sibling, nextSibling;\r\n\r\n\t\t\tif (how != DELETE)\r\n\t\t\t\tfrag = doc.createDocumentFragment();\r\n\r\n\t\t\tn = _traverseLeftBoundary(startAncestor, how);\r\n\t\t\tif (frag)\r\n\t\t\t\tfrag.appendChild(n);\r\n\r\n\t\t\tcommonParent = startAncestor.parentNode;\r\n\t\t\tstartOffset = nodeIndex(startAncestor);\r\n\t\t\tendOffset = nodeIndex(endAncestor);\r\n\t\t\t++startOffset;\r\n\r\n\t\t\tcnt = endOffset - startOffset;\r\n\t\t\tsibling = startAncestor.nextSibling;\r\n\r\n\t\t\twhile (cnt > 0) {\r\n\t\t\t\tnextSibling = sibling.nextSibling;\r\n\t\t\t\tn = _traverseFullySelected(sibling, how);\r\n\r\n\t\t\t\tif (frag)\r\n\t\t\t\t\tfrag.appendChild(n);\r\n\r\n\t\t\t\tsibling = nextSibling;\r\n\t\t\t\t--cnt;\r\n\t\t\t}\r\n\r\n\t\t\tn = _traverseRightBoundary(endAncestor, how);\r\n\r\n\t\t\tif (frag)\r\n\t\t\t\tfrag.appendChild(n);\r\n\r\n\t\t\tif (how != CLONE) {\r\n\t\t\t\tt.setStartAfter(startAncestor);\r\n\t\t\t\tt.collapse(TRUE);\r\n\t\t\t}\r\n\r\n\t\t\treturn frag;\r\n\t\t};\r\n\r\n\t\tfunction _traverseRightBoundary(root, how) {\r\n\t\t\tvar next = _getSelectedNode(t[END_CONTAINER], t[END_OFFSET] - 1), parent, clonedParent, prevSibling, clonedChild, clonedGrandParent, isFullySelected = next != t[END_CONTAINER];\r\n\r\n\t\t\tif (next == root)\r\n\t\t\t\treturn _traverseNode(next, isFullySelected, FALSE, how);\r\n\r\n\t\t\tparent = next.parentNode;\r\n\t\t\tclonedParent = _traverseNode(parent, FALSE, FALSE, how);\r\n\r\n\t\t\twhile (parent) {\r\n\t\t\t\twhile (next) {\r\n\t\t\t\t\tprevSibling = next.previousSibling;\r\n\t\t\t\t\tclonedChild = _traverseNode(next, isFullySelected, FALSE, how);\r\n\r\n\t\t\t\t\tif (how != DELETE)\r\n\t\t\t\t\t\tclonedParent.insertBefore(clonedChild, clonedParent.firstChild);\r\n\r\n\t\t\t\t\tisFullySelected = TRUE;\r\n\t\t\t\t\tnext = prevSibling;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (parent == root)\r\n\t\t\t\t\treturn clonedParent;\r\n\r\n\t\t\t\tnext = parent.previousSibling;\r\n\t\t\t\tparent = parent.parentNode;\r\n\r\n\t\t\t\tclonedGrandParent = _traverseNode(parent, FALSE, FALSE, how);\r\n\r\n\t\t\t\tif (how != DELETE)\r\n\t\t\t\t\tclonedGrandParent.appendChild(clonedParent);\r\n\r\n\t\t\t\tclonedParent = clonedGrandParent;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tfunction _traverseLeftBoundary(root, how) {\r\n\t\t\tvar next = _getSelectedNode(t[START_CONTAINER], t[START_OFFSET]), isFullySelected = next != t[START_CONTAINER], parent, clonedParent, nextSibling, clonedChild, clonedGrandParent;\r\n\r\n\t\t\tif (next == root)\r\n\t\t\t\treturn _traverseNode(next, isFullySelected, TRUE, how);\r\n\r\n\t\t\tparent = next.parentNode;\r\n\t\t\tclonedParent = _traverseNode(parent, FALSE, TRUE, how);\r\n\r\n\t\t\twhile (parent) {\r\n\t\t\t\twhile (next) {\r\n\t\t\t\t\tnextSibling = next.nextSibling;\r\n\t\t\t\t\tclonedChild = _traverseNode(next, isFullySelected, TRUE, how);\r\n\r\n\t\t\t\t\tif (how != DELETE)\r\n\t\t\t\t\t\tclonedParent.appendChild(clonedChild);\r\n\r\n\t\t\t\t\tisFullySelected = TRUE;\r\n\t\t\t\t\tnext = nextSibling;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (parent == root)\r\n\t\t\t\t\treturn clonedParent;\r\n\r\n\t\t\t\tnext = parent.nextSibling;\r\n\t\t\t\tparent = parent.parentNode;\r\n\r\n\t\t\t\tclonedGrandParent = _traverseNode(parent, FALSE, TRUE, how);\r\n\r\n\t\t\t\tif (how != DELETE)\r\n\t\t\t\t\tclonedGrandParent.appendChild(clonedParent);\r\n\r\n\t\t\t\tclonedParent = clonedGrandParent;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tfunction _traverseNode(n, isFullySelected, isLeft, how) {\r\n\t\t\tvar txtValue, newNodeValue, oldNodeValue, offset, newNode;\r\n\r\n\t\t\tif (isFullySelected)\r\n\t\t\t\treturn _traverseFullySelected(n, how);\r\n\r\n\t\t\tif (n.nodeType == 3 /* TEXT_NODE */) {\r\n\t\t\t\ttxtValue = n.nodeValue;\r\n\r\n\t\t\t\tif (isLeft) {\r\n\t\t\t\t\toffset = t[START_OFFSET];\r\n\t\t\t\t\tnewNodeValue = txtValue.substring(offset);\r\n\t\t\t\t\toldNodeValue = txtValue.substring(0, offset);\r\n\t\t\t\t} else {\r\n\t\t\t\t\toffset = t[END_OFFSET];\r\n\t\t\t\t\tnewNodeValue = txtValue.substring(0, offset);\r\n\t\t\t\t\toldNodeValue = txtValue.substring(offset);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (how != CLONE)\r\n\t\t\t\t\tn.nodeValue = oldNodeValue;\r\n\r\n\t\t\t\tif (how == DELETE)\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\tnewNode = n.cloneNode(FALSE);\r\n\t\t\t\tnewNode.nodeValue = newNodeValue;\r\n\r\n\t\t\t\treturn newNode;\r\n\t\t\t}\r\n\r\n\t\t\tif (how == DELETE)\r\n\t\t\t\treturn;\r\n\r\n\t\t\treturn n.cloneNode(FALSE);\r\n\t\t};\r\n\r\n\t\tfunction _traverseFullySelected(n, how) {\r\n\t\t\tif (how != DELETE)\r\n\t\t\t\treturn how == CLONE ? n.cloneNode(TRUE) : n;\r\n\r\n\t\t\tn.parentNode.removeChild(n);\r\n\t\t};\r\n\t};\r\n\r\n\tns.Range = Range;\r\n})(tinymce.dom);\r\n\r\n(function() {\r\n\tfunction Selection(selection) {\r\n\t\tvar self = this, dom = selection.dom, TRUE = true, FALSE = false;\r\n\r\n\t\tfunction getPosition(rng, start) {\r\n\t\t\tvar checkRng, startIndex = 0, endIndex, inside,\r\n\t\t\t\tchildren, child, offset, index, position = -1, parent;\r\n\r\n\t\t\t// Setup test range, collapse it and get the parent\r\n\t\t\tcheckRng = rng.duplicate();\r\n\t\t\tcheckRng.collapse(start);\r\n\t\t\tparent = checkRng.parentElement();\r\n\r\n\t\t\t// Check if the selection is within the right document\r\n\t\t\tif (parent.ownerDocument !== selection.dom.doc)\r\n\t\t\t\treturn;\r\n\r\n\t\t\t// IE will report non editable elements as it's parent so look for an editable one\r\n\t\t\twhile (parent.contentEditable === \"false\") {\r\n\t\t\t\tparent = parent.parentNode;\r\n\t\t\t}\r\n\r\n\t\t\t// If parent doesn't have any children then return that we are inside the element\r\n\t\t\tif (!parent.hasChildNodes()) {\r\n\t\t\t\treturn {node : parent, inside : 1};\r\n\t\t\t}\r\n\r\n\t\t\t// Setup node list and endIndex\r\n\t\t\tchildren = parent.children;\r\n\t\t\tendIndex = children.length - 1;\r\n\r\n\t\t\t// Perform a binary search for the position\r\n\t\t\twhile (startIndex <= endIndex) {\r\n\t\t\t\tindex = Math.floor((startIndex + endIndex) / 2);\r\n\r\n\t\t\t\t// Move selection to node and compare the ranges\r\n\t\t\t\tchild = children[index];\r\n\t\t\t\tcheckRng.moveToElementText(child);\r\n\t\t\t\tposition = checkRng.compareEndPoints(start ? 'StartToStart' : 'EndToEnd', rng);\r\n\r\n\t\t\t\t// Before/after or an exact match\r\n\t\t\t\tif (position > 0) {\r\n\t\t\t\t\tendIndex = index - 1;\r\n\t\t\t\t} else if (position < 0) {\r\n\t\t\t\t\tstartIndex = index + 1;\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn {node : child};\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Check if child position is before or we didn't find a position\r\n\t\t\tif (position < 0) {\r\n\t\t\t\t// No element child was found use the parent element and the offset inside that\r\n\t\t\t\tif (!child) {\r\n\t\t\t\t\tcheckRng.moveToElementText(parent);\r\n\t\t\t\t\tcheckRng.collapse(true);\r\n\t\t\t\t\tchild = parent;\r\n\t\t\t\t\tinside = true;\r\n\t\t\t\t} else\r\n\t\t\t\t\tcheckRng.collapse(false);\r\n\r\n\t\t\t\tcheckRng.setEndPoint(start ? 'EndToStart' : 'EndToEnd', rng);\r\n\r\n\t\t\t\t// Fix for edge case: <div style=\"width: 100px; height:100px;\"><table>..</table>ab|c</div>\r\n\t\t\t\tif (checkRng.compareEndPoints(start ? 'StartToStart' : 'StartToEnd', rng) > 0) {\r\n\t\t\t\t\tcheckRng = rng.duplicate();\r\n\t\t\t\t\tcheckRng.collapse(start);\r\n\r\n\t\t\t\t\toffset = -1;\r\n\t\t\t\t\twhile (parent == checkRng.parentElement()) {\r\n\t\t\t\t\t\tif (checkRng.move('character', -1) == 0)\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\toffset++;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\toffset = offset || checkRng.text.replace('\\r\\n', ' ').length;\r\n\t\t\t} else {\r\n\t\t\t\t// Child position is after the selection endpoint\r\n\t\t\t\tcheckRng.collapse(true);\r\n\t\t\t\tcheckRng.setEndPoint(start ? 'StartToStart' : 'StartToEnd', rng);\r\n\r\n\t\t\t\t// Get the length of the text to find where the endpoint is relative to it's container\r\n\t\t\t\toffset = checkRng.text.replace('\\r\\n', ' ').length;\r\n\t\t\t}\r\n\r\n\t\t\treturn {node : child, position : position, offset : offset, inside : inside};\r\n\t\t};\r\n\r\n\t\t// Returns a W3C DOM compatible range object by using the IE Range API\r\n\t\tfunction getRange() {\r\n\t\t\tvar ieRange = selection.getRng(), domRange = dom.createRng(), element, collapsed, tmpRange, element2, bookmark, fail;\r\n\r\n\t\t\t// If selection is outside the current document just return an empty range\r\n\t\t\telement = ieRange.item ? ieRange.item(0) : ieRange.parentElement();\r\n\t\t\tif (element.ownerDocument != dom.doc)\r\n\t\t\t\treturn domRange;\r\n\r\n\t\t\tcollapsed = selection.isCollapsed();\r\n\r\n\t\t\t// Handle control selection\r\n\t\t\tif (ieRange.item) {\r\n\t\t\t\tdomRange.setStart(element.parentNode, dom.nodeIndex(element));\r\n\t\t\t\tdomRange.setEnd(domRange.startContainer, domRange.startOffset + 1);\r\n\r\n\t\t\t\treturn domRange;\r\n\t\t\t}\r\n\r\n\t\t\tfunction findEndPoint(start) {\r\n\t\t\t\tvar endPoint = getPosition(ieRange, start), container, offset, textNodeOffset = 0, sibling, undef, nodeValue;\r\n\r\n\t\t\t\tcontainer = endPoint.node;\r\n\t\t\t\toffset = endPoint.offset;\r\n\r\n\t\t\t\tif (endPoint.inside && !container.hasChildNodes()) {\r\n\t\t\t\t\tdomRange[start ? 'setStart' : 'setEnd'](container, 0);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (offset === undef) {\r\n\t\t\t\t\tdomRange[start ? 'setStartBefore' : 'setEndAfter'](container);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (endPoint.position < 0) {\r\n\t\t\t\t\tsibling = endPoint.inside ? container.firstChild : container.nextSibling;\r\n\r\n\t\t\t\t\tif (!sibling) {\r\n\t\t\t\t\t\tdomRange[start ? 'setStartAfter' : 'setEndAfter'](container);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (!offset) {\r\n\t\t\t\t\t\tif (sibling.nodeType == 3)\r\n\t\t\t\t\t\t\tdomRange[start ? 'setStart' : 'setEnd'](sibling, 0);\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tdomRange[start ? 'setStartBefore' : 'setEndBefore'](sibling);\r\n\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Find the text node and offset\r\n\t\t\t\t\twhile (sibling) {\r\n\t\t\t\t\t\tnodeValue = sibling.nodeValue;\r\n\t\t\t\t\t\ttextNodeOffset += nodeValue.length;\r\n\r\n\t\t\t\t\t\t// We are at or passed the position we where looking for\r\n\t\t\t\t\t\tif (textNodeOffset >= offset) {\r\n\t\t\t\t\t\t\tcontainer = sibling;\r\n\t\t\t\t\t\t\ttextNodeOffset -= offset;\r\n\t\t\t\t\t\t\ttextNodeOffset = nodeValue.length - textNodeOffset;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tsibling = sibling.nextSibling;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Find the text node and offset\r\n\t\t\t\t\tsibling = container.previousSibling;\r\n\r\n\t\t\t\t\tif (!sibling)\r\n\t\t\t\t\t\treturn domRange[start ? 'setStartBefore' : 'setEndBefore'](container);\r\n\r\n\t\t\t\t\t// If there isn't any text to loop then use the first position\r\n\t\t\t\t\tif (!offset) {\r\n\t\t\t\t\t\tif (container.nodeType == 3)\r\n\t\t\t\t\t\t\tdomRange[start ? 'setStart' : 'setEnd'](sibling, container.nodeValue.length);\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tdomRange[start ? 'setStartAfter' : 'setEndAfter'](sibling);\r\n\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\twhile (sibling) {\r\n\t\t\t\t\t\ttextNodeOffset += sibling.nodeValue.length;\r\n\r\n\t\t\t\t\t\t// We are at or passed the position we where looking for\r\n\t\t\t\t\t\tif (textNodeOffset >= offset) {\r\n\t\t\t\t\t\t\tcontainer = sibling;\r\n\t\t\t\t\t\t\ttextNodeOffset -= offset;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tsibling = sibling.previousSibling;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdomRange[start ? 'setStart' : 'setEnd'](container, textNodeOffset);\r\n\t\t\t};\r\n\r\n\t\t\ttry {\r\n\t\t\t\t// Find start point\r\n\t\t\t\tfindEndPoint(true);\r\n\r\n\t\t\t\t// Find end point if needed\r\n\t\t\t\tif (!collapsed)\r\n\t\t\t\t\tfindEndPoint();\r\n\t\t\t} catch (ex) {\r\n\t\t\t\t// IE has a nasty bug where text nodes might throw \"invalid argument\" when you\r\n\t\t\t\t// access the nodeValue or other properties of text nodes. This seems to happend when\r\n\t\t\t\t// text nodes are split into two nodes by a delete/backspace call. So lets detect it and try to fix it.\r\n\t\t\t\tif (ex.number == -2147024809) {\r\n\t\t\t\t\t// Get the current selection\r\n\t\t\t\t\tbookmark = self.getBookmark(2);\r\n\r\n\t\t\t\t\t// Get start element\r\n\t\t\t\t\ttmpRange = ieRange.duplicate();\r\n\t\t\t\t\ttmpRange.collapse(true);\r\n\t\t\t\t\telement = tmpRange.parentElement();\r\n\r\n\t\t\t\t\t// Get end element\r\n\t\t\t\t\tif (!collapsed) {\r\n\t\t\t\t\t\ttmpRange = ieRange.duplicate();\r\n\t\t\t\t\t\ttmpRange.collapse(false);\r\n\t\t\t\t\t\telement2 = tmpRange.parentElement();\r\n\t\t\t\t\t\telement2.innerHTML = element2.innerHTML;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Remove the broken elements\r\n\t\t\t\t\telement.innerHTML = element.innerHTML;\r\n\r\n\t\t\t\t\t// Restore the selection\r\n\t\t\t\t\tself.moveToBookmark(bookmark);\r\n\r\n\t\t\t\t\t// Since the range has moved we need to re-get it\r\n\t\t\t\t\tieRange = selection.getRng();\r\n\r\n\t\t\t\t\t// Find start point\r\n\t\t\t\t\tfindEndPoint(true);\r\n\r\n\t\t\t\t\t// Find end point if needed\r\n\t\t\t\t\tif (!collapsed)\r\n\t\t\t\t\t\tfindEndPoint();\r\n\t\t\t\t} else\r\n\t\t\t\t\tthrow ex; // Throw other errors\r\n\t\t\t}\r\n\r\n\t\t\treturn domRange;\r\n\t\t};\r\n\r\n\t\tthis.getBookmark = function(type) {\r\n\t\t\tvar rng = selection.getRng(), start, end, bookmark = {};\r\n\r\n\t\t\tfunction getIndexes(node) {\r\n\t\t\t\tvar node, parent, root, children, i, indexes = [];\r\n\r\n\t\t\t\tparent = node.parentNode;\r\n\t\t\t\troot = dom.getRoot().parentNode;\r\n\r\n\t\t\t\twhile (parent != root && parent.nodeType !== 9) {\r\n\t\t\t\t\tchildren = parent.children;\r\n\r\n\t\t\t\t\ti = children.length;\r\n\t\t\t\t\twhile (i--) {\r\n\t\t\t\t\t\tif (node === children[i]) {\r\n\t\t\t\t\t\t\tindexes.push(i);\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tnode = parent;\r\n\t\t\t\t\tparent = parent.parentNode;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn indexes;\r\n\t\t\t};\r\n\r\n\t\t\tfunction getBookmarkEndPoint(start) {\r\n\t\t\t\tvar position;\r\n\r\n\t\t\t\tposition = getPosition(rng, start);\r\n\t\t\t\tif (position) {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tposition : position.position,\r\n\t\t\t\t\t\toffset : position.offset,\r\n\t\t\t\t\t\tindexes : getIndexes(position.node),\r\n\t\t\t\t\t\tinside : position.inside\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\t// Non ubstructive bookmark\r\n\t\t\tif (type === 2) {\r\n\t\t\t\t// Handle text selection\r\n\t\t\t\tif (!rng.item) {\r\n\t\t\t\t\tbookmark.start = getBookmarkEndPoint(true);\r\n\r\n\t\t\t\t\tif (!selection.isCollapsed())\r\n\t\t\t\t\t\tbookmark.end = getBookmarkEndPoint();\r\n\t\t\t\t} else\r\n\t\t\t\t\tbookmark.start = {ctrl : true, indexes : getIndexes(rng.item(0))};\r\n\t\t\t}\r\n\r\n\t\t\treturn bookmark;\r\n\t\t};\r\n\r\n\t\tthis.moveToBookmark = function(bookmark) {\r\n\t\t\tvar rng, body = dom.doc.body;\r\n\r\n\t\t\tfunction resolveIndexes(indexes) {\r\n\t\t\t\tvar node, i, idx, children;\r\n\r\n\t\t\t\tnode = dom.getRoot();\r\n\t\t\t\tfor (i = indexes.length - 1; i >= 0; i--) {\r\n\t\t\t\t\tchildren = node.children;\r\n\t\t\t\t\tidx = indexes[i];\r\n\r\n\t\t\t\t\tif (idx <= children.length - 1) {\r\n\t\t\t\t\t\tnode = children[idx];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn node;\r\n\t\t\t};\r\n\r\n\t\t\tfunction setBookmarkEndPoint(start) {\r\n\t\t\t\tvar endPoint = bookmark[start ? 'start' : 'end'], moveLeft, moveRng, undef;\r\n\r\n\t\t\t\tif (endPoint) {\r\n\t\t\t\t\tmoveLeft = endPoint.position > 0;\r\n\r\n\t\t\t\t\tmoveRng = body.createTextRange();\r\n\t\t\t\t\tmoveRng.moveToElementText(resolveIndexes(endPoint.indexes));\r\n\r\n\t\t\t\t\toffset = endPoint.offset;\r\n\t\t\t\t\tif (offset !== undef) {\r\n\t\t\t\t\t\tmoveRng.collapse(endPoint.inside || moveLeft);\r\n\t\t\t\t\t\tmoveRng.moveStart('character', moveLeft ? -offset : offset);\r\n\t\t\t\t\t} else\r\n\t\t\t\t\t\tmoveRng.collapse(start);\r\n\r\n\t\t\t\t\trng.setEndPoint(start ? 'StartToStart' : 'EndToStart', moveRng);\r\n\r\n\t\t\t\t\tif (start)\r\n\t\t\t\t\t\trng.collapse(true);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tif (bookmark.start) {\r\n\t\t\t\tif (bookmark.start.ctrl) {\r\n\t\t\t\t\trng = body.createControlRange();\r\n\t\t\t\t\trng.addElement(resolveIndexes(bookmark.start.indexes));\r\n\t\t\t\t\trng.select();\r\n\t\t\t\t} else {\r\n\t\t\t\t\trng = body.createTextRange();\r\n\t\t\t\t\tsetBookmarkEndPoint(true);\r\n\t\t\t\t\tsetBookmarkEndPoint();\r\n\t\t\t\t\trng.select();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tthis.addRange = function(rng) {\r\n\t\t\tvar ieRng, ctrlRng, startContainer, startOffset, endContainer, endOffset, doc = selection.dom.doc, body = doc.body;\r\n\r\n\t\t\tfunction setEndPoint(start) {\r\n\t\t\t\tvar container, offset, marker, tmpRng, nodes;\r\n\r\n\t\t\t\tmarker = dom.create('a');\r\n\t\t\t\tcontainer = start ? startContainer : endContainer;\r\n\t\t\t\toffset = start ? startOffset : endOffset;\r\n\t\t\t\ttmpRng = ieRng.duplicate();\r\n\r\n\t\t\t\tif (container == doc || container == doc.documentElement) {\r\n\t\t\t\t\tcontainer = body;\r\n\t\t\t\t\toffset = 0;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (container.nodeType == 3) {\r\n\t\t\t\t\tcontainer.parentNode.insertBefore(marker, container);\r\n\t\t\t\t\ttmpRng.moveToElementText(marker);\r\n\t\t\t\t\ttmpRng.moveStart('character', offset);\r\n\t\t\t\t\tdom.remove(marker);\r\n\t\t\t\t\tieRng.setEndPoint(start ? 'StartToStart' : 'EndToEnd', tmpRng);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tnodes = container.childNodes;\r\n\r\n\t\t\t\t\tif (nodes.length) {\r\n\t\t\t\t\t\tif (offset >= nodes.length) {\r\n\t\t\t\t\t\t\tdom.insertAfter(marker, nodes[nodes.length - 1]);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tcontainer.insertBefore(marker, nodes[offset]);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\ttmpRng.moveToElementText(marker);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// Empty node selection for example <div>|</div>\r\n\t\t\t\t\t\tmarker = doc.createTextNode('\\uFEFF');\r\n\t\t\t\t\t\tcontainer.appendChild(marker);\r\n\t\t\t\t\t\ttmpRng.moveToElementText(marker.parentNode);\r\n\t\t\t\t\t\ttmpRng.collapse(TRUE);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tieRng.setEndPoint(start ? 'StartToStart' : 'EndToEnd', tmpRng);\r\n\t\t\t\t\tdom.remove(marker);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Setup some shorter versions\r\n\t\t\tstartContainer = rng.startContainer;\r\n\t\t\tstartOffset = rng.startOffset;\r\n\t\t\tendContainer = rng.endContainer;\r\n\t\t\tendOffset = rng.endOffset;\r\n\t\t\tieRng = body.createTextRange();\r\n\r\n\t\t\t// If single element selection then try making a control selection out of it\r\n\t\t\tif (startContainer == endContainer && startContainer.nodeType == 1 && startOffset == endOffset - 1) {\r\n\t\t\t\tif (startOffset == endOffset - 1) {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tctrlRng = body.createControlRange();\r\n\t\t\t\t\t\tctrlRng.addElement(startContainer.childNodes[startOffset]);\r\n\t\t\t\t\t\tctrlRng.select();\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t} catch (ex) {\r\n\t\t\t\t\t\t// Ignore\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Set start/end point of selection\r\n\t\t\tsetEndPoint(true);\r\n\t\t\tsetEndPoint();\r\n\r\n\t\t\t// Select the new range and scroll it into view\r\n\t\t\tieRng.select();\r\n\t\t};\r\n\r\n\t\t// Expose range method\r\n\t\tthis.getRangeAt = getRange;\r\n\t};\r\n\r\n\t// Expose the selection object\r\n\ttinymce.dom.TridentSelection = Selection;\r\n})();\r\n\r\n\r\n/*\r\n * Sizzle CSS Selector Engine - v1.0\r\n *  Copyright 2009, The Dojo Foundation\r\n *  Released under the MIT, BSD, and GPL Licenses.\r\n *  More information: http://sizzlejs.com/\r\n */\r\n(function(){\r\n\r\nvar chunker = /((?:\\((?:\\([^()]+\\)|[^()]+)+\\)|\\[(?:\\[[^\\[\\]]*\\]|['\"][^'\"]*['\"]|[^\\[\\]'\"]+)+\\]|\\\\.|[^ >+~,(\\[\\\\]+)+|[>+~])(\\s*,\\s*)?((?:.|\\r|\\n)*)/g,\r\n\tdone = 0,\r\n\ttoString = Object.prototype.toString,\r\n\thasDuplicate = false,\r\n\tbaseHasDuplicate = true;\r\n\r\n// Here we check if the JavaScript engine is using some sort of\r\n// optimization where it does not always call our comparision\r\n// function. If that is the case, discard the hasDuplicate value.\r\n//   Thus far that includes Google Chrome.\r\n[0, 0].sort(function(){\r\n\tbaseHasDuplicate = false;\r\n\treturn 0;\r\n});\r\n\r\nvar Sizzle = function(selector, context, results, seed) {\r\n\tresults = results || [];\r\n\tcontext = context || document;\r\n\r\n\tvar origContext = context;\r\n\r\n\tif ( context.nodeType !== 1 && context.nodeType !== 9 ) {\r\n\t\treturn [];\r\n\t}\r\n\r\n\tif ( !selector || typeof selector !== \"string\" ) {\r\n\t\treturn results;\r\n\t}\r\n\r\n\tvar parts = [], m, set, checkSet, extra, prune = true, contextXML = Sizzle.isXML(context),\r\n\t\tsoFar = selector, ret, cur, pop, i;\r\n\r\n\t// Reset the position of the chunker regexp (start from head)\r\n\tdo {\r\n\t\tchunker.exec(\"\");\r\n\t\tm = chunker.exec(soFar);\r\n\r\n\t\tif ( m ) {\r\n\t\t\tsoFar = m[3];\r\n\r\n\t\t\tparts.push( m[1] );\r\n\r\n\t\t\tif ( m[2] ) {\r\n\t\t\t\textra = m[3];\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t} while ( m );\r\n\r\n\tif ( parts.length > 1 && origPOS.exec( selector ) ) {\r\n\t\tif ( parts.length === 2 && Expr.relative[ parts[0] ] ) {\r\n\t\t\tset = posProcess( parts[0] + parts[1], context );\r\n\t\t} else {\r\n\t\t\tset = Expr.relative[ parts[0] ] ?\r\n\t\t\t\t[ context ] :\r\n\t\t\t\tSizzle( parts.shift(), context );\r\n\r\n\t\t\twhile ( parts.length ) {\r\n\t\t\t\tselector = parts.shift();\r\n\r\n\t\t\t\tif ( Expr.relative[ selector ] ) {\r\n\t\t\t\t\tselector += parts.shift();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tset = posProcess( selector, set );\r\n\t\t\t}\r\n\t\t}\r\n\t} else {\r\n\t\t// Take a shortcut and set the context if the root selector is an ID\r\n\t\t// (but not if it'll be faster if the inner selector is an ID)\r\n\t\tif ( !seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&\r\n\t\t\t\tExpr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1]) ) {\r\n\t\t\tret = Sizzle.find( parts.shift(), context, contextXML );\r\n\t\t\tcontext = ret.expr ? Sizzle.filter( ret.expr, ret.set )[0] : ret.set[0];\r\n\t\t}\r\n\r\n\t\tif ( context ) {\r\n\t\t\tret = seed ?\r\n\t\t\t\t{ expr: parts.pop(), set: makeArray(seed) } :\r\n\t\t\t\tSizzle.find( parts.pop(), parts.length === 1 && (parts[0] === \"~\" || parts[0] === \"+\") && context.parentNode ? context.parentNode : context, contextXML );\r\n\t\t\tset = ret.expr ? Sizzle.filter( ret.expr, ret.set ) : ret.set;\r\n\r\n\t\t\tif ( parts.length > 0 ) {\r\n\t\t\t\tcheckSet = makeArray(set);\r\n\t\t\t} else {\r\n\t\t\t\tprune = false;\r\n\t\t\t}\r\n\r\n\t\t\twhile ( parts.length ) {\r\n\t\t\t\tcur = parts.pop();\r\n\t\t\t\tpop = cur;\r\n\r\n\t\t\t\tif ( !Expr.relative[ cur ] ) {\r\n\t\t\t\t\tcur = \"\";\r\n\t\t\t\t} else {\r\n\t\t\t\t\tpop = parts.pop();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( pop == null ) {\r\n\t\t\t\t\tpop = context;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tExpr.relative[ cur ]( checkSet, pop, contextXML );\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tcheckSet = parts = [];\r\n\t\t}\r\n\t}\r\n\r\n\tif ( !checkSet ) {\r\n\t\tcheckSet = set;\r\n\t}\r\n\r\n\tif ( !checkSet ) {\r\n\t\tSizzle.error( cur || selector );\r\n\t}\r\n\r\n\tif ( toString.call(checkSet) === \"[object Array]\" ) {\r\n\t\tif ( !prune ) {\r\n\t\t\tresults.push.apply( results, checkSet );\r\n\t\t} else if ( context && context.nodeType === 1 ) {\r\n\t\t\tfor ( i = 0; checkSet[i] != null; i++ ) {\r\n\t\t\t\tif ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && Sizzle.contains(context, checkSet[i])) ) {\r\n\t\t\t\t\tresults.push( set[i] );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor ( i = 0; checkSet[i] != null; i++ ) {\r\n\t\t\t\tif ( checkSet[i] && checkSet[i].nodeType === 1 ) {\r\n\t\t\t\t\tresults.push( set[i] );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t} else {\r\n\t\tmakeArray( checkSet, results );\r\n\t}\r\n\r\n\tif ( extra ) {\r\n\t\tSizzle( extra, origContext, results, seed );\r\n\t\tSizzle.uniqueSort( results );\r\n\t}\r\n\r\n\treturn results;\r\n};\r\n\r\nSizzle.uniqueSort = function(results){\r\n\tif ( sortOrder ) {\r\n\t\thasDuplicate = baseHasDuplicate;\r\n\t\tresults.sort(sortOrder);\r\n\r\n\t\tif ( hasDuplicate ) {\r\n\t\t\tfor ( var i = 1; i < results.length; i++ ) {\r\n\t\t\t\tif ( results[i] === results[i-1] ) {\r\n\t\t\t\t\tresults.splice(i--, 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn results;\r\n};\r\n\r\nSizzle.matches = function(expr, set){\r\n\treturn Sizzle(expr, null, null, set);\r\n};\r\n\r\nSizzle.find = function(expr, context, isXML){\r\n\tvar set;\r\n\r\n\tif ( !expr ) {\r\n\t\treturn [];\r\n\t}\r\n\r\n\tfor ( var i = 0, l = Expr.order.length; i < l; i++ ) {\r\n\t\tvar type = Expr.order[i], match;\r\n\r\n\t\tif ( (match = Expr.leftMatch[ type ].exec( expr )) ) {\r\n\t\t\tvar left = match[1];\r\n\t\t\tmatch.splice(1,1);\r\n\r\n\t\t\tif ( left.substr( left.length - 1 ) !== \"\\\\\" ) {\r\n\t\t\t\tmatch[1] = (match[1] || \"\").replace(/\\\\/g, \"\");\r\n\t\t\t\tset = Expr.find[ type ]( match, context, isXML );\r\n\t\t\t\tif ( set != null ) {\r\n\t\t\t\t\texpr = expr.replace( Expr.match[ type ], \"\" );\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif ( !set ) {\r\n\t\tset = context.getElementsByTagName(\"*\");\r\n\t}\r\n\r\n\treturn {set: set, expr: expr};\r\n};\r\n\r\nSizzle.filter = function(expr, set, inplace, not){\r\n\tvar old = expr, result = [], curLoop = set, match, anyFound,\r\n\t\tisXMLFilter = set && set[0] && Sizzle.isXML(set[0]);\r\n\r\n\twhile ( expr && set.length ) {\r\n\t\tfor ( var type in Expr.filter ) {\r\n\t\t\tif ( (match = Expr.leftMatch[ type ].exec( expr )) != null && match[2] ) {\r\n\t\t\t\tvar filter = Expr.filter[ type ], found, item, left = match[1];\r\n\t\t\t\tanyFound = false;\r\n\r\n\t\t\t\tmatch.splice(1,1);\r\n\r\n\t\t\t\tif ( left.substr( left.length - 1 ) === \"\\\\\" ) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( curLoop === result ) {\r\n\t\t\t\t\tresult = [];\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( Expr.preFilter[ type ] ) {\r\n\t\t\t\t\tmatch = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );\r\n\r\n\t\t\t\t\tif ( !match ) {\r\n\t\t\t\t\t\tanyFound = found = true;\r\n\t\t\t\t\t} else if ( match === true ) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( match ) {\r\n\t\t\t\t\tfor ( var i = 0; (item = curLoop[i]) != null; i++ ) {\r\n\t\t\t\t\t\tif ( item ) {\r\n\t\t\t\t\t\t\tfound = filter( item, match, i, curLoop );\r\n\t\t\t\t\t\t\tvar pass = not ^ !!found;\r\n\r\n\t\t\t\t\t\t\tif ( inplace && found != null ) {\r\n\t\t\t\t\t\t\t\tif ( pass ) {\r\n\t\t\t\t\t\t\t\t\tanyFound = true;\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tcurLoop[i] = false;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else if ( pass ) {\r\n\t\t\t\t\t\t\t\tresult.push( item );\r\n\t\t\t\t\t\t\t\tanyFound = true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( found !== undefined ) {\r\n\t\t\t\t\tif ( !inplace ) {\r\n\t\t\t\t\t\tcurLoop = result;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\texpr = expr.replace( Expr.match[ type ], \"\" );\r\n\r\n\t\t\t\t\tif ( !anyFound ) {\r\n\t\t\t\t\t\treturn [];\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Improper expression\r\n\t\tif ( expr === old ) {\r\n\t\t\tif ( anyFound == null ) {\r\n\t\t\t\tSizzle.error( expr );\r\n\t\t\t} else {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\told = expr;\r\n\t}\r\n\r\n\treturn curLoop;\r\n};\r\n\r\nSizzle.error = function( msg ) {\r\n\tthrow \"Syntax error, unrecognized expression: \" + msg;\r\n};\r\n\r\nvar Expr = Sizzle.selectors = {\r\n\torder: [ \"ID\", \"NAME\", \"TAG\" ],\r\n\tmatch: {\r\n\t\tID: /#((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)/,\r\n\t\tCLASS: /\\.((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)/,\r\n\t\tNAME: /\\[name=['\"]*((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)['\"]*\\]/,\r\n\t\tATTR: /\\[\\s*((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)\\s*(?:(\\S?=)\\s*(['\"]*)(.*?)\\3|)\\s*\\]/,\r\n\t\tTAG: /^((?:[\\w\\u00c0-\\uFFFF\\*\\-]|\\\\.)+)/,\r\n\t\tCHILD: /:(only|nth|last|first)-child(?:\\((even|odd|[\\dn+\\-]*)\\))?/,\r\n\t\tPOS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\\((\\d*)\\))?(?=[^\\-]|$)/,\r\n\t\tPSEUDO: /:((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)(?:\\((['\"]?)((?:\\([^\\)]+\\)|[^\\(\\)]*)+)\\2\\))?/\r\n\t},\r\n\tleftMatch: {},\r\n\tattrMap: {\r\n\t\t\"class\": \"className\",\r\n\t\t\"for\": \"htmlFor\"\r\n\t},\r\n\tattrHandle: {\r\n\t\thref: function(elem){\r\n\t\t\treturn elem.getAttribute(\"href\");\r\n\t\t}\r\n\t},\r\n\trelative: {\r\n\t\t\"+\": function(checkSet, part){\r\n\t\t\tvar isPartStr = typeof part === \"string\",\r\n\t\t\t\tisTag = isPartStr && !/\\W/.test(part),\r\n\t\t\t\tisPartStrNotTag = isPartStr && !isTag;\r\n\r\n\t\t\tif ( isTag ) {\r\n\t\t\t\tpart = part.toLowerCase();\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {\r\n\t\t\t\tif ( (elem = checkSet[i]) ) {\r\n\t\t\t\t\twhile ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {}\r\n\r\n\t\t\t\t\tcheckSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ?\r\n\t\t\t\t\t\telem || false :\r\n\t\t\t\t\t\telem === part;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif ( isPartStrNotTag ) {\r\n\t\t\t\tSizzle.filter( part, checkSet, true );\r\n\t\t\t}\r\n\t\t},\r\n\t\t\">\": function(checkSet, part){\r\n\t\t\tvar isPartStr = typeof part === \"string\",\r\n\t\t\t\telem, i = 0, l = checkSet.length;\r\n\r\n\t\t\tif ( isPartStr && !/\\W/.test(part) ) {\r\n\t\t\t\tpart = part.toLowerCase();\r\n\r\n\t\t\t\tfor ( ; i < l; i++ ) {\r\n\t\t\t\t\telem = checkSet[i];\r\n\t\t\t\t\tif ( elem ) {\r\n\t\t\t\t\t\tvar parent = elem.parentNode;\r\n\t\t\t\t\t\tcheckSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tfor ( ; i < l; i++ ) {\r\n\t\t\t\t\telem = checkSet[i];\r\n\t\t\t\t\tif ( elem ) {\r\n\t\t\t\t\t\tcheckSet[i] = isPartStr ?\r\n\t\t\t\t\t\t\telem.parentNode :\r\n\t\t\t\t\t\t\telem.parentNode === part;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( isPartStr ) {\r\n\t\t\t\t\tSizzle.filter( part, checkSet, true );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\t\"\": function(checkSet, part, isXML){\r\n\t\t\tvar doneName = done++, checkFn = dirCheck, nodeCheck;\r\n\r\n\t\t\tif ( typeof part === \"string\" && !/\\W/.test(part) ) {\r\n\t\t\t\tpart = part.toLowerCase();\r\n\t\t\t\tnodeCheck = part;\r\n\t\t\t\tcheckFn = dirNodeCheck;\r\n\t\t\t}\r\n\r\n\t\t\tcheckFn(\"parentNode\", part, doneName, checkSet, nodeCheck, isXML);\r\n\t\t},\r\n\t\t\"~\": function(checkSet, part, isXML){\r\n\t\t\tvar doneName = done++, checkFn = dirCheck, nodeCheck;\r\n\r\n\t\t\tif ( typeof part === \"string\" && !/\\W/.test(part) ) {\r\n\t\t\t\tpart = part.toLowerCase();\r\n\t\t\t\tnodeCheck = part;\r\n\t\t\t\tcheckFn = dirNodeCheck;\r\n\t\t\t}\r\n\r\n\t\t\tcheckFn(\"previousSibling\", part, doneName, checkSet, nodeCheck, isXML);\r\n\t\t}\r\n\t},\r\n\tfind: {\r\n\t\tID: function(match, context, isXML){\r\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && !isXML ) {\r\n\t\t\t\tvar m = context.getElementById(match[1]);\r\n\t\t\t\treturn m ? [m] : [];\r\n\t\t\t}\r\n\t\t},\r\n\t\tNAME: function(match, context){\r\n\t\t\tif ( typeof context.getElementsByName !== \"undefined\" ) {\r\n\t\t\t\tvar ret = [], results = context.getElementsByName(match[1]);\r\n\r\n\t\t\t\tfor ( var i = 0, l = results.length; i < l; i++ ) {\r\n\t\t\t\t\tif ( results[i].getAttribute(\"name\") === match[1] ) {\r\n\t\t\t\t\t\tret.push( results[i] );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn ret.length === 0 ? null : ret;\r\n\t\t\t}\r\n\t\t},\r\n\t\tTAG: function(match, context){\r\n\t\t\treturn context.getElementsByTagName(match[1]);\r\n\t\t}\r\n\t},\r\n\tpreFilter: {\r\n\t\tCLASS: function(match, curLoop, inplace, result, not, isXML){\r\n\t\t\tmatch = \" \" + match[1].replace(/\\\\/g, \"\") + \" \";\r\n\r\n\t\t\tif ( isXML ) {\r\n\t\t\t\treturn match;\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {\r\n\t\t\t\tif ( elem ) {\r\n\t\t\t\t\tif ( not ^ (elem.className && (\" \" + elem.className + \" \").replace(/[\\t\\n]/g, \" \").indexOf(match) >= 0) ) {\r\n\t\t\t\t\t\tif ( !inplace ) {\r\n\t\t\t\t\t\t\tresult.push( elem );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if ( inplace ) {\r\n\t\t\t\t\t\tcurLoop[i] = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn false;\r\n\t\t},\r\n\t\tID: function(match){\r\n\t\t\treturn match[1].replace(/\\\\/g, \"\");\r\n\t\t},\r\n\t\tTAG: function(match, curLoop){\r\n\t\t\treturn match[1].toLowerCase();\r\n\t\t},\r\n\t\tCHILD: function(match){\r\n\t\t\tif ( match[1] === \"nth\" ) {\r\n\t\t\t\t// parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'\r\n\t\t\t\tvar test = /(-?)(\\d*)n((?:\\+|-)?\\d*)/.exec(\r\n\t\t\t\t\tmatch[2] === \"even\" && \"2n\" || match[2] === \"odd\" && \"2n+1\" ||\r\n\t\t\t\t\t!/\\D/.test( match[2] ) && \"0n+\" + match[2] || match[2]);\r\n\r\n\t\t\t\t// calculate the numbers (first)n+(last) including if they are negative\r\n\t\t\t\tmatch[2] = (test[1] + (test[2] || 1)) - 0;\r\n\t\t\t\tmatch[3] = test[3] - 0;\r\n\t\t\t}\r\n\r\n\t\t\t// TODO: Move to normal caching system\r\n\t\t\tmatch[0] = done++;\r\n\r\n\t\t\treturn match;\r\n\t\t},\r\n\t\tATTR: function(match, curLoop, inplace, result, not, isXML){\r\n\t\t\tvar name = match[1].replace(/\\\\/g, \"\");\r\n\r\n\t\t\tif ( !isXML && Expr.attrMap[name] ) {\r\n\t\t\t\tmatch[1] = Expr.attrMap[name];\r\n\t\t\t}\r\n\r\n\t\t\tif ( match[2] === \"~=\" ) {\r\n\t\t\t\tmatch[4] = \" \" + match[4] + \" \";\r\n\t\t\t}\r\n\r\n\t\t\treturn match;\r\n\t\t},\r\n\t\tPSEUDO: function(match, curLoop, inplace, result, not){\r\n\t\t\tif ( match[1] === \"not\" ) {\r\n\t\t\t\t// If we're dealing with a complex expression, or a simple one\r\n\t\t\t\tif ( ( chunker.exec(match[3]) || \"\" ).length > 1 || /^\\w/.test(match[3]) ) {\r\n\t\t\t\t\tmatch[3] = Sizzle(match[3], null, null, curLoop);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);\r\n\t\t\t\t\tif ( !inplace ) {\r\n\t\t\t\t\t\tresult.push.apply( result, ret );\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t} else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\treturn match;\r\n\t\t},\r\n\t\tPOS: function(match){\r\n\t\t\tmatch.unshift( true );\r\n\t\t\treturn match;\r\n\t\t}\r\n\t},\r\n\tfilters: {\r\n\t\tenabled: function(elem){\r\n\t\t\treturn elem.disabled === false && elem.type !== \"hidden\";\r\n\t\t},\r\n\t\tdisabled: function(elem){\r\n\t\t\treturn elem.disabled === true;\r\n\t\t},\r\n\t\tchecked: function(elem){\r\n\t\t\treturn elem.checked === true;\r\n\t\t},\r\n\t\tselected: function(elem){\r\n\t\t\t// Accessing this property makes selected-by-default\r\n\t\t\t// options in Safari work properly\r\n\t\t\telem.parentNode.selectedIndex;\r\n\t\t\treturn elem.selected === true;\r\n\t\t},\r\n\t\tparent: function(elem){\r\n\t\t\treturn !!elem.firstChild;\r\n\t\t},\r\n\t\tempty: function(elem){\r\n\t\t\treturn !elem.firstChild;\r\n\t\t},\r\n\t\thas: function(elem, i, match){\r\n\t\t\treturn !!Sizzle( match[3], elem ).length;\r\n\t\t},\r\n\t\theader: function(elem){\r\n\t\t\treturn (/h\\d/i).test( elem.nodeName );\r\n\t\t},\r\n\t\ttext: function(elem){\r\n\t\t\treturn \"text\" === elem.type;\r\n\t\t},\r\n\t\tradio: function(elem){\r\n\t\t\treturn \"radio\" === elem.type;\r\n\t\t},\r\n\t\tcheckbox: function(elem){\r\n\t\t\treturn \"checkbox\" === elem.type;\r\n\t\t},\r\n\t\tfile: function(elem){\r\n\t\t\treturn \"file\" === elem.type;\r\n\t\t},\r\n\t\tpassword: function(elem){\r\n\t\t\treturn \"password\" === elem.type;\r\n\t\t},\r\n\t\tsubmit: function(elem){\r\n\t\t\treturn \"submit\" === elem.type;\r\n\t\t},\r\n\t\timage: function(elem){\r\n\t\t\treturn \"image\" === elem.type;\r\n\t\t},\r\n\t\treset: function(elem){\r\n\t\t\treturn \"reset\" === elem.type;\r\n\t\t},\r\n\t\tbutton: function(elem){\r\n\t\t\treturn \"button\" === elem.type || elem.nodeName.toLowerCase() === \"button\";\r\n\t\t},\r\n\t\tinput: function(elem){\r\n\t\t\treturn (/input|select|textarea|button/i).test(elem.nodeName);\r\n\t\t}\r\n\t},\r\n\tsetFilters: {\r\n\t\tfirst: function(elem, i){\r\n\t\t\treturn i === 0;\r\n\t\t},\r\n\t\tlast: function(elem, i, match, array){\r\n\t\t\treturn i === array.length - 1;\r\n\t\t},\r\n\t\teven: function(elem, i){\r\n\t\t\treturn i % 2 === 0;\r\n\t\t},\r\n\t\todd: function(elem, i){\r\n\t\t\treturn i % 2 === 1;\r\n\t\t},\r\n\t\tlt: function(elem, i, match){\r\n\t\t\treturn i < match[3] - 0;\r\n\t\t},\r\n\t\tgt: function(elem, i, match){\r\n\t\t\treturn i > match[3] - 0;\r\n\t\t},\r\n\t\tnth: function(elem, i, match){\r\n\t\t\treturn match[3] - 0 === i;\r\n\t\t},\r\n\t\teq: function(elem, i, match){\r\n\t\t\treturn match[3] - 0 === i;\r\n\t\t}\r\n\t},\r\n\tfilter: {\r\n\t\tPSEUDO: function(elem, match, i, array){\r\n\t\t\tvar name = match[1], filter = Expr.filters[ name ];\r\n\r\n\t\t\tif ( filter ) {\r\n\t\t\t\treturn filter( elem, i, match, array );\r\n\t\t\t} else if ( name === \"contains\" ) {\r\n\t\t\t\treturn (elem.textContent || elem.innerText || Sizzle.getText([ elem ]) || \"\").indexOf(match[3]) >= 0;\r\n\t\t\t} else if ( name === \"not\" ) {\r\n\t\t\t\tvar not = match[3];\r\n\r\n\t\t\t\tfor ( var j = 0, l = not.length; j < l; j++ ) {\r\n\t\t\t\t\tif ( not[j] === elem ) {\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn true;\r\n\t\t\t} else {\r\n\t\t\t\tSizzle.error( \"Syntax error, unrecognized expression: \" + name );\r\n\t\t\t}\r\n\t\t},\r\n\t\tCHILD: function(elem, match){\r\n\t\t\tvar type = match[1], node = elem;\r\n\t\t\tswitch (type) {\r\n\t\t\t\tcase 'only':\r\n\t\t\t\tcase 'first':\r\n\t\t\t\t\twhile ( (node = node.previousSibling) )\t {\r\n\t\t\t\t\t\tif ( node.nodeType === 1 ) {\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( type === \"first\" ) {\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnode = elem;\r\n\t\t\t\tcase 'last':\r\n\t\t\t\t\twhile ( (node = node.nextSibling) )\t {\r\n\t\t\t\t\t\tif ( node.nodeType === 1 ) {\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn true;\r\n\t\t\t\tcase 'nth':\r\n\t\t\t\t\tvar first = match[2], last = match[3];\r\n\r\n\t\t\t\t\tif ( first === 1 && last === 0 ) {\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvar doneName = match[0],\r\n\t\t\t\t\t\tparent = elem.parentNode;\r\n\r\n\t\t\t\t\tif ( parent && (parent.sizcache !== doneName || !elem.nodeIndex) ) {\r\n\t\t\t\t\t\tvar count = 0;\r\n\t\t\t\t\t\tfor ( node = parent.firstChild; node; node = node.nextSibling ) {\r\n\t\t\t\t\t\t\tif ( node.nodeType === 1 ) {\r\n\t\t\t\t\t\t\t\tnode.nodeIndex = ++count;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tparent.sizcache = doneName;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvar diff = elem.nodeIndex - last;\r\n\t\t\t\t\tif ( first === 0 ) {\r\n\t\t\t\t\t\treturn diff === 0;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn ( diff % first === 0 && diff / first >= 0 );\r\n\t\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tID: function(elem, match){\r\n\t\t\treturn elem.nodeType === 1 && elem.getAttribute(\"id\") === match;\r\n\t\t},\r\n\t\tTAG: function(elem, match){\r\n\t\t\treturn (match === \"*\" && elem.nodeType === 1) || elem.nodeName.toLowerCase() === match;\r\n\t\t},\r\n\t\tCLASS: function(elem, match){\r\n\t\t\treturn (\" \" + (elem.className || elem.getAttribute(\"class\")) + \" \")\r\n\t\t\t\t.indexOf( match ) > -1;\r\n\t\t},\r\n\t\tATTR: function(elem, match){\r\n\t\t\tvar name = match[1],\r\n\t\t\t\tresult = Expr.attrHandle[ name ] ?\r\n\t\t\t\t\tExpr.attrHandle[ name ]( elem ) :\r\n\t\t\t\t\telem[ name ] != null ?\r\n\t\t\t\t\t\telem[ name ] :\r\n\t\t\t\t\t\telem.getAttribute( name ),\r\n\t\t\t\tvalue = result + \"\",\r\n\t\t\t\ttype = match[2],\r\n\t\t\t\tcheck = match[4];\r\n\r\n\t\t\treturn result == null ?\r\n\t\t\t\ttype === \"!=\" :\r\n\t\t\t\ttype === \"=\" ?\r\n\t\t\t\tvalue === check :\r\n\t\t\t\ttype === \"*=\" ?\r\n\t\t\t\tvalue.indexOf(check) >= 0 :\r\n\t\t\t\ttype === \"~=\" ?\r\n\t\t\t\t(\" \" + value + \" \").indexOf(check) >= 0 :\r\n\t\t\t\t!check ?\r\n\t\t\t\tvalue && result !== false :\r\n\t\t\t\ttype === \"!=\" ?\r\n\t\t\t\tvalue !== check :\r\n\t\t\t\ttype === \"^=\" ?\r\n\t\t\t\tvalue.indexOf(check) === 0 :\r\n\t\t\t\ttype === \"$=\" ?\r\n\t\t\t\tvalue.substr(value.length - check.length) === check :\r\n\t\t\t\ttype === \"|=\" ?\r\n\t\t\t\tvalue === check || value.substr(0, check.length + 1) === check + \"-\" :\r\n\t\t\t\tfalse;\r\n\t\t},\r\n\t\tPOS: function(elem, match, i, array){\r\n\t\t\tvar name = match[2], filter = Expr.setFilters[ name ];\r\n\r\n\t\t\tif ( filter ) {\r\n\t\t\t\treturn filter( elem, i, match, array );\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n};\r\n\r\nvar origPOS = Expr.match.POS,\r\n\tfescape = function(all, num){\r\n\t\treturn \"\\\\\" + (num - 0 + 1);\r\n\t};\r\n\r\nfor ( var type in Expr.match ) {\r\n\tExpr.match[ type ] = new RegExp( Expr.match[ type ].source + (/(?![^\\[]*\\])(?![^\\(]*\\))/.source) );\r\n\tExpr.leftMatch[ type ] = new RegExp( /(^(?:.|\\r|\\n)*?)/.source + Expr.match[ type ].source.replace(/\\\\(\\d+)/g, fescape) );\r\n}\r\n\r\nvar makeArray = function(array, results) {\r\n\tarray = Array.prototype.slice.call( array, 0 );\r\n\r\n\tif ( results ) {\r\n\t\tresults.push.apply( results, array );\r\n\t\treturn results;\r\n\t}\r\n\r\n\treturn array;\r\n};\r\n\r\n// Perform a simple check to determine if the browser is capable of\r\n// converting a NodeList to an array using builtin methods.\r\n// Also verifies that the returned array holds DOM nodes\r\n// (which is not the case in the Blackberry browser)\r\ntry {\r\n\tArray.prototype.slice.call( document.documentElement.childNodes, 0 )[0].nodeType;\r\n\r\n// Provide a fallback method if it does not work\r\n} catch(e){\r\n\tmakeArray = function(array, results) {\r\n\t\tvar ret = results || [], i = 0;\r\n\r\n\t\tif ( toString.call(array) === \"[object Array]\" ) {\r\n\t\t\tArray.prototype.push.apply( ret, array );\r\n\t\t} else {\r\n\t\t\tif ( typeof array.length === \"number\" ) {\r\n\t\t\t\tfor ( var l = array.length; i < l; i++ ) {\r\n\t\t\t\t\tret.push( array[i] );\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tfor ( ; array[i]; i++ ) {\r\n\t\t\t\t\tret.push( array[i] );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn ret;\r\n\t};\r\n}\r\n\r\nvar sortOrder;\r\n\r\nif ( document.documentElement.compareDocumentPosition ) {\r\n\tsortOrder = function( a, b ) {\r\n\t\tif ( !a.compareDocumentPosition || !b.compareDocumentPosition ) {\r\n\t\t\tif ( a == b ) {\r\n\t\t\t\thasDuplicate = true;\r\n\t\t\t}\r\n\t\t\treturn a.compareDocumentPosition ? -1 : 1;\r\n\t\t}\r\n\r\n\t\tvar ret = a.compareDocumentPosition(b) & 4 ? -1 : a === b ? 0 : 1;\r\n\t\tif ( ret === 0 ) {\r\n\t\t\thasDuplicate = true;\r\n\t\t}\r\n\t\treturn ret;\r\n\t};\r\n} else if ( \"sourceIndex\" in document.documentElement ) {\r\n\tsortOrder = function( a, b ) {\r\n\t\tif ( !a.sourceIndex || !b.sourceIndex ) {\r\n\t\t\tif ( a == b ) {\r\n\t\t\t\thasDuplicate = true;\r\n\t\t\t}\r\n\t\t\treturn a.sourceIndex ? -1 : 1;\r\n\t\t}\r\n\r\n\t\tvar ret = a.sourceIndex - b.sourceIndex;\r\n\t\tif ( ret === 0 ) {\r\n\t\t\thasDuplicate = true;\r\n\t\t}\r\n\t\treturn ret;\r\n\t};\r\n} else if ( document.createRange ) {\r\n\tsortOrder = function( a, b ) {\r\n\t\tif ( !a.ownerDocument || !b.ownerDocument ) {\r\n\t\t\tif ( a == b ) {\r\n\t\t\t\thasDuplicate = true;\r\n\t\t\t}\r\n\t\t\treturn a.ownerDocument ? -1 : 1;\r\n\t\t}\r\n\r\n\t\tvar aRange = a.ownerDocument.createRange(), bRange = b.ownerDocument.createRange();\r\n\t\taRange.setStart(a, 0);\r\n\t\taRange.setEnd(a, 0);\r\n\t\tbRange.setStart(b, 0);\r\n\t\tbRange.setEnd(b, 0);\r\n\t\tvar ret = aRange.compareBoundaryPoints(Range.START_TO_END, bRange);\r\n\t\tif ( ret === 0 ) {\r\n\t\t\thasDuplicate = true;\r\n\t\t}\r\n\t\treturn ret;\r\n\t};\r\n}\r\n\r\n// Utility function for retreiving the text value of an array of DOM nodes\r\nSizzle.getText = function( elems ) {\r\n\tvar ret = \"\", elem;\r\n\r\n\tfor ( var i = 0; elems[i]; i++ ) {\r\n\t\telem = elems[i];\r\n\r\n\t\t// Get the text from text nodes and CDATA nodes\r\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 4 ) {\r\n\t\t\tret += elem.nodeValue;\r\n\r\n\t\t// Traverse everything else, except comment nodes\r\n\t\t} else if ( elem.nodeType !== 8 ) {\r\n\t\t\tret += Sizzle.getText( elem.childNodes );\r\n\t\t}\r\n\t}\r\n\r\n\treturn ret;\r\n};\r\n\r\n// Check to see if the browser returns elements by name when\r\n// querying by getElementById (and provide a workaround)\r\n(function(){\r\n\t// We're going to inject a fake input element with a specified name\r\n\tvar form = document.createElement(\"div\"),\r\n\t\tid = \"script\" + (new Date()).getTime();\r\n\tform.innerHTML = \"<a name='\" + id + \"'/>\";\r\n\r\n\t// Inject it into the root element, check its status, and remove it quickly\r\n\tvar root = document.documentElement;\r\n\troot.insertBefore( form, root.firstChild );\r\n\r\n\t// The workaround has to do additional checks after a getElementById\r\n\t// Which slows things down for other browsers (hence the branching)\r\n\tif ( document.getElementById( id ) ) {\r\n\t\tExpr.find.ID = function(match, context, isXML){\r\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && !isXML ) {\r\n\t\t\t\tvar m = context.getElementById(match[1]);\r\n\t\t\t\treturn m ? m.id === match[1] || typeof m.getAttributeNode !== \"undefined\" && m.getAttributeNode(\"id\").nodeValue === match[1] ? [m] : undefined : [];\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tExpr.filter.ID = function(elem, match){\r\n\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" && elem.getAttributeNode(\"id\");\r\n\t\t\treturn elem.nodeType === 1 && node && node.nodeValue === match;\r\n\t\t};\r\n\t}\r\n\r\n\troot.removeChild( form );\r\n\troot = form = null; // release memory in IE\r\n})();\r\n\r\n(function(){\r\n\t// Check to see if the browser returns only elements\r\n\t// when doing getElementsByTagName(\"*\")\r\n\r\n\t// Create a fake element\r\n\tvar div = document.createElement(\"div\");\r\n\tdiv.appendChild( document.createComment(\"\") );\r\n\r\n\t// Make sure no comments are found\r\n\tif ( div.getElementsByTagName(\"*\").length > 0 ) {\r\n\t\tExpr.find.TAG = function(match, context){\r\n\t\t\tvar results = context.getElementsByTagName(match[1]);\r\n\r\n\t\t\t// Filter out possible comments\r\n\t\t\tif ( match[1] === \"*\" ) {\r\n\t\t\t\tvar tmp = [];\r\n\r\n\t\t\t\tfor ( var i = 0; results[i]; i++ ) {\r\n\t\t\t\t\tif ( results[i].nodeType === 1 ) {\r\n\t\t\t\t\t\ttmp.push( results[i] );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tresults = tmp;\r\n\t\t\t}\r\n\r\n\t\t\treturn results;\r\n\t\t};\r\n\t}\r\n\r\n\t// Check to see if an attribute returns normalized href attributes\r\n\tdiv.innerHTML = \"<a href='#'></a>\";\r\n\tif ( div.firstChild && typeof div.firstChild.getAttribute !== \"undefined\" &&\r\n\t\t\tdiv.firstChild.getAttribute(\"href\") !== \"#\" ) {\r\n\t\tExpr.attrHandle.href = function(elem){\r\n\t\t\treturn elem.getAttribute(\"href\", 2);\r\n\t\t};\r\n\t}\r\n\r\n\tdiv = null; // release memory in IE\r\n})();\r\n\r\nif ( document.querySelectorAll ) {\r\n\t(function(){\r\n\t\tvar oldSizzle = Sizzle, div = document.createElement(\"div\");\r\n\t\tdiv.innerHTML = \"<p class='TEST'></p>\";\r\n\r\n\t\t// Safari can't handle uppercase or unicode characters when\r\n\t\t// in quirks mode.\r\n\t\tif ( div.querySelectorAll && div.querySelectorAll(\".TEST\").length === 0 ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tSizzle = function(query, context, extra, seed){\r\n\t\t\tcontext = context || document;\r\n\r\n\t\t\t// Only use querySelectorAll on non-XML documents\r\n\t\t\t// (ID selectors don't work in non-HTML documents)\r\n\t\t\tif ( !seed && context.nodeType === 9 && !Sizzle.isXML(context) ) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\treturn makeArray( context.querySelectorAll(query), extra );\r\n\t\t\t\t} catch(e){}\r\n\t\t\t}\r\n\r\n\t\t\treturn oldSizzle(query, context, extra, seed);\r\n\t\t};\r\n\r\n\t\tfor ( var prop in oldSizzle ) {\r\n\t\t\tSizzle[ prop ] = oldSizzle[ prop ];\r\n\t\t}\r\n\r\n\t\tdiv = null; // release memory in IE\r\n\t})();\r\n}\r\n\r\n(function(){\r\n\tvar div = document.createElement(\"div\");\r\n\r\n\tdiv.innerHTML = \"<div class='test e'></div><div class='test'></div>\";\r\n\r\n\t// Opera can't find a second classname (in 9.6)\r\n\t// Also, make sure that getElementsByClassName actually exists\r\n\tif ( !div.getElementsByClassName || div.getElementsByClassName(\"e\").length === 0 ) {\r\n\t\treturn;\r\n\t}\r\n\r\n\t// Safari caches class attributes, doesn't catch changes (in 3.2)\r\n\tdiv.lastChild.className = \"e\";\r\n\r\n\tif ( div.getElementsByClassName(\"e\").length === 1 ) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tExpr.order.splice(1, 0, \"CLASS\");\r\n\tExpr.find.CLASS = function(match, context, isXML) {\r\n\t\tif ( typeof context.getElementsByClassName !== \"undefined\" && !isXML ) {\r\n\t\t\treturn context.getElementsByClassName(match[1]);\r\n\t\t}\r\n\t};\r\n\r\n\tdiv = null; // release memory in IE\r\n})();\r\n\r\nfunction dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {\r\n\tfor ( var i = 0, l = checkSet.length; i < l; i++ ) {\r\n\t\tvar elem = checkSet[i];\r\n\t\tif ( elem ) {\r\n\t\t\telem = elem[dir];\r\n\t\t\tvar match = false;\r\n\r\n\t\t\twhile ( elem ) {\r\n\t\t\t\tif ( elem.sizcache === doneName ) {\r\n\t\t\t\t\tmatch = checkSet[elem.sizset];\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( elem.nodeType === 1 && !isXML ){\r\n\t\t\t\t\telem.sizcache = doneName;\r\n\t\t\t\t\telem.sizset = i;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( elem.nodeName.toLowerCase() === cur ) {\r\n\t\t\t\t\tmatch = elem;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\telem = elem[dir];\r\n\t\t\t}\r\n\r\n\t\t\tcheckSet[i] = match;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {\r\n\tfor ( var i = 0, l = checkSet.length; i < l; i++ ) {\r\n\t\tvar elem = checkSet[i];\r\n\t\tif ( elem ) {\r\n\t\t\telem = elem[dir];\r\n\t\t\tvar match = false;\r\n\r\n\t\t\twhile ( elem ) {\r\n\t\t\t\tif ( elem.sizcache === doneName ) {\r\n\t\t\t\t\tmatch = checkSet[elem.sizset];\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( elem.nodeType === 1 ) {\r\n\t\t\t\t\tif ( !isXML ) {\r\n\t\t\t\t\t\telem.sizcache = doneName;\r\n\t\t\t\t\t\telem.sizset = i;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( typeof cur !== \"string\" ) {\r\n\t\t\t\t\t\tif ( elem === cur ) {\r\n\t\t\t\t\t\t\tmatch = true;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {\r\n\t\t\t\t\t\tmatch = elem;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\telem = elem[dir];\r\n\t\t\t}\r\n\r\n\t\t\tcheckSet[i] = match;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nSizzle.contains = document.compareDocumentPosition ? function(a, b){\r\n\treturn !!(a.compareDocumentPosition(b) & 16);\r\n} : function(a, b){\r\n\treturn a !== b && (a.contains ? a.contains(b) : true);\r\n};\r\n\r\nSizzle.isXML = function(elem){\r\n\t// documentElement is verified for cases where it doesn't yet exist\r\n\t// (such as loading iframes in IE - #4833)\r\n\tvar documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;\r\n\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\r\n};\r\n\r\nvar posProcess = function(selector, context){\r\n\tvar tmpSet = [], later = \"\", match,\r\n\t\troot = context.nodeType ? [context] : context;\r\n\r\n\t// Position selectors must be done after the filter\r\n\t// And so must :not(positional) so we move all PSEUDOs to the end\r\n\twhile ( (match = Expr.match.PSEUDO.exec( selector )) ) {\r\n\t\tlater += match[0];\r\n\t\tselector = selector.replace( Expr.match.PSEUDO, \"\" );\r\n\t}\r\n\r\n\tselector = Expr.relative[selector] ? selector + \"*\" : selector;\r\n\r\n\tfor ( var i = 0, l = root.length; i < l; i++ ) {\r\n\t\tSizzle( selector, root[i], tmpSet );\r\n\t}\r\n\r\n\treturn Sizzle.filter( later, tmpSet );\r\n};\r\n\r\n// EXPOSE\r\n\r\nwindow.tinymce.dom.Sizzle = Sizzle;\r\n\r\n})();\r\n\r\n\r\n(function(tinymce) {\r\n\t// Shorten names\r\n\tvar each = tinymce.each, DOM = tinymce.DOM, isIE = tinymce.isIE, isWebKit = tinymce.isWebKit, Event;\r\n\r\n\ttinymce.create('tinymce.dom.EventUtils', {\r\n\t\tEventUtils : function() {\r\n\t\t\tthis.inits = [];\r\n\t\t\tthis.events = [];\r\n\t\t},\r\n\r\n\t\tadd : function(o, n, f, s) {\r\n\t\t\tvar cb, t = this, el = t.events, r;\r\n\r\n\t\t\tif (n instanceof Array) {\r\n\t\t\t\tr = [];\r\n\r\n\t\t\t\teach(n, function(n) {\r\n\t\t\t\t\tr.push(t.add(o, n, f, s));\r\n\t\t\t\t});\r\n\r\n\t\t\t\treturn r;\r\n\t\t\t}\r\n\r\n\t\t\t// Handle array\r\n\t\t\tif (o && o.hasOwnProperty && o instanceof Array) {\r\n\t\t\t\tr = [];\r\n\r\n\t\t\t\teach(o, function(o) {\r\n\t\t\t\t\to = DOM.get(o);\r\n\t\t\t\t\tr.push(t.add(o, n, f, s));\r\n\t\t\t\t});\r\n\r\n\t\t\t\treturn r;\r\n\t\t\t}\r\n\r\n\t\t\to = DOM.get(o);\r\n\r\n\t\t\tif (!o)\r\n\t\t\t\treturn;\r\n\r\n\t\t\t// Setup event callback\r\n\t\t\tcb = function(e) {\r\n\t\t\t\t// Is all events disabled\r\n\t\t\t\tif (t.disabled)\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\te = e || window.event;\r\n\r\n\t\t\t\t// Patch in target, preventDefault and stopPropagation in IE it's W3C valid\r\n\t\t\t\tif (e && isIE) {\r\n\t\t\t\t\tif (!e.target)\r\n\t\t\t\t\t\te.target = e.srcElement;\r\n\r\n\t\t\t\t\t// Patch in preventDefault, stopPropagation methods for W3C compatibility\r\n\t\t\t\t\ttinymce.extend(e, t._stoppers);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!s)\r\n\t\t\t\t\treturn f(e);\r\n\r\n\t\t\t\treturn f.call(s, e);\r\n\t\t\t};\r\n\r\n\t\t\tif (n == 'unload') {\r\n\t\t\t\ttinymce.unloads.unshift({func : cb});\r\n\t\t\t\treturn cb;\r\n\t\t\t}\r\n\r\n\t\t\tif (n == 'init') {\r\n\t\t\t\tif (t.domLoaded)\r\n\t\t\t\t\tcb();\r\n\t\t\t\telse\r\n\t\t\t\t\tt.inits.push(cb);\r\n\r\n\t\t\t\treturn cb;\r\n\t\t\t}\r\n\r\n\t\t\t// Store away listener reference\r\n\t\t\tel.push({\r\n\t\t\t\tobj : o,\r\n\t\t\t\tname : n,\r\n\t\t\t\tfunc : f,\r\n\t\t\t\tcfunc : cb,\r\n\t\t\t\tscope : s\r\n\t\t\t});\r\n\r\n\t\t\tt._add(o, n, cb);\r\n\r\n\t\t\treturn f;\r\n\t\t},\r\n\r\n\t\tremove : function(o, n, f) {\r\n\t\t\tvar t = this, a = t.events, s = false, r;\r\n\r\n\t\t\t// Handle array\r\n\t\t\tif (o && o.hasOwnProperty && o instanceof Array) {\r\n\t\t\t\tr = [];\r\n\r\n\t\t\t\teach(o, function(o) {\r\n\t\t\t\t\to = DOM.get(o);\r\n\t\t\t\t\tr.push(t.remove(o, n, f));\r\n\t\t\t\t});\r\n\r\n\t\t\t\treturn r;\r\n\t\t\t}\r\n\r\n\t\t\to = DOM.get(o);\r\n\r\n\t\t\teach(a, function(e, i) {\r\n\t\t\t\tif (e.obj == o && e.name == n && (!f || (e.func == f || e.cfunc == f))) {\r\n\t\t\t\t\ta.splice(i, 1);\r\n\t\t\t\t\tt._remove(o, n, e.cfunc);\r\n\t\t\t\t\ts = true;\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\treturn s;\r\n\t\t},\r\n\r\n\t\tclear : function(o) {\r\n\t\t\tvar t = this, a = t.events, i, e;\r\n\r\n\t\t\tif (o) {\r\n\t\t\t\to = DOM.get(o);\r\n\r\n\t\t\t\tfor (i = a.length - 1; i >= 0; i--) {\r\n\t\t\t\t\te = a[i];\r\n\r\n\t\t\t\t\tif (e.obj === o) {\r\n\t\t\t\t\t\tt._remove(e.obj, e.name, e.cfunc);\r\n\t\t\t\t\t\te.obj = e.cfunc = null;\r\n\t\t\t\t\t\ta.splice(i, 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tcancel : function(e) {\r\n\t\t\tif (!e)\r\n\t\t\t\treturn false;\r\n\r\n\t\t\tthis.stop(e);\r\n\r\n\t\t\treturn this.prevent(e);\r\n\t\t},\r\n\r\n\t\tstop : function(e) {\r\n\t\t\tif (e.stopPropagation)\r\n\t\t\t\te.stopPropagation();\r\n\t\t\telse\r\n\t\t\t\te.cancelBubble = true;\r\n\r\n\t\t\treturn false;\r\n\t\t},\r\n\r\n\t\tprevent : function(e) {\r\n\t\t\tif (e.preventDefault)\r\n\t\t\t\te.preventDefault();\r\n\t\t\telse\r\n\t\t\t\te.returnValue = false;\r\n\r\n\t\t\treturn false;\r\n\t\t},\r\n\r\n\t\tdestroy : function() {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\teach(t.events, function(e, i) {\r\n\t\t\t\tt._remove(e.obj, e.name, e.cfunc);\r\n\t\t\t\te.obj = e.cfunc = null;\r\n\t\t\t});\r\n\r\n\t\t\tt.events = [];\r\n\t\t\tt = null;\r\n\t\t},\r\n\r\n\t\t_add : function(o, n, f) {\r\n\t\t\tif (o.attachEvent)\r\n\t\t\t\to.attachEvent('on' + n, f);\r\n\t\t\telse if (o.addEventListener)\r\n\t\t\t\to.addEventListener(n, f, false);\r\n\t\t\telse\r\n\t\t\t\to['on' + n] = f;\r\n\t\t},\r\n\r\n\t\t_remove : function(o, n, f) {\r\n\t\t\tif (o) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tif (o.detachEvent)\r\n\t\t\t\t\t\to.detachEvent('on' + n, f);\r\n\t\t\t\t\telse if (o.removeEventListener)\r\n\t\t\t\t\t\to.removeEventListener(n, f, false);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\to['on' + n] = null;\r\n\t\t\t\t} catch (ex) {\r\n\t\t\t\t\t// Might fail with permission denined on IE so we just ignore that\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_pageInit : function(win) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\t// Keep it from running more than once\r\n\t\t\tif (t.domLoaded)\r\n\t\t\t\treturn;\r\n\r\n\t\t\tt.domLoaded = true;\r\n\r\n\t\t\teach(t.inits, function(c) {\r\n\t\t\t\tc();\r\n\t\t\t});\r\n\r\n\t\t\tt.inits = [];\r\n\t\t},\r\n\r\n\t\t_wait : function(win) {\r\n\t\t\tvar t = this, doc = win.document;\r\n\r\n\t\t\t// No need since the document is already loaded\r\n\t\t\tif (win.tinyMCE_GZ && tinyMCE_GZ.loaded) {\r\n\t\t\t\tt.domLoaded = 1;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// Use IE method\r\n\t\t\tif (doc.attachEvent) {\r\n\t\t\t\tdoc.attachEvent(\"onreadystatechange\", function() {\r\n\t\t\t\t\tif (doc.readyState === \"complete\") {\r\n\t\t\t\t\t\tdoc.detachEvent(\"onreadystatechange\", arguments.callee);\r\n\t\t\t\t\t\tt._pageInit(win);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\tif (doc.documentElement.doScroll && win == win.top) {\r\n\t\t\t\t\t(function() {\r\n\t\t\t\t\t\tif (t.domLoaded)\r\n\t\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t// If IE is used, use the trick by Diego Perini licensed under MIT by request to the author.\r\n\t\t\t\t\t\t\t// http://javascript.nwbox.com/IEContentLoaded/\r\n\t\t\t\t\t\t\tdoc.documentElement.doScroll(\"left\");\r\n\t\t\t\t\t\t} catch (ex) {\r\n\t\t\t\t\t\t\tsetTimeout(arguments.callee, 0);\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tt._pageInit(win);\r\n\t\t\t\t\t})();\r\n\t\t\t\t}\r\n\t\t\t} else if (doc.addEventListener) {\r\n\t\t\t\tt._add(win, 'DOMContentLoaded', function() {\r\n\t\t\t\t\tt._pageInit(win);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tt._add(win, 'load', function() {\r\n\t\t\t\tt._pageInit(win);\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t_stoppers : {\r\n\t\t\tpreventDefault : function() {\r\n\t\t\t\tthis.returnValue = false;\r\n\t\t\t},\r\n\r\n\t\t\tstopPropagation : function() {\r\n\t\t\t\tthis.cancelBubble = true;\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\r\n\tEvent = tinymce.dom.Event = new tinymce.dom.EventUtils();\r\n\r\n\t// Dispatch DOM content loaded event for IE and Safari\r\n\tEvent._wait(window);\r\n\r\n\ttinymce.addUnload(function() {\r\n\t\tEvent.destroy();\r\n\t});\r\n})(tinymce);\r\n\r\n(function(tinymce) {\r\n\ttinymce.dom.Element = function(id, settings) {\r\n\t\tvar t = this, dom, el;\r\n\r\n\t\tt.settings = settings = settings || {};\r\n\t\tt.id = id;\r\n\t\tt.dom = dom = settings.dom || tinymce.DOM;\r\n\r\n\t\t// Only IE leaks DOM references, this is a lot faster\r\n\t\tif (!tinymce.isIE)\r\n\t\t\tel = dom.get(t.id);\r\n\r\n\t\ttinymce.each(\r\n\t\t\t\t('getPos,getRect,getParent,add,setStyle,getStyle,setStyles,' +\r\n\t\t\t\t'setAttrib,setAttribs,getAttrib,addClass,removeClass,' +\r\n\t\t\t\t'hasClass,getOuterHTML,setOuterHTML,remove,show,hide,' +\r\n\t\t\t\t'isHidden,setHTML,get').split(/,/)\r\n\t\t\t, function(k) {\r\n\t\t\t\tt[k] = function() {\r\n\t\t\t\t\tvar a = [id], i;\r\n\r\n\t\t\t\t\tfor (i = 0; i < arguments.length; i++)\r\n\t\t\t\t\t\ta.push(arguments[i]);\r\n\r\n\t\t\t\t\ta = dom[k].apply(dom, a);\r\n\t\t\t\t\tt.update(k);\r\n\r\n\t\t\t\t\treturn a;\r\n\t\t\t\t};\r\n\t\t});\r\n\r\n\t\ttinymce.extend(t, {\r\n\t\t\ton : function(n, f, s) {\r\n\t\t\t\treturn tinymce.dom.Event.add(t.id, n, f, s);\r\n\t\t\t},\r\n\r\n\t\t\tgetXY : function() {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tx : parseInt(t.getStyle('left')),\r\n\t\t\t\t\ty : parseInt(t.getStyle('top'))\r\n\t\t\t\t};\r\n\t\t\t},\r\n\r\n\t\t\tgetSize : function() {\r\n\t\t\t\tvar n = dom.get(t.id);\r\n\r\n\t\t\t\treturn {\r\n\t\t\t\t\tw : parseInt(t.getStyle('width') || n.clientWidth),\r\n\t\t\t\t\th : parseInt(t.getStyle('height') || n.clientHeight)\r\n\t\t\t\t};\r\n\t\t\t},\r\n\r\n\t\t\tmoveTo : function(x, y) {\r\n\t\t\t\tt.setStyles({left : x, top : y});\r\n\t\t\t},\r\n\r\n\t\t\tmoveBy : function(x, y) {\r\n\t\t\t\tvar p = t.getXY();\r\n\r\n\t\t\t\tt.moveTo(p.x + x, p.y + y);\r\n\t\t\t},\r\n\r\n\t\t\tresizeTo : function(w, h) {\r\n\t\t\t\tt.setStyles({width : w, height : h});\r\n\t\t\t},\r\n\r\n\t\t\tresizeBy : function(w, h) {\r\n\t\t\t\tvar s = t.getSize();\r\n\r\n\t\t\t\tt.resizeTo(s.w + w, s.h + h);\r\n\t\t\t},\r\n\r\n\t\t\tupdate : function(k) {\r\n\t\t\t\tvar b;\r\n\r\n\t\t\t\tif (tinymce.isIE6 && settings.blocker) {\r\n\t\t\t\t\tk = k || '';\r\n\r\n\t\t\t\t\t// Ignore getters\r\n\t\t\t\t\tif (k.indexOf('get') === 0 || k.indexOf('has') === 0 || k.indexOf('is') === 0)\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t// Remove blocker on remove\r\n\t\t\t\t\tif (k == 'remove') {\r\n\t\t\t\t\t\tdom.remove(t.blocker);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (!t.blocker) {\r\n\t\t\t\t\t\tt.blocker = dom.uniqueId();\r\n\t\t\t\t\t\tb = dom.add(settings.container || dom.getRoot(), 'iframe', {id : t.blocker, style : 'position:absolute;', frameBorder : 0, src : 'javascript:\"\"'});\r\n\t\t\t\t\t\tdom.setStyle(b, 'opacity', 0);\r\n\t\t\t\t\t} else\r\n\t\t\t\t\t\tb = dom.get(t.blocker);\r\n\r\n\t\t\t\t\tdom.setStyles(b, {\r\n\t\t\t\t\t\tleft : t.getStyle('left', 1),\r\n\t\t\t\t\t\ttop : t.getStyle('top', 1),\r\n\t\t\t\t\t\twidth : t.getStyle('width', 1),\r\n\t\t\t\t\t\theight : t.getStyle('height', 1),\r\n\t\t\t\t\t\tdisplay : t.getStyle('display', 1),\r\n\t\t\t\t\t\tzIndex : parseInt(t.getStyle('zIndex', 1) || 0) - 1\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t};\r\n})(tinymce);\r\n\r\n(function(tinymce) {\r\n\tfunction trimNl(s) {\r\n\t\treturn s.replace(/[\\n\\r]+/g, '');\r\n\t};\r\n\r\n\t// Shorten names\r\n\tvar is = tinymce.is, isIE = tinymce.isIE, each = tinymce.each;\r\n\r\n\ttinymce.create('tinymce.dom.Selection', {\r\n\t\tSelection : function(dom, win, serializer) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\tt.dom = dom;\r\n\t\t\tt.win = win;\r\n\t\t\tt.serializer = serializer;\r\n\r\n\t\t\t// Add events\r\n\t\t\teach([\r\n\t\t\t\t'onBeforeSetContent',\r\n\r\n\t\t\t\t'onBeforeGetContent',\r\n\r\n\t\t\t\t'onSetContent',\r\n\r\n\t\t\t\t'onGetContent'\r\n\t\t\t], function(e) {\r\n\t\t\t\tt[e] = new tinymce.util.Dispatcher(t);\r\n\t\t\t});\r\n\r\n\t\t\t// No W3C Range support\r\n\t\t\tif (!t.win.getSelection)\r\n\t\t\t\tt.tridentSel = new tinymce.dom.TridentSelection(t);\r\n\r\n\t\t\tif (tinymce.isIE && dom.boxModel)\r\n\t\t\t\tthis._fixIESelection();\r\n\r\n\t\t\t// Prevent leaks\r\n\t\t\ttinymce.addUnload(t.destroy, t);\r\n\t\t},\r\n\r\n\t\tsetCursorLocation: function(node, offset) {\r\n\t\t\tvar t = this; var r = t.dom.createRng();\r\n\t\t\tr.setStart(node, offset);\r\n\t\t\tr.setEnd(node, offset);\r\n\t\t\tt.setRng(r);\r\n\t\t\tt.collapse(false);\r\n\t\t},\r\n\t\tgetContent : function(s) {\r\n\t\t\tvar t = this, r = t.getRng(), e = t.dom.create(\"body\"), se = t.getSel(), wb, wa, n;\r\n\r\n\t\t\ts = s || {};\r\n\t\t\twb = wa = '';\r\n\t\t\ts.get = true;\r\n\t\t\ts.format = s.format || 'html';\r\n\t\t\ts.forced_root_block = '';\r\n\t\t\tt.onBeforeGetContent.dispatch(t, s);\r\n\r\n\t\t\tif (s.format == 'text')\r\n\t\t\t\treturn t.isCollapsed() ? '' : (r.text || (se.toString ? se.toString() : ''));\r\n\r\n\t\t\tif (r.cloneContents) {\r\n\t\t\t\tn = r.cloneContents();\r\n\r\n\t\t\t\tif (n)\r\n\t\t\t\t\te.appendChild(n);\r\n\t\t\t} else if (is(r.item) || is(r.htmlText)) {\r\n\t\t\t\t// IE will produce invalid markup if elements are present that\r\n\t\t\t\t// it doesn't understand like custom elements or HTML5 elements.\r\n\t\t\t\t// Adding a BR in front of the contents and then remoiving it seems to fix it though.\r\n\t\t\t\te.innerHTML = '<br>' + (r.item ? r.item(0).outerHTML : r.htmlText);\r\n\t\t\t\te.removeChild(e.firstChild);\r\n\t\t\t} else\r\n\t\t\t\te.innerHTML = r.toString();\r\n\r\n\t\t\t// Keep whitespace before and after\r\n\t\t\tif (/^\\s/.test(e.innerHTML))\r\n\t\t\t\twb = ' ';\r\n\r\n\t\t\tif (/\\s+$/.test(e.innerHTML))\r\n\t\t\t\twa = ' ';\r\n\r\n\t\t\ts.getInner = true;\r\n\r\n\t\t\ts.content = t.isCollapsed() ? '' : wb + t.serializer.serialize(e, s) + wa;\r\n\t\t\tt.onGetContent.dispatch(t, s);\r\n\r\n\t\t\treturn s.content;\r\n\t\t},\r\n\r\n\t\tsetContent : function(content, args) {\r\n\t\t\tvar self = this, rng = self.getRng(), caretNode, doc = self.win.document, frag, temp;\r\n\r\n\t\t\targs = args || {format : 'html'};\r\n\t\t\targs.set = true;\r\n\t\t\tcontent = args.content = content;\r\n\r\n\t\t\t// Dispatch before set content event\r\n\t\t\tif (!args.no_events)\r\n\t\t\t\tself.onBeforeSetContent.dispatch(self, args);\r\n\r\n\t\t\tcontent = args.content;\r\n\r\n\t\t\tif (rng.insertNode) {\r\n\t\t\t\t// Make caret marker since insertNode places the caret in the beginning of text after insert\r\n\t\t\t\tcontent += '<span id=\"__caret\">_</span>';\r\n\r\n\t\t\t\t// Delete and insert new node\r\n\t\t\t\tif (rng.startContainer == doc && rng.endContainer == doc) {\r\n\t\t\t\t\t// WebKit will fail if the body is empty since the range is then invalid and it can't insert contents\r\n\t\t\t\t\tdoc.body.innerHTML = content;\r\n\t\t\t\t} else {\r\n\t\t\t\t\trng.deleteContents();\r\n\r\n\t\t\t\t\tif (doc.body.childNodes.length == 0) {\r\n\t\t\t\t\t\tdoc.body.innerHTML = content;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// createContextualFragment doesn't exists in IE 9 DOMRanges\r\n\t\t\t\t\t\tif (rng.createContextualFragment) {\r\n\t\t\t\t\t\t\trng.insertNode(rng.createContextualFragment(content));\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// Fake createContextualFragment call in IE 9\r\n\t\t\t\t\t\t\tfrag = doc.createDocumentFragment();\r\n\t\t\t\t\t\t\ttemp = doc.createElement('div');\r\n\r\n\t\t\t\t\t\t\tfrag.appendChild(temp);\r\n\t\t\t\t\t\t\ttemp.outerHTML = content;\r\n\r\n\t\t\t\t\t\t\trng.insertNode(frag);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Move to caret marker\r\n\t\t\t\tcaretNode = self.dom.get('__caret');\r\n\r\n\t\t\t\t// Make sure we wrap it compleatly, Opera fails with a simple select call\r\n\t\t\t\trng = doc.createRange();\r\n\t\t\t\trng.setStartBefore(caretNode);\r\n\t\t\t\trng.setEndBefore(caretNode);\r\n\t\t\t\tself.setRng(rng);\r\n\r\n\t\t\t\t// Remove the caret position\r\n\t\t\t\tself.dom.remove('__caret');\r\n\r\n\t\t\t\ttry {\r\n\t\t\t\t\tself.setRng(rng);\r\n\t\t\t\t} catch (ex) {\r\n\t\t\t\t\t// Might fail on Opera for some odd reason\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (rng.item) {\r\n\t\t\t\t\t// Delete content and get caret text selection\r\n\t\t\t\t\tdoc.execCommand('Delete', false, null);\r\n\t\t\t\t\trng = self.getRng();\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Explorer removes spaces from the beginning of pasted contents\r\n\t\t\t\tif (/^\\s+/.test(content)) {\r\n\t\t\t\t\trng.pasteHTML('<span id=\"__mce_tmp\">_</span>' + content);\r\n\t\t\t\t\tself.dom.remove('__mce_tmp');\r\n\t\t\t\t} else\r\n\t\t\t\t\trng.pasteHTML(content);\r\n\t\t\t}\r\n\r\n\t\t\t// Dispatch set content event\r\n\t\t\tif (!args.no_events)\r\n\t\t\t\tself.onSetContent.dispatch(self, args);\r\n\t\t},\r\n\r\n\t\tgetStart : function() {\r\n\t\t\tvar rng = this.getRng(), startElement, parentElement, checkRng, node;\r\n\r\n\t\t\tif (rng.duplicate || rng.item) {\r\n\t\t\t\t// Control selection, return first item\r\n\t\t\t\tif (rng.item)\r\n\t\t\t\t\treturn rng.item(0);\r\n\r\n\t\t\t\t// Get start element\r\n\t\t\t\tcheckRng = rng.duplicate();\r\n\t\t\t\tcheckRng.collapse(1);\r\n\t\t\t\tstartElement = checkRng.parentElement();\r\n\r\n\t\t\t\t// Check if range parent is inside the start element, then return the inner parent element\r\n\t\t\t\t// This will fix issues when a single element is selected, IE would otherwise return the wrong start element\r\n\t\t\t\tparentElement = node = rng.parentElement();\r\n\t\t\t\twhile (node = node.parentNode) {\r\n\t\t\t\t\tif (node == startElement) {\r\n\t\t\t\t\t\tstartElement = parentElement;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn startElement;\r\n\t\t\t} else {\r\n\t\t\t\tstartElement = rng.startContainer;\r\n\r\n\t\t\t\tif (startElement.nodeType == 1 && startElement.hasChildNodes())\r\n\t\t\t\t\tstartElement = startElement.childNodes[Math.min(startElement.childNodes.length - 1, rng.startOffset)];\r\n\r\n\t\t\t\tif (startElement && startElement.nodeType == 3)\r\n\t\t\t\t\treturn startElement.parentNode;\r\n\r\n\t\t\t\treturn startElement;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tgetEnd : function() {\r\n\t\t\tvar t = this, r = t.getRng(), e, eo;\r\n\r\n\t\t\tif (r.duplicate || r.item) {\r\n\t\t\t\tif (r.item)\r\n\t\t\t\t\treturn r.item(0);\r\n\r\n\t\t\t\tr = r.duplicate();\r\n\t\t\t\tr.collapse(0);\r\n\t\t\t\te = r.parentElement();\r\n\r\n\t\t\t\tif (e && e.nodeName == 'BODY')\r\n\t\t\t\t\treturn e.lastChild || e;\r\n\r\n\t\t\t\treturn e;\r\n\t\t\t} else {\r\n\t\t\t\te = r.endContainer;\r\n\t\t\t\teo = r.endOffset;\r\n\r\n\t\t\t\tif (e.nodeType == 1 && e.hasChildNodes())\r\n\t\t\t\t\te = e.childNodes[eo > 0 ? eo - 1 : eo];\r\n\r\n\t\t\t\tif (e && e.nodeType == 3)\r\n\t\t\t\t\treturn e.parentNode;\r\n\r\n\t\t\t\treturn e;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tgetBookmark : function(type, normalized) {\r\n\t\t\tvar t = this, dom = t.dom, rng, rng2, id, collapsed, name, element, index, chr = '\\uFEFF', styles;\r\n\r\n\t\t\tfunction findIndex(name, element) {\r\n\t\t\t\tvar index = 0;\r\n\r\n\t\t\t\teach(dom.select(name), function(node, i) {\r\n\t\t\t\t\tif (node == element)\r\n\t\t\t\t\t\tindex = i;\r\n\t\t\t\t});\r\n\r\n\t\t\t\treturn index;\r\n\t\t\t};\r\n\r\n\t\t\tif (type == 2) {\r\n\t\t\t\tfunction getLocation() {\r\n\t\t\t\t\tvar rng = t.getRng(true), root = dom.getRoot(), bookmark = {};\r\n\r\n\t\t\t\t\tfunction getPoint(rng, start) {\r\n\t\t\t\t\t\tvar container = rng[start ? 'startContainer' : 'endContainer'],\r\n\t\t\t\t\t\t\toffset = rng[start ? 'startOffset' : 'endOffset'], point = [], node, childNodes, after = 0;\r\n\r\n\t\t\t\t\t\tif (container.nodeType == 3) {\r\n\t\t\t\t\t\t\tif (normalized) {\r\n\t\t\t\t\t\t\t\tfor (node = container.previousSibling; node && node.nodeType == 3; node = node.previousSibling)\r\n\t\t\t\t\t\t\t\t\toffset += node.nodeValue.length;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tpoint.push(offset);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tchildNodes = container.childNodes;\r\n\r\n\t\t\t\t\t\t\tif (offset >= childNodes.length && childNodes.length) {\r\n\t\t\t\t\t\t\t\tafter = 1;\r\n\t\t\t\t\t\t\t\toffset = Math.max(0, childNodes.length - 1);\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tpoint.push(t.dom.nodeIndex(childNodes[offset], normalized) + after);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tfor (; container && container != root; container = container.parentNode)\r\n\t\t\t\t\t\t\tpoint.push(t.dom.nodeIndex(container, normalized));\r\n\r\n\t\t\t\t\t\treturn point;\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tbookmark.start = getPoint(rng, true);\r\n\r\n\t\t\t\t\tif (!t.isCollapsed())\r\n\t\t\t\t\t\tbookmark.end = getPoint(rng);\r\n\r\n\t\t\t\t\treturn bookmark;\r\n\t\t\t\t};\r\n\r\n\t\t\t\tif (t.tridentSel)\r\n\t\t\t\t\treturn t.tridentSel.getBookmark(type);\r\n\r\n\t\t\t\treturn getLocation();\r\n\t\t\t}\r\n\r\n\t\t\t// Handle simple range\r\n\t\t\tif (type)\r\n\t\t\t\treturn {rng : t.getRng()};\r\n\r\n\t\t\trng = t.getRng();\r\n\t\t\tid = dom.uniqueId();\r\n\t\t\tcollapsed = tinyMCE.activeEditor.selection.isCollapsed();\r\n\t\t\tstyles = 'overflow:hidden;line-height:0px';\r\n\r\n\t\t\t// Explorer method\r\n\t\t\tif (rng.duplicate || rng.item) {\r\n\t\t\t\t// Text selection\r\n\t\t\t\tif (!rng.item) {\r\n\t\t\t\t\trng2 = rng.duplicate();\r\n\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\t// Insert start marker\r\n\t\t\t\t\t\trng.collapse();\r\n\t\t\t\t\t\trng.pasteHTML('<span data-mce-type=\"bookmark\" id=\"' + id + '_start\" style=\"' + styles + '\">' + chr + '</span>');\r\n\r\n\t\t\t\t\t\t// Insert end marker\r\n\t\t\t\t\t\tif (!collapsed) {\r\n\t\t\t\t\t\t\trng2.collapse(false);\r\n\r\n\t\t\t\t\t\t\t// Detect the empty space after block elements in IE and move the end back one character <p></p>] becomes <p>]</p>\r\n\t\t\t\t\t\t\trng.moveToElementText(rng2.parentElement());\r\n\t\t\t\t\t\t\tif (rng.compareEndPoints('StartToEnd', rng2) == 0)\r\n\t\t\t\t\t\t\t\trng2.move('character', -1);\r\n\r\n\t\t\t\t\t\t\trng2.pasteHTML('<span data-mce-type=\"bookmark\" id=\"' + id + '_end\" style=\"' + styles + '\">' + chr + '</span>');\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} catch (ex) {\r\n\t\t\t\t\t\t// IE might throw unspecified error so lets ignore it\r\n\t\t\t\t\t\treturn null;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Control selection\r\n\t\t\t\t\telement = rng.item(0);\r\n\t\t\t\t\tname = element.nodeName;\r\n\r\n\t\t\t\t\treturn {name : name, index : findIndex(name, element)};\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\telement = t.getNode();\r\n\t\t\t\tname = element.nodeName;\r\n\t\t\t\tif (name == 'IMG')\r\n\t\t\t\t\treturn {name : name, index : findIndex(name, element)};\r\n\r\n\t\t\t\t// W3C method\r\n\t\t\t\trng2 = rng.cloneRange();\r\n\r\n\t\t\t\t// Insert end marker\r\n\t\t\t\tif (!collapsed) {\r\n\t\t\t\t\trng2.collapse(false);\r\n\t\t\t\t\trng2.insertNode(dom.create('span', {'data-mce-type' : \"bookmark\", id : id + '_end', style : styles}, chr));\r\n\t\t\t\t}\r\n\r\n\t\t\t\trng.collapse(true);\r\n\t\t\t\trng.insertNode(dom.create('span', {'data-mce-type' : \"bookmark\", id : id + '_start', style : styles}, chr));\r\n\t\t\t}\r\n\r\n\t\t\tt.moveToBookmark({id : id, keep : 1});\r\n\r\n\t\t\treturn {id : id};\r\n\t\t},\r\n\r\n\t\tmoveToBookmark : function(bookmark) {\r\n\t\t\tvar t = this, dom = t.dom, marker1, marker2, rng, root, startContainer, endContainer, startOffset, endOffset;\r\n\r\n\t\t\tif (bookmark) {\r\n\t\t\t\tif (bookmark.start) {\r\n\t\t\t\t\trng = dom.createRng();\r\n\t\t\t\t\troot = dom.getRoot();\r\n\r\n\t\t\t\t\tfunction setEndPoint(start) {\r\n\t\t\t\t\t\tvar point = bookmark[start ? 'start' : 'end'], i, node, offset, children;\r\n\r\n\t\t\t\t\t\tif (point) {\r\n\t\t\t\t\t\t\toffset = point[0];\r\n\r\n\t\t\t\t\t\t\t// Find container node\r\n\t\t\t\t\t\t\tfor (node = root, i = point.length - 1; i >= 1; i--) {\r\n\t\t\t\t\t\t\t\tchildren = node.childNodes;\r\n\r\n\t\t\t\t\t\t\t\tif (point[i] > children.length - 1)\r\n\t\t\t\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t\t\t\tnode = children[point[i]];\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// Move text offset to best suitable location\r\n\t\t\t\t\t\t\tif (node.nodeType === 3)\r\n\t\t\t\t\t\t\t\toffset = Math.min(point[0], node.nodeValue.length);\r\n\r\n\t\t\t\t\t\t\t// Move element offset to best suitable location\r\n\t\t\t\t\t\t\tif (node.nodeType === 1)\r\n\t\t\t\t\t\t\t\toffset = Math.min(point[0], node.childNodes.length);\r\n\r\n\t\t\t\t\t\t\t// Set offset within container node\r\n\t\t\t\t\t\t\tif (start)\r\n\t\t\t\t\t\t\t\trng.setStart(node, offset);\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\trng.setEnd(node, offset);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tif (t.tridentSel)\r\n\t\t\t\t\t\treturn t.tridentSel.moveToBookmark(bookmark);\r\n\r\n\t\t\t\t\tif (setEndPoint(true) && setEndPoint()) {\r\n\t\t\t\t\t\tt.setRng(rng);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (bookmark.id) {\r\n\t\t\t\t\tfunction restoreEndPoint(suffix) {\r\n\t\t\t\t\t\tvar marker = dom.get(bookmark.id + '_' + suffix), node, idx, next, prev, keep = bookmark.keep;\r\n\r\n\t\t\t\t\t\tif (marker) {\r\n\t\t\t\t\t\t\tnode = marker.parentNode;\r\n\r\n\t\t\t\t\t\t\tif (suffix == 'start') {\r\n\t\t\t\t\t\t\t\tif (!keep) {\r\n\t\t\t\t\t\t\t\t\tidx = dom.nodeIndex(marker);\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tnode = marker.firstChild;\r\n\t\t\t\t\t\t\t\t\tidx = 1;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tstartContainer = endContainer = node;\r\n\t\t\t\t\t\t\t\tstartOffset = endOffset = idx;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tif (!keep) {\r\n\t\t\t\t\t\t\t\t\tidx = dom.nodeIndex(marker);\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tnode = marker.firstChild;\r\n\t\t\t\t\t\t\t\t\tidx = 1;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tendContainer = node;\r\n\t\t\t\t\t\t\t\tendOffset = idx;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif (!keep) {\r\n\t\t\t\t\t\t\t\tprev = marker.previousSibling;\r\n\t\t\t\t\t\t\t\tnext = marker.nextSibling;\r\n\r\n\t\t\t\t\t\t\t\t// Remove all marker text nodes\r\n\t\t\t\t\t\t\t\teach(tinymce.grep(marker.childNodes), function(node) {\r\n\t\t\t\t\t\t\t\t\tif (node.nodeType == 3)\r\n\t\t\t\t\t\t\t\t\t\tnode.nodeValue = node.nodeValue.replace(/\\uFEFF/g, '');\r\n\t\t\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t\t\t// Remove marker but keep children if for example contents where inserted into the marker\r\n\t\t\t\t\t\t\t\t// Also remove duplicated instances of the marker for example by a split operation or by WebKit auto split on paste feature\r\n\t\t\t\t\t\t\t\twhile (marker = dom.get(bookmark.id + '_' + suffix))\r\n\t\t\t\t\t\t\t\t\tdom.remove(marker, 1);\r\n\r\n\t\t\t\t\t\t\t\t// If siblings are text nodes then merge them unless it's Opera since it some how removes the node\r\n\t\t\t\t\t\t\t\t// and we are sniffing since adding a lot of detection code for a browser with 3% of the market isn't worth the effort. Sorry, Opera but it's just a fact\r\n\t\t\t\t\t\t\t\tif (prev && next && prev.nodeType == next.nodeType && prev.nodeType == 3 && !tinymce.isOpera) {\r\n\t\t\t\t\t\t\t\t\tidx = prev.nodeValue.length;\r\n\t\t\t\t\t\t\t\t\tprev.appendData(next.nodeValue);\r\n\t\t\t\t\t\t\t\t\tdom.remove(next);\r\n\r\n\t\t\t\t\t\t\t\t\tif (suffix == 'start') {\r\n\t\t\t\t\t\t\t\t\t\tstartContainer = endContainer = prev;\r\n\t\t\t\t\t\t\t\t\t\tstartOffset = endOffset = idx;\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\tendContainer = prev;\r\n\t\t\t\t\t\t\t\t\t\tendOffset = idx;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tfunction addBogus(node) {\r\n\t\t\t\t\t\t// Adds a bogus BR element for empty block elements or just a space on IE since it renders BR elements incorrectly\r\n\t\t\t\t\t\tif (dom.isBlock(node) && !node.innerHTML)\r\n\t\t\t\t\t\t\tnode.innerHTML = !isIE ? '<br data-mce-bogus=\"1\" />' : ' ';\r\n\r\n\t\t\t\t\t\treturn node;\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\t// Restore start/end points\r\n\t\t\t\t\trestoreEndPoint('start');\r\n\t\t\t\t\trestoreEndPoint('end');\r\n\r\n\t\t\t\t\tif (startContainer) {\r\n\t\t\t\t\t\trng = dom.createRng();\r\n\t\t\t\t\t\trng.setStart(addBogus(startContainer), startOffset);\r\n\t\t\t\t\t\trng.setEnd(addBogus(endContainer), endOffset);\r\n\t\t\t\t\t\tt.setRng(rng);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (bookmark.name) {\r\n\t\t\t\t\tt.select(dom.select(bookmark.name)[bookmark.index]);\r\n\t\t\t\t} else if (bookmark.rng)\r\n\t\t\t\t\tt.setRng(bookmark.rng);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tselect : function(node, content) {\r\n\t\t\tvar t = this, dom = t.dom, rng = dom.createRng(), idx;\r\n\r\n\t\t\tif (node) {\r\n\t\t\t\tidx = dom.nodeIndex(node);\r\n\t\t\t\trng.setStart(node.parentNode, idx);\r\n\t\t\t\trng.setEnd(node.parentNode, idx + 1);\r\n\r\n\t\t\t\t// Find first/last text node or BR element\r\n\t\t\t\tif (content) {\r\n\t\t\t\t\tfunction setPoint(node, start) {\r\n\t\t\t\t\t\tvar walker = new tinymce.dom.TreeWalker(node, node);\r\n\r\n\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\t// Text node\r\n\t\t\t\t\t\t\tif (node.nodeType == 3 && tinymce.trim(node.nodeValue).length != 0) {\r\n\t\t\t\t\t\t\t\tif (start)\r\n\t\t\t\t\t\t\t\t\trng.setStart(node, 0);\r\n\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\trng.setEnd(node, node.nodeValue.length);\r\n\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// BR element\r\n\t\t\t\t\t\t\tif (node.nodeName == 'BR') {\r\n\t\t\t\t\t\t\t\tif (start)\r\n\t\t\t\t\t\t\t\t\trng.setStartBefore(node);\r\n\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\trng.setEndBefore(node);\r\n\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} while (node = (start ? walker.next() : walker.prev()));\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tsetPoint(node, 1);\r\n\t\t\t\t\tsetPoint(node);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tt.setRng(rng);\r\n\t\t\t}\r\n\r\n\t\t\treturn node;\r\n\t\t},\r\n\r\n\t\tisCollapsed : function() {\r\n\t\t\tvar t = this, r = t.getRng(), s = t.getSel();\r\n\r\n\t\t\tif (!r || r.item)\r\n\t\t\t\treturn false;\r\n\r\n\t\t\tif (r.compareEndPoints)\r\n\t\t\t\treturn r.compareEndPoints('StartToEnd', r) === 0;\r\n\r\n\t\t\treturn !s || r.collapsed;\r\n\t\t},\r\n\r\n\t\tcollapse : function(to_start) {\r\n\t\t\tvar self = this, rng = self.getRng(), node;\r\n\r\n\t\t\t// Control range on IE\r\n\t\t\tif (rng.item) {\r\n\t\t\t\tnode = rng.item(0);\r\n\t\t\t\trng = self.win.document.body.createTextRange();\r\n\t\t\t\trng.moveToElementText(node);\r\n\t\t\t}\r\n\r\n\t\t\trng.collapse(!!to_start);\r\n\t\t\tself.setRng(rng);\r\n\t\t},\r\n\r\n\t\tgetSel : function() {\r\n\t\t\tvar t = this, w = this.win;\r\n\r\n\t\t\treturn w.getSelection ? w.getSelection() : w.document.selection;\r\n\t\t},\r\n\r\n\t\tgetRng : function(w3c) {\r\n\t\t\tvar t = this, s, r, elm, doc = t.win.document;\r\n\r\n\t\t\t// Found tridentSel object then we need to use that one\r\n\t\t\tif (w3c && t.tridentSel)\r\n\t\t\t\treturn t.tridentSel.getRangeAt(0);\r\n\r\n\t\t\ttry {\r\n\t\t\t\tif (s = t.getSel())\r\n\t\t\t\t\tr = s.rangeCount > 0 ? s.getRangeAt(0) : (s.createRange ? s.createRange() : doc.createRange());\r\n\t\t\t} catch (ex) {\r\n\t\t\t\t// IE throws unspecified error here if TinyMCE is placed in a frame/iframe\r\n\t\t\t}\r\n\r\n\t\t\t// We have W3C ranges and it's IE then fake control selection since IE9 doesn't handle that correctly yet\r\n\t\t\tif (tinymce.isIE && r && r.setStart && doc.selection.createRange().item) {\r\n\t\t\t\telm = doc.selection.createRange().item(0);\r\n\t\t\t\tr = doc.createRange();\r\n\t\t\t\tr.setStartBefore(elm);\r\n\t\t\t\tr.setEndAfter(elm);\r\n\t\t\t}\r\n\r\n\t\t\t// No range found then create an empty one\r\n\t\t\t// This can occur when the editor is placed in a hidden container element on Gecko\r\n\t\t\t// Or on IE when there was an exception\r\n\t\t\tif (!r)\r\n\t\t\t\tr = doc.createRange ? doc.createRange() : doc.body.createTextRange();\r\n\r\n\t\t\tif (t.selectedRange && t.explicitRange) {\r\n\t\t\t\tif (r.compareBoundaryPoints(r.START_TO_START, t.selectedRange) === 0 && r.compareBoundaryPoints(r.END_TO_END, t.selectedRange) === 0) {\r\n\t\t\t\t\t// Safari, Opera and Chrome only ever select text which causes the range to change.\r\n\t\t\t\t\t// This lets us use the originally set range if the selection hasn't been changed by the user.\r\n\t\t\t\t\tr = t.explicitRange;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tt.selectedRange = null;\r\n\t\t\t\t\tt.explicitRange = null;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn r;\r\n\t\t},\r\n\r\n\t\tsetRng : function(r) {\r\n\t\t\tvar s, t = this;\r\n\r\n\t\t\tif (!t.tridentSel) {\r\n\t\t\t\ts = t.getSel();\r\n\r\n\t\t\t\tif (s) {\r\n\t\t\t\t\tt.explicitRange = r;\r\n\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\ts.removeAllRanges();\r\n\t\t\t\t\t} catch (ex) {\r\n\t\t\t\t\t\t// IE9 might throw errors here don't know why\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ts.addRange(r);\r\n\t\t\t\t\tt.selectedRange = s.getRangeAt(0);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t// Is W3C Range\r\n\t\t\t\tif (r.cloneRange) {\r\n\t\t\t\t\tt.tridentSel.addRange(r);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Is IE specific range\r\n\t\t\t\ttry {\r\n\t\t\t\t\tr.select();\r\n\t\t\t\t} catch (ex) {\r\n\t\t\t\t\t// Needed for some odd IE bug #1843306\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tsetNode : function(n) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\tt.setContent(t.dom.getOuterHTML(n));\r\n\r\n\t\t\treturn n;\r\n\t\t},\r\n\r\n\t\tgetNode : function() {\r\n\t\t\tvar t = this, rng = t.getRng(), sel = t.getSel(), elm, start = rng.startContainer, end = rng.endContainer;\r\n\r\n\t\t\t// Range maybe lost after the editor is made visible again\r\n\t\t\tif (!rng)\r\n\t\t\t\treturn t.dom.getRoot();\r\n\r\n\t\t\tif (rng.setStart) {\r\n\t\t\t\telm = rng.commonAncestorContainer;\r\n\r\n\t\t\t\t// Handle selection a image or other control like element such as anchors\r\n\t\t\t\tif (!rng.collapsed) {\r\n\t\t\t\t\tif (rng.startContainer == rng.endContainer) {\r\n\t\t\t\t\t\tif (rng.endOffset - rng.startOffset < 2) {\r\n\t\t\t\t\t\t\tif (rng.startContainer.hasChildNodes())\r\n\t\t\t\t\t\t\t\telm = rng.startContainer.childNodes[rng.startOffset];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// If the anchor node is a element instead of a text node then return this element\r\n\t\t\t\t\t//if (tinymce.isWebKit && sel.anchorNode && sel.anchorNode.nodeType == 1)\r\n\t\t\t\t\t//\treturn sel.anchorNode.childNodes[sel.anchorOffset];\r\n\r\n\t\t\t\t\t// Handle cases where the selection is immediately wrapped around a node and return that node instead of it's parent.\r\n\t\t\t\t\t// This happens when you double click an underlined word in FireFox.\r\n\t\t\t\t\tif (start.nodeType === 3 && end.nodeType === 3) {\r\n\t\t\t\t\t\tfunction skipEmptyTextNodes(n, forwards) {\r\n\t\t\t\t\t\t\tvar orig = n;\r\n\t\t\t\t\t\t\twhile (n && n.nodeType === 3 && n.length === 0) {\r\n\t\t\t\t\t\t\t\tn = forwards ? n.nextSibling : n.previousSibling;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn n || orig;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (start.length === rng.startOffset) {\r\n\t\t\t\t\t\t\tstart = skipEmptyTextNodes(start.nextSibling, true);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tstart = start.parentNode;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (rng.endOffset === 0) {\r\n\t\t\t\t\t\t\tend = skipEmptyTextNodes(end.previousSibling, false);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tend = end.parentNode;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (start && start === end)\r\n\t\t\t\t\t\t\treturn start;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (elm && elm.nodeType == 3)\r\n\t\t\t\t\treturn elm.parentNode;\r\n\r\n\t\t\t\treturn elm;\r\n\t\t\t}\r\n\r\n\t\t\treturn rng.item ? rng.item(0) : rng.parentElement();\r\n\t\t},\r\n\r\n\t\tgetSelectedBlocks : function(st, en) {\r\n\t\t\tvar t = this, dom = t.dom, sb, eb, n, bl = [];\r\n\r\n\t\t\tsb = dom.getParent(st || t.getStart(), dom.isBlock);\r\n\t\t\teb = dom.getParent(en || t.getEnd(), dom.isBlock);\r\n\r\n\t\t\tif (sb)\r\n\t\t\t\tbl.push(sb);\r\n\r\n\t\t\tif (sb && eb && sb != eb) {\r\n\t\t\t\tn = sb;\r\n\r\n\t\t\t\tvar walker = new tinymce.dom.TreeWalker(sb, dom.getRoot());\r\n\t\t\t\twhile ((n = walker.next()) && n != eb) {\r\n\t\t\t\t\tif (dom.isBlock(n))\r\n\t\t\t\t\t\tbl.push(n);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (eb && sb != eb)\r\n\t\t\t\tbl.push(eb);\r\n\r\n\t\t\treturn bl;\r\n\t\t},\r\n\r\n\t\tnormalize : function() {\r\n\t\t\tvar self = this, rng, normalized;\r\n\r\n\t\t\t// Normalize only on non IE browsers for now\r\n\t\t\tif (tinymce.isIE)\r\n\t\t\t\treturn;\r\n\r\n\t\t\tfunction normalizeEndPoint(start) {\r\n\t\t\t\tvar container, offset, walker, dom = self.dom, body = dom.getRoot(), node;\r\n\r\n\t\t\t\tcontainer = rng[(start ? 'start' : 'end') + 'Container'];\r\n\t\t\t\toffset = rng[(start ? 'start' : 'end') + 'Offset'];\r\n\r\n\t\t\t\t// If the container is a document move it to the body element\r\n\t\t\t\tif (container.nodeType === 9) {\r\n\t\t\t\t\tcontainer = container.body;\r\n\t\t\t\t\toffset = 0;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// If the container is body try move it into the closest text node or position\r\n\t\t\t\t// TODO: Add more logic here to handle element selection cases\r\n\t\t\t\tif (container === body) {\r\n\t\t\t\t\t// Resolve the index\r\n\t\t\t\t\tif (container.hasChildNodes()) {\r\n\t\t\t\t\t\tcontainer = container.childNodes[Math.min(!start && offset > 0 ? offset - 1 : offset, container.childNodes.length - 1)];\r\n\t\t\t\t\t\toffset = 0;\r\n\r\n\t\t\t\t\t\t// Don't walk into elements that doesn't have any child nodes like a IMG\r\n\t\t\t\t\t\tif (container.hasChildNodes()) {\r\n\t\t\t\t\t\t\t// Walk the DOM to find a text node to place the caret at or a BR\r\n\t\t\t\t\t\t\tnode = container;\r\n\t\t\t\t\t\t\twalker = new tinymce.dom.TreeWalker(container, body);\r\n\t\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\t\t// Found a text node use that position\r\n\t\t\t\t\t\t\t\tif (node.nodeType === 3) {\r\n\t\t\t\t\t\t\t\t\toffset = start ? 0 : node.nodeValue.length - 1;\r\n\t\t\t\t\t\t\t\t\tcontainer = node;\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t// Found a BR element that we can place the caret before\r\n\t\t\t\t\t\t\t\tif (node.nodeName === 'BR') {\r\n\t\t\t\t\t\t\t\t\toffset = dom.nodeIndex(node);\r\n\t\t\t\t\t\t\t\t\tcontainer = node.parentNode;\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} while (node = (start ? walker.next() : walker.prev()));\r\n\r\n\t\t\t\t\t\t\tnormalized = true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Set endpoint if it was normalized\r\n\t\t\t\tif (normalized)\r\n\t\t\t\t\trng['set' + (start ? 'Start' : 'End')](container, offset);\r\n\t\t\t};\r\n\r\n\t\t\trng = self.getRng();\r\n\r\n\t\t\t// Normalize the end points\r\n\t\t\tnormalizeEndPoint(true);\r\n\r\n\t\t\tif (rng.collapsed)\r\n\t\t\t\tnormalizeEndPoint();\r\n\r\n\t\t\t// Set the selection if it was normalized\r\n\t\t\tif (normalized) {\r\n\t\t\t\t//console.log(self.dom.dumpRng(rng));\r\n\t\t\t\tself.setRng(rng);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tdestroy : function(s) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\tt.win = null;\r\n\r\n\t\t\t// Manual destroy then remove unload handler\r\n\t\t\tif (!s)\r\n\t\t\t\ttinymce.removeUnload(t.destroy);\r\n\t\t},\r\n\r\n\t\t// IE has an issue where you can't select/move the caret by clicking outside the body if the document is in standards mode\r\n\t\t_fixIESelection : function() {\r\n\t\t\tvar dom = this.dom, doc = dom.doc, body = doc.body, started, startRng, htmlElm;\r\n\r\n\t\t\t// Make HTML element unselectable since we are going to handle selection by hand\r\n\t\t\tdoc.documentElement.unselectable = true;\r\n\r\n\t\t\t// Return range from point or null if it failed\r\n\t\t\tfunction rngFromPoint(x, y) {\r\n\t\t\t\tvar rng = body.createTextRange();\r\n\r\n\t\t\t\ttry {\r\n\t\t\t\t\trng.moveToPoint(x, y);\r\n\t\t\t\t} catch (ex) {\r\n\t\t\t\t\t// IE sometimes throws and exception, so lets just ignore it\r\n\t\t\t\t\trng = null;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn rng;\r\n\t\t\t};\r\n\r\n\t\t\t// Fires while the selection is changing\r\n\t\t\tfunction selectionChange(e) {\r\n\t\t\t\tvar pointRng;\r\n\r\n\t\t\t\t// Check if the button is down or not\r\n\t\t\t\tif (e.button) {\r\n\t\t\t\t\t// Create range from mouse position\r\n\t\t\t\t\tpointRng = rngFromPoint(e.x, e.y);\r\n\r\n\t\t\t\t\tif (pointRng) {\r\n\t\t\t\t\t\t// Check if pointRange is before/after selection then change the endPoint\r\n\t\t\t\t\t\tif (pointRng.compareEndPoints('StartToStart', startRng) > 0)\r\n\t\t\t\t\t\t\tpointRng.setEndPoint('StartToStart', startRng);\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tpointRng.setEndPoint('EndToEnd', startRng);\r\n\r\n\t\t\t\t\t\tpointRng.select();\r\n\t\t\t\t\t}\r\n\t\t\t\t} else\r\n\t\t\t\t\tendSelection();\r\n\t\t\t}\r\n\r\n\t\t\t// Removes listeners\r\n\t\t\tfunction endSelection() {\r\n\t\t\t\tvar rng = doc.selection.createRange();\r\n\r\n\t\t\t\t// If the range is collapsed then use the last start range\r\n\t\t\t\tif (startRng && !rng.item && rng.compareEndPoints('StartToEnd', rng) === 0)\r\n\t\t\t\t\tstartRng.select();\r\n\r\n\t\t\t\tdom.unbind(doc, 'mouseup', endSelection);\r\n\t\t\t\tdom.unbind(doc, 'mousemove', selectionChange);\r\n\t\t\t\tstartRng = started = 0;\r\n\t\t\t};\r\n\r\n\t\t\t// Detect when user selects outside BODY\r\n\t\t\tdom.bind(doc, ['mousedown', 'contextmenu'], function(e) {\r\n\t\t\t\tif (e.target.nodeName === 'HTML') {\r\n\t\t\t\t\tif (started)\r\n\t\t\t\t\t\tendSelection();\r\n\r\n\t\t\t\t\t// Detect vertical scrollbar, since IE will fire a mousedown on the scrollbar and have target set as HTML\r\n\t\t\t\t\thtmlElm = doc.documentElement;\r\n\t\t\t\t\tif (htmlElm.scrollHeight > htmlElm.clientHeight)\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\tstarted = 1;\r\n\t\t\t\t\t// Setup start position\r\n\t\t\t\t\tstartRng = rngFromPoint(e.x, e.y);\r\n\t\t\t\t\tif (startRng) {\r\n\t\t\t\t\t\t// Listen for selection change events\r\n\t\t\t\t\t\tdom.bind(doc, 'mouseup', endSelection);\r\n\t\t\t\t\t\tdom.bind(doc, 'mousemove', selectionChange);\r\n\r\n\t\t\t\t\t\tdom.win.focus();\r\n\t\t\t\t\t\tstartRng.select();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t});\r\n})(tinymce);\r\n\r\n(function(tinymce) {\r\n\ttinymce.dom.Serializer = function(settings, dom, schema) {\r\n\t\tvar onPreProcess, onPostProcess, isIE = tinymce.isIE, each = tinymce.each, htmlParser;\r\n\r\n\t\t// Support the old apply_source_formatting option\r\n\t\tif (!settings.apply_source_formatting)\r\n\t\t\tsettings.indent = false;\r\n\r\n\t\tsettings.remove_trailing_brs = true;\r\n\r\n\t\t// Default DOM and Schema if they are undefined\r\n\t\tdom = dom || tinymce.DOM;\r\n\t\tschema = schema || new tinymce.html.Schema(settings);\r\n\t\tsettings.entity_encoding = settings.entity_encoding || 'named';\r\n\r\n\t\tonPreProcess = new tinymce.util.Dispatcher(self);\r\n\r\n\t\tonPostProcess = new tinymce.util.Dispatcher(self);\r\n\r\n\t\thtmlParser = new tinymce.html.DomParser(settings, schema);\r\n\r\n\t\t// Convert move data-mce-src, data-mce-href and data-mce-style into nodes or process them if needed\r\n\t\thtmlParser.addAttributeFilter('src,href,style', function(nodes, name) {\r\n\t\t\tvar i = nodes.length, node, value, internalName = 'data-mce-' + name, urlConverter = settings.url_converter, urlConverterScope = settings.url_converter_scope, undef;\r\n\r\n\t\t\twhile (i--) {\r\n\t\t\t\tnode = nodes[i];\r\n\r\n\t\t\t\tvalue = node.attributes.map[internalName];\r\n\t\t\t\tif (value !== undef) {\r\n\t\t\t\t\t// Set external name to internal value and remove internal\r\n\t\t\t\t\tnode.attr(name, value.length > 0 ? value : null);\r\n\t\t\t\t\tnode.attr(internalName, null);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// No internal attribute found then convert the value we have in the DOM\r\n\t\t\t\t\tvalue = node.attributes.map[name];\r\n\r\n\t\t\t\t\tif (name === \"style\")\r\n\t\t\t\t\t\tvalue = dom.serializeStyle(dom.parseStyle(value), node.name);\r\n\t\t\t\t\telse if (urlConverter)\r\n\t\t\t\t\t\tvalue = urlConverter.call(urlConverterScope, value, name, node.name);\r\n\r\n\t\t\t\t\tnode.attr(name, value.length > 0 ? value : null);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// Remove internal classes mceItem<..>\r\n\t\thtmlParser.addAttributeFilter('class', function(nodes, name) {\r\n\t\t\tvar i = nodes.length, node, value;\r\n\r\n\t\t\twhile (i--) {\r\n\t\t\t\tnode = nodes[i];\r\n\t\t\t\tvalue = node.attr('class').replace(/\\s*mce(Item\\w+|Selected)\\s*/g, '');\r\n\t\t\t\tnode.attr('class', value.length > 0 ? value : null);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// Remove bookmark elements\r\n\t\thtmlParser.addAttributeFilter('data-mce-type', function(nodes, name, args) {\r\n\t\t\tvar i = nodes.length, node;\r\n\r\n\t\t\twhile (i--) {\r\n\t\t\t\tnode = nodes[i];\r\n\r\n\t\t\t\tif (node.attributes.map['data-mce-type'] === 'bookmark' && !args.cleanup)\r\n\t\t\t\t\tnode.remove();\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// Force script into CDATA sections and remove the mce- prefix also add comments around styles\r\n\t\thtmlParser.addNodeFilter('script,style', function(nodes, name) {\r\n\t\t\tvar i = nodes.length, node, value;\r\n\r\n\t\t\tfunction trim(value) {\r\n\t\t\t\treturn value.replace(/(<!--\\[CDATA\\[|\\]\\]-->)/g, '\\n')\r\n\t\t\t\t\t\t.replace(/^[\\r\\n]*|[\\r\\n]*$/g, '')\r\n\t\t\t\t\t\t.replace(/^\\s*(\\/\\/\\s*<!--|\\/\\/\\s*<!\\[CDATA\\[|<!--|<!\\[CDATA\\[)[\\r\\n]*/g, '')\r\n\t\t\t\t\t\t.replace(/\\s*(\\/\\/\\s*\\]\\]>|\\/\\/\\s*-->|\\]\\]>|-->|\\]\\]-->)\\s*$/g, '');\r\n\t\t\t};\r\n\r\n\t\t\twhile (i--) {\r\n\t\t\t\tnode = nodes[i];\r\n\t\t\t\tvalue = node.firstChild ? node.firstChild.value : '';\r\n\r\n\t\t\t\tif (name === \"script\") {\r\n\t\t\t\t\t// Remove mce- prefix from script elements\r\n\t\t\t\t\tnode.attr('type', (node.attr('type') || 'text/javascript').replace(/^mce\\-/, ''));\r\n\r\n\t\t\t\t\tif (value.length > 0)\r\n\t\t\t\t\t\tnode.firstChild.value = '// <![CDATA[\\n' + trim(value) + '\\n// ]]>';\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (value.length > 0)\r\n\t\t\t\t\t\tnode.firstChild.value = '<!--\\n' + trim(value) + '\\n-->';\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// Convert comments to cdata and handle protected comments\r\n\t\thtmlParser.addNodeFilter('#comment', function(nodes, name) {\r\n\t\t\tvar i = nodes.length, node;\r\n\r\n\t\t\twhile (i--) {\r\n\t\t\t\tnode = nodes[i];\r\n\r\n\t\t\t\tif (node.value.indexOf('[CDATA[') === 0) {\r\n\t\t\t\t\tnode.name = '#cdata';\r\n\t\t\t\t\tnode.type = 4;\r\n\t\t\t\t\tnode.value = node.value.replace(/^\\[CDATA\\[|\\]\\]$/g, '');\r\n\t\t\t\t} else if (node.value.indexOf('mce:protected ') === 0) {\r\n\t\t\t\t\tnode.name = \"#text\";\r\n\t\t\t\t\tnode.type = 3;\r\n\t\t\t\t\tnode.raw = true;\r\n\t\t\t\t\tnode.value = unescape(node.value).substr(14);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\thtmlParser.addNodeFilter('xml:namespace,input', function(nodes, name) {\r\n\t\t\tvar i = nodes.length, node;\r\n\r\n\t\t\twhile (i--) {\r\n\t\t\t\tnode = nodes[i];\r\n\t\t\t\tif (node.type === 7)\r\n\t\t\t\t\tnode.remove();\r\n\t\t\t\telse if (node.type === 1) {\r\n\t\t\t\t\tif (name === \"input\" && !(\"type\" in node.attributes.map))\r\n\t\t\t\t\t\tnode.attr('type', 'text');\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// Fix list elements, TODO: Replace this later\r\n\t\tif (settings.fix_list_elements) {\r\n\t\t\thtmlParser.addNodeFilter('ul,ol', function(nodes, name) {\r\n\t\t\t\tvar i = nodes.length, node, parentNode;\r\n\r\n\t\t\t\twhile (i--) {\r\n\t\t\t\t\tnode = nodes[i];\r\n\t\t\t\t\tparentNode = node.parent;\r\n\r\n\t\t\t\t\tif (parentNode.name === 'ul' || parentNode.name === 'ol') {\r\n\t\t\t\t\t\tif (node.prev && node.prev.name === 'li') {\r\n\t\t\t\t\t\t\tnode.prev.append(node);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\t// Remove internal data attributes\r\n\t\thtmlParser.addAttributeFilter('data-mce-src,data-mce-href,data-mce-style', function(nodes, name) {\r\n\t\t\tvar i = nodes.length;\r\n\r\n\t\t\twhile (i--) {\r\n\t\t\t\tnodes[i].attr(name, null);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// Return public methods\r\n\t\treturn {\r\n\t\t\tschema : schema,\r\n\r\n\t\t\taddNodeFilter : htmlParser.addNodeFilter,\r\n\r\n\t\t\taddAttributeFilter : htmlParser.addAttributeFilter,\r\n\r\n\t\t\tonPreProcess : onPreProcess,\r\n\r\n\t\t\tonPostProcess : onPostProcess,\r\n\r\n\t\t\tserialize : function(node, args) {\r\n\t\t\t\tvar impl, doc, oldDoc, htmlSerializer, content;\r\n\r\n\t\t\t\t// Explorer won't clone contents of script and style and the\r\n\t\t\t\t// selected index of select elements are cleared on a clone operation.\r\n\t\t\t\tif (isIE && dom.select('script,style,select,map').length > 0) {\r\n\t\t\t\t\tcontent = node.innerHTML;\r\n\t\t\t\t\tnode = node.cloneNode(false);\r\n\t\t\t\t\tdom.setHTML(node, content);\r\n\t\t\t\t} else\r\n\t\t\t\t\tnode = node.cloneNode(true);\r\n\r\n\t\t\t\t// Nodes needs to be attached to something in WebKit/Opera\r\n\t\t\t\t// Older builds of Opera crashes if you attach the node to an document created dynamically\r\n\t\t\t\t// and since we can't feature detect a crash we need to sniff the acutal build number\r\n\t\t\t\t// This fix will make DOM ranges and make Sizzle happy!\r\n                if (tinymce.isOpera && opera.buildNumber() >= 1767) {\r\n                    impl = node.ownerDocument.implementation;\r\n                    if (impl.createHTMLDocument) {\r\n                        // Create an empty HTML document\r\n                        doc = impl.createHTMLDocument(\"\");\r\n\r\n                        // Add the element or it's children if it's a body element to the new document\r\n                        each(node.nodeName == 'BODY' ? node.childNodes : [node], function(node) {\r\n                            doc.body.appendChild(doc.importNode(node, true));\r\n                        });\r\n\r\n                        // Grab first child or body element for serialization\r\n                        if (node.nodeName != 'BODY')\r\n                            node = doc.body.firstChild;\r\n                        else\r\n                            node = doc.body;\r\n\r\n                        // set the new document in DOMUtils so createElement etc works\r\n                        oldDoc = dom.doc;\r\n                        dom.doc = doc;\r\n                    }\r\n                }\r\n\t\t\t\targs = args || {};\r\n\t\t\t\targs.format = args.format || 'html';\r\n\r\n\t\t\t\t// Pre process\r\n\t\t\t\tif (!args.no_events) {\r\n\t\t\t\t\targs.node = node;\r\n\t\t\t\t\tonPreProcess.dispatch(self, args);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Setup serializer\r\n\t\t\t\thtmlSerializer = new tinymce.html.Serializer(settings, schema);\r\n\r\n\t\t\t\t// Parse and serialize HTML\r\n\t\t\t\targs.content = htmlSerializer.serialize(\r\n\t\t\t\t\thtmlParser.parse(args.getInner ? node.innerHTML : tinymce.trim(dom.getOuterHTML(node), args), args)\r\n\t\t\t\t);\r\n\r\n\t\t\t\t// Replace all BOM characters for now until we can find a better solution\r\n\t\t\t\tif (!args.cleanup)\r\n\t\t\t\t\targs.content = args.content.replace(/\\uFEFF|\\u200B/g, '');\r\n\r\n\t\t\t\t// Post process\r\n\t\t\t\tif (!args.no_events)\r\n\t\t\t\t\tonPostProcess.dispatch(self, args);\r\n\r\n\t\t\t\t// Restore the old document if it was changed\r\n\t\t\t\tif (oldDoc)\r\n\t\t\t\t\tdom.doc = oldDoc;\r\n\r\n\t\t\t\targs.node = null;\r\n\r\n\t\t\t\treturn args.content;\r\n\t\t\t},\r\n\r\n\t\t\taddRules : function(rules) {\r\n\t\t\t\tschema.addValidElements(rules);\r\n\t\t\t},\r\n\r\n\t\t\tsetRules : function(rules) {\r\n\t\t\t\tschema.setValidElements(rules);\r\n\t\t\t}\r\n\t\t};\r\n\t};\r\n})(tinymce);\r\n(function(tinymce) {\r\n\ttinymce.dom.ScriptLoader = function(settings) {\r\n\t\tvar QUEUED = 0,\r\n\t\t\tLOADING = 1,\r\n\t\t\tLOADED = 2,\r\n\t\t\tstates = {},\r\n\t\t\tqueue = [],\r\n\t\t\tscriptLoadedCallbacks = {},\r\n\t\t\tqueueLoadedCallbacks = [],\r\n\t\t\tloading = 0,\r\n\t\t\tundefined;\r\n\r\n\t\tfunction loadScript(url, callback) {\r\n\t\t\tvar t = this, dom = tinymce.DOM, elm, uri, loc, id;\r\n\r\n\t\t\t// Execute callback when script is loaded\r\n\t\t\tfunction done() {\r\n\t\t\t\tdom.remove(id);\r\n\r\n\t\t\t\tif (elm)\r\n\t\t\t\t\telm.onreadystatechange = elm.onload = elm = null;\r\n\r\n\t\t\t\tcallback();\r\n\t\t\t};\r\n\r\n\t\t\tfunction error() {\r\n\t\t\t\t// Report the error so it's easier for people to spot loading errors\r\n\t\t\t\tif (typeof(console) !== \"undefined\" && console.log)\r\n\t\t\t\t\tconsole.log(\"Failed to load: \" + url);\r\n\r\n\t\t\t\t// We can't mark it as done if there is a load error since\r\n\t\t\t\t// A) We don't want to produce 404 errors on the server and\r\n\t\t\t\t// B) the onerror event won't fire on all browsers.\r\n\t\t\t\t// done();\r\n\t\t\t};\r\n\r\n\t\t\tid = dom.uniqueId();\r\n\r\n\t\t\tif (tinymce.isIE6) {\r\n\t\t\t\turi = new tinymce.util.URI(url);\r\n\t\t\t\tloc = location;\r\n\r\n\t\t\t\t// If script is from same domain and we\r\n\t\t\t\t// use IE 6 then use XHR since it's more reliable\r\n\t\t\t\tif (uri.host == loc.hostname && uri.port == loc.port && (uri.protocol + ':') == loc.protocol && uri.protocol.toLowerCase() != 'file') {\r\n\t\t\t\t\ttinymce.util.XHR.send({\r\n\t\t\t\t\t\turl : tinymce._addVer(uri.getURI()),\r\n\t\t\t\t\t\tsuccess : function(content) {\r\n\t\t\t\t\t\t\t// Create new temp script element\r\n\t\t\t\t\t\t\tvar script = dom.create('script', {\r\n\t\t\t\t\t\t\t\ttype : 'text/javascript'\r\n\t\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t\t// Evaluate script in global scope\r\n\t\t\t\t\t\t\tscript.text = content;\r\n\t\t\t\t\t\t\tdocument.getElementsByTagName('head')[0].appendChild(script);\r\n\t\t\t\t\t\t\tdom.remove(script);\r\n\r\n\t\t\t\t\t\t\tdone();\r\n\t\t\t\t\t\t},\r\n\r\n\t\t\t\t\t\terror : error\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Create new script element\r\n\t\t\telm = dom.create('script', {\r\n\t\t\t\tid : id,\r\n\t\t\t\ttype : 'text/javascript',\r\n\t\t\t\tsrc : tinymce._addVer(url)\r\n\t\t\t});\r\n\r\n\t\t\t// Add onload listener for non IE browsers since IE9\r\n\t\t\t// fires onload event before the script is parsed and executed\r\n\t\t\tif (!tinymce.isIE)\r\n\t\t\t\telm.onload = done;\r\n\r\n\t\t\t// Add onerror event will get fired on some browsers but not all of them\r\n\t\t\telm.onerror = error;\r\n\r\n\t\t\t// Opera 9.60 doesn't seem to fire the onreadystate event at correctly\r\n\t\t\tif (!tinymce.isOpera) {\r\n\t\t\t\telm.onreadystatechange = function() {\r\n\t\t\t\t\tvar state = elm.readyState;\r\n\r\n\t\t\t\t\t// Loaded state is passed on IE 6 however there\r\n\t\t\t\t\t// are known issues with this method but we can't use\r\n\t\t\t\t\t// XHR in a cross domain loading\r\n\t\t\t\t\tif (state == 'complete' || state == 'loaded')\r\n\t\t\t\t\t\tdone();\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\t// Most browsers support this feature so we report errors\r\n\t\t\t// for those at least to help users track their missing plugins etc\r\n\t\t\t// todo: Removed since it produced error if the document is unloaded by navigating away, re-add it as an option\r\n\t\t\t/*elm.onerror = function() {\r\n\t\t\t\talert('Failed to load: ' + url);\r\n\t\t\t};*/\r\n\r\n\t\t\t// Add script to document\r\n\t\t\t(document.getElementsByTagName('head')[0] || document.body).appendChild(elm);\r\n\t\t};\r\n\r\n\t\tthis.isDone = function(url) {\r\n\t\t\treturn states[url] == LOADED;\r\n\t\t};\r\n\r\n\t\tthis.markDone = function(url) {\r\n\t\t\tstates[url] = LOADED;\r\n\t\t};\r\n\r\n\t\tthis.add = this.load = function(url, callback, scope) {\r\n\t\t\tvar item, state = states[url];\r\n\r\n\t\t\t// Add url to load queue\r\n\t\t\tif (state == undefined) {\r\n\t\t\t\tqueue.push(url);\r\n\t\t\t\tstates[url] = QUEUED;\r\n\t\t\t}\r\n\r\n\t\t\tif (callback) {\r\n\t\t\t\t// Store away callback for later execution\r\n\t\t\t\tif (!scriptLoadedCallbacks[url])\r\n\t\t\t\t\tscriptLoadedCallbacks[url] = [];\r\n\r\n\t\t\t\tscriptLoadedCallbacks[url].push({\r\n\t\t\t\t\tfunc : callback,\r\n\t\t\t\t\tscope : scope || this\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tthis.loadQueue = function(callback, scope) {\r\n\t\t\tthis.loadScripts(queue, callback, scope);\r\n\t\t};\r\n\r\n\t\tthis.loadScripts = function(scripts, callback, scope) {\r\n\t\t\tvar loadScripts;\r\n\r\n\t\t\tfunction execScriptLoadedCallbacks(url) {\r\n\t\t\t\t// Execute URL callback functions\r\n\t\t\t\ttinymce.each(scriptLoadedCallbacks[url], function(callback) {\r\n\t\t\t\t\tcallback.func.call(callback.scope);\r\n\t\t\t\t});\r\n\r\n\t\t\t\tscriptLoadedCallbacks[url] = undefined;\r\n\t\t\t};\r\n\r\n\t\t\tqueueLoadedCallbacks.push({\r\n\t\t\t\tfunc : callback,\r\n\t\t\t\tscope : scope || this\r\n\t\t\t});\r\n\r\n\t\t\tloadScripts = function() {\r\n\t\t\t\tvar loadingScripts = tinymce.grep(scripts);\r\n\r\n\t\t\t\t// Current scripts has been handled\r\n\t\t\t\tscripts.length = 0;\r\n\r\n\t\t\t\t// Load scripts that needs to be loaded\r\n\t\t\t\ttinymce.each(loadingScripts, function(url) {\r\n\t\t\t\t\t// Script is already loaded then execute script callbacks directly\r\n\t\t\t\t\tif (states[url] == LOADED) {\r\n\t\t\t\t\t\texecScriptLoadedCallbacks(url);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Is script not loading then start loading it\r\n\t\t\t\t\tif (states[url] != LOADING) {\r\n\t\t\t\t\t\tstates[url] = LOADING;\r\n\t\t\t\t\t\tloading++;\r\n\r\n\t\t\t\t\t\tloadScript(url, function() {\r\n\t\t\t\t\t\t\tstates[url] = LOADED;\r\n\t\t\t\t\t\t\tloading--;\r\n\r\n\t\t\t\t\t\t\texecScriptLoadedCallbacks(url);\r\n\r\n\t\t\t\t\t\t\t// Load more scripts if they where added by the recently loaded script\r\n\t\t\t\t\t\t\tloadScripts();\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// No scripts are currently loading then execute all pending queue loaded callbacks\r\n\t\t\t\tif (!loading) {\r\n\t\t\t\t\ttinymce.each(queueLoadedCallbacks, function(callback) {\r\n\t\t\t\t\t\tcallback.func.call(callback.scope);\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\tqueueLoadedCallbacks.length = 0;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tloadScripts();\r\n\t\t};\r\n\t};\r\n\r\n\t// Global script loader\r\n\ttinymce.ScriptLoader = new tinymce.dom.ScriptLoader();\r\n})(tinymce);\r\n\r\ntinymce.dom.TreeWalker = function(start_node, root_node) {\r\n\tvar node = start_node;\r\n\r\n\tfunction findSibling(node, start_name, sibling_name, shallow) {\r\n\t\tvar sibling, parent;\r\n\r\n\t\tif (node) {\r\n\t\t\t// Walk into nodes if it has a start\r\n\t\t\tif (!shallow && node[start_name])\r\n\t\t\t\treturn node[start_name];\r\n\r\n\t\t\t// Return the sibling if it has one\r\n\t\t\tif (node != root_node) {\r\n\t\t\t\tsibling = node[sibling_name];\r\n\t\t\t\tif (sibling)\r\n\t\t\t\t\treturn sibling;\r\n\r\n\t\t\t\t// Walk up the parents to look for siblings\r\n\t\t\t\tfor (parent = node.parentNode; parent && parent != root_node; parent = parent.parentNode) {\r\n\t\t\t\t\tsibling = parent[sibling_name];\r\n\t\t\t\t\tif (sibling)\r\n\t\t\t\t\t\treturn sibling;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tthis.current = function() {\r\n\t\treturn node;\r\n\t};\r\n\r\n\tthis.next = function(shallow) {\r\n\t\treturn (node = findSibling(node, 'firstChild', 'nextSibling', shallow));\r\n\t};\r\n\r\n\tthis.prev = function(shallow) {\r\n\t\treturn (node = findSibling(node, 'lastChild', 'previousSibling', shallow));\r\n\t};\r\n};\r\n\r\n(function(tinymce) {\r\n\ttinymce.dom.RangeUtils = function(dom) {\r\n\t\tvar INVISIBLE_CHAR = '\\uFEFF';\r\n\r\n\t\tthis.walk = function(rng, callback) {\r\n\t\t\tvar startContainer = rng.startContainer,\r\n\t\t\t\tstartOffset = rng.startOffset,\r\n\t\t\t\tendContainer = rng.endContainer,\r\n\t\t\t\tendOffset = rng.endOffset,\r\n\t\t\t\tancestor, startPoint,\r\n\t\t\t\tendPoint, node, parent, siblings, nodes;\r\n\r\n\t\t\t// Handle table cell selection the table plugin enables\r\n\t\t\t// you to fake select table cells and perform formatting actions on them\r\n\t\t\tnodes = dom.select('td.mceSelected,th.mceSelected');\r\n\t\t\tif (nodes.length > 0) {\r\n\t\t\t\ttinymce.each(nodes, function(node) {\r\n\t\t\t\t\tcallback([node]);\r\n\t\t\t\t});\r\n\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tfunction exclude(nodes) {\r\n\t\t\t\tvar node;\r\n\r\n\t\t\t\t// First node is excluded\r\n\t\t\t\tnode = nodes[0];\r\n\t\t\t\tif (node.nodeType === 3 && node === startContainer && startOffset >= node.nodeValue.length) {\r\n\t\t\t\t\tnodes.splice(0, 1);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Last node is excluded\r\n\t\t\t\tnode = nodes[nodes.length - 1];\r\n\t\t\t\tif (endOffset === 0 && nodes.length > 0 && node === endContainer && node.nodeType === 3) {\r\n\t\t\t\t\tnodes.splice(nodes.length - 1, 1);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn nodes;\r\n\t\t\t};\r\n\r\n\t\t\tfunction collectSiblings(node, name, end_node) {\r\n\t\t\t\tvar siblings = [];\r\n\r\n\t\t\t\tfor (; node && node != end_node; node = node[name])\r\n\t\t\t\t\tsiblings.push(node);\r\n\r\n\t\t\t\treturn siblings;\r\n\t\t\t};\r\n\r\n\t\t\tfunction findEndPoint(node, root) {\r\n\t\t\t\tdo {\r\n\t\t\t\t\tif (node.parentNode == root)\r\n\t\t\t\t\t\treturn node;\r\n\r\n\t\t\t\t\tnode = node.parentNode;\r\n\t\t\t\t} while(node);\r\n\t\t\t};\r\n\r\n\t\t\tfunction walkBoundary(start_node, end_node, next) {\r\n\t\t\t\tvar siblingName = next ? 'nextSibling' : 'previousSibling';\r\n\r\n\t\t\t\tfor (node = start_node, parent = node.parentNode; node && node != end_node; node = parent) {\r\n\t\t\t\t\tparent = node.parentNode;\r\n\t\t\t\t\tsiblings = collectSiblings(node == start_node ? node : node[siblingName], siblingName);\r\n\r\n\t\t\t\t\tif (siblings.length) {\r\n\t\t\t\t\t\tif (!next)\r\n\t\t\t\t\t\t\tsiblings.reverse();\r\n\r\n\t\t\t\t\t\tcallback(exclude(siblings));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\t// If index based start position then resolve it\r\n\t\t\tif (startContainer.nodeType == 1 && startContainer.hasChildNodes())\r\n\t\t\t\tstartContainer = startContainer.childNodes[startOffset];\r\n\r\n\t\t\t// If index based end position then resolve it\r\n\t\t\tif (endContainer.nodeType == 1 && endContainer.hasChildNodes())\r\n\t\t\t\tendContainer = endContainer.childNodes[Math.min(endOffset - 1, endContainer.childNodes.length - 1)];\r\n\r\n\t\t\t// Same container\r\n\t\t\tif (startContainer == endContainer)\r\n\t\t\t\treturn callback(exclude([startContainer]));\r\n\r\n\t\t\t// Find common ancestor and end points\r\n\t\t\tancestor = dom.findCommonAncestor(startContainer, endContainer);\r\n\r\n\t\t\t// Process left side\r\n\t\t\tfor (node = startContainer; node; node = node.parentNode) {\r\n\t\t\t\tif (node === endContainer)\r\n\t\t\t\t\treturn walkBoundary(startContainer, ancestor, true);\r\n\r\n\t\t\t\tif (node === ancestor)\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\t// Process right side\r\n\t\t\tfor (node = endContainer; node; node = node.parentNode) {\r\n\t\t\t\tif (node === startContainer)\r\n\t\t\t\t\treturn walkBoundary(endContainer, ancestor);\r\n\r\n\t\t\t\tif (node === ancestor)\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\t// Find start/end point\r\n\t\t\tstartPoint = findEndPoint(startContainer, ancestor) || startContainer;\r\n\t\t\tendPoint = findEndPoint(endContainer, ancestor) || endContainer;\r\n\r\n\t\t\t// Walk left leaf\r\n\t\t\twalkBoundary(startContainer, startPoint, true);\r\n\r\n\t\t\t// Walk the middle from start to end point\r\n\t\t\tsiblings = collectSiblings(\r\n\t\t\t\tstartPoint == startContainer ? startPoint : startPoint.nextSibling,\r\n\t\t\t\t'nextSibling',\r\n\t\t\t\tendPoint == endContainer ? endPoint.nextSibling : endPoint\r\n\t\t\t);\r\n\r\n\t\t\tif (siblings.length)\r\n\t\t\t\tcallback(exclude(siblings));\r\n\r\n\t\t\t// Walk right leaf\r\n\t\t\twalkBoundary(endContainer, endPoint);\r\n\t\t};\r\n\r\n\t\tthis.split = function(rng) {\r\n\t\t\tvar startContainer = rng.startContainer,\r\n\t\t\t\tstartOffset = rng.startOffset,\r\n\t\t\t\tendContainer = rng.endContainer,\r\n\t\t\t\tendOffset = rng.endOffset;\r\n\r\n\t\t\tfunction splitText(node, offset) {\r\n\t\t\t\treturn node.splitText(offset);\r\n\t\t\t};\r\n\r\n\t\t\t// Handle single text node\r\n\t\t\tif (startContainer == endContainer && startContainer.nodeType == 3) {\r\n\t\t\t\tif (startOffset > 0 && startOffset < startContainer.nodeValue.length) {\r\n\t\t\t\t\tendContainer = splitText(startContainer, startOffset);\r\n\t\t\t\t\tstartContainer = endContainer.previousSibling;\r\n\r\n\t\t\t\t\tif (endOffset > startOffset) {\r\n\t\t\t\t\t\tendOffset = endOffset - startOffset;\r\n\t\t\t\t\t\tstartContainer = endContainer = splitText(endContainer, endOffset).previousSibling;\r\n\t\t\t\t\t\tendOffset = endContainer.nodeValue.length;\r\n\t\t\t\t\t\tstartOffset = 0;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tendOffset = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t// Split startContainer text node if needed\r\n\t\t\t\tif (startContainer.nodeType == 3 && startOffset > 0 && startOffset < startContainer.nodeValue.length) {\r\n\t\t\t\t\tstartContainer = splitText(startContainer, startOffset);\r\n\t\t\t\t\tstartOffset = 0;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Split endContainer text node if needed\r\n\t\t\t\tif (endContainer.nodeType == 3 && endOffset > 0 && endOffset < endContainer.nodeValue.length) {\r\n\t\t\t\t\tendContainer = splitText(endContainer, endOffset).previousSibling;\r\n\t\t\t\t\tendOffset = endContainer.nodeValue.length;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn {\r\n\t\t\t\tstartContainer : startContainer,\r\n\t\t\t\tstartOffset : startOffset,\r\n\t\t\t\tendContainer : endContainer,\r\n\t\t\t\tendOffset : endOffset\r\n\t\t\t};\r\n\t\t};\r\n\r\n\t};\r\n\r\n\ttinymce.dom.RangeUtils.compareRanges = function(rng1, rng2) {\r\n\t\tif (rng1 && rng2) {\r\n\t\t\t// Compare native IE ranges\r\n\t\t\tif (rng1.item || rng1.duplicate) {\r\n\t\t\t\t// Both are control ranges and the selected element matches\r\n\t\t\t\tif (rng1.item && rng2.item && rng1.item(0) === rng2.item(0))\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t// Both are text ranges and the range matches\r\n\t\t\t\tif (rng1.isEqual && rng2.isEqual && rng2.isEqual(rng1))\r\n\t\t\t\t\treturn true;\r\n\t\t\t} else {\r\n\t\t\t\t// Compare w3c ranges\r\n\t\t\t\treturn rng1.startContainer == rng2.startContainer && rng1.startOffset == rng2.startOffset;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t};\r\n})(tinymce);\r\n\r\n(function(tinymce) {\r\n\tvar Event = tinymce.dom.Event, each = tinymce.each;\r\n\r\n\ttinymce.create('tinymce.ui.KeyboardNavigation', {\r\n\t\tKeyboardNavigation: function(settings, dom) {\r\n\t\t\tvar t = this, root = settings.root, items = settings.items,\r\n\t\t\t\t\tenableUpDown = settings.enableUpDown, enableLeftRight = settings.enableLeftRight || !settings.enableUpDown,\r\n\t\t\t\t\texcludeFromTabOrder = settings.excludeFromTabOrder,\r\n\t\t\t\t\titemFocussed, itemBlurred, rootKeydown, rootFocussed, focussedId;\r\n\r\n\t\t\tdom = dom || tinymce.DOM;\r\n\r\n\t\t\titemFocussed = function(evt) {\r\n\t\t\t\tfocussedId = evt.target.id;\r\n\t\t\t};\r\n\r\n\t\t\titemBlurred = function(evt) {\r\n\t\t\t\tdom.setAttrib(evt.target.id, 'tabindex', '-1');\r\n\t\t\t};\r\n\r\n\t\t\trootFocussed = function(evt) {\r\n\t\t\t\tvar item = dom.get(focussedId);\r\n\t\t\t\tdom.setAttrib(item, 'tabindex', '0');\r\n\t\t\t\titem.focus();\r\n\t\t\t};\r\n\r\n\t\t\tt.focus = function() {\r\n\t\t\t\tdom.get(focussedId).focus();\r\n\t\t\t};\r\n\r\n\t\t\tt.destroy = function() {\r\n\t\t\t\teach(items, function(item) {\r\n\t\t\t\t\tdom.unbind(dom.get(item.id), 'focus', itemFocussed);\r\n\t\t\t\t\tdom.unbind(dom.get(item.id), 'blur', itemBlurred);\r\n\t\t\t\t});\r\n\r\n\t\t\t\tdom.unbind(dom.get(root), 'focus', rootFocussed);\r\n\t\t\t\tdom.unbind(dom.get(root), 'keydown', rootKeydown);\r\n\r\n\t\t\t\titems = dom = root = t.focus = itemFocussed = itemBlurred = rootKeydown = rootFocussed = null;\r\n\t\t\t\tt.destroy = function() {};\r\n\t\t\t};\r\n\r\n\t\t\tt.moveFocus = function(dir, evt) {\r\n\t\t\t\tvar idx = -1, controls = t.controls, newFocus;\r\n\r\n\t\t\t\tif (!focussedId)\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\teach(items, function(item, index) {\r\n\t\t\t\t\tif (item.id === focussedId) {\r\n\t\t\t\t\t\tidx = index;\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\tidx += dir;\r\n\t\t\t\tif (idx < 0) {\r\n\t\t\t\t\tidx = items.length - 1;\r\n\t\t\t\t} else if (idx >= items.length) {\r\n\t\t\t\t\tidx = 0;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnewFocus = items[idx];\r\n\t\t\t\tdom.setAttrib(focussedId, 'tabindex', '-1');\r\n\t\t\t\tdom.setAttrib(newFocus.id, 'tabindex', '0');\r\n\t\t\t\tdom.get(newFocus.id).focus();\r\n\r\n\t\t\t\tif (settings.actOnFocus) {\r\n\t\t\t\t\tsettings.onAction(newFocus.id);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (evt)\r\n\t\t\t\t\tEvent.cancel(evt);\r\n\t\t\t};\r\n\r\n\t\t\trootKeydown = function(evt) {\r\n\t\t\t\tvar DOM_VK_LEFT = 37, DOM_VK_RIGHT = 39, DOM_VK_UP = 38, DOM_VK_DOWN = 40, DOM_VK_ESCAPE = 27, DOM_VK_ENTER = 14, DOM_VK_RETURN = 13, DOM_VK_SPACE = 32;\r\n\r\n\t\t\t\tswitch (evt.keyCode) {\r\n\t\t\t\t\tcase DOM_VK_LEFT:\r\n\t\t\t\t\t\tif (enableLeftRight) t.moveFocus(-1);\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase DOM_VK_RIGHT:\r\n\t\t\t\t\t\tif (enableLeftRight) t.moveFocus(1);\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase DOM_VK_UP:\r\n\t\t\t\t\t\tif (enableUpDown) t.moveFocus(-1);\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase DOM_VK_DOWN:\r\n\t\t\t\t\t\tif (enableUpDown) t.moveFocus(1);\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase DOM_VK_ESCAPE:\r\n\t\t\t\t\t\tif (settings.onCancel) {\r\n\t\t\t\t\t\t\tsettings.onCancel();\r\n\t\t\t\t\t\t\tEvent.cancel(evt);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase DOM_VK_ENTER:\r\n\t\t\t\t\tcase DOM_VK_RETURN:\r\n\t\t\t\t\tcase DOM_VK_SPACE:\r\n\t\t\t\t\t\tif (settings.onAction) {\r\n\t\t\t\t\t\t\tsettings.onAction(focussedId);\r\n\t\t\t\t\t\t\tEvent.cancel(evt);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\t// Set up state and listeners for each item.\r\n\t\t\teach(items, function(item, idx) {\r\n\t\t\t\tvar tabindex;\r\n\r\n\t\t\t\tif (!item.id) {\r\n\t\t\t\t\titem.id = dom.uniqueId('_mce_item_');\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (excludeFromTabOrder) {\r\n\t\t\t\t\tdom.bind(item.id, 'blur', itemBlurred);\r\n\t\t\t\t\ttabindex = '-1';\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttabindex = (idx === 0 ? '0' : '-1');\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdom.setAttrib(item.id, 'tabindex', tabindex);\r\n\t\t\t\tdom.bind(dom.get(item.id), 'focus', itemFocussed);\r\n\t\t\t});\r\n\r\n\t\t\t// Setup initial state for root element.\r\n\t\t\tif (items[0]){\r\n\t\t\t\tfocussedId = items[0].id;\r\n\t\t\t}\r\n\r\n\t\t\tdom.setAttrib(root, 'tabindex', '-1');\r\n\r\n\t\t\t// Setup listeners for root element.\r\n\t\t\tdom.bind(dom.get(root), 'focus', rootFocussed);\r\n\t\t\tdom.bind(dom.get(root), 'keydown', rootKeydown);\r\n\t\t}\r\n\t});\r\n})(tinymce);\r\n\r\n(function(tinymce) {\r\n\t// Shorten class names\r\n\tvar DOM = tinymce.DOM, is = tinymce.is;\r\n\r\n\ttinymce.create('tinymce.ui.Control', {\r\n\t\tControl : function(id, s, editor) {\r\n\t\t\tthis.id = id;\r\n\t\t\tthis.settings = s = s || {};\r\n\t\t\tthis.rendered = false;\r\n\t\t\tthis.onRender = new tinymce.util.Dispatcher(this);\r\n\t\t\tthis.classPrefix = '';\r\n\t\t\tthis.scope = s.scope || this;\r\n\t\t\tthis.disabled = 0;\r\n\t\t\tthis.active = 0;\r\n\t\t\tthis.editor = editor;\r\n\t\t},\r\n\r\n\t\tsetAriaProperty : function(property, value) {\r\n\t\t\tvar element = DOM.get(this.id + '_aria') || DOM.get(this.id);\r\n\t\t\tif (element) {\r\n\t\t\t\tDOM.setAttrib(element, 'aria-' + property, !!value);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tfocus : function() {\r\n\t\t\tDOM.get(this.id).focus();\r\n\t\t},\r\n\r\n\t\tsetDisabled : function(s) {\r\n\t\t\tif (s != this.disabled) {\r\n\t\t\t\tthis.setAriaProperty('disabled', s);\r\n\r\n\t\t\t\tthis.setState('Disabled', s);\r\n\t\t\t\tthis.setState('Enabled', !s);\r\n\t\t\t\tthis.disabled = s;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tisDisabled : function() {\r\n\t\t\treturn this.disabled;\r\n\t\t},\r\n\r\n\t\tsetActive : function(s) {\r\n\t\t\tif (s != this.active) {\r\n\t\t\t\tthis.setState('Active', s);\r\n\t\t\t\tthis.active = s;\r\n\t\t\t\tthis.setAriaProperty('pressed', s);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tisActive : function() {\r\n\t\t\treturn this.active;\r\n\t\t},\r\n\r\n\t\tsetState : function(c, s) {\r\n\t\t\tvar n = DOM.get(this.id);\r\n\r\n\t\t\tc = this.classPrefix + c;\r\n\r\n\t\t\tif (s)\r\n\t\t\t\tDOM.addClass(n, c);\r\n\t\t\telse\r\n\t\t\t\tDOM.removeClass(n, c);\r\n\t\t},\r\n\r\n\t\tisRendered : function() {\r\n\t\t\treturn this.rendered;\r\n\t\t},\r\n\r\n\t\trenderHTML : function() {\r\n\t\t},\r\n\r\n\t\trenderTo : function(n) {\r\n\t\t\tDOM.setHTML(n, this.renderHTML());\r\n\t\t},\r\n\r\n\t\tpostRender : function() {\r\n\t\t\tvar t = this, b;\r\n\r\n\t\t\t// Set pending states\r\n\t\t\tif (is(t.disabled)) {\r\n\t\t\t\tb = t.disabled;\r\n\t\t\t\tt.disabled = -1;\r\n\t\t\t\tt.setDisabled(b);\r\n\t\t\t}\r\n\r\n\t\t\tif (is(t.active)) {\r\n\t\t\t\tb = t.active;\r\n\t\t\t\tt.active = -1;\r\n\t\t\t\tt.setActive(b);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tremove : function() {\r\n\t\t\tDOM.remove(this.id);\r\n\t\t\tthis.destroy();\r\n\t\t},\r\n\r\n\t\tdestroy : function() {\r\n\t\t\ttinymce.dom.Event.clear(this.id);\r\n\t\t}\r\n\t});\r\n})(tinymce);\r\ntinymce.create('tinymce.ui.Container:tinymce.ui.Control', {\r\n\tContainer : function(id, s, editor) {\r\n\t\tthis.parent(id, s, editor);\r\n\r\n\t\tthis.controls = [];\r\n\r\n\t\tthis.lookup = {};\r\n\t},\r\n\r\n\tadd : function(c) {\r\n\t\tthis.lookup[c.id] = c;\r\n\t\tthis.controls.push(c);\r\n\r\n\t\treturn c;\r\n\t},\r\n\r\n\tget : function(n) {\r\n\t\treturn this.lookup[n];\r\n\t}\r\n});\r\n\r\n\r\ntinymce.create('tinymce.ui.Separator:tinymce.ui.Control', {\r\n\tSeparator : function(id, s) {\r\n\t\tthis.parent(id, s);\r\n\t\tthis.classPrefix = 'mceSeparator';\r\n\t\tthis.setDisabled(true);\r\n\t},\r\n\r\n\trenderHTML : function() {\r\n\t\treturn tinymce.DOM.createHTML('span', {'class' : this.classPrefix, role : 'separator', 'aria-orientation' : 'vertical', tabindex : '-1'});\r\n\t}\r\n});\r\n\r\n(function(tinymce) {\r\n\tvar is = tinymce.is, DOM = tinymce.DOM, each = tinymce.each, walk = tinymce.walk;\r\n\r\n\ttinymce.create('tinymce.ui.MenuItem:tinymce.ui.Control', {\r\n\t\tMenuItem : function(id, s) {\r\n\t\t\tthis.parent(id, s);\r\n\t\t\tthis.classPrefix = 'mceMenuItem';\r\n\t\t},\r\n\r\n\t\tsetSelected : function(s) {\r\n\t\t\tthis.setState('Selected', s);\r\n\t\t\tthis.setAriaProperty('checked', !!s);\r\n\t\t\tthis.selected = s;\r\n\t\t},\r\n\r\n\t\tisSelected : function() {\r\n\t\t\treturn this.selected;\r\n\t\t},\r\n\r\n\t\tpostRender : function() {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\tt.parent();\r\n\r\n\t\t\t// Set pending state\r\n\t\t\tif (is(t.selected))\r\n\t\t\t\tt.setSelected(t.selected);\r\n\t\t}\r\n\t});\r\n})(tinymce);\r\n\r\n(function(tinymce) {\r\n\tvar is = tinymce.is, DOM = tinymce.DOM, each = tinymce.each, walk = tinymce.walk;\r\n\r\n\ttinymce.create('tinymce.ui.Menu:tinymce.ui.MenuItem', {\r\n\t\tMenu : function(id, s) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\tt.parent(id, s);\r\n\t\t\tt.items = {};\r\n\t\t\tt.collapsed = false;\r\n\t\t\tt.menuCount = 0;\r\n\t\t\tt.onAddItem = new tinymce.util.Dispatcher(this);\r\n\t\t},\r\n\r\n\t\texpand : function(d) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\tif (d) {\r\n\t\t\t\twalk(t, function(o) {\r\n\t\t\t\t\tif (o.expand)\r\n\t\t\t\t\t\to.expand();\r\n\t\t\t\t}, 'items', t);\r\n\t\t\t}\r\n\r\n\t\t\tt.collapsed = false;\r\n\t\t},\r\n\r\n\t\tcollapse : function(d) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\tif (d) {\r\n\t\t\t\twalk(t, function(o) {\r\n\t\t\t\t\tif (o.collapse)\r\n\t\t\t\t\t\to.collapse();\r\n\t\t\t\t}, 'items', t);\r\n\t\t\t}\r\n\r\n\t\t\tt.collapsed = true;\r\n\t\t},\r\n\r\n\t\tisCollapsed : function() {\r\n\t\t\treturn this.collapsed;\r\n\t\t},\r\n\r\n\t\tadd : function(o) {\r\n\t\t\tif (!o.settings)\r\n\t\t\t\to = new tinymce.ui.MenuItem(o.id || DOM.uniqueId(), o);\r\n\r\n\t\t\tthis.onAddItem.dispatch(this, o);\r\n\r\n\t\t\treturn this.items[o.id] = o;\r\n\t\t},\r\n\r\n\t\taddSeparator : function() {\r\n\t\t\treturn this.add({separator : true});\r\n\t\t},\r\n\r\n\t\taddMenu : function(o) {\r\n\t\t\tif (!o.collapse)\r\n\t\t\t\to = this.createMenu(o);\r\n\r\n\t\t\tthis.menuCount++;\r\n\r\n\t\t\treturn this.add(o);\r\n\t\t},\r\n\r\n\t\thasMenus : function() {\r\n\t\t\treturn this.menuCount !== 0;\r\n\t\t},\r\n\r\n\t\tremove : function(o) {\r\n\t\t\tdelete this.items[o.id];\r\n\t\t},\r\n\r\n\t\tremoveAll : function() {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\twalk(t, function(o) {\r\n\t\t\t\tif (o.removeAll)\r\n\t\t\t\t\to.removeAll();\r\n\t\t\t\telse\r\n\t\t\t\t\to.remove();\r\n\r\n\t\t\t\to.destroy();\r\n\t\t\t}, 'items', t);\r\n\r\n\t\t\tt.items = {};\r\n\t\t},\r\n\r\n\t\tcreateMenu : function(o) {\r\n\t\t\tvar m = new tinymce.ui.Menu(o.id || DOM.uniqueId(), o);\r\n\r\n\t\t\tm.onAddItem.add(this.onAddItem.dispatch, this.onAddItem);\r\n\r\n\t\t\treturn m;\r\n\t\t}\r\n\t});\r\n})(tinymce);\r\n(function(tinymce) {\r\n\tvar is = tinymce.is, DOM = tinymce.DOM, each = tinymce.each, Event = tinymce.dom.Event, Element = tinymce.dom.Element;\r\n\r\n\ttinymce.create('tinymce.ui.DropMenu:tinymce.ui.Menu', {\r\n\t\tDropMenu : function(id, s) {\r\n\t\t\ts = s || {};\r\n\t\t\ts.container = s.container || DOM.doc.body;\r\n\t\t\ts.offset_x = s.offset_x || 0;\r\n\t\t\ts.offset_y = s.offset_y || 0;\r\n\t\t\ts.vp_offset_x = s.vp_offset_x || 0;\r\n\t\t\ts.vp_offset_y = s.vp_offset_y || 0;\r\n\r\n\t\t\tif (is(s.icons) && !s.icons)\r\n\t\t\t\ts['class'] += ' mceNoIcons';\r\n\r\n\t\t\tthis.parent(id, s);\r\n\t\t\tthis.onShowMenu = new tinymce.util.Dispatcher(this);\r\n\t\t\tthis.onHideMenu = new tinymce.util.Dispatcher(this);\r\n\t\t\tthis.classPrefix = 'mceMenu';\r\n\t\t},\r\n\r\n\t\tcreateMenu : function(s) {\r\n\t\t\tvar t = this, cs = t.settings, m;\r\n\r\n\t\t\ts.container = s.container || cs.container;\r\n\t\t\ts.parent = t;\r\n\t\t\ts.constrain = s.constrain || cs.constrain;\r\n\t\t\ts['class'] = s['class'] || cs['class'];\r\n\t\t\ts.vp_offset_x = s.vp_offset_x || cs.vp_offset_x;\r\n\t\t\ts.vp_offset_y = s.vp_offset_y || cs.vp_offset_y;\r\n\t\t\ts.keyboard_focus = cs.keyboard_focus;\r\n\t\t\tm = new tinymce.ui.DropMenu(s.id || DOM.uniqueId(), s);\r\n\r\n\t\t\tm.onAddItem.add(t.onAddItem.dispatch, t.onAddItem);\r\n\r\n\t\t\treturn m;\r\n\t\t},\r\n\r\n\t\tfocus : function() {\r\n\t\t\tvar t = this;\r\n\t\t\tif (t.keyboardNav) {\r\n\t\t\t\tt.keyboardNav.focus();\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tupdate : function() {\r\n\t\t\tvar t = this, s = t.settings, tb = DOM.get('menu_' + t.id + '_tbl'), co = DOM.get('menu_' + t.id + '_co'), tw, th;\r\n\r\n\t\t\ttw = s.max_width ? Math.min(tb.clientWidth, s.max_width) : tb.clientWidth;\r\n\t\t\tth = s.max_height ? Math.min(tb.clientHeight, s.max_height) : tb.clientHeight;\r\n\r\n\t\t\tif (!DOM.boxModel)\r\n\t\t\t\tt.element.setStyles({width : tw + 2, height : th + 2});\r\n\t\t\telse\r\n\t\t\t\tt.element.setStyles({width : tw, height : th});\r\n\r\n\t\t\tif (s.max_width)\r\n\t\t\t\tDOM.setStyle(co, 'width', tw);\r\n\r\n\t\t\tif (s.max_height) {\r\n\t\t\t\tDOM.setStyle(co, 'height', th);\r\n\r\n\t\t\t\tif (tb.clientHeight < s.max_height)\r\n\t\t\t\t\tDOM.setStyle(co, 'overflow', 'hidden');\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tshowMenu : function(x, y, px) {\r\n\t\t\tvar t = this, s = t.settings, co, vp = DOM.getViewPort(), w, h, mx, my, ot = 2, dm, tb, cp = t.classPrefix;\r\n\r\n\t\t\tt.collapse(1);\r\n\r\n\t\t\tif (t.isMenuVisible)\r\n\t\t\t\treturn;\r\n\r\n\t\t\tif (!t.rendered) {\r\n\t\t\t\tco = DOM.add(t.settings.container, t.renderNode());\r\n\r\n\t\t\t\teach(t.items, function(o) {\r\n\t\t\t\t\to.postRender();\r\n\t\t\t\t});\r\n\r\n\t\t\t\tt.element = new Element('menu_' + t.id, {blocker : 1, container : s.container});\r\n\t\t\t} else\r\n\t\t\t\tco = DOM.get('menu_' + t.id);\r\n\r\n\t\t\t// Move layer out of sight unless it's Opera since it scrolls to top of page due to an bug\r\n\t\t\tif (!tinymce.isOpera)\r\n\t\t\t\tDOM.setStyles(co, {left : -0xFFFF , top : -0xFFFF});\r\n\r\n\t\t\tDOM.show(co);\r\n\t\t\tt.update();\r\n\r\n\t\t\tx += s.offset_x || 0;\r\n\t\t\ty += s.offset_y || 0;\r\n\t\t\tvp.w -= 4;\r\n\t\t\tvp.h -= 4;\r\n\r\n\t\t\t// Move inside viewport if not submenu\r\n\t\t\tif (s.constrain) {\r\n\t\t\t\tw = co.clientWidth - ot;\r\n\t\t\t\th = co.clientHeight - ot;\r\n\t\t\t\tmx = vp.x + vp.w;\r\n\t\t\t\tmy = vp.y + vp.h;\r\n\r\n\t\t\t\tif ((x + s.vp_offset_x + w) > mx)\r\n\t\t\t\t\tx = px ? px - w : Math.max(0, (mx - s.vp_offset_x) - w);\r\n\r\n\t\t\t\tif ((y + s.vp_offset_y + h) > my)\r\n\t\t\t\t\ty = Math.max(0, (my - s.vp_offset_y) - h);\r\n\t\t\t}\r\n\r\n\t\t\tDOM.setStyles(co, {left : x , top : y});\r\n\t\t\tt.element.update();\r\n\r\n\t\t\tt.isMenuVisible = 1;\r\n\t\t\tt.mouseClickFunc = Event.add(co, 'click', function(e) {\r\n\t\t\t\tvar m;\r\n\r\n\t\t\t\te = e.target;\r\n\r\n\t\t\t\tif (e && (e = DOM.getParent(e, 'tr')) && !DOM.hasClass(e, cp + 'ItemSub')) {\r\n\t\t\t\t\tm = t.items[e.id];\r\n\r\n\t\t\t\t\tif (m.isDisabled())\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\tdm = t;\r\n\r\n\t\t\t\t\twhile (dm) {\r\n\t\t\t\t\t\tif (dm.hideMenu)\r\n\t\t\t\t\t\t\tdm.hideMenu();\r\n\r\n\t\t\t\t\t\tdm = dm.settings.parent;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (m.settings.onclick)\r\n\t\t\t\t\t\tm.settings.onclick(e);\r\n\r\n\t\t\t\t\treturn Event.cancel(e); // Cancel to fix onbeforeunload problem\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tif (t.hasMenus()) {\r\n\t\t\t\tt.mouseOverFunc = Event.add(co, 'mouseover', function(e) {\r\n\t\t\t\t\tvar m, r, mi;\r\n\r\n\t\t\t\t\te = e.target;\r\n\t\t\t\t\tif (e && (e = DOM.getParent(e, 'tr'))) {\r\n\t\t\t\t\t\tm = t.items[e.id];\r\n\r\n\t\t\t\t\t\tif (t.lastMenu)\r\n\t\t\t\t\t\t\tt.lastMenu.collapse(1);\r\n\r\n\t\t\t\t\t\tif (m.isDisabled())\r\n\t\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t\tif (e && DOM.hasClass(e, cp + 'ItemSub')) {\r\n\t\t\t\t\t\t\t//p = DOM.getPos(s.container);\r\n\t\t\t\t\t\t\tr = DOM.getRect(e);\r\n\t\t\t\t\t\t\tm.showMenu((r.x + r.w - ot), r.y - ot, r.x);\r\n\t\t\t\t\t\t\tt.lastMenu = m;\r\n\t\t\t\t\t\t\tDOM.addClass(DOM.get(m.id).firstChild, cp + 'ItemActive');\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tEvent.add(co, 'keydown', t._keyHandler, t);\r\n\r\n\t\t\tt.onShowMenu.dispatch(t);\r\n\r\n\t\t\tif (s.keyboard_focus) {\r\n\t\t\t\tt._setupKeyboardNav();\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\thideMenu : function(c) {\r\n\t\t\tvar t = this, co = DOM.get('menu_' + t.id), e;\r\n\r\n\t\t\tif (!t.isMenuVisible)\r\n\t\t\t\treturn;\r\n\r\n\t\t\tif (t.keyboardNav) t.keyboardNav.destroy();\r\n\t\t\tEvent.remove(co, 'mouseover', t.mouseOverFunc);\r\n\t\t\tEvent.remove(co, 'click', t.mouseClickFunc);\r\n\t\t\tEvent.remove(co, 'keydown', t._keyHandler);\r\n\t\t\tDOM.hide(co);\r\n\t\t\tt.isMenuVisible = 0;\r\n\r\n\t\t\tif (!c)\r\n\t\t\t\tt.collapse(1);\r\n\r\n\t\t\tif (t.element)\r\n\t\t\t\tt.element.hide();\r\n\r\n\t\t\tif (e = DOM.get(t.id))\r\n\t\t\t\tDOM.removeClass(e.firstChild, t.classPrefix + 'ItemActive');\r\n\r\n\t\t\tt.onHideMenu.dispatch(t);\r\n\t\t},\r\n\r\n\t\tadd : function(o) {\r\n\t\t\tvar t = this, co;\r\n\r\n\t\t\to = t.parent(o);\r\n\r\n\t\t\tif (t.isRendered && (co = DOM.get('menu_' + t.id)))\r\n\t\t\t\tt._add(DOM.select('tbody', co)[0], o);\r\n\r\n\t\t\treturn o;\r\n\t\t},\r\n\r\n\t\tcollapse : function(d) {\r\n\t\t\tthis.parent(d);\r\n\t\t\tthis.hideMenu(1);\r\n\t\t},\r\n\r\n\t\tremove : function(o) {\r\n\t\t\tDOM.remove(o.id);\r\n\t\t\tthis.destroy();\r\n\r\n\t\t\treturn this.parent(o);\r\n\t\t},\r\n\r\n\t\tdestroy : function() {\r\n\t\t\tvar t = this, co = DOM.get('menu_' + t.id);\r\n\r\n\t\t\tif (t.keyboardNav) t.keyboardNav.destroy();\r\n\t\t\tEvent.remove(co, 'mouseover', t.mouseOverFunc);\r\n\t\t\tEvent.remove(DOM.select('a', co), 'focus', t.mouseOverFunc);\r\n\t\t\tEvent.remove(co, 'click', t.mouseClickFunc);\r\n\t\t\tEvent.remove(co, 'keydown', t._keyHandler);\r\n\r\n\t\t\tif (t.element)\r\n\t\t\t\tt.element.remove();\r\n\r\n\t\t\tDOM.remove(co);\r\n\t\t},\r\n\r\n\t\trenderNode : function() {\r\n\t\t\tvar t = this, s = t.settings, n, tb, co, w;\r\n\r\n\t\t\tw = DOM.create('div', {role: 'listbox', id : 'menu_' + t.id, 'class' : s['class'], 'style' : 'position:absolute;left:0;top:0;z-index:200000;outline:0'});\r\n\t\t\tif (t.settings.parent) {\r\n\t\t\t\tDOM.setAttrib(w, 'aria-parent', 'menu_' + t.settings.parent.id);\r\n\t\t\t}\r\n\t\t\tco = DOM.add(w, 'div', {role: 'presentation', id : 'menu_' + t.id + '_co', 'class' : t.classPrefix + (s['class'] ? ' ' + s['class'] : '')});\r\n\t\t\tt.element = new Element('menu_' + t.id, {blocker : 1, container : s.container});\r\n\r\n\t\t\tif (s.menu_line)\r\n\t\t\t\tDOM.add(co, 'span', {'class' : t.classPrefix + 'Line'});\r\n\r\n//\t\t\tn = DOM.add(co, 'div', {id : 'menu_' + t.id + '_co', 'class' : 'mceMenuContainer'});\r\n\t\t\tn = DOM.add(co, 'table', {role: 'presentation', id : 'menu_' + t.id + '_tbl', border : 0, cellPadding : 0, cellSpacing : 0});\r\n\t\t\ttb = DOM.add(n, 'tbody');\r\n\r\n\t\t\teach(t.items, function(o) {\r\n\t\t\t\tt._add(tb, o);\r\n\t\t\t});\r\n\r\n\t\t\tt.rendered = true;\r\n\r\n\t\t\treturn w;\r\n\t\t},\r\n\r\n\t\t// Internal functions\r\n\t\t_setupKeyboardNav : function(){\r\n\t\t\tvar contextMenu, menuItems, t=this;\r\n\t\t\tcontextMenu = DOM.select('#menu_' + t.id)[0];\r\n\t\t\tmenuItems = DOM.select('a[role=option]', 'menu_' + t.id);\r\n\t\t\tmenuItems.splice(0,0,contextMenu);\r\n\t\t\tt.keyboardNav = new tinymce.ui.KeyboardNavigation({\r\n\t\t\t\troot: 'menu_' + t.id,\r\n\t\t\t\titems: menuItems,\r\n\t\t\t\tonCancel: function() {\r\n\t\t\t\t\tt.hideMenu();\r\n\t\t\t\t},\r\n\t\t\t\tenableUpDown: true\r\n\t\t\t});\r\n\t\t\tcontextMenu.focus();\r\n\t\t},\r\n\r\n\t\t_keyHandler : function(evt) {\r\n\t\t\tvar t = this, e;\r\n\t\t\tswitch (evt.keyCode) {\r\n\t\t\t\tcase 37: // Left\r\n\t\t\t\t\tif (t.settings.parent) {\r\n\t\t\t\t\t\tt.hideMenu();\r\n\t\t\t\t\t\tt.settings.parent.focus();\r\n\t\t\t\t\t\tEvent.cancel(evt);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 39: // Right\r\n\t\t\t\t\tif (t.mouseOverFunc)\r\n\t\t\t\t\t\tt.mouseOverFunc(evt);\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_add : function(tb, o) {\r\n\t\t\tvar n, s = o.settings, a, ro, it, cp = this.classPrefix, ic;\r\n\r\n\t\t\tif (s.separator) {\r\n\t\t\t\tro = DOM.add(tb, 'tr', {id : o.id, 'class' : cp + 'ItemSeparator'});\r\n\t\t\t\tDOM.add(ro, 'td', {'class' : cp + 'ItemSeparator'});\r\n\r\n\t\t\t\tif (n = ro.previousSibling)\r\n\t\t\t\t\tDOM.addClass(n, 'mceLast');\r\n\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tn = ro = DOM.add(tb, 'tr', {id : o.id, 'class' : cp + 'Item ' + cp + 'ItemEnabled'});\r\n\t\t\tn = it = DOM.add(n, s.titleItem ? 'th' : 'td');\r\n\t\t\tn = a = DOM.add(n, 'a', {id: o.id + '_aria',  role: s.titleItem ? 'presentation' : 'option', href : 'javascript:;', onclick : \"return false;\", onmousedown : 'return false;'});\r\n\r\n\t\t\tif (s.parent) {\r\n\t\t\t\tDOM.setAttrib(a, 'aria-haspopup', 'true');\r\n\t\t\t\tDOM.setAttrib(a, 'aria-owns', 'menu_' + o.id);\r\n\t\t\t}\r\n\r\n\t\t\tDOM.addClass(it, s['class']);\r\n//\t\t\tn = DOM.add(n, 'span', {'class' : 'item'});\r\n\r\n\t\t\tic = DOM.add(n, 'span', {'class' : 'mceIcon' + (s.icon ? ' mce_' + s.icon : '')});\r\n\r\n\t\t\tif (s.icon_src)\r\n\t\t\t\tDOM.add(ic, 'img', {src : s.icon_src});\r\n\r\n\t\t\tn = DOM.add(n, s.element || 'span', {'class' : 'mceText', title : o.settings.title}, o.settings.title);\r\n\r\n\t\t\tif (o.settings.style)\r\n\t\t\t\tDOM.setAttrib(n, 'style', o.settings.style);\r\n\r\n\t\t\tif (tb.childNodes.length == 1)\r\n\t\t\t\tDOM.addClass(ro, 'mceFirst');\r\n\r\n\t\t\tif ((n = ro.previousSibling) && DOM.hasClass(n, cp + 'ItemSeparator'))\r\n\t\t\t\tDOM.addClass(ro, 'mceFirst');\r\n\r\n\t\t\tif (o.collapse)\r\n\t\t\t\tDOM.addClass(ro, cp + 'ItemSub');\r\n\r\n\t\t\tif (n = ro.previousSibling)\r\n\t\t\t\tDOM.removeClass(n, 'mceLast');\r\n\r\n\t\t\tDOM.addClass(ro, 'mceLast');\r\n\t\t}\r\n\t});\r\n})(tinymce);\r\n(function(tinymce) {\r\n\tvar DOM = tinymce.DOM;\r\n\r\n\ttinymce.create('tinymce.ui.Button:tinymce.ui.Control', {\r\n\t\tButton : function(id, s, ed) {\r\n\t\t\tthis.parent(id, s, ed);\r\n\t\t\tthis.classPrefix = 'mceButton';\r\n\t\t},\r\n\r\n\t\trenderHTML : function() {\r\n\t\t\tvar cp = this.classPrefix, s = this.settings, h, l;\r\n\r\n\t\t\tl = DOM.encode(s.label || '');\r\n\t\t\th = '<a role=\"button\" id=\"' + this.id + '\" href=\"javascript:;\" class=\"' + cp + ' ' + cp + 'Enabled ' + s['class'] + (l ? ' ' + cp + 'Labeled' : '') +'\" onmousedown=\"return false;\" onclick=\"return false;\" aria-labelledby=\"' + this.id + '_voice\" title=\"' + DOM.encode(s.title) + '\">';\r\n\t\t\tif (s.image && !(this.editor  &&this.editor.forcedHighContrastMode) )\r\n\t\t\t\th += '<img class=\"mceIcon\" src=\"' + s.image + '\" alt=\"' + DOM.encode(s.title) + '\" />' + l;\r\n\t\t\telse\r\n\t\t\t\th += '<span class=\"mceIcon ' + s['class'] + '\"></span>' + (l ? '<span class=\"' + cp + 'Label\">' + l + '</span>' : '');\r\n\r\n\t\t\th += '<span class=\"mceVoiceLabel mceIconOnly\" style=\"display: none;\" id=\"' + this.id + '_voice\">' + s.title + '</span>';\r\n\t\t\th += '</a>';\r\n\t\t\treturn h;\r\n\t\t},\r\n\r\n\t\tpostRender : function() {\r\n\t\t\tvar t = this, s = t.settings;\r\n\r\n\t\t\ttinymce.dom.Event.add(t.id, 'click', function(e) {\r\n\t\t\t\tif (!t.isDisabled())\r\n\t\t\t\t\treturn s.onclick.call(s.scope, e);\r\n\t\t\t});\r\n\t\t}\r\n\t});\r\n})(tinymce);\r\n\r\n(function(tinymce) {\r\n\tvar DOM = tinymce.DOM, Event = tinymce.dom.Event, each = tinymce.each, Dispatcher = tinymce.util.Dispatcher;\r\n\r\n\ttinymce.create('tinymce.ui.ListBox:tinymce.ui.Control', {\r\n\t\tListBox : function(id, s, ed) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\tt.parent(id, s, ed);\r\n\r\n\t\t\tt.items = [];\r\n\r\n\t\t\tt.onChange = new Dispatcher(t);\r\n\r\n\t\t\tt.onPostRender = new Dispatcher(t);\r\n\r\n\t\t\tt.onAdd = new Dispatcher(t);\r\n\r\n\t\t\tt.onRenderMenu = new tinymce.util.Dispatcher(this);\r\n\r\n\t\t\tt.classPrefix = 'mceListBox';\r\n\t\t},\r\n\r\n\t\tselect : function(va) {\r\n\t\t\tvar t = this, fv, f;\r\n\r\n\t\t\tif (va == undefined)\r\n\t\t\t\treturn t.selectByIndex(-1);\r\n\r\n\t\t\t// Is string or number make function selector\r\n\t\t\tif (va && va.call)\r\n\t\t\t\tf = va;\r\n\t\t\telse {\r\n\t\t\t\tf = function(v) {\r\n\t\t\t\t\treturn v == va;\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\t// Do we need to do something?\r\n\t\t\tif (va != t.selectedValue) {\r\n\t\t\t\t// Find item\r\n\t\t\t\teach(t.items, function(o, i) {\r\n\t\t\t\t\tif (f(o.value)) {\r\n\t\t\t\t\t\tfv = 1;\r\n\t\t\t\t\t\tt.selectByIndex(i);\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\tif (!fv)\r\n\t\t\t\t\tt.selectByIndex(-1);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tselectByIndex : function(idx) {\r\n\t\t\tvar t = this, e, o, label;\r\n\r\n\t\t\tif (idx != t.selectedIndex) {\r\n\t\t\t\te = DOM.get(t.id + '_text');\r\n\t\t\t\tlabel = DOM.get(t.id + '_voiceDesc');\r\n\t\t\t\to = t.items[idx];\r\n\r\n\t\t\t\tif (o) {\r\n\t\t\t\t\tt.selectedValue = o.value;\r\n\t\t\t\t\tt.selectedIndex = idx;\r\n\t\t\t\t\tDOM.setHTML(e, DOM.encode(o.title));\r\n\t\t\t\t\tDOM.setHTML(label, t.settings.title + \" - \" + o.title);\r\n\t\t\t\t\tDOM.removeClass(e, 'mceTitle');\r\n\t\t\t\t\tDOM.setAttrib(t.id, 'aria-valuenow', o.title);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tDOM.setHTML(e, DOM.encode(t.settings.title));\r\n\t\t\t\t\tDOM.setHTML(label, DOM.encode(t.settings.title));\r\n\t\t\t\t\tDOM.addClass(e, 'mceTitle');\r\n\t\t\t\t\tt.selectedValue = t.selectedIndex = null;\r\n\t\t\t\t\tDOM.setAttrib(t.id, 'aria-valuenow', t.settings.title);\r\n\t\t\t\t}\r\n\t\t\t\te = 0;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tadd : function(n, v, o) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\to = o || {};\r\n\t\t\to = tinymce.extend(o, {\r\n\t\t\t\ttitle : n,\r\n\t\t\t\tvalue : v\r\n\t\t\t});\r\n\r\n\t\t\tt.items.push(o);\r\n\t\t\tt.onAdd.dispatch(t, o);\r\n\t\t},\r\n\r\n\t\tgetLength : function() {\r\n\t\t\treturn this.items.length;\r\n\t\t},\r\n\r\n\t\trenderHTML : function() {\r\n\t\t\tvar h = '', t = this, s = t.settings, cp = t.classPrefix;\r\n\r\n\t\t\th = '<span role=\"listbox\" aria-haspopup=\"true\" aria-labelledby=\"' + t.id +'_voiceDesc\" aria-describedby=\"' + t.id + '_voiceDesc\"><table role=\"presentation\" tabindex=\"0\" id=\"' + t.id + '\" cellpadding=\"0\" cellspacing=\"0\" class=\"' + cp + ' ' + cp + 'Enabled' + (s['class'] ? (' ' + s['class']) : '') + '\"><tbody><tr>';\r\n\t\t\th += '<td>' + DOM.createHTML('span', {id: t.id + '_voiceDesc', 'class': 'voiceLabel', style:'display:none;'}, t.settings.title);\r\n\t\t\th += DOM.createHTML('a', {id : t.id + '_text', tabindex : -1, href : 'javascript:;', 'class' : 'mceText', onclick : \"return false;\", onmousedown : 'return false;'}, DOM.encode(t.settings.title)) + '</td>';\r\n\t\t\th += '<td>' + DOM.createHTML('a', {id : t.id + '_open', tabindex : -1, href : 'javascript:;', 'class' : 'mceOpen', onclick : \"return false;\", onmousedown : 'return false;'}, '<span><span style=\"display:none;\" class=\"mceIconOnly\" aria-hidden=\"true\">\\u25BC</span></span>') + '</td>';\r\n\t\t\th += '</tr></tbody></table></span>';\r\n\r\n\t\t\treturn h;\r\n\t\t},\r\n\r\n\t\tshowMenu : function() {\r\n\t\t\tvar t = this, p2, e = DOM.get(this.id), m;\r\n\r\n\t\t\tif (t.isDisabled() || t.items.length == 0)\r\n\t\t\t\treturn;\r\n\r\n\t\t\tif (t.menu && t.menu.isMenuVisible)\r\n\t\t\t\treturn t.hideMenu();\r\n\r\n\t\t\tif (!t.isMenuRendered) {\r\n\t\t\t\tt.renderMenu();\r\n\t\t\t\tt.isMenuRendered = true;\r\n\t\t\t}\r\n\r\n\t\t\tp2 = DOM.getPos(e);\r\n\r\n\t\t\tm = t.menu;\r\n\t\t\tm.settings.offset_x = p2.x;\r\n\t\t\tm.settings.offset_y = p2.y;\r\n\t\t\tm.settings.keyboard_focus = !tinymce.isOpera; // Opera is buggy when it comes to auto focus\r\n\r\n\t\t\t// Select in menu\r\n\t\t\tif (t.oldID)\r\n\t\t\t\tm.items[t.oldID].setSelected(0);\r\n\r\n\t\t\teach(t.items, function(o) {\r\n\t\t\t\tif (o.value === t.selectedValue) {\r\n\t\t\t\t\tm.items[o.id].setSelected(1);\r\n\t\t\t\t\tt.oldID = o.id;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tm.showMenu(0, e.clientHeight);\r\n\r\n\t\t\tEvent.add(DOM.doc, 'mousedown', t.hideMenu, t);\r\n\t\t\tDOM.addClass(t.id, t.classPrefix + 'Selected');\r\n\r\n\t\t\t//DOM.get(t.id + '_text').focus();\r\n\t\t},\r\n\r\n\t\thideMenu : function(e) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\tif (t.menu && t.menu.isMenuVisible) {\r\n\t\t\t\tDOM.removeClass(t.id, t.classPrefix + 'Selected');\r\n\r\n\t\t\t\t// Prevent double toogles by canceling the mouse click event to the button\r\n\t\t\t\tif (e && e.type == \"mousedown\" && (e.target.id == t.id + '_text' || e.target.id == t.id + '_open'))\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\tif (!e || !DOM.getParent(e.target, '.mceMenu')) {\r\n\t\t\t\t\tDOM.removeClass(t.id, t.classPrefix + 'Selected');\r\n\t\t\t\t\tEvent.remove(DOM.doc, 'mousedown', t.hideMenu, t);\r\n\t\t\t\t\tt.menu.hideMenu();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\trenderMenu : function() {\r\n\t\t\tvar t = this, m;\r\n\r\n\t\t\tm = t.settings.control_manager.createDropMenu(t.id + '_menu', {\r\n\t\t\t\tmenu_line : 1,\r\n\t\t\t\t'class' : t.classPrefix + 'Menu mceNoIcons',\r\n\t\t\t\tmax_width : 150,\r\n\t\t\t\tmax_height : 150\r\n\t\t\t});\r\n\r\n\t\t\tm.onHideMenu.add(function() {\r\n\t\t\t\tt.hideMenu();\r\n\t\t\t\tt.focus();\r\n\t\t\t});\r\n\r\n\t\t\tm.add({\r\n\t\t\t\ttitle : t.settings.title,\r\n\t\t\t\t'class' : 'mceMenuItemTitle',\r\n\t\t\t\tonclick : function() {\r\n\t\t\t\t\tif (t.settings.onselect('') !== false)\r\n\t\t\t\t\t\tt.select(''); // Must be runned after\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\teach(t.items, function(o) {\r\n\t\t\t\t// No value then treat it as a title\r\n\t\t\t\tif (o.value === undefined) {\r\n\t\t\t\t\tm.add({\r\n\t\t\t\t\t\ttitle : o.title,\r\n\t\t\t\t\t\trole : \"option\",\r\n\t\t\t\t\t\t'class' : 'mceMenuItemTitle',\r\n\t\t\t\t\t\tonclick : function() {\r\n\t\t\t\t\t\t\tif (t.settings.onselect('') !== false)\r\n\t\t\t\t\t\t\t\tt.select(''); // Must be runned after\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t} else {\r\n\t\t\t\t\to.id = DOM.uniqueId();\r\n\t\t\t\t\to.role= \"option\";\r\n\t\t\t\t\to.onclick = function() {\r\n\t\t\t\t\t\tif (t.settings.onselect(o.value) !== false)\r\n\t\t\t\t\t\t\tt.select(o.value); // Must be runned after\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tm.add(o);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tt.onRenderMenu.dispatch(t, m);\r\n\t\t\tt.menu = m;\r\n\t\t},\r\n\r\n\t\tpostRender : function() {\r\n\t\t\tvar t = this, cp = t.classPrefix;\r\n\r\n\t\t\tEvent.add(t.id, 'click', t.showMenu, t);\r\n\t\t\tEvent.add(t.id, 'keydown', function(evt) {\r\n\t\t\t\tif (evt.keyCode == 32) { // Space\r\n\t\t\t\t\tt.showMenu(evt);\r\n\t\t\t\t\tEvent.cancel(evt);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tEvent.add(t.id, 'focus', function() {\r\n\t\t\t\tif (!t._focused) {\r\n\t\t\t\t\tt.keyDownHandler = Event.add(t.id, 'keydown', function(e) {\r\n\t\t\t\t\t\tif (e.keyCode == 40) {\r\n\t\t\t\t\t\t\tt.showMenu();\r\n\t\t\t\t\t\t\tEvent.cancel(e);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t\tt.keyPressHandler = Event.add(t.id, 'keypress', function(e) {\r\n\t\t\t\t\t\tvar v;\r\n\t\t\t\t\t\tif (e.keyCode == 13) {\r\n\t\t\t\t\t\t\t// Fake select on enter\r\n\t\t\t\t\t\t\tv = t.selectedValue;\r\n\t\t\t\t\t\t\tt.selectedValue = null; // Needs to be null to fake change\r\n\t\t\t\t\t\t\tEvent.cancel(e);\r\n\t\t\t\t\t\t\tt.settings.onselect(v);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\tt._focused = 1;\r\n\t\t\t});\r\n\t\t\tEvent.add(t.id, 'blur', function() {\r\n\t\t\t\tEvent.remove(t.id, 'keydown', t.keyDownHandler);\r\n\t\t\t\tEvent.remove(t.id, 'keypress', t.keyPressHandler);\r\n\t\t\t\tt._focused = 0;\r\n\t\t\t});\r\n\r\n\t\t\t// Old IE doesn't have hover on all elements\r\n\t\t\tif (tinymce.isIE6 || !DOM.boxModel) {\r\n\t\t\t\tEvent.add(t.id, 'mouseover', function() {\r\n\t\t\t\t\tif (!DOM.hasClass(t.id, cp + 'Disabled'))\r\n\t\t\t\t\t\tDOM.addClass(t.id, cp + 'Hover');\r\n\t\t\t\t});\r\n\r\n\t\t\t\tEvent.add(t.id, 'mouseout', function() {\r\n\t\t\t\t\tif (!DOM.hasClass(t.id, cp + 'Disabled'))\r\n\t\t\t\t\t\tDOM.removeClass(t.id, cp + 'Hover');\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tt.onPostRender.dispatch(t, DOM.get(t.id));\r\n\t\t},\r\n\r\n\t\tdestroy : function() {\r\n\t\t\tthis.parent();\r\n\r\n\t\t\tEvent.clear(this.id + '_text');\r\n\t\t\tEvent.clear(this.id + '_open');\r\n\t\t}\r\n\t});\r\n})(tinymce);\r\n\r\n(function(tinymce) {\r\n\tvar DOM = tinymce.DOM, Event = tinymce.dom.Event, each = tinymce.each, Dispatcher = tinymce.util.Dispatcher;\r\n\r\n\ttinymce.create('tinymce.ui.NativeListBox:tinymce.ui.ListBox', {\r\n\t\tNativeListBox : function(id, s) {\r\n\t\t\tthis.parent(id, s);\r\n\t\t\tthis.classPrefix = 'mceNativeListBox';\r\n\t\t},\r\n\r\n\t\tsetDisabled : function(s) {\r\n\t\t\tDOM.get(this.id).disabled = s;\r\n\t\t\tthis.setAriaProperty('disabled', s);\r\n\t\t},\r\n\r\n\t\tisDisabled : function() {\r\n\t\t\treturn DOM.get(this.id).disabled;\r\n\t\t},\r\n\r\n\t\tselect : function(va) {\r\n\t\t\tvar t = this, fv, f;\r\n\r\n\t\t\tif (va == undefined)\r\n\t\t\t\treturn t.selectByIndex(-1);\r\n\r\n\t\t\t// Is string or number make function selector\r\n\t\t\tif (va && va.call)\r\n\t\t\t\tf = va;\r\n\t\t\telse {\r\n\t\t\t\tf = function(v) {\r\n\t\t\t\t\treturn v == va;\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\t// Do we need to do something?\r\n\t\t\tif (va != t.selectedValue) {\r\n\t\t\t\t// Find item\r\n\t\t\t\teach(t.items, function(o, i) {\r\n\t\t\t\t\tif (f(o.value)) {\r\n\t\t\t\t\t\tfv = 1;\r\n\t\t\t\t\t\tt.selectByIndex(i);\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\tif (!fv)\r\n\t\t\t\t\tt.selectByIndex(-1);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tselectByIndex : function(idx) {\r\n\t\t\tDOM.get(this.id).selectedIndex = idx + 1;\r\n\t\t\tthis.selectedValue = this.items[idx] ? this.items[idx].value : null;\r\n\t\t},\r\n\r\n\t\tadd : function(n, v, a) {\r\n\t\t\tvar o, t = this;\r\n\r\n\t\t\ta = a || {};\r\n\t\t\ta.value = v;\r\n\r\n\t\t\tif (t.isRendered())\r\n\t\t\t\tDOM.add(DOM.get(this.id), 'option', a, n);\r\n\r\n\t\t\to = {\r\n\t\t\t\ttitle : n,\r\n\t\t\t\tvalue : v,\r\n\t\t\t\tattribs : a\r\n\t\t\t};\r\n\r\n\t\t\tt.items.push(o);\r\n\t\t\tt.onAdd.dispatch(t, o);\r\n\t\t},\r\n\r\n\t\tgetLength : function() {\r\n\t\t\treturn this.items.length;\r\n\t\t},\r\n\r\n\t\trenderHTML : function() {\r\n\t\t\tvar h, t = this;\r\n\r\n\t\t\th = DOM.createHTML('option', {value : ''}, '-- ' + t.settings.title + ' --');\r\n\r\n\t\t\teach(t.items, function(it) {\r\n\t\t\t\th += DOM.createHTML('option', {value : it.value}, it.title);\r\n\t\t\t});\r\n\r\n\t\t\th = DOM.createHTML('select', {id : t.id, 'class' : 'mceNativeListBox', 'aria-labelledby': t.id + '_aria'}, h);\r\n\t\t\th += DOM.createHTML('span', {id : t.id + '_aria', 'style': 'display: none'}, t.settings.title);\r\n\t\t\treturn h;\r\n\t\t},\r\n\r\n\t\tpostRender : function() {\r\n\t\t\tvar t = this, ch, changeListenerAdded = true;\r\n\r\n\t\t\tt.rendered = true;\r\n\r\n\t\t\tfunction onChange(e) {\r\n\t\t\t\tvar v = t.items[e.target.selectedIndex - 1];\r\n\r\n\t\t\t\tif (v && (v = v.value)) {\r\n\t\t\t\t\tt.onChange.dispatch(t, v);\r\n\r\n\t\t\t\t\tif (t.settings.onselect)\r\n\t\t\t\t\t\tt.settings.onselect(v);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tEvent.add(t.id, 'change', onChange);\r\n\r\n\t\t\t// Accessibility keyhandler\r\n\t\t\tEvent.add(t.id, 'keydown', function(e) {\r\n\t\t\t\tvar bf;\r\n\r\n\t\t\t\tEvent.remove(t.id, 'change', ch);\r\n\t\t\t\tchangeListenerAdded = false;\r\n\r\n\t\t\t\tbf = Event.add(t.id, 'blur', function() {\r\n\t\t\t\t\tif (changeListenerAdded) return;\r\n\t\t\t\t\tchangeListenerAdded = true;\r\n\t\t\t\t\tEvent.add(t.id, 'change', onChange);\r\n\t\t\t\t\tEvent.remove(t.id, 'blur', bf);\r\n\t\t\t\t});\r\n\r\n\t\t\t\t//prevent default left and right keys on chrome - so that the keyboard navigation is used.\r\n\t\t\t\tif (tinymce.isWebKit && (e.keyCode==37 ||e.keyCode==39)) {\r\n\t\t\t\t\treturn Event.prevent(e);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (e.keyCode == 13 || e.keyCode == 32) {\r\n\t\t\t\t\tonChange(e);\r\n\t\t\t\t\treturn Event.cancel(e);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tt.onPostRender.dispatch(t, DOM.get(t.id));\r\n\t\t}\r\n\t});\r\n})(tinymce);\r\n\r\n(function(tinymce) {\r\n\tvar DOM = tinymce.DOM, Event = tinymce.dom.Event, each = tinymce.each;\r\n\r\n\ttinymce.create('tinymce.ui.MenuButton:tinymce.ui.Button', {\r\n\t\tMenuButton : function(id, s, ed) {\r\n\t\t\tthis.parent(id, s, ed);\r\n\r\n\t\t\tthis.onRenderMenu = new tinymce.util.Dispatcher(this);\r\n\r\n\t\t\ts.menu_container = s.menu_container || DOM.doc.body;\r\n\t\t},\r\n\r\n\t\tshowMenu : function() {\r\n\t\t\tvar t = this, p1, p2, e = DOM.get(t.id), m;\r\n\r\n\t\t\tif (t.isDisabled())\r\n\t\t\t\treturn;\r\n\r\n\t\t\tif (!t.isMenuRendered) {\r\n\t\t\t\tt.renderMenu();\r\n\t\t\t\tt.isMenuRendered = true;\r\n\t\t\t}\r\n\r\n\t\t\tif (t.isMenuVisible)\r\n\t\t\t\treturn t.hideMenu();\r\n\r\n\t\t\tp1 = DOM.getPos(t.settings.menu_container);\r\n\t\t\tp2 = DOM.getPos(e);\r\n\r\n\t\t\tm = t.menu;\r\n\t\t\tm.settings.offset_x = p2.x;\r\n\t\t\tm.settings.offset_y = p2.y;\r\n\t\t\tm.settings.vp_offset_x = p2.x;\r\n\t\t\tm.settings.vp_offset_y = p2.y;\r\n\t\t\tm.settings.keyboard_focus = t._focused;\r\n\t\t\tm.showMenu(0, e.clientHeight);\r\n\r\n\t\t\tEvent.add(DOM.doc, 'mousedown', t.hideMenu, t);\r\n\t\t\tt.setState('Selected', 1);\r\n\r\n\t\t\tt.isMenuVisible = 1;\r\n\t\t},\r\n\r\n\t\trenderMenu : function() {\r\n\t\t\tvar t = this, m;\r\n\r\n\t\t\tm = t.settings.control_manager.createDropMenu(t.id + '_menu', {\r\n\t\t\t\tmenu_line : 1,\r\n\t\t\t\t'class' : this.classPrefix + 'Menu',\r\n\t\t\t\ticons : t.settings.icons\r\n\t\t\t});\r\n\r\n\t\t\tm.onHideMenu.add(function() {\r\n\t\t\t\tt.hideMenu();\r\n\t\t\t\tt.focus();\r\n\t\t\t});\r\n\r\n\t\t\tt.onRenderMenu.dispatch(t, m);\r\n\t\t\tt.menu = m;\r\n\t\t},\r\n\r\n\t\thideMenu : function(e) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\t// Prevent double toogles by canceling the mouse click event to the button\r\n\t\t\tif (e && e.type == \"mousedown\" && DOM.getParent(e.target, function(e) {return e.id === t.id || e.id === t.id + '_open';}))\r\n\t\t\t\treturn;\r\n\r\n\t\t\tif (!e || !DOM.getParent(e.target, '.mceMenu')) {\r\n\t\t\t\tt.setState('Selected', 0);\r\n\t\t\t\tEvent.remove(DOM.doc, 'mousedown', t.hideMenu, t);\r\n\t\t\t\tif (t.menu)\r\n\t\t\t\t\tt.menu.hideMenu();\r\n\t\t\t}\r\n\r\n\t\t\tt.isMenuVisible = 0;\r\n\t\t},\r\n\r\n\t\tpostRender : function() {\r\n\t\t\tvar t = this, s = t.settings;\r\n\r\n\t\t\tEvent.add(t.id, 'click', function() {\r\n\t\t\t\tif (!t.isDisabled()) {\r\n\t\t\t\t\tif (s.onclick)\r\n\t\t\t\t\t\ts.onclick(t.value);\r\n\r\n\t\t\t\t\tt.showMenu();\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t});\r\n})(tinymce);\r\n\r\n(function(tinymce) {\r\n\tvar DOM = tinymce.DOM, Event = tinymce.dom.Event, each = tinymce.each;\r\n\r\n\ttinymce.create('tinymce.ui.SplitButton:tinymce.ui.MenuButton', {\r\n\t\tSplitButton : function(id, s, ed) {\r\n\t\t\tthis.parent(id, s, ed);\r\n\t\t\tthis.classPrefix = 'mceSplitButton';\r\n\t\t},\r\n\r\n\t\trenderHTML : function() {\r\n\t\t\tvar h, t = this, s = t.settings, h1;\r\n\r\n\t\t\th = '<tbody><tr>';\r\n\r\n\t\t\tif (s.image)\r\n\t\t\t\th1 = DOM.createHTML('img ', {src : s.image, role: 'presentation', 'class' : 'mceAction ' + s['class']});\r\n\t\t\telse\r\n\t\t\t\th1 = DOM.createHTML('span', {'class' : 'mceAction ' + s['class']}, '');\r\n\r\n\t\t\th1 += DOM.createHTML('span', {'class': 'mceVoiceLabel mceIconOnly', id: t.id + '_voice', style: 'display:none;'}, s.title);\r\n\t\t\th += '<td >' + DOM.createHTML('a', {role: 'button', id : t.id + '_action', tabindex: '-1', href : 'javascript:;', 'class' : 'mceAction ' + s['class'], onclick : \"return false;\", onmousedown : 'return false;', title : s.title}, h1) + '</td>';\r\n\r\n\t\t\th1 = DOM.createHTML('span', {'class' : 'mceOpen ' + s['class']}, '<span style=\"display:none;\" class=\"mceIconOnly\" aria-hidden=\"true\">\\u25BC</span>');\r\n\t\t\th += '<td >' + DOM.createHTML('a', {role: 'button', id : t.id + '_open', tabindex: '-1', href : 'javascript:;', 'class' : 'mceOpen ' + s['class'], onclick : \"return false;\", onmousedown : 'return false;', title : s.title}, h1) + '</td>';\r\n\r\n\t\t\th += '</tr></tbody>';\r\n\t\t\th = DOM.createHTML('table', { role: 'presentation',   'class' : 'mceSplitButton mceSplitButtonEnabled ' + s['class'], cellpadding : '0', cellspacing : '0', title : s.title}, h);\r\n\t\t\treturn DOM.createHTML('div', {id : t.id, role: 'button', tabindex: '0', 'aria-labelledby': t.id + '_voice', 'aria-haspopup': 'true'}, h);\r\n\t\t},\r\n\r\n\t\tpostRender : function() {\r\n\t\t\tvar t = this, s = t.settings, activate;\r\n\r\n\t\t\tif (s.onclick) {\r\n\t\t\t\tactivate = function(evt) {\r\n\t\t\t\t\tif (!t.isDisabled()) {\r\n\t\t\t\t\t\ts.onclick(t.value);\r\n\t\t\t\t\t\tEvent.cancel(evt);\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t\tEvent.add(t.id + '_action', 'click', activate);\r\n\t\t\t\tEvent.add(t.id, ['click', 'keydown'], function(evt) {\r\n\t\t\t\t\tvar DOM_VK_SPACE = 32, DOM_VK_ENTER = 14, DOM_VK_RETURN = 13, DOM_VK_UP = 38, DOM_VK_DOWN = 40;\r\n\t\t\t\t\tif ((evt.keyCode === 32 || evt.keyCode === 13 || evt.keyCode === 14) && !evt.altKey && !evt.ctrlKey && !evt.metaKey) {\r\n\t\t\t\t\t\tactivate();\r\n\t\t\t\t\t\tEvent.cancel(evt);\r\n\t\t\t\t\t} else if (evt.type === 'click' || evt.keyCode === DOM_VK_DOWN) {\r\n\t\t\t\t\t\tt.showMenu();\r\n\t\t\t\t\t\tEvent.cancel(evt);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tEvent.add(t.id + '_open', 'click', function (evt) {\r\n\t\t\t\tt.showMenu();\r\n\t\t\t\tEvent.cancel(evt);\r\n\t\t\t});\r\n\t\t\tEvent.add([t.id, t.id + '_open'], 'focus', function() {t._focused = 1;});\r\n\t\t\tEvent.add([t.id, t.id + '_open'], 'blur', function() {t._focused = 0;});\r\n\r\n\t\t\t// Old IE doesn't have hover on all elements\r\n\t\t\tif (tinymce.isIE6 || !DOM.boxModel) {\r\n\t\t\t\tEvent.add(t.id, 'mouseover', function() {\r\n\t\t\t\t\tif (!DOM.hasClass(t.id, 'mceSplitButtonDisabled'))\r\n\t\t\t\t\t\tDOM.addClass(t.id, 'mceSplitButtonHover');\r\n\t\t\t\t});\r\n\r\n\t\t\t\tEvent.add(t.id, 'mouseout', function() {\r\n\t\t\t\t\tif (!DOM.hasClass(t.id, 'mceSplitButtonDisabled'))\r\n\t\t\t\t\t\tDOM.removeClass(t.id, 'mceSplitButtonHover');\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tdestroy : function() {\r\n\t\t\tthis.parent();\r\n\r\n\t\t\tEvent.clear(this.id + '_action');\r\n\t\t\tEvent.clear(this.id + '_open');\r\n\t\t\tEvent.clear(this.id);\r\n\t\t}\r\n\t});\r\n})(tinymce);\r\n\r\n(function(tinymce) {\r\n\tvar DOM = tinymce.DOM, Event = tinymce.dom.Event, is = tinymce.is, each = tinymce.each;\r\n\r\n\ttinymce.create('tinymce.ui.ColorSplitButton:tinymce.ui.SplitButton', {\r\n\t\tColorSplitButton : function(id, s, ed) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\tt.parent(id, s, ed);\r\n\r\n\t\t\tt.settings = s = tinymce.extend({\r\n\t\t\t\tcolors : '000000,993300,333300,003300,003366,000080,333399,333333,800000,FF6600,808000,008000,008080,0000FF,666699,808080,FF0000,FF9900,99CC00,339966,33CCCC,3366FF,800080,999999,FF00FF,FFCC00,FFFF00,00FF00,00FFFF,00CCFF,993366,C0C0C0,FF99CC,FFCC99,FFFF99,CCFFCC,CCFFFF,99CCFF,CC99FF,FFFFFF',\r\n\t\t\t\tgrid_width : 8,\r\n\t\t\t\tdefault_color : '#888888'\r\n\t\t\t}, t.settings);\r\n\r\n\t\t\tt.onShowMenu = new tinymce.util.Dispatcher(t);\r\n\r\n\t\t\tt.onHideMenu = new tinymce.util.Dispatcher(t);\r\n\r\n\t\t\tt.value = s.default_color;\r\n\t\t},\r\n\r\n\t\tshowMenu : function() {\r\n\t\t\tvar t = this, r, p, e, p2;\r\n\r\n\t\t\tif (t.isDisabled())\r\n\t\t\t\treturn;\r\n\r\n\t\t\tif (!t.isMenuRendered) {\r\n\t\t\t\tt.renderMenu();\r\n\t\t\t\tt.isMenuRendered = true;\r\n\t\t\t}\r\n\r\n\t\t\tif (t.isMenuVisible)\r\n\t\t\t\treturn t.hideMenu();\r\n\r\n\t\t\te = DOM.get(t.id);\r\n\t\t\tDOM.show(t.id + '_menu');\r\n\t\t\tDOM.addClass(e, 'mceSplitButtonSelected');\r\n\t\t\tp2 = DOM.getPos(e);\r\n\t\t\tDOM.setStyles(t.id + '_menu', {\r\n\t\t\t\tleft : p2.x,\r\n\t\t\t\ttop : p2.y + e.clientHeight,\r\n\t\t\t\tzIndex : 200000\r\n\t\t\t});\r\n\t\t\te = 0;\r\n\r\n\t\t\tEvent.add(DOM.doc, 'mousedown', t.hideMenu, t);\r\n\t\t\tt.onShowMenu.dispatch(t);\r\n\r\n\t\t\tif (t._focused) {\r\n\t\t\t\tt._keyHandler = Event.add(t.id + '_menu', 'keydown', function(e) {\r\n\t\t\t\t\tif (e.keyCode == 27)\r\n\t\t\t\t\t\tt.hideMenu();\r\n\t\t\t\t});\r\n\r\n\t\t\t\tDOM.select('a', t.id + '_menu')[0].focus(); // Select first link\r\n\t\t\t}\r\n\r\n\t\t\tt.isMenuVisible = 1;\r\n\t\t},\r\n\r\n\t\thideMenu : function(e) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\tif (t.isMenuVisible) {\r\n\t\t\t\t// Prevent double toogles by canceling the mouse click event to the button\r\n\t\t\t\tif (e && e.type == \"mousedown\" && DOM.getParent(e.target, function(e) {return e.id === t.id + '_open';}))\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\tif (!e || !DOM.getParent(e.target, '.mceSplitButtonMenu')) {\r\n\t\t\t\t\tDOM.removeClass(t.id, 'mceSplitButtonSelected');\r\n\t\t\t\t\tEvent.remove(DOM.doc, 'mousedown', t.hideMenu, t);\r\n\t\t\t\t\tEvent.remove(t.id + '_menu', 'keydown', t._keyHandler);\r\n\t\t\t\t\tDOM.hide(t.id + '_menu');\r\n\t\t\t\t}\r\n\r\n\t\t\t\tt.isMenuVisible = 0;\r\n\t\t\t\tt.onHideMenu.dispatch();\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\trenderMenu : function() {\r\n\t\t\tvar t = this, m, i = 0, s = t.settings, n, tb, tr, w, context;\r\n\r\n\t\t\tw = DOM.add(s.menu_container, 'div', {role: 'listbox', id : t.id + '_menu', 'class' : s['menu_class'] + ' ' + s['class'], style : 'position:absolute;left:0;top:-1000px;'});\r\n\t\t\tm = DOM.add(w, 'div', {'class' : s['class'] + ' mceSplitButtonMenu'});\r\n\t\t\tDOM.add(m, 'span', {'class' : 'mceMenuLine'});\r\n\r\n\t\t\tn = DOM.add(m, 'table', {role: 'presentation', 'class' : 'mceColorSplitMenu'});\r\n\t\t\ttb = DOM.add(n, 'tbody');\r\n\r\n\t\t\t// Generate color grid\r\n\t\t\ti = 0;\r\n\t\t\teach(is(s.colors, 'array') ? s.colors : s.colors.split(','), function(c) {\r\n\t\t\t\tc = c.replace(/^#/, '');\r\n\r\n\t\t\t\tif (!i--) {\r\n\t\t\t\t\ttr = DOM.add(tb, 'tr');\r\n\t\t\t\t\ti = s.grid_width - 1;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tn = DOM.add(tr, 'td');\r\n\t\t\t\tn = DOM.add(n, 'a', {\r\n\t\t\t\t\trole : 'option',\r\n\t\t\t\t\thref : 'javascript:;',\r\n\t\t\t\t\tstyle : {\r\n\t\t\t\t\t\tbackgroundColor : '#' + c\r\n\t\t\t\t\t},\r\n\t\t\t\t\t'title': t.editor.getLang('colors.' + c, c),\r\n\t\t\t\t\t'data-mce-color' : '#' + c\r\n\t\t\t\t});\r\n\r\n\t\t\t\tif (t.editor.forcedHighContrastMode) {\r\n\t\t\t\t\tn = DOM.add(n, 'canvas', { width: 16, height: 16, 'aria-hidden': 'true' });\r\n\t\t\t\t\tif (n.getContext && (context = n.getContext(\"2d\"))) {\r\n\t\t\t\t\t\tcontext.fillStyle = '#' + c;\r\n\t\t\t\t\t\tcontext.fillRect(0, 0, 16, 16);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// No point leaving a canvas element around if it's not supported for drawing on anyway.\r\n\t\t\t\t\t\tDOM.remove(n);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tif (s.more_colors_func) {\r\n\t\t\t\tn = DOM.add(tb, 'tr');\r\n\t\t\t\tn = DOM.add(n, 'td', {colspan : s.grid_width, 'class' : 'mceMoreColors'});\r\n\t\t\t\tn = DOM.add(n, 'a', {role: 'option', id : t.id + '_more', href : 'javascript:;', onclick : 'return false;', 'class' : 'mceMoreColors'}, s.more_colors_title);\r\n\r\n\t\t\t\tEvent.add(n, 'click', function(e) {\r\n\t\t\t\t\ts.more_colors_func.call(s.more_colors_scope || this);\r\n\t\t\t\t\treturn Event.cancel(e); // Cancel to fix onbeforeunload problem\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tDOM.addClass(m, 'mceColorSplitMenu');\r\n\r\n\t\t\tnew tinymce.ui.KeyboardNavigation({\r\n\t\t\t\troot: t.id + '_menu',\r\n\t\t\t\titems: DOM.select('a', t.id + '_menu'),\r\n\t\t\t\tonCancel: function() {\r\n\t\t\t\t\tt.hideMenu();\r\n\t\t\t\t\tt.focus();\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\t// Prevent IE from scrolling and hindering click to occur #4019\r\n\t\t\tEvent.add(t.id + '_menu', 'mousedown', function(e) {return Event.cancel(e);});\r\n\r\n\t\t\tEvent.add(t.id + '_menu', 'click', function(e) {\r\n\t\t\t\tvar c;\r\n\r\n\t\t\t\te = DOM.getParent(e.target, 'a', tb);\r\n\r\n\t\t\t\tif (e && e.nodeName.toLowerCase() == 'a' && (c = e.getAttribute('data-mce-color')))\r\n\t\t\t\t\tt.setColor(c);\r\n\r\n\t\t\t\treturn Event.cancel(e); // Prevent IE auto save warning\r\n\t\t\t});\r\n\r\n\t\t\treturn w;\r\n\t\t},\r\n\r\n\t\tsetColor : function(c) {\r\n\t\t\tthis.displayColor(c);\r\n\t\t\tthis.hideMenu();\r\n\t\t\tthis.settings.onselect(c);\r\n\t\t},\r\n\r\n\t\tdisplayColor : function(c) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\tDOM.setStyle(t.id + '_preview', 'backgroundColor', c);\r\n\r\n\t\t\tt.value = c;\r\n\t\t},\r\n\r\n\t\tpostRender : function() {\r\n\t\t\tvar t = this, id = t.id;\r\n\r\n\t\t\tt.parent();\r\n\t\t\tDOM.add(id + '_action', 'div', {id : id + '_preview', 'class' : 'mceColorPreview'});\r\n\t\t\tDOM.setStyle(t.id + '_preview', 'backgroundColor', t.value);\r\n\t\t},\r\n\r\n\t\tdestroy : function() {\r\n\t\t\tthis.parent();\r\n\r\n\t\t\tEvent.clear(this.id + '_menu');\r\n\t\t\tEvent.clear(this.id + '_more');\r\n\t\t\tDOM.remove(this.id + '_menu');\r\n\t\t}\r\n\t});\r\n})(tinymce);\r\n\r\n(function(tinymce) {\r\n// Shorten class names\r\nvar dom = tinymce.DOM, each = tinymce.each, Event = tinymce.dom.Event;\r\ntinymce.create('tinymce.ui.ToolbarGroup:tinymce.ui.Container', {\r\n\trenderHTML : function() {\r\n\t\tvar t = this, h = [], controls = t.controls, each = tinymce.each, settings = t.settings;\r\n\r\n\t\th.push('<div id=\"' + t.id + '\" role=\"group\" aria-labelledby=\"' + t.id + '_voice\">');\r\n\t\t//TODO: ACC test this out - adding a role = application for getting the landmarks working well.\r\n\t\th.push(\"<span role='application'>\");\r\n\t\th.push('<span id=\"' + t.id + '_voice\" class=\"mceVoiceLabel\" style=\"display:none;\">' + dom.encode(settings.name) + '</span>');\r\n\t\teach(controls, function(toolbar) {\r\n\t\t\th.push(toolbar.renderHTML());\r\n\t\t});\r\n\t\th.push(\"</span>\");\r\n\t\th.push('</div>');\r\n\r\n\t\treturn h.join('');\r\n\t},\r\n\r\n\tfocus : function() {\r\n\t\tvar t = this;\r\n\t\tdom.get(t.id).focus();\r\n\t},\r\n\r\n\tpostRender : function() {\r\n\t\tvar t = this, items = [];\r\n\r\n\t\teach(t.controls, function(toolbar) {\r\n\t\t\teach (toolbar.controls, function(control) {\r\n\t\t\t\tif (control.id) {\r\n\t\t\t\t\titems.push(control);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t});\r\n\r\n\t\tt.keyNav = new tinymce.ui.KeyboardNavigation({\r\n\t\t\troot: t.id,\r\n\t\t\titems: items,\r\n\t\t\tonCancel: function() {\r\n\t\t\t\t//Move focus if webkit so that navigation back will read the item.\r\n\t\t\t\tif (tinymce.isWebKit) {\r\n\t\t\t\t\tdom.get(t.editor.id+\"_ifr\").focus();\r\n\t\t\t\t}\r\n\t\t\t\tt.editor.focus();\r\n\t\t\t},\r\n\t\t\texcludeFromTabOrder: !t.settings.tab_focus_toolbar\r\n\t\t});\r\n\t},\r\n\r\n\tdestroy : function() {\r\n\t\tvar self = this;\r\n\r\n\t\tself.parent();\r\n\t\tself.keyNav.destroy();\r\n\t\tEvent.clear(self.id);\r\n\t}\r\n});\r\n})(tinymce);\r\n\r\n(function(tinymce) {\r\n// Shorten class names\r\nvar dom = tinymce.DOM, each = tinymce.each;\r\ntinymce.create('tinymce.ui.Toolbar:tinymce.ui.Container', {\r\n\trenderHTML : function() {\r\n\t\tvar t = this, h = '', c, co, s = t.settings, i, pr, nx, cl;\r\n\r\n\t\tcl = t.controls;\r\n\t\tfor (i=0; i<cl.length; i++) {\r\n\t\t\t// Get current control, prev control, next control and if the control is a list box or not\r\n\t\t\tco = cl[i];\r\n\t\t\tpr = cl[i - 1];\r\n\t\t\tnx = cl[i + 1];\r\n\r\n\t\t\t// Add toolbar start\r\n\t\t\tif (i === 0) {\r\n\t\t\t\tc = 'mceToolbarStart';\r\n\r\n\t\t\t\tif (co.Button)\r\n\t\t\t\t\tc += ' mceToolbarStartButton';\r\n\t\t\t\telse if (co.SplitButton)\r\n\t\t\t\t\tc += ' mceToolbarStartSplitButton';\r\n\t\t\t\telse if (co.ListBox)\r\n\t\t\t\t\tc += ' mceToolbarStartListBox';\r\n\r\n\t\t\t\th += dom.createHTML('td', {'class' : c}, dom.createHTML('span', null, '<!-- IE -->'));\r\n\t\t\t}\r\n\r\n\t\t\t// Add toolbar end before list box and after the previous button\r\n\t\t\t// This is to fix the o2k7 editor skins\r\n\t\t\tif (pr && co.ListBox) {\r\n\t\t\t\tif (pr.Button || pr.SplitButton)\r\n\t\t\t\t\th += dom.createHTML('td', {'class' : 'mceToolbarEnd'}, dom.createHTML('span', null, '<!-- IE -->'));\r\n\t\t\t}\r\n\r\n\t\t\t// Render control HTML\r\n\r\n\t\t\t// IE 8 quick fix, needed to propertly generate a hit area for anchors\r\n\t\t\tif (dom.stdMode)\r\n\t\t\t\th += '<td style=\"position: relative\">' + co.renderHTML() + '</td>';\r\n\t\t\telse\r\n\t\t\t\th += '<td>' + co.renderHTML() + '</td>';\r\n\r\n\t\t\t// Add toolbar start after list box and before the next button\r\n\t\t\t// This is to fix the o2k7 editor skins\r\n\t\t\tif (nx && co.ListBox) {\r\n\t\t\t\tif (nx.Button || nx.SplitButton)\r\n\t\t\t\t\th += dom.createHTML('td', {'class' : 'mceToolbarStart'}, dom.createHTML('span', null, '<!-- IE -->'));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tc = 'mceToolbarEnd';\r\n\r\n\t\tif (co.Button)\r\n\t\t\tc += ' mceToolbarEndButton';\r\n\t\telse if (co.SplitButton)\r\n\t\t\tc += ' mceToolbarEndSplitButton';\r\n\t\telse if (co.ListBox)\r\n\t\t\tc += ' mceToolbarEndListBox';\r\n\r\n\t\th += dom.createHTML('td', {'class' : c}, dom.createHTML('span', null, '<!-- IE -->'));\r\n\r\n\t\treturn dom.createHTML('table', {id : t.id, 'class' : 'mceToolbar' + (s['class'] ? ' ' + s['class'] : ''), cellpadding : '0', cellspacing : '0', align : t.settings.align || '', role: 'presentation', tabindex: '-1'}, '<tbody><tr>' + h + '</tr></tbody>');\r\n\t}\r\n});\r\n})(tinymce);\r\n\r\n(function(tinymce) {\r\n\tvar Dispatcher = tinymce.util.Dispatcher, each = tinymce.each;\r\n\r\n\ttinymce.create('tinymce.AddOnManager', {\r\n\t\tAddOnManager : function() {\r\n\t\t\tvar self = this;\r\n\r\n\t\t\tself.items = [];\r\n\t\t\tself.urls = {};\r\n\t\t\tself.lookup = {};\r\n\t\t\tself.onAdd = new Dispatcher(self);\r\n\t\t},\r\n\r\n\t\tget : function(n) {\r\n\t\t\tif (this.lookup[n]) {\r\n\t\t\t\treturn this.lookup[n].instance;\r\n\t\t\t} else {\r\n\t\t\t\treturn undefined;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tdependencies : function(n) {\r\n\t\t\tvar result;\r\n\t\t\tif (this.lookup[n]) {\r\n\t\t\t\tresult = this.lookup[n].dependencies;\r\n\t\t\t}\r\n\t\t\treturn result || [];\r\n\t\t},\r\n\r\n\t\trequireLangPack : function(n) {\r\n\t\t\tvar s = tinymce.settings;\r\n\r\n\t\t\tif (s && s.language && s.language_load !== false)\r\n\t\t\t\ttinymce.ScriptLoader.add(this.urls[n] + '/langs/' + s.language + '.js');\r\n\t\t},\r\n\r\n\t\tadd : function(id, o, dependencies) {\r\n\t\t\tthis.items.push(o);\r\n\t\t\tthis.lookup[id] = {instance:o, dependencies:dependencies};\r\n\t\t\tthis.onAdd.dispatch(this, id, o);\r\n\r\n\t\t\treturn o;\r\n\t\t},\r\n\t\tcreateUrl: function(baseUrl, dep) {\r\n\t\t\tif (typeof dep === \"object\") {\r\n\t\t\t\treturn dep\r\n\t\t\t} else {\r\n\t\t\t\treturn {prefix: baseUrl.prefix, resource: dep, suffix: baseUrl.suffix};\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\taddComponents: function(pluginName, scripts) {\r\n\t\t\tvar pluginUrl = this.urls[pluginName];\r\n\t\t\ttinymce.each(scripts, function(script){\r\n\t\t\t\ttinymce.ScriptLoader.add(pluginUrl+\"/\"+script);\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\tload : function(n, u, cb, s) {\r\n\t\t\tvar t = this, url = u;\r\n\r\n\t\t\tfunction loadDependencies() {\r\n\t\t\t\tvar dependencies = t.dependencies(n);\r\n\t\t\t\ttinymce.each(dependencies, function(dep) {\r\n\t\t\t\t\tvar newUrl = t.createUrl(u, dep);\r\n\t\t\t\t\tt.load(newUrl.resource, newUrl, undefined, undefined);\r\n\t\t\t\t});\r\n\t\t\t\tif (cb) {\r\n\t\t\t\t\tif (s) {\r\n\t\t\t\t\t\tcb.call(s);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tcb.call(tinymce.ScriptLoader);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (t.urls[n])\r\n\t\t\t\treturn;\r\n\t\t\tif (typeof u === \"object\")\r\n\t\t\t\turl = u.prefix + u.resource + u.suffix;\r\n\r\n\t\t\tif (url.indexOf('/') != 0 && url.indexOf('://') == -1)\r\n\t\t\t\turl = tinymce.baseURL + '/' + url;\r\n\r\n\t\t\tt.urls[n] = url.substring(0, url.lastIndexOf('/'));\r\n\r\n\t\t\tif (t.lookup[n]) {\r\n\t\t\t\tloadDependencies();\r\n\t\t\t} else {\r\n\t\t\t\ttinymce.ScriptLoader.add(url, loadDependencies, s);\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\r\n\t// Create plugin and theme managers\r\n\ttinymce.PluginManager = new tinymce.AddOnManager();\r\n\ttinymce.ThemeManager = new tinymce.AddOnManager();\r\n}(tinymce));\r\n\r\n(function(tinymce) {\r\n\t// Shorten names\r\n\tvar each = tinymce.each, extend = tinymce.extend,\r\n\t\tDOM = tinymce.DOM, Event = tinymce.dom.Event,\r\n\t\tThemeManager = tinymce.ThemeManager, PluginManager = tinymce.PluginManager,\r\n\t\texplode = tinymce.explode,\r\n\t\tDispatcher = tinymce.util.Dispatcher, undefined, instanceCounter = 0;\r\n\r\n\t// Setup some URLs where the editor API is located and where the document is\r\n\ttinymce.documentBaseURL = window.location.href.replace(/[\\?#].*$/, '').replace(/[\\/\\\\][^\\/]+$/, '');\r\n\tif (!/[\\/\\\\]$/.test(tinymce.documentBaseURL))\r\n\t\ttinymce.documentBaseURL += '/';\r\n\r\n\ttinymce.baseURL = new tinymce.util.URI(tinymce.documentBaseURL).toAbsolute(tinymce.baseURL);\r\n\r\n\ttinymce.baseURI = new tinymce.util.URI(tinymce.baseURL);\r\n\r\n\t// Add before unload listener\r\n\t// This was required since IE was leaking memory if you added and removed beforeunload listeners\r\n\t// with attachEvent/detatchEvent so this only adds one listener and instances can the attach to the onBeforeUnload event\r\n\ttinymce.onBeforeUnload = new Dispatcher(tinymce);\r\n\r\n\t// Must be on window or IE will leak if the editor is placed in frame or iframe\r\n\tEvent.add(window, 'beforeunload', function(e) {\r\n\t\ttinymce.onBeforeUnload.dispatch(tinymce, e);\r\n\t});\r\n\r\n\ttinymce.onAddEditor = new Dispatcher(tinymce);\r\n\r\n\ttinymce.onRemoveEditor = new Dispatcher(tinymce);\r\n\r\n\ttinymce.EditorManager = extend(tinymce, {\r\n\t\teditors : [],\r\n\r\n\t\ti18n : {},\r\n\r\n\t\tactiveEditor : null,\r\n\r\n\t\tinit : function(s) {\r\n\t\t\tvar t = this, pl, sl = tinymce.ScriptLoader, e, el = [], ed;\r\n\r\n\t\t\tfunction execCallback(se, n, s) {\r\n\t\t\t\tvar f = se[n];\r\n\r\n\t\t\t\tif (!f)\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\tif (tinymce.is(f, 'string')) {\r\n\t\t\t\t\ts = f.replace(/\\.\\w+$/, '');\r\n\t\t\t\t\ts = s ? tinymce.resolve(s) : 0;\r\n\t\t\t\t\tf = tinymce.resolve(f);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn f.apply(s || this, Array.prototype.slice.call(arguments, 2));\r\n\t\t\t};\r\n\r\n\t\t\ts = extend({\r\n\t\t\t\ttheme : \"simple\",\r\n\t\t\t\tlanguage : \"en\"\r\n\t\t\t}, s);\r\n\r\n\t\t\tt.settings = s;\r\n\r\n\t\t\t// Legacy call\r\n\t\t\tEvent.add(document, 'init', function() {\r\n\t\t\t\tvar l, co;\r\n\r\n\t\t\t\texecCallback(s, 'onpageload');\r\n\r\n\t\t\t\tswitch (s.mode) {\r\n\t\t\t\t\tcase \"exact\":\r\n\t\t\t\t\t\tl = s.elements || '';\r\n\r\n\t\t\t\t\t\tif(l.length > 0) {\r\n\t\t\t\t\t\t\teach(explode(l), function(v) {\r\n\t\t\t\t\t\t\t\tif (DOM.get(v)) {\r\n\t\t\t\t\t\t\t\t\ted = new tinymce.Editor(v, s);\r\n\t\t\t\t\t\t\t\t\tel.push(ed);\r\n\t\t\t\t\t\t\t\t\ted.render(1);\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\teach(document.forms, function(f) {\r\n\t\t\t\t\t\t\t\t\t\teach(f.elements, function(e) {\r\n\t\t\t\t\t\t\t\t\t\t\tif (e.name === v) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tv = 'mce_editor_' + instanceCounter++;\r\n\t\t\t\t\t\t\t\t\t\t\t\tDOM.setAttrib(e, 'id', v);\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\ted = new tinymce.Editor(v, s);\r\n\t\t\t\t\t\t\t\t\t\t\t\tel.push(ed);\r\n\t\t\t\t\t\t\t\t\t\t\t\ted.render(1);\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase \"textareas\":\r\n\t\t\t\t\tcase \"specific_textareas\":\r\n\t\t\t\t\t\tfunction hasClass(n, c) {\r\n\t\t\t\t\t\t\treturn c.constructor === RegExp ? c.test(n.className) : DOM.hasClass(n, c);\r\n\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\teach(DOM.select('textarea'), function(v) {\r\n\t\t\t\t\t\t\tif (s.editor_deselector && hasClass(v, s.editor_deselector))\r\n\t\t\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t\t\tif (!s.editor_selector || hasClass(v, s.editor_selector)) {\r\n\t\t\t\t\t\t\t\t// Can we use the name\r\n\t\t\t\t\t\t\t\te = DOM.get(v.name);\r\n\t\t\t\t\t\t\t\tif (!v.id && !e)\r\n\t\t\t\t\t\t\t\t\tv.id = v.name;\r\n\r\n\t\t\t\t\t\t\t\t// Generate unique name if missing or already exists\r\n\t\t\t\t\t\t\t\tif (!v.id || t.get(v.id))\r\n\t\t\t\t\t\t\t\t\tv.id = DOM.uniqueId();\r\n\r\n\t\t\t\t\t\t\t\ted = new tinymce.Editor(v.id, s);\r\n\t\t\t\t\t\t\t\tel.push(ed);\r\n\t\t\t\t\t\t\t\ted.render(1);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Call onInit when all editors are initialized\r\n\t\t\t\tif (s.oninit) {\r\n\t\t\t\t\tl = co = 0;\r\n\r\n\t\t\t\t\teach(el, function(ed) {\r\n\t\t\t\t\t\tco++;\r\n\r\n\t\t\t\t\t\tif (!ed.initialized) {\r\n\t\t\t\t\t\t\t// Wait for it\r\n\t\t\t\t\t\t\ted.onInit.add(function() {\r\n\t\t\t\t\t\t\t\tl++;\r\n\r\n\t\t\t\t\t\t\t\t// All done\r\n\t\t\t\t\t\t\t\tif (l == co)\r\n\t\t\t\t\t\t\t\t\texecCallback(s, 'oninit');\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t} else\r\n\t\t\t\t\t\t\tl++;\r\n\r\n\t\t\t\t\t\t// All done\r\n\t\t\t\t\t\tif (l == co)\r\n\t\t\t\t\t\t\texecCallback(s, 'oninit');\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\tget : function(id) {\r\n\t\t\tif (id === undefined)\r\n\t\t\t\treturn this.editors;\r\n\r\n\t\t\treturn this.editors[id];\r\n\t\t},\r\n\r\n\t\tgetInstanceById : function(id) {\r\n\t\t\treturn this.get(id);\r\n\t\t},\r\n\r\n\t\tadd : function(editor) {\r\n\t\t\tvar self = this, editors = self.editors;\r\n\r\n\t\t\t// Add named and index editor instance\r\n\t\t\teditors[editor.id] = editor;\r\n\t\t\teditors.push(editor);\r\n\r\n\t\t\tself._setActive(editor);\r\n\t\t\tself.onAddEditor.dispatch(self, editor);\r\n\r\n\r\n\t\t\treturn editor;\r\n\t\t},\r\n\r\n\t\tremove : function(editor) {\r\n\t\t\tvar t = this, i, editors = t.editors;\r\n\r\n\t\t\t// Not in the collection\r\n\t\t\tif (!editors[editor.id])\r\n\t\t\t\treturn null;\r\n\r\n\t\t\tdelete editors[editor.id];\r\n\r\n\t\t\tfor (i = 0; i < editors.length; i++) {\r\n\t\t\t\tif (editors[i] == editor) {\r\n\t\t\t\t\teditors.splice(i, 1);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Select another editor since the active one was removed\r\n\t\t\tif (t.activeEditor == editor)\r\n\t\t\t\tt._setActive(editors[0]);\r\n\r\n\t\t\teditor.destroy();\r\n\t\t\tt.onRemoveEditor.dispatch(t, editor);\r\n\r\n\t\t\treturn editor;\r\n\t\t},\r\n\r\n\t\texecCommand : function(c, u, v) {\r\n\t\t\tvar t = this, ed = t.get(v), w;\r\n\r\n\t\t\t// Manager commands\r\n\t\t\tswitch (c) {\r\n\t\t\t\tcase \"mceFocus\":\r\n\t\t\t\t\ted.focus();\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\tcase \"mceAddEditor\":\r\n\t\t\t\tcase \"mceAddControl\":\r\n\t\t\t\t\tif (!t.get(v))\r\n\t\t\t\t\t\tnew tinymce.Editor(v, t.settings).render();\r\n\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\tcase \"mceAddFrameControl\":\r\n\t\t\t\t\tw = v.window;\r\n\r\n\t\t\t\t\t// Add tinyMCE global instance and tinymce namespace to specified window\r\n\t\t\t\t\tw.tinyMCE = tinyMCE;\r\n\t\t\t\t\tw.tinymce = tinymce;\r\n\r\n\t\t\t\t\ttinymce.DOM.doc = w.document;\r\n\t\t\t\t\ttinymce.DOM.win = w;\r\n\r\n\t\t\t\t\ted = new tinymce.Editor(v.element_id, v);\r\n\t\t\t\t\ted.render();\r\n\r\n\t\t\t\t\t// Fix IE memory leaks\r\n\t\t\t\t\tif (tinymce.isIE) {\r\n\t\t\t\t\t\tfunction clr() {\r\n\t\t\t\t\t\t\ted.destroy();\r\n\t\t\t\t\t\t\tw.detachEvent('onunload', clr);\r\n\t\t\t\t\t\t\tw = w.tinyMCE = w.tinymce = null; // IE leak\r\n\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\tw.attachEvent('onunload', clr);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tv.page_window = null;\r\n\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\tcase \"mceRemoveEditor\":\r\n\t\t\t\tcase \"mceRemoveControl\":\r\n\t\t\t\t\tif (ed)\r\n\t\t\t\t\t\ted.remove();\r\n\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\tcase 'mceToggleEditor':\r\n\t\t\t\t\tif (!ed) {\r\n\t\t\t\t\t\tt.execCommand('mceAddControl', 0, v);\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (ed.isHidden())\r\n\t\t\t\t\t\ted.show();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\ted.hide();\r\n\r\n\t\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\t// Run command on active editor\r\n\t\t\tif (t.activeEditor)\r\n\t\t\t\treturn t.activeEditor.execCommand(c, u, v);\r\n\r\n\t\t\treturn false;\r\n\t\t},\r\n\r\n\t\texecInstanceCommand : function(id, c, u, v) {\r\n\t\t\tvar ed = this.get(id);\r\n\r\n\t\t\tif (ed)\r\n\t\t\t\treturn ed.execCommand(c, u, v);\r\n\r\n\t\t\treturn false;\r\n\t\t},\r\n\r\n\t\ttriggerSave : function() {\r\n\t\t\teach(this.editors, function(e) {\r\n\t\t\t\te.save();\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\taddI18n : function(p, o) {\r\n\t\t\tvar lo, i18n = this.i18n;\r\n\r\n\t\t\tif (!tinymce.is(p, 'string')) {\r\n\t\t\t\teach(p, function(o, lc) {\r\n\t\t\t\t\teach(o, function(o, g) {\r\n\t\t\t\t\t\teach(o, function(o, k) {\r\n\t\t\t\t\t\t\tif (g === 'common')\r\n\t\t\t\t\t\t\t\ti18n[lc + '.' + k] = o;\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\ti18n[lc + '.' + g + '.' + k] = o;\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t});\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\teach(o, function(o, k) {\r\n\t\t\t\t\ti18n[p + '.' + k] = o;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t// Private methods\r\n\r\n\t\t_setActive : function(editor) {\r\n\t\t\tthis.selectedInstance = this.activeEditor = editor;\r\n\t\t}\r\n\t});\r\n})(tinymce);\r\n\r\n(function(tinymce) {\r\n\t// Shorten these names\r\n\tvar DOM = tinymce.DOM, Event = tinymce.dom.Event, extend = tinymce.extend,\r\n\t\tDispatcher = tinymce.util.Dispatcher, each = tinymce.each, isGecko = tinymce.isGecko,\r\n\t\tisIE = tinymce.isIE, isWebKit = tinymce.isWebKit, is = tinymce.is,\r\n\t\tThemeManager = tinymce.ThemeManager, PluginManager = tinymce.PluginManager,\r\n\t\tinArray = tinymce.inArray, grep = tinymce.grep, explode = tinymce.explode;\r\n\r\n\ttinymce.create('tinymce.Editor', {\r\n\t\tEditor : function(id, s) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\tt.id = t.editorId = id;\r\n\r\n\t\t\tt.execCommands = {};\r\n\t\t\tt.queryStateCommands = {};\r\n\t\t\tt.queryValueCommands = {};\r\n\r\n\t\t\tt.isNotDirty = false;\r\n\r\n\t\t\tt.plugins = {};\r\n\r\n\t\t\t// Add events to the editor\r\n\t\t\teach([\r\n\t\t\t\t'onPreInit',\r\n\r\n\t\t\t\t'onBeforeRenderUI',\r\n\r\n\t\t\t\t'onPostRender',\r\n\r\n\t\t\t\t'onInit',\r\n\r\n\t\t\t\t'onRemove',\r\n\r\n\t\t\t\t'onActivate',\r\n\r\n\t\t\t\t'onDeactivate',\r\n\r\n\t\t\t\t'onClick',\r\n\r\n\t\t\t\t'onEvent',\r\n\r\n\t\t\t\t'onMouseUp',\r\n\r\n\t\t\t\t'onMouseDown',\r\n\r\n\t\t\t\t'onDblClick',\r\n\r\n\t\t\t\t'onKeyDown',\r\n\r\n\t\t\t\t'onKeyUp',\r\n\r\n\t\t\t\t'onKeyPress',\r\n\r\n\t\t\t\t'onContextMenu',\r\n\r\n\t\t\t\t'onSubmit',\r\n\r\n\t\t\t\t'onReset',\r\n\r\n\t\t\t\t'onPaste',\r\n\r\n\t\t\t\t'onPreProcess',\r\n\r\n\t\t\t\t'onPostProcess',\r\n\r\n\t\t\t\t'onBeforeSetContent',\r\n\r\n\t\t\t\t'onBeforeGetContent',\r\n\r\n\t\t\t\t'onSetContent',\r\n\r\n\t\t\t\t'onGetContent',\r\n\r\n\t\t\t\t'onLoadContent',\r\n\r\n\t\t\t\t'onSaveContent',\r\n\r\n\t\t\t\t'onNodeChange',\r\n\r\n\t\t\t\t'onChange',\r\n\r\n\t\t\t\t'onBeforeExecCommand',\r\n\r\n\t\t\t\t'onExecCommand',\r\n\r\n\t\t\t\t'onUndo',\r\n\r\n\t\t\t\t'onRedo',\r\n\r\n\t\t\t\t'onVisualAid',\r\n\r\n\t\t\t\t'onSetProgressState'\r\n\t\t\t], function(e) {\r\n\t\t\t\tt[e] = new Dispatcher(t);\r\n\t\t\t});\r\n\r\n\t\t\tt.settings = s = extend({\r\n\t\t\t\tid : id,\r\n\t\t\t\tlanguage : 'en',\r\n\t\t\t\tdocs_language : 'en',\r\n\t\t\t\ttheme : 'simple',\r\n\t\t\t\tskin : 'default',\r\n\t\t\t\tdelta_width : 0,\r\n\t\t\t\tdelta_height : 0,\r\n\t\t\t\tpopup_css : '',\r\n\t\t\t\tplugins : '',\r\n\t\t\t\tdocument_base_url : tinymce.documentBaseURL,\r\n\t\t\t\tadd_form_submit_trigger : 1,\r\n\t\t\t\tsubmit_patch : 1,\r\n\t\t\t\tadd_unload_trigger : 1,\r\n\t\t\t\tconvert_urls : 1,\r\n\t\t\t\trelative_urls : 1,\r\n\t\t\t\tremove_script_host : 1,\r\n\t\t\t\ttable_inline_editing : 0,\r\n\t\t\t\tobject_resizing : 1,\r\n\t\t\t\tcleanup : 1,\r\n\t\t\t\taccessibility_focus : 1,\r\n\t\t\t\tcustom_shortcuts : 1,\r\n\t\t\t\tcustom_undo_redo_keyboard_shortcuts : 1,\r\n\t\t\t\tcustom_undo_redo_restore_selection : 1,\r\n\t\t\t\tcustom_undo_redo : 1,\r\n\t\t\t\tdoctype : tinymce.isIE6 ? '<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">' : '<!DOCTYPE>', // Use old doctype on IE 6 to avoid horizontal scroll\r\n\t\t\t\tvisual_table_class : 'mceItemTable',\r\n\t\t\t\tvisual : 1,\r\n\t\t\t\tfont_size_style_values : 'xx-small,x-small,small,medium,large,x-large,xx-large',\r\n\t\t\t\tfont_size_legacy_values : 'xx-small,small,medium,large,x-large,xx-large,300%', // See: http://www.w3.org/TR/CSS2/fonts.html#propdef-font-size\r\n\t\t\t\tapply_source_formatting : 1,\r\n\t\t\t\tdirectionality : 'ltr',\r\n\t\t\t\tforced_root_block : 'p',\r\n\t\t\t\thidden_input : 1,\r\n\t\t\t\tpadd_empty_editor : 1,\r\n\t\t\t\trender_ui : 1,\r\n\t\t\t\tinit_theme : 1,\r\n\t\t\t\tforce_p_newlines : 1,\r\n\t\t\t\tindentation : '30px',\r\n\t\t\t\tkeep_styles : 1,\r\n\t\t\t\tfix_table_elements : 1,\r\n\t\t\t\tinline_styles : 1,\r\n\t\t\t\tconvert_fonts_to_spans : true,\r\n\t\t\t\tindent : 'simple',\r\n\t\t\t\tindent_before : 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,ul,li,area,table,thead,tfoot,tbody,tr',\r\n\t\t\t\tindent_after : 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,ul,li,area,table,thead,tfoot,tbody,tr',\r\n\t\t\t\tvalidate : true,\r\n\t\t\t\tentity_encoding : 'named',\r\n\t\t\t\turl_converter : t.convertURL,\r\n\t\t\t\turl_converter_scope : t,\r\n\t\t\t\tie7_compat : true\r\n\t\t\t}, s);\r\n\r\n\t\t\tt.documentBaseURI = new tinymce.util.URI(s.document_base_url || tinymce.documentBaseURL, {\r\n\t\t\t\tbase_uri : tinyMCE.baseURI\r\n\t\t\t});\r\n\r\n\t\t\tt.baseURI = tinymce.baseURI;\r\n\r\n\t\t\tt.contentCSS = [];\r\n\r\n\t\t\t// Call setup\r\n\t\t\tt.execCallback('setup', t);\r\n\t\t},\r\n\r\n\t\trender : function(nst) {\r\n\t\t\tvar t = this, s = t.settings, id = t.id, sl = tinymce.ScriptLoader;\r\n\r\n\t\t\t// Page is not loaded yet, wait for it\r\n\t\t\tif (!Event.domLoaded) {\r\n\t\t\t\tEvent.add(document, 'init', function() {\r\n\t\t\t\t\tt.render();\r\n\t\t\t\t});\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\ttinyMCE.settings = s;\r\n\r\n\t\t\t// Element not found, then skip initialization\r\n\t\t\tif (!t.getElement())\r\n\t\t\t\treturn;\r\n\r\n\t\t\t// Is a iPad/iPhone and not on iOS5, then skip initialization. We need to sniff\r\n\t\t\t// here since the browser says it has contentEditable support but there is no visible\r\n\t\t\t// caret We will remove this check ones Apple implements full contentEditable support\r\n\t\t\tif (tinymce.isIDevice && !tinymce.isIOS5)\r\n\t\t\t\treturn;\r\n\r\n\t\t\t// Add hidden input for non input elements inside form elements\r\n\t\t\tif (!/TEXTAREA|INPUT/i.test(t.getElement().nodeName) && s.hidden_input && DOM.getParent(id, 'form'))\r\n\t\t\t\tDOM.insertAfter(DOM.create('input', {type : 'hidden', name : id}), id);\r\n\r\n\t\t\tif (tinymce.WindowManager)\r\n\t\t\t\tt.windowManager = new tinymce.WindowManager(t);\r\n\r\n\t\t\tif (s.encoding == 'xml') {\r\n\t\t\t\tt.onGetContent.add(function(ed, o) {\r\n\t\t\t\t\tif (o.save)\r\n\t\t\t\t\t\to.content = DOM.encode(o.content);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tif (s.add_form_submit_trigger) {\r\n\t\t\t\tt.onSubmit.addToTop(function() {\r\n\t\t\t\t\tif (t.initialized) {\r\n\t\t\t\t\t\tt.save();\r\n\t\t\t\t\t\tt.isNotDirty = 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tif (s.add_unload_trigger) {\r\n\t\t\t\tt._beforeUnload = tinyMCE.onBeforeUnload.add(function() {\r\n\t\t\t\t\tif (t.initialized && !t.destroyed && !t.isHidden())\r\n\t\t\t\t\t\tt.save({format : 'raw', no_events : true});\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\ttinymce.addUnload(t.destroy, t);\r\n\r\n\t\t\tif (s.submit_patch) {\r\n\t\t\t\tt.onBeforeRenderUI.add(function() {\r\n\t\t\t\t\tvar n = t.getElement().form;\r\n\r\n\t\t\t\t\tif (!n)\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t// Already patched\r\n\t\t\t\t\tif (n._mceOldSubmit)\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t// Check page uses id=\"submit\" or name=\"submit\" for it's submit button\r\n\t\t\t\t\tif (!n.submit.nodeType && !n.submit.length) {\r\n\t\t\t\t\t\tt.formElement = n;\r\n\t\t\t\t\t\tn._mceOldSubmit = n.submit;\r\n\t\t\t\t\t\tn.submit = function() {\r\n\t\t\t\t\t\t\t// Save all instances\r\n\t\t\t\t\t\t\ttinymce.triggerSave();\r\n\t\t\t\t\t\t\tt.isNotDirty = 1;\r\n\r\n\t\t\t\t\t\t\treturn t.formElement._mceOldSubmit(t.formElement);\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tn = null;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// Load scripts\r\n\t\t\tfunction loadScripts() {\r\n\t\t\t\tif (s.language && s.language_load !== false)\r\n\t\t\t\t\tsl.add(tinymce.baseURL + '/langs/' + s.language + '.js');\r\n\r\n\t\t\t\tif (s.theme && s.theme.charAt(0) != '-' && !ThemeManager.urls[s.theme])\r\n\t\t\t\t\tThemeManager.load(s.theme, 'themes/' + s.theme + '/editor_template' + tinymce.suffix + '.js');\r\n\r\n\t\t\t\teach(explode(s.plugins), function(p) {\r\n\t\t\t\t\tif (p &&!PluginManager.urls[p]) {\r\n\t\t\t\t\t\tif (p.charAt(0) == '-') {\r\n\t\t\t\t\t\t\tp = p.substr(1, p.length);\r\n\t\t\t\t\t\t\tvar dependencies = PluginManager.dependencies(p);\r\n\t\t\t\t\t\t\teach(dependencies, function(dep) {\r\n\t\t\t\t\t\t\t\tvar defaultSettings = {prefix:'plugins/', resource: dep, suffix:'/editor_plugin' + tinymce.suffix + '.js'};\r\n\t\t\t\t\t\t\t\tvar dep = PluginManager.createUrl(defaultSettings, dep);\r\n\t\t\t\t\t\t\t\tPluginManager.load(dep.resource, dep);\r\n\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// Skip safari plugin, since it is removed as of 3.3b1\r\n\t\t\t\t\t\t\tif (p == 'safari') {\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tPluginManager.load(p, {prefix:'plugins/', resource: p, suffix:'/editor_plugin' + tinymce.suffix + '.js'});\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// Init when que is loaded\r\n\t\t\t\tsl.loadQueue(function() {\r\n\t\t\t\t\tif (!t.removed)\r\n\t\t\t\t\t\tt.init();\r\n\t\t\t\t});\r\n\t\t\t};\r\n\r\n\t\t\tloadScripts();\r\n\t\t},\r\n\r\n\t\tinit : function() {\r\n\t\t\tvar n, t = this, s = t.settings, w, h, e = t.getElement(), o, ti, u, bi, bc, re, i, initializedPlugins = [];\r\n\r\n\t\t\ttinymce.add(t);\r\n\r\n\t\t\ts.aria_label = s.aria_label || DOM.getAttrib(e, 'aria-label', t.getLang('aria.rich_text_area'));\r\n\r\n\t\t\tif (s.theme) {\r\n\t\t\t\ts.theme = s.theme.replace(/-/, '');\r\n\t\t\t\to = ThemeManager.get(s.theme);\r\n\t\t\t\tt.theme = new o();\r\n\r\n\t\t\t\tif (t.theme.init && s.init_theme)\r\n\t\t\t\t\tt.theme.init(t, ThemeManager.urls[s.theme] || tinymce.documentBaseURL.replace(/\\/$/, ''));\r\n\t\t\t}\r\n\t\t\tfunction initPlugin(p) {\r\n\t\t\t\tvar c = PluginManager.get(p), u = PluginManager.urls[p] || tinymce.documentBaseURL.replace(/\\/$/, ''), po;\r\n\t\t\t\tif (c && tinymce.inArray(initializedPlugins,p) === -1) {\r\n\t\t\t\t\teach(PluginManager.dependencies(p), function(dep){\r\n\t\t\t\t\t\tinitPlugin(dep);\r\n\t\t\t\t\t});\r\n\t\t\t\t\tpo = new c(t, u);\r\n\r\n\t\t\t\t\tt.plugins[p] = po;\r\n\r\n\t\t\t\t\tif (po.init) {\r\n\t\t\t\t\t\tpo.init(t, u);\r\n\t\t\t\t\t\tinitializedPlugins.push(p);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Create all plugins\r\n\t\t\teach(explode(s.plugins.replace(/\\-/g, '')), initPlugin);\r\n\r\n\t\t\t// Setup popup CSS path(s)\r\n\t\t\tif (s.popup_css !== false) {\r\n\t\t\t\tif (s.popup_css)\r\n\t\t\t\t\ts.popup_css = t.documentBaseURI.toAbsolute(s.popup_css);\r\n\t\t\t\telse\r\n\t\t\t\t\ts.popup_css = t.baseURI.toAbsolute(\"themes/\" + s.theme + \"/skins/\" + s.skin + \"/dialog.css\");\r\n\t\t\t}\r\n\r\n\t\t\tif (s.popup_css_add)\r\n\t\t\t\ts.popup_css += ',' + t.documentBaseURI.toAbsolute(s.popup_css_add);\r\n\r\n\t\t\tt.controlManager = new tinymce.ControlManager(t);\r\n\r\n\t\t\tif (s.custom_undo_redo) {\r\n\t\t\t\tt.onBeforeExecCommand.add(function(ed, cmd, ui, val, a) {\r\n\t\t\t\t\tif (cmd != 'Undo' && cmd != 'Redo' && cmd != 'mceRepaint' && (!a || !a.skip_undo))\r\n\t\t\t\t\t\tt.undoManager.beforeChange();\r\n\t\t\t\t});\r\n\r\n\t\t\t\tt.onExecCommand.add(function(ed, cmd, ui, val, a) {\r\n\t\t\t\t\tif (cmd != 'Undo' && cmd != 'Redo' && cmd != 'mceRepaint' && (!a || !a.skip_undo))\r\n\t\t\t\t\t\tt.undoManager.add();\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tt.onExecCommand.add(function(ed, c) {\r\n\t\t\t\t// Don't refresh the select lists until caret move\r\n\t\t\t\tif (!/^(FontName|FontSize)$/.test(c))\r\n\t\t\t\t\tt.nodeChanged();\r\n\t\t\t});\r\n\r\n\t\t\t// Remove ghost selections on images and tables in Gecko\r\n\t\t\tif (isGecko) {\r\n\t\t\t\tfunction repaint(a, o) {\r\n\t\t\t\t\tif (!o || !o.initial)\r\n\t\t\t\t\t\tt.execCommand('mceRepaint');\r\n\t\t\t\t};\r\n\r\n\t\t\t\tt.onUndo.add(repaint);\r\n\t\t\t\tt.onRedo.add(repaint);\r\n\t\t\t\tt.onSetContent.add(repaint);\r\n\t\t\t}\r\n\r\n\t\t\t// Enables users to override the control factory\r\n\t\t\tt.onBeforeRenderUI.dispatch(t, t.controlManager);\r\n\r\n\t\t\t// Measure box\r\n\t\t\tif (s.render_ui) {\r\n\t\t\t\tw = s.width || e.style.width || e.offsetWidth;\r\n\t\t\t\th = s.height || e.style.height || e.offsetHeight;\r\n\t\t\t\tt.orgDisplay = e.style.display;\r\n\t\t\t\tre = /^[0-9\\.]+(|px)$/i;\r\n\r\n\t\t\t\tif (re.test('' + w))\r\n\t\t\t\t\tw = Math.max(parseInt(w) + (o.deltaWidth || 0), 100);\r\n\r\n\t\t\t\tif (re.test('' + h))\r\n\t\t\t\t\th = Math.max(parseInt(h) + (o.deltaHeight || 0), 100);\r\n\r\n\t\t\t\t// Render UI\r\n\t\t\t\to = t.theme.renderUI({\r\n\t\t\t\t\ttargetNode : e,\r\n\t\t\t\t\twidth : w,\r\n\t\t\t\t\theight : h,\r\n\t\t\t\t\tdeltaWidth : s.delta_width,\r\n\t\t\t\t\tdeltaHeight : s.delta_height\r\n\t\t\t\t});\r\n\r\n\t\t\t\tt.editorContainer = o.editorContainer;\r\n\t\t\t}\r\n\r\n\r\n\t\t\t// User specified a document.domain value\r\n\t\t\tif (document.domain && location.hostname != document.domain)\r\n\t\t\t\ttinymce.relaxedDomain = document.domain;\r\n\r\n\t\t\t// Resize editor\r\n\t\t\tDOM.setStyles(o.sizeContainer || o.editorContainer, {\r\n\t\t\t\twidth : w,\r\n\t\t\t\theight : h\r\n\t\t\t});\r\n\r\n\t\t\t// Load specified content CSS last\r\n\t\t\tif (s.content_css) {\r\n\t\t\t\ttinymce.each(explode(s.content_css), function(u) {\r\n\t\t\t\t\tt.contentCSS.push(t.documentBaseURI.toAbsolute(u));\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\th = (o.iframeHeight || h) + (typeof(h) == 'number' ? (o.deltaHeight || 0) : '');\r\n\t\t\tif (h < 100)\r\n\t\t\t\th = 100;\r\n\r\n\t\t\tt.iframeHTML = s.doctype + '<html><head xmlns=\"http://www.w3.org/1999/xhtml\">';\r\n\r\n\t\t\t// We only need to override paths if we have to\r\n\t\t\t// IE has a bug where it remove site absolute urls to relative ones if this is specified\r\n\t\t\tif (s.document_base_url != tinymce.documentBaseURL)\r\n\t\t\t\tt.iframeHTML += '<base href=\"' + t.documentBaseURI.getURI() + '\" />';\r\n\r\n\t\t\t// IE8 doesn't support carets behind images setting ie7_compat would force IE8+ to run in IE7 compat mode.\r\n\t\t\tif (s.ie7_compat)\r\n\t\t\t\tt.iframeHTML += '<meta http-equiv=\"X-UA-Compatible\" content=\"IE=7\" />';\r\n\t\t\telse\r\n\t\t\t\tt.iframeHTML += '<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />';\r\n\r\n\t\t\tt.iframeHTML += '<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />';\r\n\r\n\t\t\t// Load the CSS by injecting them into the HTML this will reduce \"flicker\"\r\n\t\t\tfor (i = 0; i < t.contentCSS.length; i++) {\r\n\t\t\t\tt.iframeHTML += '<link type=\"text/css\" rel=\"stylesheet\" href=\"' + t.contentCSS[i] + '\" />';\r\n\t\t\t}\r\n\r\n\t\t\tbi = s.body_id || 'tinymce';\r\n\t\t\tif (bi.indexOf('=') != -1) {\r\n\t\t\t\tbi = t.getParam('body_id', '', 'hash');\r\n\t\t\t\tbi = bi[t.id] || bi;\r\n\t\t\t}\r\n\r\n\t\t\tbc = s.body_class || '';\r\n\t\t\tif (bc.indexOf('=') != -1) {\r\n\t\t\t\tbc = t.getParam('body_class', '', 'hash');\r\n\t\t\t\tbc = bc[t.id] || '';\r\n\t\t\t}\r\n\r\n\t\t\tt.iframeHTML += '</head><body id=\"' + bi + '\" class=\"mceContentBody ' + bc + '\"><br></body></html>';\r\n\r\n\t\t\t// Domain relaxing enabled, then set document domain\r\n\t\t\tif (tinymce.relaxedDomain && (isIE || (tinymce.isOpera && parseFloat(opera.version()) < 11))) {\r\n\t\t\t\t// We need to write the contents here in IE since multiple writes messes up refresh button and back button\r\n\t\t\t\tu = 'javascript:(function(){document.open();document.domain=\"' + document.domain + '\";var ed = window.parent.tinyMCE.get(\"' + t.id + '\");document.write(ed.iframeHTML);document.close();ed.setupIframe();})()';\r\n\t\t\t}\r\n\r\n\t\t\t// Create iframe\r\n\t\t\t// TODO: ACC add the appropriate description on this.\r\n\t\t\tn = DOM.add(o.iframeContainer, 'iframe', {\r\n\t\t\t\tid : t.id + \"_ifr\",\r\n\t\t\t\tsrc : u || 'javascript:\"\"', // Workaround for HTTPS warning in IE6/7\r\n\t\t\t\tframeBorder : '0',\r\n\t\t\t\tallowTransparency : \"true\",\r\n\t\t\t\ttitle : s.aria_label,\r\n\t\t\t\tstyle : {\r\n\t\t\t\t\twidth : '100%',\r\n\t\t\t\t\theight : h,\r\n\t\t\t\t\tdisplay : 'block' // Important for Gecko to render the iframe correctly\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tt.contentAreaContainer = o.iframeContainer;\r\n\t\t\tDOM.get(o.editorContainer).style.display = t.orgDisplay;\r\n\t\t\tDOM.get(t.id).style.display = 'none';\r\n\t\t\tDOM.setAttrib(t.id, 'aria-hidden', true);\r\n\r\n\t\t\tif (!tinymce.relaxedDomain || !u)\r\n\t\t\t\tt.setupIframe();\r\n\r\n\t\t\te = n = o = null; // Cleanup\r\n\t\t},\r\n\r\n\t\tsetupIframe : function() {\r\n\t\t\tvar t = this, s = t.settings, e = DOM.get(t.id), d = t.getDoc(), h, b;\r\n\r\n\t\t\t// Setup iframe body\r\n\t\t\tif (!isIE || !tinymce.relaxedDomain) {\r\n\t\t\t\td.open();\r\n\t\t\t\td.write(t.iframeHTML);\r\n\t\t\t\td.close();\r\n\r\n\t\t\t\tif (tinymce.relaxedDomain)\r\n\t\t\t\t\td.domain = tinymce.relaxedDomain;\r\n\t\t\t}\r\n\r\n\t\t\t// It will not steal focus while setting contentEditable\r\n\t\t\tb = t.getBody();\r\n\t\t\tb.disabled = true;\r\n\r\n\t\t\tif (!s.readonly)\r\n\t\t\t\tb.contentEditable = true;\r\n\r\n\t\t\tb.disabled = false;\r\n\r\n\t\t\tt.schema = new tinymce.html.Schema(s);\r\n\r\n\t\t\tt.dom = new tinymce.dom.DOMUtils(t.getDoc(), {\r\n\t\t\t\tkeep_values : true,\r\n\t\t\t\turl_converter : t.convertURL,\r\n\t\t\t\turl_converter_scope : t,\r\n\t\t\t\thex_colors : s.force_hex_style_colors,\r\n\t\t\t\tclass_filter : s.class_filter,\r\n\t\t\t\tupdate_styles : 1,\r\n\t\t\t\tfix_ie_paragraphs : 1,\r\n\t\t\t\tschema : t.schema\r\n\t\t\t});\r\n\r\n\t\t\tt.parser = new tinymce.html.DomParser(s, t.schema);\r\n\r\n\t\t\t// Force anchor names closed, unless the setting \"allow_html_in_named_anchor\" is explicitly included.\r\n\t\t\tif (!t.settings.allow_html_in_named_anchor) {\r\n\t\t\t\tt.parser.addAttributeFilter('name', function(nodes, name) {\r\n\t\t\t\t\tvar i = nodes.length, sibling, prevSibling, parent, node;\r\n\r\n\t\t\t\t\twhile (i--) {\r\n\t\t\t\t\t\tnode = nodes[i];\r\n\t\t\t\t\t\tif (node.name === 'a' && node.firstChild) {\r\n\t\t\t\t\t\t\tparent = node.parent;\r\n\r\n\t\t\t\t\t\t\t// Move children after current node\r\n\t\t\t\t\t\t\tsibling = node.lastChild;\r\n\t\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\t\tprevSibling = sibling.prev;\r\n\t\t\t\t\t\t\t\tparent.insert(sibling, node);\r\n\t\t\t\t\t\t\t\tsibling = prevSibling;\r\n\t\t\t\t\t\t\t} while (sibling);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// Convert src and href into data-mce-src, data-mce-href and data-mce-style\r\n\t\t\tt.parser.addAttributeFilter('src,href,style', function(nodes, name) {\r\n\t\t\t\tvar i = nodes.length, node, dom = t.dom, value, internalName;\r\n\r\n\t\t\t\twhile (i--) {\r\n\t\t\t\t\tnode = nodes[i];\r\n\t\t\t\t\tvalue = node.attr(name);\r\n\t\t\t\t\tinternalName = 'data-mce-' + name;\r\n\r\n\t\t\t\t\t// Add internal attribute if we need to we don't on a refresh of the document\r\n\t\t\t\t\tif (!node.attributes.map[internalName]) {\r\n\t\t\t\t\t\tif (name === \"style\")\r\n\t\t\t\t\t\t\tnode.attr(internalName, dom.serializeStyle(dom.parseStyle(value), node.name));\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tnode.attr(internalName, t.convertURL(value, name, node.name));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\t// Keep scripts from executing\r\n\t\t\tt.parser.addNodeFilter('script', function(nodes, name) {\r\n\t\t\t\tvar i = nodes.length, node;\r\n\r\n\t\t\t\twhile (i--) {\r\n\t\t\t\t\tnode = nodes[i];\r\n\t\t\t\t\tnode.attr('type', 'mce-' + (node.attr('type') || 'text/javascript'));\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tt.parser.addNodeFilter('#cdata', function(nodes, name) {\r\n\t\t\t\tvar i = nodes.length, node;\r\n\r\n\t\t\t\twhile (i--) {\r\n\t\t\t\t\tnode = nodes[i];\r\n\t\t\t\t\tnode.type = 8;\r\n\t\t\t\t\tnode.name = '#comment';\r\n\t\t\t\t\tnode.value = '[CDATA[' + node.value + ']]';\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tt.parser.addNodeFilter('p,h1,h2,h3,h4,h5,h6,div', function(nodes, name) {\r\n\t\t\t\tvar i = nodes.length, node, nonEmptyElements = t.schema.getNonEmptyElements();\r\n\r\n\t\t\t\twhile (i--) {\r\n\t\t\t\t\tnode = nodes[i];\r\n\r\n\t\t\t\t\tif (node.isEmpty(nonEmptyElements))\r\n\t\t\t\t\t\tnode.empty().append(new tinymce.html.Node('br', 1)).shortEnded = true;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tt.serializer = new tinymce.dom.Serializer(s, t.dom, t.schema);\r\n\r\n\t\t\tt.selection = new tinymce.dom.Selection(t.dom, t.getWin(), t.serializer);\r\n\r\n\t\t\tt.formatter = new tinymce.Formatter(this);\r\n\r\n\t\t\t// Register default formats\r\n\t\t\tt.formatter.register({\r\n\t\t\t\talignleft : [\r\n\t\t\t\t\t{selector : 'p,h1,h2,h3,h4,h5,h6,td,th,div,ul,ol,li', styles : {textAlign : 'left'}},\r\n\t\t\t\t\t{selector : 'img,table', collapsed : false, styles : {'float' : 'left'}}\r\n\t\t\t\t],\r\n\r\n\t\t\t\taligncenter : [\r\n\t\t\t\t\t{selector : 'p,h1,h2,h3,h4,h5,h6,td,th,div,ul,ol,li', styles : {textAlign : 'center'}},\r\n\t\t\t\t\t{selector : 'img', collapsed : false, styles : {display : 'block', marginLeft : 'auto', marginRight : 'auto'}},\r\n\t\t\t\t\t{selector : 'table', collapsed : false, styles : {marginLeft : 'auto', marginRight : 'auto'}}\r\n\t\t\t\t],\r\n\r\n\t\t\t\talignright : [\r\n\t\t\t\t\t{selector : 'p,h1,h2,h3,h4,h5,h6,td,th,div,ul,ol,li', styles : {textAlign : 'right'}},\r\n\t\t\t\t\t{selector : 'img,table', collapsed : false, styles : {'float' : 'right'}}\r\n\t\t\t\t],\r\n\r\n\t\t\t\talignfull : [\r\n\t\t\t\t\t{selector : 'p,h1,h2,h3,h4,h5,h6,td,th,div,ul,ol,li', styles : {textAlign : 'justify'}}\r\n\t\t\t\t],\r\n\r\n\t\t\t\tbold : [\r\n\t\t\t\t\t{inline : 'strong', remove : 'all'},\r\n\t\t\t\t\t{inline : 'span', styles : {fontWeight : 'bold'}},\r\n\t\t\t\t\t{inline : 'b', remove : 'all'}\r\n\t\t\t\t],\r\n\r\n\t\t\t\titalic : [\r\n\t\t\t\t\t{inline : 'em', remove : 'all'},\r\n\t\t\t\t\t{inline : 'span', styles : {fontStyle : 'italic'}},\r\n\t\t\t\t\t{inline : 'i', remove : 'all'}\r\n\t\t\t\t],\r\n\r\n\t\t\t\tunderline : [\r\n\t\t\t\t\t{inline : 'span', styles : {textDecoration : 'underline'}, exact : true},\r\n\t\t\t\t\t{inline : 'u', remove : 'all'}\r\n\t\t\t\t],\r\n\r\n\t\t\t\tstrikethrough : [\r\n\t\t\t\t\t{inline : 'span', styles : {textDecoration : 'line-through'}, exact : true},\r\n\t\t\t\t\t{inline : 'strike', remove : 'all'}\r\n\t\t\t\t],\r\n\r\n\t\t\t\tforecolor : {inline : 'span', styles : {color : '%value'}, wrap_links : false},\r\n\t\t\t\thilitecolor : {inline : 'span', styles : {backgroundColor : '%value'}, wrap_links : false},\r\n\t\t\t\tfontname : {inline : 'span', styles : {fontFamily : '%value'}},\r\n\t\t\t\tfontsize : {inline : 'span', styles : {fontSize : '%value'}},\r\n\t\t\t\tfontsize_class : {inline : 'span', attributes : {'class' : '%value'}},\r\n\t\t\t\tblockquote : {block : 'blockquote', wrapper : 1, remove : 'all'},\r\n\t\t\t\tsubscript : {inline : 'sub'},\r\n\t\t\t\tsuperscript : {inline : 'sup'},\r\n\r\n\t\t\t\tlink : {inline : 'a', selector : 'a', remove : 'all', split : true, deep : true,\r\n\t\t\t\t\tonmatch : function(node) {\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tonformat : function(elm, fmt, vars) {\r\n\t\t\t\t\t\teach(vars, function(value, key) {\r\n\t\t\t\t\t\t\tt.dom.setAttrib(elm, key, value);\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\r\n\t\t\t\tremoveformat : [\r\n\t\t\t\t\t{selector : 'b,strong,em,i,font,u,strike', remove : 'all', split : true, expand : false, block_expand : true, deep : true},\r\n\t\t\t\t\t{selector : 'span', attributes : ['style', 'class'], remove : 'empty', split : true, expand : false, deep : true},\r\n\t\t\t\t\t{selector : '*', attributes : ['style', 'class'], split : false, expand : false, deep : true}\r\n\t\t\t\t]\r\n\t\t\t});\r\n\r\n\t\t\t// Register default block formats\r\n\t\t\teach('p h1 h2 h3 h4 h5 h6 div address pre div code dt dd samp'.split(/\\s/), function(name) {\r\n\t\t\t\tt.formatter.register(name, {block : name, remove : 'all'});\r\n\t\t\t});\r\n\r\n\t\t\t// Register user defined formats\r\n\t\t\tt.formatter.register(t.settings.formats);\r\n\r\n\t\t\tt.undoManager = new tinymce.UndoManager(t);\r\n\r\n\t\t\t// Pass through\r\n\t\t\tt.undoManager.onAdd.add(function(um, l) {\r\n\t\t\t\tif (um.hasUndo())\r\n\t\t\t\t\treturn t.onChange.dispatch(t, l, um);\r\n\t\t\t});\r\n\r\n\t\t\tt.undoManager.onUndo.add(function(um, l) {\r\n\t\t\t\treturn t.onUndo.dispatch(t, l, um);\r\n\t\t\t});\r\n\r\n\t\t\tt.undoManager.onRedo.add(function(um, l) {\r\n\t\t\t\treturn t.onRedo.dispatch(t, l, um);\r\n\t\t\t});\r\n\r\n\t\t\tt.forceBlocks = new tinymce.ForceBlocks(t, {\r\n\t\t\t\tforced_root_block : s.forced_root_block\r\n\t\t\t});\r\n\r\n\t\t\tt.editorCommands = new tinymce.EditorCommands(t);\r\n\r\n\t\t\t// Pass through\r\n\t\t\tt.serializer.onPreProcess.add(function(se, o) {\r\n\t\t\t\treturn t.onPreProcess.dispatch(t, o, se);\r\n\t\t\t});\r\n\r\n\t\t\tt.serializer.onPostProcess.add(function(se, o) {\r\n\t\t\t\treturn t.onPostProcess.dispatch(t, o, se);\r\n\t\t\t});\r\n\r\n\t\t\tt.onPreInit.dispatch(t);\r\n\r\n\t\t\tif (!s.gecko_spellcheck)\r\n\t\t\t\tt.getBody().spellcheck = 0;\r\n\r\n\t\t\tif (!s.readonly)\r\n\t\t\t\tt._addEvents();\r\n\r\n\t\t\tt.controlManager.onPostRender.dispatch(t, t.controlManager);\r\n\t\t\tt.onPostRender.dispatch(t);\r\n\r\n\t\t\tt.quirks = new tinymce.util.Quirks(this);\r\n\r\n\t\t\tif (s.directionality)\r\n\t\t\t\tt.getBody().dir = s.directionality;\r\n\r\n\t\t\tif (s.nowrap)\r\n\t\t\t\tt.getBody().style.whiteSpace = \"nowrap\";\r\n\r\n\t\t\tif (s.handle_node_change_callback) {\r\n\t\t\t\tt.onNodeChange.add(function(ed, cm, n) {\r\n\t\t\t\t\tt.execCallback('handle_node_change_callback', t.id, n, -1, -1, true, t.selection.isCollapsed());\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tif (s.save_callback) {\r\n\t\t\t\tt.onSaveContent.add(function(ed, o) {\r\n\t\t\t\t\tvar h = t.execCallback('save_callback', t.id, o.content, t.getBody());\r\n\r\n\t\t\t\t\tif (h)\r\n\t\t\t\t\t\to.content = h;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tif (s.onchange_callback) {\r\n\t\t\t\tt.onChange.add(function(ed, l) {\r\n\t\t\t\t\tt.execCallback('onchange_callback', t, l);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tif (s.protect) {\r\n\t\t\t\tt.onBeforeSetContent.add(function(ed, o) {\r\n\t\t\t\t\tif (s.protect) {\r\n\t\t\t\t\t\teach(s.protect, function(pattern) {\r\n\t\t\t\t\t\t\to.content = o.content.replace(pattern, function(str) {\r\n\t\t\t\t\t\t\t\treturn '<!--mce:protected ' + escape(str) + '-->';\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tif (s.convert_newlines_to_brs) {\r\n\t\t\t\tt.onBeforeSetContent.add(function(ed, o) {\r\n\t\t\t\t\tif (o.initial)\r\n\t\t\t\t\t\to.content = o.content.replace(/\\r?\\n/g, '<br />');\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tif (s.preformatted) {\r\n\t\t\t\tt.onPostProcess.add(function(ed, o) {\r\n\t\t\t\t\to.content = o.content.replace(/^\\s*<pre.*?>/, '');\r\n\t\t\t\t\to.content = o.content.replace(/<\\/pre>\\s*$/, '');\r\n\r\n\t\t\t\t\tif (o.set)\r\n\t\t\t\t\t\to.content = '<pre class=\"mceItemHidden\">' + o.content + '</pre>';\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tif (s.verify_css_classes) {\r\n\t\t\t\tt.serializer.attribValueFilter = function(n, v) {\r\n\t\t\t\t\tvar s, cl;\r\n\r\n\t\t\t\t\tif (n == 'class') {\r\n\t\t\t\t\t\t// Build regexp for classes\r\n\t\t\t\t\t\tif (!t.classesRE) {\r\n\t\t\t\t\t\t\tcl = t.dom.getClasses();\r\n\r\n\t\t\t\t\t\t\tif (cl.length > 0) {\r\n\t\t\t\t\t\t\t\ts = '';\r\n\r\n\t\t\t\t\t\t\t\teach (cl, function(o) {\r\n\t\t\t\t\t\t\t\t\ts += (s ? '|' : '') + o['class'];\r\n\t\t\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t\t\tt.classesRE = new RegExp('(' + s + ')', 'gi');\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn !t.classesRE || /(\\bmceItem\\w+\\b|\\bmceTemp\\w+\\b)/g.test(v) || t.classesRE.test(v) ? v : '';\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn v;\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\tif (s.cleanup_callback) {\r\n\t\t\t\tt.onBeforeSetContent.add(function(ed, o) {\r\n\t\t\t\t\to.content = t.execCallback('cleanup_callback', 'insert_to_editor', o.content, o);\r\n\t\t\t\t});\r\n\r\n\t\t\t\tt.onPreProcess.add(function(ed, o) {\r\n\t\t\t\t\tif (o.set)\r\n\t\t\t\t\t\tt.execCallback('cleanup_callback', 'insert_to_editor_dom', o.node, o);\r\n\r\n\t\t\t\t\tif (o.get)\r\n\t\t\t\t\t\tt.execCallback('cleanup_callback', 'get_from_editor_dom', o.node, o);\r\n\t\t\t\t});\r\n\r\n\t\t\t\tt.onPostProcess.add(function(ed, o) {\r\n\t\t\t\t\tif (o.set)\r\n\t\t\t\t\t\to.content = t.execCallback('cleanup_callback', 'insert_to_editor', o.content, o);\r\n\r\n\t\t\t\t\tif (o.get)\r\n\t\t\t\t\t\to.content = t.execCallback('cleanup_callback', 'get_from_editor', o.content, o);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tif (s.save_callback) {\r\n\t\t\t\tt.onGetContent.add(function(ed, o) {\r\n\t\t\t\t\tif (o.save)\r\n\t\t\t\t\t\to.content = t.execCallback('save_callback', t.id, o.content, t.getBody());\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tif (s.handle_event_callback) {\r\n\t\t\t\tt.onEvent.add(function(ed, e, o) {\r\n\t\t\t\t\tif (t.execCallback('handle_event_callback', e, ed, o) === false)\r\n\t\t\t\t\t\tEvent.cancel(e);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// Add visual aids when new contents is added\r\n\t\t\tt.onSetContent.add(function() {\r\n\t\t\t\tt.addVisual(t.getBody());\r\n\t\t\t});\r\n\r\n\t\t\t// Remove empty contents\r\n\t\t\tif (s.padd_empty_editor) {\r\n\t\t\t\tt.onPostProcess.add(function(ed, o) {\r\n\t\t\t\t\to.content = o.content.replace(/^(<p[^>]*>(&nbsp;|&#160;|\\s|\\u00a0|)<\\/p>[\\r\\n]*|<br \\/>[\\r\\n]*)$/, '');\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tif (isGecko) {\r\n\t\t\t\t// Fix gecko link bug, when a link is placed at the end of block elements there is\r\n\t\t\t\t// no way to move the caret behind the link. This fix adds a bogus br element after the link\r\n\t\t\t\tfunction fixLinks(ed, o) {\r\n\t\t\t\t\teach(ed.dom.select('a'), function(n) {\r\n\t\t\t\t\t\tvar pn = n.parentNode;\r\n\r\n\t\t\t\t\t\tif (ed.dom.isBlock(pn) && pn.lastChild === n)\r\n\t\t\t\t\t\t\ted.dom.add(pn, 'br', {'data-mce-bogus' : 1});\r\n\t\t\t\t\t});\r\n\t\t\t\t};\r\n\r\n\t\t\t\tt.onExecCommand.add(function(ed, cmd) {\r\n\t\t\t\t\tif (cmd === 'CreateLink')\r\n\t\t\t\t\t\tfixLinks(ed);\r\n\t\t\t\t});\r\n\r\n\t\t\t\tt.onSetContent.add(t.selection.onSetContent.add(fixLinks));\r\n\t\t\t}\r\n\r\n\t\t\tt.load({initial : true, format : 'html'});\r\n\t\t\tt.startContent = t.getContent({format : 'raw'});\r\n\t\t\tt.undoManager.add();\r\n\t\t\tt.initialized = true;\r\n\r\n\t\t\tt.onInit.dispatch(t);\r\n\t\t\tt.execCallback('setupcontent_callback', t.id, t.getBody(), t.getDoc());\r\n\t\t\tt.execCallback('init_instance_callback', t);\r\n\t\t\tt.focus(true);\r\n\t\t\tt.nodeChanged({initial : 1});\r\n\r\n\t\t\t// Load specified content CSS last\r\n\t\t\teach(t.contentCSS, function(u) {\r\n\t\t\t\tt.dom.loadCSS(u);\r\n\t\t\t});\r\n\r\n\t\t\t// Handle auto focus\r\n\t\t\tif (s.auto_focus) {\r\n\t\t\t\tsetTimeout(function () {\r\n\t\t\t\t\tvar ed = tinymce.get(s.auto_focus);\r\n\r\n\t\t\t\t\ted.selection.select(ed.getBody(), 1);\r\n\t\t\t\t\ted.selection.collapse(1);\r\n\t\t\t\t\ted.getBody().focus();\r\n\t\t\t\t\ted.getWin().focus();\r\n\t\t\t\t}, 100);\r\n\t\t\t}\r\n\r\n\t\t\te = null;\r\n\t\t},\r\n\r\n\r\n\t\tfocus : function(sf) {\r\n\t\t\tvar oed, t = this, selection = t.selection, ce = t.settings.content_editable, ieRng, controlElm, doc = t.getDoc();\r\n\r\n\t\t\tif (!sf) {\r\n\t\t\t\t// Get selected control element\r\n\t\t\t\tieRng = selection.getRng();\r\n\t\t\t\tif (ieRng.item) {\r\n\t\t\t\t\tcontrolElm = ieRng.item(0);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tt._refreshContentEditable();\r\n\t\t\t\tselection.normalize();\r\n\r\n\t\t\t\t// Is not content editable\r\n\t\t\t\tif (!ce)\r\n\t\t\t\t\tt.getWin().focus();\r\n\r\n\t\t\t\t// Focus the body as well since it's contentEditable\r\n\t\t\t\tif (tinymce.isGecko) {\r\n\t\t\t\t\tt.getBody().focus();\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Restore selected control element\r\n\t\t\t\t// This is needed when for example an image is selected within a\r\n\t\t\t\t// layer a call to focus will then remove the control selection\r\n\t\t\t\tif (controlElm && controlElm.ownerDocument == doc) {\r\n\t\t\t\t\tieRng = doc.body.createControlRange();\r\n\t\t\t\t\tieRng.addElement(controlElm);\r\n\t\t\t\t\tieRng.select();\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif (tinymce.activeEditor != t) {\r\n\t\t\t\tif ((oed = tinymce.activeEditor) != null)\r\n\t\t\t\t\toed.onDeactivate.dispatch(oed, t);\r\n\r\n\t\t\t\tt.onActivate.dispatch(t, oed);\r\n\t\t\t}\r\n\r\n\t\t\ttinymce._setActive(t);\r\n\t\t},\r\n\r\n\t\texecCallback : function(n) {\r\n\t\t\tvar t = this, f = t.settings[n], s;\r\n\r\n\t\t\tif (!f)\r\n\t\t\t\treturn;\r\n\r\n\t\t\t// Look through lookup\r\n\t\t\tif (t.callbackLookup && (s = t.callbackLookup[n])) {\r\n\t\t\t\tf = s.func;\r\n\t\t\t\ts = s.scope;\r\n\t\t\t}\r\n\r\n\t\t\tif (is(f, 'string')) {\r\n\t\t\t\ts = f.replace(/\\.\\w+$/, '');\r\n\t\t\t\ts = s ? tinymce.resolve(s) : 0;\r\n\t\t\t\tf = tinymce.resolve(f);\r\n\t\t\t\tt.callbackLookup = t.callbackLookup || {};\r\n\t\t\t\tt.callbackLookup[n] = {func : f, scope : s};\r\n\t\t\t}\r\n\r\n\t\t\treturn f.apply(s || t, Array.prototype.slice.call(arguments, 1));\r\n\t\t},\r\n\r\n\t\ttranslate : function(s) {\r\n\t\t\tvar c = this.settings.language || 'en', i18n = tinymce.i18n;\r\n\r\n\t\t\tif (!s)\r\n\t\t\t\treturn '';\r\n\r\n\t\t\treturn i18n[c + '.' + s] || s.replace(/{\\#([^}]+)\\}/g, function(a, b) {\r\n\t\t\t\treturn i18n[c + '.' + b] || '{#' + b + '}';\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\tgetLang : function(n, dv) {\r\n\t\t\treturn tinymce.i18n[(this.settings.language || 'en') + '.' + n] || (is(dv) ? dv : '{#' + n + '}');\r\n\t\t},\r\n\r\n\t\tgetParam : function(n, dv, ty) {\r\n\t\t\tvar tr = tinymce.trim, v = is(this.settings[n]) ? this.settings[n] : dv, o;\r\n\r\n\t\t\tif (ty === 'hash') {\r\n\t\t\t\to = {};\r\n\r\n\t\t\t\tif (is(v, 'string')) {\r\n\t\t\t\t\teach(v.indexOf('=') > 0 ? v.split(/[;,](?![^=;,]*(?:[;,]|$))/) : v.split(','), function(v) {\r\n\t\t\t\t\t\tv = v.split('=');\r\n\r\n\t\t\t\t\t\tif (v.length > 1)\r\n\t\t\t\t\t\t\to[tr(v[0])] = tr(v[1]);\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\to[tr(v[0])] = tr(v);\r\n\t\t\t\t\t});\r\n\t\t\t\t} else\r\n\t\t\t\t\to = v;\r\n\r\n\t\t\t\treturn o;\r\n\t\t\t}\r\n\r\n\t\t\treturn v;\r\n\t\t},\r\n\r\n\t\tnodeChanged : function(o) {\r\n\t\t\tvar t = this, s = t.selection, n = s.getStart() || t.getBody();\r\n\r\n\t\t\t// Fix for bug #1896577 it seems that this can not be fired while the editor is loading\r\n\t\t\tif (t.initialized) {\r\n\t\t\t\to = o || {};\r\n\t\t\t\tn = isIE && n.ownerDocument != t.getDoc() ? t.getBody() : n; // Fix for IE initial state\r\n\r\n\t\t\t\t// Get parents and add them to object\r\n\t\t\t\to.parents = [];\r\n\t\t\t\tt.dom.getParent(n, function(node) {\r\n\t\t\t\t\tif (node.nodeName == 'BODY')\r\n\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\to.parents.push(node);\r\n\t\t\t\t});\r\n\r\n\t\t\t\tt.onNodeChange.dispatch(\r\n\t\t\t\t\tt,\r\n\t\t\t\t\to ? o.controlManager || t.controlManager : t.controlManager,\r\n\t\t\t\t\tn,\r\n\t\t\t\t\ts.isCollapsed(),\r\n\t\t\t\t\to\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\taddButton : function(n, s) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\tt.buttons = t.buttons || {};\r\n\t\t\tt.buttons[n] = s;\r\n\t\t},\r\n\r\n\t\taddCommand : function(name, callback, scope) {\r\n\t\t\tthis.execCommands[name] = {func : callback, scope : scope || this};\r\n\t\t},\r\n\r\n\t\taddQueryStateHandler : function(name, callback, scope) {\r\n\t\t\tthis.queryStateCommands[name] = {func : callback, scope : scope || this};\r\n\t\t},\r\n\r\n\t\taddQueryValueHandler : function(name, callback, scope) {\r\n\t\t\tthis.queryValueCommands[name] = {func : callback, scope : scope || this};\r\n\t\t},\r\n\r\n\t\taddShortcut : function(pa, desc, cmd_func, sc) {\r\n\t\t\tvar t = this, c;\r\n\r\n\t\t\tif (!t.settings.custom_shortcuts)\r\n\t\t\t\treturn false;\r\n\r\n\t\t\tt.shortcuts = t.shortcuts || {};\r\n\r\n\t\t\tif (is(cmd_func, 'string')) {\r\n\t\t\t\tc = cmd_func;\r\n\r\n\t\t\t\tcmd_func = function() {\r\n\t\t\t\t\tt.execCommand(c, false, null);\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\tif (is(cmd_func, 'object')) {\r\n\t\t\t\tc = cmd_func;\r\n\r\n\t\t\t\tcmd_func = function() {\r\n\t\t\t\t\tt.execCommand(c[0], c[1], c[2]);\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\teach(explode(pa), function(pa) {\r\n\t\t\t\tvar o = {\r\n\t\t\t\t\tfunc : cmd_func,\r\n\t\t\t\t\tscope : sc || this,\r\n\t\t\t\t\tdesc : desc,\r\n\t\t\t\t\talt : false,\r\n\t\t\t\t\tctrl : false,\r\n\t\t\t\t\tshift : false\r\n\t\t\t\t};\r\n\r\n\t\t\t\teach(explode(pa, '+'), function(v) {\r\n\t\t\t\t\tswitch (v) {\r\n\t\t\t\t\t\tcase 'alt':\r\n\t\t\t\t\t\tcase 'ctrl':\r\n\t\t\t\t\t\tcase 'shift':\r\n\t\t\t\t\t\t\to[v] = true;\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\to.charCode = v.charCodeAt(0);\r\n\t\t\t\t\t\t\to.keyCode = v.toUpperCase().charCodeAt(0);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\tt.shortcuts[(o.ctrl ? 'ctrl' : '') + ',' + (o.alt ? 'alt' : '') + ',' + (o.shift ? 'shift' : '') + ',' + o.keyCode] = o;\r\n\t\t\t});\r\n\r\n\t\t\treturn true;\r\n\t\t},\r\n\r\n\t\texecCommand : function(cmd, ui, val, a) {\r\n\t\t\tvar t = this, s = 0, o, st;\r\n\r\n\t\t\tif (!/^(mceAddUndoLevel|mceEndUndoLevel|mceBeginUndoLevel|mceRepaint|SelectAll)$/.test(cmd) && (!a || !a.skip_focus))\r\n\t\t\t\tt.focus();\r\n\r\n\t\t\to = {};\r\n\t\t\tt.onBeforeExecCommand.dispatch(t, cmd, ui, val, o);\r\n\t\t\tif (o.terminate)\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t// Command callback\r\n\t\t\tif (t.execCallback('execcommand_callback', t.id, t.selection.getNode(), cmd, ui, val)) {\r\n\t\t\t\tt.onExecCommand.dispatch(t, cmd, ui, val, a);\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\t// Registred commands\r\n\t\t\tif (o = t.execCommands[cmd]) {\r\n\t\t\t\tst = o.func.call(o.scope, ui, val);\r\n\r\n\t\t\t\t// Fall through on true\r\n\t\t\t\tif (st !== true) {\r\n\t\t\t\t\tt.onExecCommand.dispatch(t, cmd, ui, val, a);\r\n\t\t\t\t\treturn st;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Plugin commands\r\n\t\t\teach(t.plugins, function(p) {\r\n\t\t\t\tif (p.execCommand && p.execCommand(cmd, ui, val)) {\r\n\t\t\t\t\tt.onExecCommand.dispatch(t, cmd, ui, val, a);\r\n\t\t\t\t\ts = 1;\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tif (s)\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t// Theme commands\r\n\t\t\tif (t.theme && t.theme.execCommand && t.theme.execCommand(cmd, ui, val)) {\r\n\t\t\t\tt.onExecCommand.dispatch(t, cmd, ui, val, a);\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\t// Editor commands\r\n\t\t\tif (t.editorCommands.execCommand(cmd, ui, val)) {\r\n\t\t\t\tt.onExecCommand.dispatch(t, cmd, ui, val, a);\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\t// Browser commands\r\n\t\t\tt.getDoc().execCommand(cmd, ui, val);\r\n\t\t\tt.onExecCommand.dispatch(t, cmd, ui, val, a);\r\n\t\t},\r\n\r\n\t\tqueryCommandState : function(cmd) {\r\n\t\t\tvar t = this, o, s;\r\n\r\n\t\t\t// Is hidden then return undefined\r\n\t\t\tif (t._isHidden())\r\n\t\t\t\treturn;\r\n\r\n\t\t\t// Registred commands\r\n\t\t\tif (o = t.queryStateCommands[cmd]) {\r\n\t\t\t\ts = o.func.call(o.scope);\r\n\r\n\t\t\t\t// Fall though on true\r\n\t\t\t\tif (s !== true)\r\n\t\t\t\t\treturn s;\r\n\t\t\t}\r\n\r\n\t\t\t// Registred commands\r\n\t\t\to = t.editorCommands.queryCommandState(cmd);\r\n\t\t\tif (o !== -1)\r\n\t\t\t\treturn o;\r\n\r\n\t\t\t// Browser commands\r\n\t\t\ttry {\r\n\t\t\t\treturn this.getDoc().queryCommandState(cmd);\r\n\t\t\t} catch (ex) {\r\n\t\t\t\t// Fails sometimes see bug: 1896577\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tqueryCommandValue : function(c) {\r\n\t\t\tvar t = this, o, s;\r\n\r\n\t\t\t// Is hidden then return undefined\r\n\t\t\tif (t._isHidden())\r\n\t\t\t\treturn;\r\n\r\n\t\t\t// Registred commands\r\n\t\t\tif (o = t.queryValueCommands[c]) {\r\n\t\t\t\ts = o.func.call(o.scope);\r\n\r\n\t\t\t\t// Fall though on true\r\n\t\t\t\tif (s !== true)\r\n\t\t\t\t\treturn s;\r\n\t\t\t}\r\n\r\n\t\t\t// Registred commands\r\n\t\t\to = t.editorCommands.queryCommandValue(c);\r\n\t\t\tif (is(o))\r\n\t\t\t\treturn o;\r\n\r\n\t\t\t// Browser commands\r\n\t\t\ttry {\r\n\t\t\t\treturn this.getDoc().queryCommandValue(c);\r\n\t\t\t} catch (ex) {\r\n\t\t\t\t// Fails sometimes see bug: 1896577\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tshow : function() {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\tDOM.show(t.getContainer());\r\n\t\t\tDOM.hide(t.id);\r\n\t\t\tt.load();\r\n\t\t},\r\n\r\n\t\thide : function() {\r\n\t\t\tvar t = this, d = t.getDoc();\r\n\r\n\t\t\t// Fixed bug where IE has a blinking cursor left from the editor\r\n\t\t\tif (isIE && d)\r\n\t\t\t\td.execCommand('SelectAll');\r\n\r\n\t\t\t// We must save before we hide so Safari doesn't crash\r\n\t\t\tt.save();\r\n\t\t\tDOM.hide(t.getContainer());\r\n\t\t\tDOM.setStyle(t.id, 'display', t.orgDisplay);\r\n\t\t},\r\n\r\n\t\tisHidden : function() {\r\n\t\t\treturn !DOM.isHidden(this.id);\r\n\t\t},\r\n\r\n\t\tsetProgressState : function(b, ti, o) {\r\n\t\t\tthis.onSetProgressState.dispatch(this, b, ti, o);\r\n\r\n\t\t\treturn b;\r\n\t\t},\r\n\r\n\t\tload : function(o) {\r\n\t\t\tvar t = this, e = t.getElement(), h;\r\n\r\n\t\t\tif (e) {\r\n\t\t\t\to = o || {};\r\n\t\t\t\to.load = true;\r\n\r\n\t\t\t\t// Double encode existing entities in the value\r\n\t\t\t\th = t.setContent(is(e.value) ? e.value : e.innerHTML, o);\r\n\t\t\t\to.element = e;\r\n\r\n\t\t\t\tif (!o.no_events)\r\n\t\t\t\t\tt.onLoadContent.dispatch(t, o);\r\n\r\n\t\t\t\to.element = e = null;\r\n\r\n\t\t\t\treturn h;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tsave : function(o) {\r\n\t\t\tvar t = this, e = t.getElement(), h, f;\r\n\r\n\t\t\tif (!e || !t.initialized)\r\n\t\t\t\treturn;\r\n\r\n\t\t\to = o || {};\r\n\t\t\to.save = true;\r\n\r\n\t\t\t// Add undo level will trigger onchange event\r\n\t\t\tif (!o.no_events) {\r\n\t\t\t\tt.undoManager.typing = false;\r\n\t\t\t\tt.undoManager.add();\r\n\t\t\t}\r\n\r\n\t\t\to.element = e;\r\n\t\t\th = o.content = t.getContent(o);\r\n\r\n\t\t\tif (!o.no_events)\r\n\t\t\t\tt.onSaveContent.dispatch(t, o);\r\n\r\n\t\t\th = o.content;\r\n\r\n\t\t\tif (!/TEXTAREA|INPUT/i.test(e.nodeName)) {\r\n\t\t\t\te.innerHTML = h;\r\n\r\n\t\t\t\t// Update hidden form element\r\n\t\t\t\tif (f = DOM.getParent(t.id, 'form')) {\r\n\t\t\t\t\teach(f.elements, function(e) {\r\n\t\t\t\t\t\tif (e.name == t.id) {\r\n\t\t\t\t\t\t\te.value = h;\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t} else\r\n\t\t\t\te.value = h;\r\n\r\n\t\t\to.element = e = null;\r\n\r\n\t\t\treturn h;\r\n\t\t},\r\n\r\n\t\tsetContent : function(content, args) {\r\n\t\t\tvar self = this, rootNode, body = self.getBody(), forcedRootBlockName;\r\n\r\n\t\t\t// Setup args object\r\n\t\t\targs = args || {};\r\n\t\t\targs.format = args.format || 'html';\r\n\t\t\targs.set = true;\r\n\t\t\targs.content = content;\r\n\r\n\t\t\t// Do preprocessing\r\n\t\t\tif (!args.no_events)\r\n\t\t\t\tself.onBeforeSetContent.dispatch(self, args);\r\n\r\n\t\t\tcontent = args.content;\r\n\r\n\t\t\t// Padd empty content in Gecko and Safari. Commands will otherwise fail on the content\r\n\t\t\t// It will also be impossible to place the caret in the editor unless there is a BR element present\r\n\t\t\tif (!tinymce.isIE && (content.length === 0 || /^\\s+$/.test(content))) {\r\n\t\t\t\tforcedRootBlockName = self.settings.forced_root_block;\r\n\t\t\t\tif (forcedRootBlockName)\r\n\t\t\t\t\tcontent = '<' + forcedRootBlockName + '><br data-mce-bogus=\"1\"></' + forcedRootBlockName + '>';\r\n\t\t\t\telse\r\n\t\t\t\t\tcontent = '<br data-mce-bogus=\"1\">';\r\n\r\n\t\t\t\tbody.innerHTML = content;\r\n\t\t\t\tself.selection.select(body, true);\r\n\t\t\t\tself.selection.collapse(true);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// Parse and serialize the html\r\n\t\t\tif (args.format !== 'raw') {\r\n\t\t\t\tcontent = new tinymce.html.Serializer({}, self.schema).serialize(\r\n\t\t\t\t\tself.parser.parse(content)\r\n\t\t\t\t);\r\n\t\t\t}\r\n\r\n\t\t\t// Set the new cleaned contents to the editor\r\n\t\t\targs.content = tinymce.trim(content);\r\n\t\t\tself.dom.setHTML(body, args.content);\r\n\r\n\t\t\t// Do post processing\r\n\t\t\tif (!args.no_events)\r\n\t\t\t\tself.onSetContent.dispatch(self, args);\r\n\r\n\t\t\tself.selection.normalize();\r\n\r\n\t\t\treturn args.content;\r\n\t\t},\r\n\r\n\t\tgetContent : function(args) {\r\n\t\t\tvar self = this, content;\r\n\r\n\t\t\t// Setup args object\r\n\t\t\targs = args || {};\r\n\t\t\targs.format = args.format || 'html';\r\n\t\t\targs.get = true;\r\n\r\n\t\t\t// Do preprocessing\r\n\t\t\tif (!args.no_events)\r\n\t\t\t\tself.onBeforeGetContent.dispatch(self, args);\r\n\r\n\t\t\t// Get raw contents or by default the cleaned contents\r\n\t\t\tif (args.format == 'raw')\r\n\t\t\t\tcontent = self.getBody().innerHTML;\r\n\t\t\telse\r\n\t\t\t\tcontent = self.serializer.serialize(self.getBody(), args);\r\n\r\n\t\t\targs.content = tinymce.trim(content);\r\n\r\n\t\t\t// Do post processing\r\n\t\t\tif (!args.no_events)\r\n\t\t\t\tself.onGetContent.dispatch(self, args);\r\n\r\n\t\t\treturn args.content;\r\n\t\t},\r\n\r\n\t\tisDirty : function() {\r\n\t\t\tvar self = this;\r\n\r\n\t\t\treturn tinymce.trim(self.startContent) != tinymce.trim(self.getContent({format : 'raw', no_events : 1})) && !self.isNotDirty;\r\n\t\t},\r\n\r\n\t\tgetContainer : function() {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\tif (!t.container)\r\n\t\t\t\tt.container = DOM.get(t.editorContainer || t.id + '_parent');\r\n\r\n\t\t\treturn t.container;\r\n\t\t},\r\n\r\n\t\tgetContentAreaContainer : function() {\r\n\t\t\treturn this.contentAreaContainer;\r\n\t\t},\r\n\r\n\t\tgetElement : function() {\r\n\t\t\treturn DOM.get(this.settings.content_element || this.id);\r\n\t\t},\r\n\r\n\t\tgetWin : function() {\r\n\t\t\tvar t = this, e;\r\n\r\n\t\t\tif (!t.contentWindow) {\r\n\t\t\t\te = DOM.get(t.id + \"_ifr\");\r\n\r\n\t\t\t\tif (e)\r\n\t\t\t\t\tt.contentWindow = e.contentWindow;\r\n\t\t\t}\r\n\r\n\t\t\treturn t.contentWindow;\r\n\t\t},\r\n\r\n\t\tgetDoc : function() {\r\n\t\t\tvar t = this, w;\r\n\r\n\t\t\tif (!t.contentDocument) {\r\n\t\t\t\tw = t.getWin();\r\n\r\n\t\t\t\tif (w)\r\n\t\t\t\t\tt.contentDocument = w.document;\r\n\t\t\t}\r\n\r\n\t\t\treturn t.contentDocument;\r\n\t\t},\r\n\r\n\t\tgetBody : function() {\r\n\t\t\treturn this.bodyElement || this.getDoc().body;\r\n\t\t},\r\n\r\n\t\tconvertURL : function(u, n, e) {\r\n\t\t\tvar t = this, s = t.settings;\r\n\r\n\t\t\t// Use callback instead\r\n\t\t\tif (s.urlconverter_callback)\r\n\t\t\t\treturn t.execCallback('urlconverter_callback', u, e, true, n);\r\n\r\n\t\t\t// Don't convert link href since thats the CSS files that gets loaded into the editor also skip local file URLs\r\n\t\t\tif (!s.convert_urls || (e && e.nodeName == 'LINK') || u.indexOf('file:') === 0)\r\n\t\t\t\treturn u;\r\n\r\n\t\t\t// Convert to relative\r\n\t\t\tif (s.relative_urls)\r\n\t\t\t\treturn t.documentBaseURI.toRelative(u);\r\n\r\n\t\t\t// Convert to absolute\r\n\t\t\tu = t.documentBaseURI.toAbsolute(u, s.remove_script_host);\r\n\r\n\t\t\treturn u;\r\n\t\t},\r\n\r\n\t\taddVisual : function(e) {\r\n\t\t\tvar t = this, s = t.settings;\r\n\r\n\t\t\te = e || t.getBody();\r\n\r\n\t\t\tif (!is(t.hasVisual))\r\n\t\t\t\tt.hasVisual = s.visual;\r\n\r\n\t\t\teach(t.dom.select('table,a', e), function(e) {\r\n\t\t\t\tvar v;\r\n\r\n\t\t\t\tswitch (e.nodeName) {\r\n\t\t\t\t\tcase 'TABLE':\r\n\t\t\t\t\t\tv = t.dom.getAttrib(e, 'border');\r\n\r\n\t\t\t\t\t\tif (!v || v == '0') {\r\n\t\t\t\t\t\t\tif (t.hasVisual)\r\n\t\t\t\t\t\t\t\tt.dom.addClass(e, s.visual_table_class);\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\tt.dom.removeClass(e, s.visual_table_class);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\tcase 'A':\r\n\t\t\t\t\t\tv = t.dom.getAttrib(e, 'name');\r\n\r\n\t\t\t\t\t\tif (v) {\r\n\t\t\t\t\t\t\tif (t.hasVisual)\r\n\t\t\t\t\t\t\t\tt.dom.addClass(e, 'mceItemAnchor');\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\tt.dom.removeClass(e, 'mceItemAnchor');\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tt.onVisualAid.dispatch(t, e, t.hasVisual);\r\n\t\t},\r\n\r\n\t\tremove : function() {\r\n\t\t\tvar t = this, e = t.getContainer();\r\n\r\n\t\t\tt.removed = 1; // Cancels post remove event execution\r\n\t\t\tt.hide();\r\n\r\n\t\t\tt.execCallback('remove_instance_callback', t);\r\n\t\t\tt.onRemove.dispatch(t);\r\n\r\n\t\t\t// Clear all execCommand listeners this is required to avoid errors if the editor was removed inside another command\r\n\t\t\tt.onExecCommand.listeners = [];\r\n\r\n\t\t\ttinymce.remove(t);\r\n\t\t\tDOM.remove(e);\r\n\t\t},\r\n\r\n\t\tdestroy : function(s) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\t// One time is enough\r\n\t\t\tif (t.destroyed)\r\n\t\t\t\treturn;\r\n\r\n\t\t\tif (!s) {\r\n\t\t\t\ttinymce.removeUnload(t.destroy);\r\n\t\t\t\ttinyMCE.onBeforeUnload.remove(t._beforeUnload);\r\n\r\n\t\t\t\t// Manual destroy\r\n\t\t\t\tif (t.theme && t.theme.destroy)\r\n\t\t\t\t\tt.theme.destroy();\r\n\r\n\t\t\t\t// Destroy controls, selection and dom\r\n\t\t\t\tt.controlManager.destroy();\r\n\t\t\t\tt.selection.destroy();\r\n\t\t\t\tt.dom.destroy();\r\n\r\n\t\t\t\t// Remove all events\r\n\r\n\t\t\t\t// Don't clear the window or document if content editable\r\n\t\t\t\t// is enabled since other instances might still be present\r\n\t\t\t\tif (!t.settings.content_editable) {\r\n\t\t\t\t\tEvent.clear(t.getWin());\r\n\t\t\t\t\tEvent.clear(t.getDoc());\r\n\t\t\t\t}\r\n\r\n\t\t\t\tEvent.clear(t.getBody());\r\n\t\t\t\tEvent.clear(t.formElement);\r\n\t\t\t}\r\n\r\n\t\t\tif (t.formElement) {\r\n\t\t\t\tt.formElement.submit = t.formElement._mceOldSubmit;\r\n\t\t\t\tt.formElement._mceOldSubmit = null;\r\n\t\t\t}\r\n\r\n\t\t\tt.contentAreaContainer = t.formElement = t.container = t.settings.content_element = t.bodyElement = t.contentDocument = t.contentWindow = null;\r\n\r\n\t\t\tif (t.selection)\r\n\t\t\t\tt.selection = t.selection.win = t.selection.dom = t.selection.dom.doc = null;\r\n\r\n\t\t\tt.destroyed = 1;\r\n\t\t},\r\n\r\n\t\t// Internal functions\r\n\r\n\t\t_addEvents : function() {\r\n\t\t\t// 'focus', 'blur', 'dblclick', 'beforedeactivate', submit, reset\r\n\t\t\tvar t = this, i, s = t.settings, dom = t.dom, lo = {\r\n\t\t\t\tmouseup : 'onMouseUp',\r\n\t\t\t\tmousedown : 'onMouseDown',\r\n\t\t\t\tclick : 'onClick',\r\n\t\t\t\tkeyup : 'onKeyUp',\r\n\t\t\t\tkeydown : 'onKeyDown',\r\n\t\t\t\tkeypress : 'onKeyPress',\r\n\t\t\t\tsubmit : 'onSubmit',\r\n\t\t\t\treset : 'onReset',\r\n\t\t\t\tcontextmenu : 'onContextMenu',\r\n\t\t\t\tdblclick : 'onDblClick',\r\n\t\t\t\tpaste : 'onPaste' // Doesn't work in all browsers yet\r\n\t\t\t};\r\n\r\n\t\t\tfunction eventHandler(e, o) {\r\n\t\t\t\tvar ty = e.type;\r\n\r\n\t\t\t\t// Don't fire events when it's removed\r\n\t\t\t\tif (t.removed)\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t// Generic event handler\r\n\t\t\t\tif (t.onEvent.dispatch(t, e, o) !== false) {\r\n\t\t\t\t\t// Specific event handler\r\n\t\t\t\t\tt[lo[e.fakeType || e.type]].dispatch(t, e, o);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\t// Add DOM events\r\n\t\t\teach(lo, function(v, k) {\r\n\t\t\t\tswitch (k) {\r\n\t\t\t\t\tcase 'contextmenu':\r\n\t\t\t\t\t\tdom.bind(t.getDoc(), k, eventHandler);\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'paste':\r\n\t\t\t\t\t\tdom.bind(t.getBody(), k, function(e) {\r\n\t\t\t\t\t\t\teventHandler(e);\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'submit':\r\n\t\t\t\t\tcase 'reset':\r\n\t\t\t\t\t\tdom.bind(t.getElement().form || DOM.getParent(t.id, 'form'), k, eventHandler);\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tdom.bind(s.content_editable ? t.getBody() : t.getDoc(), k, eventHandler);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tdom.bind(s.content_editable ? t.getBody() : (isGecko ? t.getDoc() : t.getWin()), 'focus', function(e) {\r\n\t\t\t\tt.focus(true);\r\n\t\t\t});\r\n\r\n\r\n\t\t\t// Fixes bug where a specified document_base_uri could result in broken images\r\n\t\t\t// This will also fix drag drop of images in Gecko\r\n\t\t\tif (tinymce.isGecko) {\r\n\t\t\t\tdom.bind(t.getDoc(), 'DOMNodeInserted', function(e) {\r\n\t\t\t\t\tvar v;\r\n\r\n\t\t\t\t\te = e.target;\r\n\r\n\t\t\t\t\tif (e.nodeType === 1 && e.nodeName === 'IMG' && (v = e.getAttribute('data-mce-src')))\r\n\t\t\t\t\t\te.src = t.documentBaseURI.toAbsolute(v);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// Set various midas options in Gecko\r\n\t\t\tif (isGecko) {\r\n\t\t\t\tfunction setOpts() {\r\n\t\t\t\t\tvar t = this, d = t.getDoc(), s = t.settings;\r\n\r\n\t\t\t\t\tif (isGecko && !s.readonly) {\r\n\t\t\t\t\t\tt._refreshContentEditable();\r\n\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t// Try new Gecko method\r\n\t\t\t\t\t\t\td.execCommand(\"styleWithCSS\", 0, false);\r\n\t\t\t\t\t\t} catch (ex) {\r\n\t\t\t\t\t\t\t// Use old method\r\n\t\t\t\t\t\t\tif (!t._isHidden())\r\n\t\t\t\t\t\t\t\ttry {d.execCommand(\"useCSS\", 0, true);} catch (ex) {}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (!s.table_inline_editing)\r\n\t\t\t\t\t\t\ttry {d.execCommand('enableInlineTableEditing', false, false);} catch (ex) {}\r\n\r\n\t\t\t\t\t\tif (!s.object_resizing)\r\n\t\t\t\t\t\t\ttry {d.execCommand('enableObjectResizing', false, false);} catch (ex) {}\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\r\n\t\t\t\tt.onBeforeExecCommand.add(setOpts);\r\n\t\t\t\tt.onMouseDown.add(setOpts);\r\n\t\t\t}\r\n\r\n\t\t\t// Add node change handlers\r\n\t\t\tt.onMouseUp.add(t.nodeChanged);\r\n\t\t\t//t.onClick.add(t.nodeChanged);\r\n\t\t\tt.onKeyUp.add(function(ed, e) {\r\n\t\t\t\tvar c = e.keyCode;\r\n\r\n\t\t\t\tif ((c >= 33 && c <= 36) || (c >= 37 && c <= 40) || c == 13 || c == 45 || c == 46 || c == 8 || (tinymce.isMac && (c == 91 || c == 93)) || e.ctrlKey)\r\n\t\t\t\t\tt.nodeChanged();\r\n\t\t\t});\r\n\r\n\r\n\t\t\t// Add block quote deletion handler\r\n\t\t\tt.onKeyDown.add(function(ed, e) {\r\n\t\t\t\t// Was the BACKSPACE key pressed?\r\n\t\t\t\tif (e.keyCode != 8)\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\tvar n = ed.selection.getRng().startContainer;\r\n\t\t\t\tvar offset = ed.selection.getRng().startOffset;\r\n\r\n\t\t\t\twhile (n && n.nodeType && n.nodeType != 1 && n.parentNode)\r\n\t\t\t\t\tn = n.parentNode;\r\n\r\n\t\t\t\t// Is the cursor at the beginning of a blockquote?\r\n\t\t\t\tif (n && n.parentNode && n.parentNode.tagName === 'BLOCKQUOTE' && n.parentNode.firstChild == n && offset == 0) {\r\n\t\t\t\t\t// Remove the blockquote\r\n\t\t\t\t\ted.formatter.toggle('blockquote', null, n.parentNode);\r\n\r\n\t\t\t\t\t// Move the caret to the beginning of n\r\n\t\t\t\t\tvar rng = ed.selection.getRng();\r\n\t\t\t\t\trng.setStart(n, 0);\r\n\t\t\t\t\trng.setEnd(n, 0);\r\n\t\t\t\t\ted.selection.setRng(rng);\r\n\t\t\t\t\ted.selection.collapse(false);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\r\n\r\n\t\t\t// Add reset handler\r\n\t\t\tt.onReset.add(function() {\r\n\t\t\t\tt.setContent(t.startContent, {format : 'raw'});\r\n\t\t\t});\r\n\r\n\t\t\t// Add shortcuts\r\n\t\t\tif (s.custom_shortcuts) {\r\n\t\t\t\tif (s.custom_undo_redo_keyboard_shortcuts) {\r\n\t\t\t\t\tt.addShortcut('ctrl+z', t.getLang('undo_desc'), 'Undo');\r\n\t\t\t\t\tt.addShortcut('ctrl+y', t.getLang('redo_desc'), 'Redo');\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Add default shortcuts for gecko\r\n\t\t\t\tt.addShortcut('ctrl+b', t.getLang('bold_desc'), 'Bold');\r\n\t\t\t\tt.addShortcut('ctrl+i', t.getLang('italic_desc'), 'Italic');\r\n\t\t\t\tt.addShortcut('ctrl+u', t.getLang('underline_desc'), 'Underline');\r\n\r\n\t\t\t\t// BlockFormat shortcuts keys\r\n\t\t\t\tfor (i=1; i<=6; i++)\r\n\t\t\t\t\tt.addShortcut('ctrl+' + i, '', ['FormatBlock', false, 'h' + i]);\r\n\r\n\t\t\t\tt.addShortcut('ctrl+7', '', ['FormatBlock', false, 'p']);\r\n\t\t\t\tt.addShortcut('ctrl+8', '', ['FormatBlock', false, 'div']);\r\n\t\t\t\tt.addShortcut('ctrl+9', '', ['FormatBlock', false, 'address']);\r\n\r\n\t\t\t\tfunction find(e) {\r\n\t\t\t\t\tvar v = null;\r\n\r\n\t\t\t\t\tif (!e.altKey && !e.ctrlKey && !e.metaKey)\r\n\t\t\t\t\t\treturn v;\r\n\r\n\t\t\t\t\teach(t.shortcuts, function(o) {\r\n\t\t\t\t\t\tif (tinymce.isMac && o.ctrl != e.metaKey)\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\telse if (!tinymce.isMac && o.ctrl != e.ctrlKey)\r\n\t\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t\tif (o.alt != e.altKey)\r\n\t\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t\tif (o.shift != e.shiftKey)\r\n\t\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t\tif (e.keyCode == o.keyCode || (e.charCode && e.charCode == o.charCode)) {\r\n\t\t\t\t\t\t\tv = o;\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\treturn v;\r\n\t\t\t\t};\r\n\r\n\t\t\t\tt.onKeyUp.add(function(ed, e) {\r\n\t\t\t\t\tvar o = find(e);\r\n\r\n\t\t\t\t\tif (o)\r\n\t\t\t\t\t\treturn Event.cancel(e);\r\n\t\t\t\t});\r\n\r\n\t\t\t\tt.onKeyPress.add(function(ed, e) {\r\n\t\t\t\t\tvar o = find(e);\r\n\r\n\t\t\t\t\tif (o)\r\n\t\t\t\t\t\treturn Event.cancel(e);\r\n\t\t\t\t});\r\n\r\n\t\t\t\tt.onKeyDown.add(function(ed, e) {\r\n\t\t\t\t\tvar o = find(e);\r\n\r\n\t\t\t\t\tif (o) {\r\n\t\t\t\t\t\to.func.call(o.scope);\r\n\t\t\t\t\t\treturn Event.cancel(e);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tif (tinymce.isIE) {\r\n\t\t\t\t// Fix so resize will only update the width and height attributes not the styles of an image\r\n\t\t\t\t// It will also block mceItemNoResize items\r\n\t\t\t\tdom.bind(t.getDoc(), 'controlselect', function(e) {\r\n\t\t\t\t\tvar re = t.resizeInfo, cb;\r\n\r\n\t\t\t\t\te = e.target;\r\n\r\n\t\t\t\t\t// Don't do this action for non image elements\r\n\t\t\t\t\tif (e.nodeName !== 'IMG')\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\tif (re)\r\n\t\t\t\t\t\tdom.unbind(re.node, re.ev, re.cb);\r\n\r\n\t\t\t\t\tif (!dom.hasClass(e, 'mceItemNoResize')) {\r\n\t\t\t\t\t\tev = 'resizeend';\r\n\t\t\t\t\t\tcb = dom.bind(e, ev, function(e) {\r\n\t\t\t\t\t\t\tvar v;\r\n\r\n\t\t\t\t\t\t\te = e.target;\r\n\r\n\t\t\t\t\t\t\tif (v = dom.getStyle(e, 'width')) {\r\n\t\t\t\t\t\t\t\tdom.setAttrib(e, 'width', v.replace(/[^0-9%]+/g, ''));\r\n\t\t\t\t\t\t\t\tdom.setStyle(e, 'width', '');\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif (v = dom.getStyle(e, 'height')) {\r\n\t\t\t\t\t\t\t\tdom.setAttrib(e, 'height', v.replace(/[^0-9%]+/g, ''));\r\n\t\t\t\t\t\t\t\tdom.setStyle(e, 'height', '');\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tev = 'resizestart';\r\n\t\t\t\t\t\tcb = dom.bind(e, 'resizestart', Event.cancel, Event);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tre = t.resizeInfo = {\r\n\t\t\t\t\t\tnode : e,\r\n\t\t\t\t\t\tev : ev,\r\n\t\t\t\t\t\tcb : cb\r\n\t\t\t\t\t};\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tif (tinymce.isOpera) {\r\n\t\t\t\tt.onClick.add(function(ed, e) {\r\n\t\t\t\t\tEvent.prevent(e);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// Add custom undo/redo handlers\r\n\t\t\tif (s.custom_undo_redo) {\r\n\t\t\t\tfunction addUndo() {\r\n\t\t\t\t\tt.undoManager.typing = false;\r\n\t\t\t\t\tt.undoManager.add();\r\n\t\t\t\t};\r\n\r\n\t\t\t\tdom.bind(t.getDoc(), 'focusout', function(e) {\r\n\t\t\t\t\tif (!t.removed && t.undoManager.typing)\r\n\t\t\t\t\t\taddUndo();\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// Add undo level when contents is drag/dropped within the editor\r\n\t\t\t\tt.dom.bind(t.dom.getRoot(), 'dragend', function(e) {\r\n\t\t\t\t\taddUndo();\r\n\t\t\t\t});\r\n\r\n\t\t\t\tt.onKeyUp.add(function(ed, e) {\r\n\t\t\t\t\tvar keyCode = e.keyCode;\r\n\r\n\t\t\t\t\tif ((keyCode >= 33 && keyCode <= 36) || (keyCode >= 37 && keyCode <= 40) || keyCode == 13 || keyCode == 45 || e.ctrlKey)\r\n\t\t\t\t\t\taddUndo();\r\n\t\t\t\t});\r\n\r\n\t\t\t\tt.onKeyDown.add(function(ed, e) {\r\n\t\t\t\t\tvar keyCode = e.keyCode, sel;\r\n\r\n\t\t\t\t\tif (keyCode == 8) {\r\n\t\t\t\t\t\tsel = t.getDoc().selection;\r\n\r\n\t\t\t\t\t\t// Fix IE control + backspace browser bug\r\n\t\t\t\t\t\tif (sel && sel.createRange && sel.createRange().item) {\r\n\t\t\t\t\t\t\tt.undoManager.beforeChange();\r\n\t\t\t\t\t\t\ted.dom.remove(sel.createRange().item(0));\r\n\t\t\t\t\t\t\taddUndo();\r\n\r\n\t\t\t\t\t\t\treturn Event.cancel(e);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Is caracter positon keys left,right,up,down,home,end,pgdown,pgup,enter\r\n\t\t\t\t\tif ((keyCode >= 33 && keyCode <= 36) || (keyCode >= 37 && keyCode <= 40) || keyCode == 13 || keyCode == 45) {\r\n\t\t\t\t\t\t// Add position before enter key is pressed, used by IE since it still uses the default browser behavior\r\n\t\t\t\t\t\t// Todo: Remove this once we normalize enter behavior on IE\r\n\t\t\t\t\t\tif (tinymce.isIE && keyCode == 13)\r\n\t\t\t\t\t\t\tt.undoManager.beforeChange();\r\n\r\n\t\t\t\t\t\tif (t.undoManager.typing)\r\n\t\t\t\t\t\t\taddUndo();\r\n\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// If key isn't shift,ctrl,alt,capslock,metakey\r\n\t\t\t\t\tif ((keyCode < 16 || keyCode > 20) && keyCode != 224 && keyCode != 91 && !t.undoManager.typing) {\r\n\t\t\t\t\t\tt.undoManager.beforeChange();\r\n\t\t\t\t\t\tt.undoManager.typing = true;\r\n\t\t\t\t\t\tt.undoManager.add();\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\tt.onMouseDown.add(function() {\r\n\t\t\t\t\tif (t.undoManager.typing)\r\n\t\t\t\t\t\taddUndo();\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// Bug fix for FireFox keeping styles from end of selection instead of start.\r\n\t\t\tif (tinymce.isGecko) {\r\n\t\t\t\tfunction getAttributeApplyFunction() {\r\n\t\t\t\t\tvar template = t.dom.getAttribs(t.selection.getStart().cloneNode(false));\r\n\r\n\t\t\t\t\treturn function() {\r\n\t\t\t\t\t\tvar target = t.selection.getStart();\r\n\r\n\t\t\t\t\t\tif (target !== t.getBody()) {\r\n\t\t\t\t\t\t\tt.dom.setAttrib(target, \"style\", null);\r\n\r\n\t\t\t\t\t\t\teach(template, function(attr) {\r\n\t\t\t\t\t\t\t\ttarget.setAttributeNode(attr.cloneNode(true));\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfunction isSelectionAcrossElements() {\r\n\t\t\t\t\tvar s = t.selection;\r\n\r\n\t\t\t\t\treturn !s.isCollapsed() && s.getStart() != s.getEnd();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tt.onKeyPress.add(function(ed, e) {\r\n\t\t\t\t\tvar applyAttributes;\r\n\r\n\t\t\t\t\tif ((e.keyCode == 8 || e.keyCode == 46) && isSelectionAcrossElements()) {\r\n\t\t\t\t\t\tapplyAttributes = getAttributeApplyFunction();\r\n\t\t\t\t\t\tt.getDoc().execCommand('delete', false, null);\r\n\t\t\t\t\t\tapplyAttributes();\r\n\r\n\t\t\t\t\t\treturn Event.cancel(e);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\tt.dom.bind(t.getDoc(), 'cut', function(e) {\r\n\t\t\t\t\tvar applyAttributes;\r\n\r\n\t\t\t\t\tif (isSelectionAcrossElements()) {\r\n\t\t\t\t\t\tapplyAttributes = getAttributeApplyFunction();\r\n\t\t\t\t\t\tt.onKeyUp.addToTop(Event.cancel, Event);\r\n\r\n\t\t\t\t\t\tsetTimeout(function() {\r\n\t\t\t\t\t\t\tapplyAttributes();\r\n\t\t\t\t\t\t\tt.onKeyUp.remove(Event.cancel, Event);\r\n\t\t\t\t\t\t}, 0);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_refreshContentEditable : function() {\r\n\t\t\tvar self = this, body, parent;\r\n\r\n\t\t\t// Check if the editor was hidden and the re-initalize contentEditable mode by removing and adding the body again\r\n\t\t\tif (self._isHidden()) {\r\n\t\t\t\tbody = self.getBody();\r\n\t\t\t\tparent = body.parentNode;\r\n\r\n\t\t\t\tparent.removeChild(body);\r\n\t\t\t\tparent.appendChild(body);\r\n\r\n\t\t\t\tbody.focus();\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_isHidden : function() {\r\n\t\t\tvar s;\r\n\r\n\t\t\tif (!isGecko)\r\n\t\t\t\treturn 0;\r\n\r\n\t\t\t// Weird, wheres that cursor selection?\r\n\t\t\ts = this.selection.getSel();\r\n\t\t\treturn (!s || !s.rangeCount || s.rangeCount == 0);\r\n\t\t}\r\n\t});\r\n})(tinymce);\r\n\r\n(function(tinymce) {\r\n\t// Added for compression purposes\r\n\tvar each = tinymce.each, undefined, TRUE = true, FALSE = false;\r\n\r\n\ttinymce.EditorCommands = function(editor) {\r\n\t\tvar dom = editor.dom,\r\n\t\t\tselection = editor.selection,\r\n\t\t\tcommands = {state: {}, exec : {}, value : {}},\r\n\t\t\tsettings = editor.settings,\r\n\t\t\tformatter = editor.formatter,\r\n\t\t\tbookmark;\r\n\r\n\t\tfunction execCommand(command, ui, value) {\r\n\t\t\tvar func;\r\n\r\n\t\t\tcommand = command.toLowerCase();\r\n\t\t\tif (func = commands.exec[command]) {\r\n\t\t\t\tfunc(command, ui, value);\r\n\t\t\t\treturn TRUE;\r\n\t\t\t}\r\n\r\n\t\t\treturn FALSE;\r\n\t\t};\r\n\r\n\t\tfunction queryCommandState(command) {\r\n\t\t\tvar func;\r\n\r\n\t\t\tcommand = command.toLowerCase();\r\n\t\t\tif (func = commands.state[command])\r\n\t\t\t\treturn func(command);\r\n\r\n\t\t\treturn -1;\r\n\t\t};\r\n\r\n\t\tfunction queryCommandValue(command) {\r\n\t\t\tvar func;\r\n\r\n\t\t\tcommand = command.toLowerCase();\r\n\t\t\tif (func = commands.value[command])\r\n\t\t\t\treturn func(command);\r\n\r\n\t\t\treturn FALSE;\r\n\t\t};\r\n\r\n\t\tfunction addCommands(command_list, type) {\r\n\t\t\ttype = type || 'exec';\r\n\r\n\t\t\teach(command_list, function(callback, command) {\r\n\t\t\t\teach(command.toLowerCase().split(','), function(command) {\r\n\t\t\t\t\tcommands[type][command] = callback;\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t\t// Expose public methods\r\n\t\ttinymce.extend(this, {\r\n\t\t\texecCommand : execCommand,\r\n\t\t\tqueryCommandState : queryCommandState,\r\n\t\t\tqueryCommandValue : queryCommandValue,\r\n\t\t\taddCommands : addCommands\r\n\t\t});\r\n\r\n\t\t// Private methods\r\n\r\n\t\tfunction execNativeCommand(command, ui, value) {\r\n\t\t\tif (ui === undefined)\r\n\t\t\t\tui = FALSE;\r\n\r\n\t\t\tif (value === undefined)\r\n\t\t\t\tvalue = null;\r\n\r\n\t\t\treturn editor.getDoc().execCommand(command, ui, value);\r\n\t\t};\r\n\r\n\t\tfunction isFormatMatch(name) {\r\n\t\t\treturn formatter.match(name);\r\n\t\t};\r\n\r\n\t\tfunction toggleFormat(name, value) {\r\n\t\t\tformatter.toggle(name, value ? {value : value} : undefined);\r\n\t\t};\r\n\r\n\t\tfunction storeSelection(type) {\r\n\t\t\tbookmark = selection.getBookmark(type);\r\n\t\t};\r\n\r\n\t\tfunction restoreSelection() {\r\n\t\t\tselection.moveToBookmark(bookmark);\r\n\t\t};\r\n\r\n\t\t// Add execCommand overrides\r\n\t\taddCommands({\r\n\t\t\t// Ignore these, added for compatibility\r\n\t\t\t'mceResetDesignMode,mceBeginUndoLevel' : function() {},\r\n\r\n\t\t\t// Add undo manager logic\r\n\t\t\t'mceEndUndoLevel,mceAddUndoLevel' : function() {\r\n\t\t\t\teditor.undoManager.add();\r\n\t\t\t},\r\n\r\n\t\t\t'Cut,Copy,Paste' : function(command) {\r\n\t\t\t\tvar doc = editor.getDoc(), failed;\r\n\r\n\t\t\t\t// Try executing the native command\r\n\t\t\t\ttry {\r\n\t\t\t\t\texecNativeCommand(command);\r\n\t\t\t\t} catch (ex) {\r\n\t\t\t\t\t// Command failed\r\n\t\t\t\t\tfailed = TRUE;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Present alert message about clipboard access not being available\r\n\t\t\t\tif (failed || !doc.queryCommandSupported(command)) {\r\n\t\t\t\t\tif (tinymce.isGecko) {\r\n\t\t\t\t\t\teditor.windowManager.confirm(editor.getLang('clipboard_msg'), function(state) {\r\n\t\t\t\t\t\t\tif (state)\r\n\t\t\t\t\t\t\t\topen('http://www.mozilla.org/editor/midasdemo/securityprefs.html', '_blank');\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t} else\r\n\t\t\t\t\t\teditor.windowManager.alert(editor.getLang('clipboard_no_support'));\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\t// Override unlink command\r\n\t\t\tunlink : function(command) {\r\n\t\t\t\tif (selection.isCollapsed())\r\n\t\t\t\t\tselection.select(selection.getNode());\r\n\r\n\t\t\t\texecNativeCommand(command);\r\n\t\t\t\tselection.collapse(FALSE);\r\n\t\t\t},\r\n\r\n\t\t\t// Override justify commands to use the text formatter engine\r\n\t\t\t'JustifyLeft,JustifyCenter,JustifyRight,JustifyFull' : function(command) {\r\n\t\t\t\tvar align = command.substring(7);\r\n\r\n\t\t\t\t// Remove all other alignments first\r\n\t\t\t\teach('left,center,right,full'.split(','), function(name) {\r\n\t\t\t\t\tif (align != name)\r\n\t\t\t\t\t\tformatter.remove('align' + name);\r\n\t\t\t\t});\r\n\r\n\t\t\t\ttoggleFormat('align' + align);\r\n\t\t\t\texecCommand('mceRepaint');\r\n\t\t\t},\r\n\r\n\t\t\t// Override list commands to fix WebKit bug\r\n\t\t\t'InsertUnorderedList,InsertOrderedList' : function(command) {\r\n\t\t\t\tvar listElm, listParent;\r\n\r\n\t\t\t\texecNativeCommand(command);\r\n\r\n\t\t\t\t// WebKit produces lists within block elements so we need to split them\r\n\t\t\t\t// we will replace the native list creation logic to custom logic later on\r\n\t\t\t\t// TODO: Remove this when the list creation logic is removed\r\n\t\t\t\tlistElm = dom.getParent(selection.getNode(), 'ol,ul');\r\n\t\t\t\tif (listElm) {\r\n\t\t\t\t\tlistParent = listElm.parentNode;\r\n\r\n\t\t\t\t\t// If list is within a text block then split that block\r\n\t\t\t\t\tif (/^(H[1-6]|P|ADDRESS|PRE)$/.test(listParent.nodeName)) {\r\n\t\t\t\t\t\tstoreSelection();\r\n\t\t\t\t\t\tdom.split(listParent, listElm);\r\n\t\t\t\t\t\trestoreSelection();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\t// Override commands to use the text formatter engine\r\n\t\t\t'Bold,Italic,Underline,Strikethrough,Superscript,Subscript' : function(command) {\r\n\t\t\t\ttoggleFormat(command);\r\n\t\t\t},\r\n\r\n\t\t\t// Override commands to use the text formatter engine\r\n\t\t\t'ForeColor,HiliteColor,FontName' : function(command, ui, value) {\r\n\t\t\t\ttoggleFormat(command, value);\r\n\t\t\t},\r\n\r\n\t\t\tFontSize : function(command, ui, value) {\r\n\t\t\t\tvar fontClasses, fontSizes;\r\n\r\n\t\t\t\t// Convert font size 1-7 to styles\r\n\t\t\t\tif (value >= 1 && value <= 7) {\r\n\t\t\t\t\tfontSizes = tinymce.explode(settings.font_size_style_values);\r\n\t\t\t\t\tfontClasses = tinymce.explode(settings.font_size_classes);\r\n\r\n\t\t\t\t\tif (fontClasses)\r\n\t\t\t\t\t\tvalue = fontClasses[value - 1] || value;\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tvalue = fontSizes[value - 1] || value;\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttoggleFormat(command, value);\r\n\t\t\t},\r\n\r\n\t\t\tRemoveFormat : function(command) {\r\n\t\t\t\tformatter.remove(command);\r\n\t\t\t},\r\n\r\n\t\t\tmceBlockQuote : function(command) {\r\n\t\t\t\ttoggleFormat('blockquote');\r\n\t\t\t},\r\n\r\n\t\t\tFormatBlock : function(command, ui, value) {\r\n\t\t\t\treturn toggleFormat(value || 'p');\r\n\t\t\t},\r\n\r\n\t\t\tmceCleanup : function() {\r\n\t\t\t\tvar bookmark = selection.getBookmark();\r\n\r\n\t\t\t\teditor.setContent(editor.getContent({cleanup : TRUE}), {cleanup : TRUE});\r\n\r\n\t\t\t\tselection.moveToBookmark(bookmark);\r\n\t\t\t},\r\n\r\n\t\t\tmceRemoveNode : function(command, ui, value) {\r\n\t\t\t\tvar node = value || selection.getNode();\r\n\r\n\t\t\t\t// Make sure that the body node isn't removed\r\n\t\t\t\tif (node != editor.getBody()) {\r\n\t\t\t\t\tstoreSelection();\r\n\t\t\t\t\teditor.dom.remove(node, TRUE);\r\n\t\t\t\t\trestoreSelection();\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\tmceSelectNodeDepth : function(command, ui, value) {\r\n\t\t\t\tvar counter = 0;\r\n\r\n\t\t\t\tdom.getParent(selection.getNode(), function(node) {\r\n\t\t\t\t\tif (node.nodeType == 1 && counter++ == value) {\r\n\t\t\t\t\t\tselection.select(node);\r\n\t\t\t\t\t\treturn FALSE;\r\n\t\t\t\t\t}\r\n\t\t\t\t}, editor.getBody());\r\n\t\t\t},\r\n\r\n\t\t\tmceSelectNode : function(command, ui, value) {\r\n\t\t\t\tselection.select(value);\r\n\t\t\t},\r\n\r\n\t\t\tmceInsertContent : function(command, ui, value) {\r\n\t\t\t\tvar parser, serializer, parentNode, rootNode, fragment, args,\r\n\t\t\t\t\tmarker, nodeRect, viewPortRect, rng, node, node2, bookmarkHtml, viewportBodyElement;\r\n\r\n\t\t\t\t// Setup parser and serializer\r\n\t\t\t\tparser = editor.parser;\r\n\t\t\t\tserializer = new tinymce.html.Serializer({}, editor.schema);\r\n\t\t\t\tbookmarkHtml = '<span id=\"mce_marker\" data-mce-type=\"bookmark\">\\uFEFF</span>';\r\n\r\n\t\t\t\t// Run beforeSetContent handlers on the HTML to be inserted\r\n\t\t\t\targs = {content: value, format: 'html'};\r\n\t\t\t\tselection.onBeforeSetContent.dispatch(selection, args);\r\n\t\t\t\tvalue = args.content;\r\n\r\n\t\t\t\t// Add caret at end of contents if it's missing\r\n\t\t\t\tif (value.indexOf('{$caret}') == -1)\r\n\t\t\t\t\tvalue += '{$caret}';\r\n\r\n\t\t\t\t// Replace the caret marker with a span bookmark element\r\n\t\t\t\tvalue = value.replace(/\\{\\$caret\\}/, bookmarkHtml);\r\n\r\n\t\t\t\t// Insert node maker where we will insert the new HTML and get it's parent\r\n\t\t\t\tif (!selection.isCollapsed())\r\n\t\t\t\t\teditor.getDoc().execCommand('Delete', false, null);\r\n\r\n\t\t\t\tparentNode = selection.getNode();\r\n\r\n\t\t\t\t// Parse the fragment within the context of the parent node\r\n\t\t\t\targs = {context : parentNode.nodeName.toLowerCase()};\r\n\t\t\t\tfragment = parser.parse(value, args);\r\n\r\n\t\t\t\t// Move the caret to a more suitable location\r\n\t\t\t\tnode = fragment.lastChild;\r\n\t\t\t\tif (node.attr('id') == 'mce_marker') {\r\n\t\t\t\t\tmarker = node;\r\n\r\n\t\t\t\t\tfor (node = node.prev; node; node = node.walk(true)) {\r\n\t\t\t\t\t\tif (node.type == 3 || !dom.isBlock(node.name)) {\r\n\t\t\t\t\t\t\tnode.parent.insert(marker, node, node.name === 'br');\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// If parser says valid we can insert the contents into that parent\r\n\t\t\t\tif (!args.invalid) {\r\n\t\t\t\t\tvalue = serializer.serialize(fragment);\r\n\r\n\t\t\t\t\t// Check if parent is empty or only has one BR element then set the innerHTML of that parent\r\n\t\t\t\t\tnode = parentNode.firstChild;\r\n\t\t\t\t\tnode2 = parentNode.lastChild;\r\n\t\t\t\t\tif (!node || (node === node2 && node.nodeName === 'BR'))\r\n\t\t\t\t\t\tdom.setHTML(parentNode, value);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tselection.setContent(value);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// If the fragment was invalid within that context then we need\r\n\t\t\t\t\t// to parse and process the parent it's inserted into\r\n\r\n\t\t\t\t\t// Insert bookmark node and get the parent\r\n\t\t\t\t\tselection.setContent(bookmarkHtml);\r\n\t\t\t\t\tparentNode = editor.selection.getNode();\r\n\t\t\t\t\trootNode = editor.getBody();\r\n\r\n\t\t\t\t\t// Opera will return the document node when selection is in root\r\n\t\t\t\t\tif (parentNode.nodeType == 9)\r\n\t\t\t\t\t\tparentNode = node = rootNode;\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tnode = parentNode;\r\n\r\n\t\t\t\t\t// Find the ancestor just before the root element\r\n\t\t\t\t\twhile (node !== rootNode) {\r\n\t\t\t\t\t\tparentNode = node;\r\n\t\t\t\t\t\tnode = node.parentNode;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Get the outer/inner HTML depending on if we are in the root and parser and serialize that\r\n\t\t\t\t\tvalue = parentNode == rootNode ? rootNode.innerHTML : dom.getOuterHTML(parentNode);\r\n\t\t\t\t\tvalue = serializer.serialize(\r\n\t\t\t\t\t\tparser.parse(\r\n\t\t\t\t\t\t\t// Need to replace by using a function since $ in the contents would otherwise be a problem\r\n\t\t\t\t\t\t\tvalue.replace(/<span (id=\"mce_marker\"|id=mce_marker).+?<\\/span>/i, function() {\r\n\t\t\t\t\t\t\t\treturn serializer.serialize(fragment);\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\t// Set the inner/outer HTML depending on if we are in the root or not\r\n\t\t\t\t\tif (parentNode == rootNode)\r\n\t\t\t\t\t\tdom.setHTML(rootNode, value);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tdom.setOuterHTML(parentNode, value);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmarker = dom.get('mce_marker');\r\n\r\n\t\t\t\t// Scroll range into view scrollIntoView on element can't be used since it will scroll the main view port as well\r\n\t\t\t\tnodeRect = dom.getRect(marker);\r\n\t\t\t\tviewPortRect = dom.getViewPort(editor.getWin());\r\n\r\n\t\t\t\t// Check if node is out side the viewport if it is then scroll to it\r\n\t\t\t\tif ((nodeRect.y + nodeRect.h > viewPortRect.y + viewPortRect.h || nodeRect.y < viewPortRect.y) ||\r\n\t\t\t\t\t(nodeRect.x > viewPortRect.x + viewPortRect.w || nodeRect.x < viewPortRect.x)) {\r\n\t\t\t\t\tviewportBodyElement = tinymce.isIE ? editor.getDoc().documentElement : editor.getBody();\r\n\t\t\t\t\tviewportBodyElement.scrollLeft = nodeRect.x;\r\n\t\t\t\t\tviewportBodyElement.scrollTop = nodeRect.y - viewPortRect.h + 25;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Move selection before marker and remove it\r\n\t\t\t\trng = dom.createRng();\r\n\r\n\t\t\t\t// If previous sibling is a text node set the selection to the end of that node\r\n\t\t\t\tnode = marker.previousSibling;\r\n\t\t\t\tif (node && node.nodeType == 3) {\r\n\t\t\t\t\trng.setStart(node, node.nodeValue.length);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// If the previous sibling isn't a text node or doesn't exist set the selection before the marker node\r\n\t\t\t\t\trng.setStartBefore(marker);\r\n\t\t\t\t\trng.setEndBefore(marker);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Remove the marker node and set the new range\r\n\t\t\t\tdom.remove(marker);\r\n\t\t\t\tselection.setRng(rng);\r\n\r\n\t\t\t\t// Dispatch after event and add any visual elements needed\r\n\t\t\t\tselection.onSetContent.dispatch(selection, args);\r\n\t\t\t\teditor.addVisual();\r\n\t\t\t},\r\n\r\n\t\t\tmceInsertRawHTML : function(command, ui, value) {\r\n\t\t\t\tselection.setContent('tiny_mce_marker');\r\n\t\t\t\teditor.setContent(editor.getContent().replace(/tiny_mce_marker/g, function() { return value }));\r\n\t\t\t},\r\n\r\n\t\t\tmceSetContent : function(command, ui, value) {\r\n\t\t\t\teditor.setContent(value);\r\n\t\t\t},\r\n\r\n\t\t\t'Indent,Outdent' : function(command) {\r\n\t\t\t\tvar intentValue, indentUnit, value;\r\n\r\n\t\t\t\t// Setup indent level\r\n\t\t\t\tintentValue = settings.indentation;\r\n\t\t\t\tindentUnit = /[a-z%]+$/i.exec(intentValue);\r\n\t\t\t\tintentValue = parseInt(intentValue);\r\n\r\n\t\t\t\tif (!queryCommandState('InsertUnorderedList') && !queryCommandState('InsertOrderedList')) {\r\n\t\t\t\t\teach(selection.getSelectedBlocks(), function(element) {\r\n\t\t\t\t\t\tif (command == 'outdent') {\r\n\t\t\t\t\t\t\tvalue = Math.max(0, parseInt(element.style.paddingLeft || 0) - intentValue);\r\n\t\t\t\t\t\t\tdom.setStyle(element, 'paddingLeft', value ? value + indentUnit : '');\r\n\t\t\t\t\t\t} else\r\n\t\t\t\t\t\t\tdom.setStyle(element, 'paddingLeft', (parseInt(element.style.paddingLeft || 0) + intentValue) + indentUnit);\r\n\t\t\t\t\t});\r\n\t\t\t\t} else\r\n\t\t\t\t\texecNativeCommand(command);\r\n\t\t\t},\r\n\r\n\t\t\tmceRepaint : function() {\r\n\t\t\t\tvar bookmark;\r\n\r\n\t\t\t\tif (tinymce.isGecko) {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tstoreSelection(TRUE);\r\n\r\n\t\t\t\t\t\tif (selection.getSel())\r\n\t\t\t\t\t\t\tselection.getSel().selectAllChildren(editor.getBody());\r\n\r\n\t\t\t\t\t\tselection.collapse(TRUE);\r\n\t\t\t\t\t\trestoreSelection();\r\n\t\t\t\t\t} catch (ex) {\r\n\t\t\t\t\t\t// Ignore\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\tmceToggleFormat : function(command, ui, value) {\r\n\t\t\t\tformatter.toggle(value);\r\n\t\t\t},\r\n\r\n\t\t\tInsertHorizontalRule : function() {\r\n\t\t\t\teditor.execCommand('mceInsertContent', false, '<hr />');\r\n\t\t\t},\r\n\r\n\t\t\tmceToggleVisualAid : function() {\r\n\t\t\t\teditor.hasVisual = !editor.hasVisual;\r\n\t\t\t\teditor.addVisual();\r\n\t\t\t},\r\n\r\n\t\t\tmceReplaceContent : function(command, ui, value) {\r\n\t\t\t\teditor.execCommand('mceInsertContent', false, value.replace(/\\{\\$selection\\}/g, selection.getContent({format : 'text'})));\r\n\t\t\t},\r\n\r\n\t\t\tmceInsertLink : function(command, ui, value) {\r\n\t\t\t\tvar anchor;\r\n\r\n\t\t\t\tif (typeof(value) == 'string')\r\n\t\t\t\t\tvalue = {href : value};\r\n\r\n\t\t\t\tanchor = dom.getParent(selection.getNode(), 'a');\r\n\r\n\t\t\t\t// Spaces are never valid in URLs and it's a very common mistake for people to make so we fix it here.\r\n\t\t\t\tvalue.href = value.href.replace(' ', '%20');\r\n\r\n\t\t\t\t// Remove existing links if there could be child links or that the href isn't specified\r\n\t\t\t\tif (!anchor || !value.href) {\r\n\t\t\t\t\tformatter.remove('link');\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Apply new link to selection\r\n\t\t\t\tif (value.href) {\r\n\t\t\t\t\tformatter.apply('link', value, anchor);\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\tselectAll : function() {\r\n\t\t\t\tvar root = dom.getRoot(), rng = dom.createRng();\r\n\r\n\t\t\t\trng.setStart(root, 0);\r\n\t\t\t\trng.setEnd(root, root.childNodes.length);\r\n\r\n\t\t\t\teditor.selection.setRng(rng);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// Add queryCommandState overrides\r\n\t\taddCommands({\r\n\t\t\t// Override justify commands\r\n\t\t\t'JustifyLeft,JustifyCenter,JustifyRight,JustifyFull' : function(command) {\r\n\t\t\t\treturn isFormatMatch('align' + command.substring(7));\r\n\t\t\t},\r\n\r\n\t\t\t'Bold,Italic,Underline,Strikethrough,Superscript,Subscript' : function(command) {\r\n\t\t\t\treturn isFormatMatch(command);\r\n\t\t\t},\r\n\r\n\t\t\tmceBlockQuote : function() {\r\n\t\t\t\treturn isFormatMatch('blockquote');\r\n\t\t\t},\r\n\r\n\t\t\tOutdent : function() {\r\n\t\t\t\tvar node;\r\n\r\n\t\t\t\tif (settings.inline_styles) {\r\n\t\t\t\t\tif ((node = dom.getParent(selection.getStart(), dom.isBlock)) && parseInt(node.style.paddingLeft) > 0)\r\n\t\t\t\t\t\treturn TRUE;\r\n\r\n\t\t\t\t\tif ((node = dom.getParent(selection.getEnd(), dom.isBlock)) && parseInt(node.style.paddingLeft) > 0)\r\n\t\t\t\t\t\treturn TRUE;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn queryCommandState('InsertUnorderedList') || queryCommandState('InsertOrderedList') || (!settings.inline_styles && !!dom.getParent(selection.getNode(), 'BLOCKQUOTE'));\r\n\t\t\t},\r\n\r\n\t\t\t'InsertUnorderedList,InsertOrderedList' : function(command) {\r\n\t\t\t\treturn dom.getParent(selection.getNode(), command == 'insertunorderedlist' ? 'UL' : 'OL');\r\n\t\t\t}\r\n\t\t}, 'state');\r\n\r\n\t\t// Add queryCommandValue overrides\r\n\t\taddCommands({\r\n\t\t\t'FontSize,FontName' : function(command) {\r\n\t\t\t\tvar value = 0, parent;\r\n\r\n\t\t\t\tif (parent = dom.getParent(selection.getNode(), 'span')) {\r\n\t\t\t\t\tif (command == 'fontsize')\r\n\t\t\t\t\t\tvalue = parent.style.fontSize;\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tvalue = parent.style.fontFamily.replace(/, /g, ',').replace(/[\\'\\\"]/g, '').toLowerCase();\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn value;\r\n\t\t\t}\r\n\t\t}, 'value');\r\n\r\n\t\t// Add undo manager logic\r\n\t\tif (settings.custom_undo_redo) {\r\n\t\t\taddCommands({\r\n\t\t\t\tUndo : function() {\r\n\t\t\t\t\teditor.undoManager.undo();\r\n\t\t\t\t},\r\n\r\n\t\t\t\tRedo : function() {\r\n\t\t\t\t\teditor.undoManager.redo();\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t};\r\n})(tinymce);\r\n\r\n(function(tinymce) {\r\n\tvar Dispatcher = tinymce.util.Dispatcher;\r\n\r\n\ttinymce.UndoManager = function(editor) {\r\n\t\tvar self, index = 0, data = [], beforeBookmark;\r\n\r\n\t\tfunction getContent() {\r\n\t\t\treturn tinymce.trim(editor.getContent({format : 'raw', no_events : 1}));\r\n\t\t};\r\n\r\n\t\treturn self = {\r\n\t\t\ttyping : false,\r\n\r\n\t\t\tonAdd : new Dispatcher(self),\r\n\r\n\t\t\tonUndo : new Dispatcher(self),\r\n\r\n\t\t\tonRedo : new Dispatcher(self),\r\n\r\n\t\t\tbeforeChange : function() {\r\n\t\t\t\tbeforeBookmark = editor.selection.getBookmark(2, true);\r\n\t\t\t},\r\n\r\n\t\t\tadd : function(level) {\r\n\t\t\t\tvar i, settings = editor.settings, lastLevel;\r\n\r\n\t\t\t\tlevel = level || {};\r\n\t\t\t\tlevel.content = getContent();\r\n\r\n\t\t\t\t// Add undo level if needed\r\n\t\t\t\tlastLevel = data[index];\r\n\t\t\t\tif (lastLevel && lastLevel.content == level.content)\r\n\t\t\t\t\treturn null;\r\n\r\n\t\t\t\t// Set before bookmark on previous level\r\n\t\t\t\tif (data[index])\r\n\t\t\t\t\tdata[index].beforeBookmark = beforeBookmark;\r\n\r\n\t\t\t\t// Time to compress\r\n\t\t\t\tif (settings.custom_undo_redo_levels) {\r\n\t\t\t\t\tif (data.length > settings.custom_undo_redo_levels) {\r\n\t\t\t\t\t\tfor (i = 0; i < data.length - 1; i++)\r\n\t\t\t\t\t\t\tdata[i] = data[i + 1];\r\n\r\n\t\t\t\t\t\tdata.length--;\r\n\t\t\t\t\t\tindex = data.length;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Get a non intrusive normalized bookmark\r\n\t\t\t\tlevel.bookmark = editor.selection.getBookmark(2, true);\r\n\r\n\t\t\t\t// Crop array if needed\r\n\t\t\t\tif (index < data.length - 1)\r\n\t\t\t\t\tdata.length = index + 1;\r\n\r\n\t\t\t\tdata.push(level);\r\n\t\t\t\tindex = data.length - 1;\r\n\r\n\t\t\t\tself.onAdd.dispatch(self, level);\r\n\t\t\t\teditor.isNotDirty = 0;\r\n\r\n\t\t\t\treturn level;\r\n\t\t\t},\r\n\r\n\t\t\tundo : function() {\r\n\t\t\t\tvar level, i;\r\n\r\n\t\t\t\tif (self.typing) {\r\n\t\t\t\t\tself.add();\r\n\t\t\t\t\tself.typing = false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (index > 0) {\r\n\t\t\t\t\tlevel = data[--index];\r\n\r\n\t\t\t\t\teditor.setContent(level.content, {format : 'raw'});\r\n\t\t\t\t\teditor.selection.moveToBookmark(level.beforeBookmark);\r\n\r\n\t\t\t\t\tself.onUndo.dispatch(self, level);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn level;\r\n\t\t\t},\r\n\r\n\t\t\tredo : function() {\r\n\t\t\t\tvar level;\r\n\r\n\t\t\t\tif (index < data.length - 1) {\r\n\t\t\t\t\tlevel = data[++index];\r\n\r\n\t\t\t\t\teditor.setContent(level.content, {format : 'raw'});\r\n\t\t\t\t\teditor.selection.moveToBookmark(level.bookmark);\r\n\r\n\t\t\t\t\tself.onRedo.dispatch(self, level);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn level;\r\n\t\t\t},\r\n\r\n\t\t\tclear : function() {\r\n\t\t\t\tdata = [];\r\n\t\t\t\tindex = 0;\r\n\t\t\t\tself.typing = false;\r\n\t\t\t},\r\n\r\n\t\t\thasUndo : function() {\r\n\t\t\t\treturn index > 0 || this.typing;\r\n\t\t\t},\r\n\r\n\t\t\thasRedo : function() {\r\n\t\t\t\treturn index < data.length - 1 && !this.typing;\r\n\t\t\t}\r\n\t\t};\r\n\t};\r\n})(tinymce);\r\n\r\n(function(tinymce) {\r\n\t// Shorten names\r\n\tvar Event = tinymce.dom.Event,\r\n\t\tisIE = tinymce.isIE,\r\n\t\tisGecko = tinymce.isGecko,\r\n\t\tisOpera = tinymce.isOpera,\r\n\t\teach = tinymce.each,\r\n\t\textend = tinymce.extend,\r\n\t\tTRUE = true,\r\n\t\tFALSE = false;\r\n\r\n\tfunction cloneFormats(node) {\r\n\t\tvar clone, temp, inner;\r\n\r\n\t\tdo {\r\n\t\t\tif (/^(SPAN|STRONG|B|EM|I|FONT|STRIKE|U)$/.test(node.nodeName)) {\r\n\t\t\t\tif (clone) {\r\n\t\t\t\t\ttemp = node.cloneNode(false);\r\n\t\t\t\t\ttemp.appendChild(clone);\r\n\t\t\t\t\tclone = temp;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tclone = inner = node.cloneNode(false);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tclone.removeAttribute('id');\r\n\t\t\t}\r\n\t\t} while (node = node.parentNode);\r\n\r\n\t\tif (clone)\r\n\t\t\treturn {wrapper : clone, inner : inner};\r\n\t};\r\n\r\n\t// Checks if the selection/caret is at the end of the specified block element\r\n\tfunction isAtEnd(rng, par) {\r\n\t\tvar rng2 = par.ownerDocument.createRange();\r\n\r\n\t\trng2.setStart(rng.endContainer, rng.endOffset);\r\n\t\trng2.setEndAfter(par);\r\n\r\n\t\t// Get number of characters to the right of the cursor if it's zero then we are at the end and need to merge the next block element\r\n\t\treturn rng2.cloneContents().textContent.length == 0;\r\n\t};\r\n\r\n\tfunction splitList(selection, dom, li) {\r\n\t\tvar listBlock, block;\r\n\r\n\t\tif (dom.isEmpty(li)) {\r\n\t\t\tlistBlock = dom.getParent(li, 'ul,ol');\r\n\r\n\t\t\tif (!dom.getParent(listBlock.parentNode, 'ul,ol')) {\r\n\t\t\t\tdom.split(listBlock, li);\r\n\t\t\t\tblock = dom.create('p', 0, '<br data-mce-bogus=\"1\" />');\r\n\t\t\t\tdom.replace(block, li);\r\n\t\t\t\tselection.select(block, 1);\r\n\t\t\t}\r\n\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\r\n\t\treturn TRUE;\r\n\t};\r\n\r\n\ttinymce.create('tinymce.ForceBlocks', {\r\n\t\tForceBlocks : function(ed) {\r\n\t\t\tvar t = this, s = ed.settings, elm;\r\n\r\n\t\t\tt.editor = ed;\r\n\t\t\tt.dom = ed.dom;\r\n\t\t\telm = (s.forced_root_block || 'p').toLowerCase();\r\n\t\t\ts.element = elm.toUpperCase();\r\n\r\n\t\t\ted.onPreInit.add(t.setup, t);\r\n\t\t},\r\n\r\n\t\tsetup : function() {\r\n\t\t\tvar t = this, ed = t.editor, s = ed.settings, dom = ed.dom, selection = ed.selection, blockElements = ed.schema.getBlockElements();\r\n\r\n\t\t\t// Force root blocks\r\n\t\t\tif (s.forced_root_block) {\r\n\t\t\t\tfunction addRootBlocks() {\r\n\t\t\t\t\tvar node = selection.getStart(), rootNode = ed.getBody(), rng, startContainer, startOffset, endContainer, endOffset, rootBlockNode, tempNode, offset = -0xFFFFFF;\r\n\r\n\t\t\t\t\tif (!node || node.nodeType !== 1)\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t// Check if node is wrapped in block\r\n\t\t\t\t\twhile (node != rootNode) {\r\n\t\t\t\t\t\tif (blockElements[node.nodeName])\r\n\t\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t\tnode = node.parentNode;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Get current selection\r\n\t\t\t\t\trng = selection.getRng();\r\n\t\t\t\t\tif (rng.setStart) {\r\n\t\t\t\t\t\tstartContainer = rng.startContainer;\r\n\t\t\t\t\t\tstartOffset = rng.startOffset;\r\n\t\t\t\t\t\tendContainer = rng.endContainer;\r\n\t\t\t\t\t\tendOffset = rng.endOffset;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// Force control range into text range\r\n\t\t\t\t\t\tif (rng.item) {\r\n\t\t\t\t\t\t\trng = ed.getDoc().body.createTextRange();\r\n\t\t\t\t\t\t\trng.moveToElementText(rng.item(0));\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\ttmpRng = rng.duplicate();\r\n\t\t\t\t\t\ttmpRng.collapse(true);\r\n\t\t\t\t\t\tstartOffset = tmpRng.move('character', offset) * -1;\r\n\r\n\t\t\t\t\t\tif (!tmpRng.collapsed) {\r\n\t\t\t\t\t\t\ttmpRng = rng.duplicate();\r\n\t\t\t\t\t\t\ttmpRng.collapse(false);\r\n\t\t\t\t\t\t\tendOffset = (tmpRng.move('character', offset) * -1) - startOffset;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Wrap non block elements and text nodes\r\n\t\t\t\t\tfor (node = rootNode.firstChild; node; node) {\r\n\t\t\t\t\t\tif (node.nodeType === 3 || (node.nodeType == 1 && !blockElements[node.nodeName])) {\r\n\t\t\t\t\t\t\tif (!rootBlockNode) {\r\n\t\t\t\t\t\t\t\trootBlockNode = dom.create(s.forced_root_block);\r\n\t\t\t\t\t\t\t\tnode.parentNode.insertBefore(rootBlockNode, node);\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\ttempNode = node;\r\n\t\t\t\t\t\t\tnode = node.nextSibling;\r\n\t\t\t\t\t\t\trootBlockNode.appendChild(tempNode);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\trootBlockNode = null;\r\n\t\t\t\t\t\t\tnode = node.nextSibling;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (rng.setStart) {\r\n\t\t\t\t\t\trng.setStart(startContainer, startOffset);\r\n\t\t\t\t\t\trng.setEnd(endContainer, endOffset);\r\n\t\t\t\t\t\tselection.setRng(rng);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\trng = ed.getDoc().body.createTextRange();\r\n\t\t\t\t\t\t\trng.moveToElementText(rootNode);\r\n\t\t\t\t\t\t\trng.collapse(true);\r\n\t\t\t\t\t\t\trng.moveStart('character', startOffset);\r\n\r\n\t\t\t\t\t\t\tif (endOffset > 0)\r\n\t\t\t\t\t\t\t\trng.moveEnd('character', endOffset);\r\n\r\n\t\t\t\t\t\t\trng.select();\r\n\t\t\t\t\t\t} catch (ex) {\r\n\t\t\t\t\t\t\t// Ignore\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ted.nodeChanged();\r\n\t\t\t\t};\r\n\r\n\t\t\t\ted.onKeyUp.add(addRootBlocks);\r\n\t\t\t\ted.onClick.add(addRootBlocks);\r\n\t\t\t}\r\n\r\n\t\t\tif (s.force_br_newlines) {\r\n\t\t\t\t// Force IE to produce BRs on enter\r\n\t\t\t\tif (isIE) {\r\n\t\t\t\t\ted.onKeyPress.add(function(ed, e) {\r\n\t\t\t\t\t\tvar n;\r\n\r\n\t\t\t\t\t\tif (e.keyCode == 13 && selection.getNode().nodeName != 'LI') {\r\n\t\t\t\t\t\t\tselection.setContent('<br id=\"__\" /> ', {format : 'raw'});\r\n\t\t\t\t\t\t\tn = dom.get('__');\r\n\t\t\t\t\t\t\tn.removeAttribute('id');\r\n\t\t\t\t\t\t\tselection.select(n);\r\n\t\t\t\t\t\t\tselection.collapse();\r\n\t\t\t\t\t\t\treturn Event.cancel(e);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (s.force_p_newlines) {\r\n\t\t\t\tif (!isIE) {\r\n\t\t\t\t\ted.onKeyPress.add(function(ed, e) {\r\n\t\t\t\t\t\tif (e.keyCode == 13 && !e.shiftKey && !t.insertPara(e))\r\n\t\t\t\t\t\t\tEvent.cancel(e);\r\n\t\t\t\t\t});\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Ungly hack to for IE to preserve the formatting when you press\r\n\t\t\t\t\t// enter at the end of a block element with formatted contents\r\n\t\t\t\t\t// This logic overrides the browsers default logic with\r\n\t\t\t\t\t// custom logic that enables us to control the output\r\n\t\t\t\t\ttinymce.addUnload(function() {\r\n\t\t\t\t\t\tt._previousFormats = 0; // Fix IE leak\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\ted.onKeyPress.add(function(ed, e) {\r\n\t\t\t\t\t\tt._previousFormats = 0;\r\n\r\n\t\t\t\t\t\t// Clone the current formats, this will later be applied to the new block contents\r\n\t\t\t\t\t\tif (e.keyCode == 13 && !e.shiftKey && ed.selection.isCollapsed() && s.keep_styles)\r\n\t\t\t\t\t\t\tt._previousFormats = cloneFormats(ed.selection.getStart());\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\ted.onKeyUp.add(function(ed, e) {\r\n\t\t\t\t\t\t// Let IE break the element and the wrap the new caret location in the previous formats\r\n\t\t\t\t\t\tif (e.keyCode == 13 && !e.shiftKey) {\r\n\t\t\t\t\t\t\tvar parent = ed.selection.getStart(), fmt = t._previousFormats;\r\n\r\n\t\t\t\t\t\t\t// Parent is an empty block\r\n\t\t\t\t\t\t\tif (!parent.hasChildNodes() && fmt) {\r\n\t\t\t\t\t\t\t\tparent = dom.getParent(parent, dom.isBlock);\r\n\r\n\t\t\t\t\t\t\t\tif (parent && parent.nodeName != 'LI') {\r\n\t\t\t\t\t\t\t\t\tparent.innerHTML = '';\r\n\r\n\t\t\t\t\t\t\t\t\tif (t._previousFormats) {\r\n\t\t\t\t\t\t\t\t\t\tparent.appendChild(fmt.wrapper);\r\n\t\t\t\t\t\t\t\t\t\tfmt.inner.innerHTML = '\\uFEFF';\r\n\t\t\t\t\t\t\t\t\t} else\r\n\t\t\t\t\t\t\t\t\t\tparent.innerHTML = '\\uFEFF';\r\n\r\n\t\t\t\t\t\t\t\t\tselection.select(parent, 1);\r\n\t\t\t\t\t\t\t\t\tselection.collapse(true);\r\n\t\t\t\t\t\t\t\t\ted.getDoc().execCommand('Delete', false, null);\r\n\t\t\t\t\t\t\t\t\tt._previousFormats = 0;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (isGecko) {\r\n\t\t\t\t\ted.onKeyDown.add(function(ed, e) {\r\n\t\t\t\t\t\tif ((e.keyCode == 8 || e.keyCode == 46) && !e.shiftKey)\r\n\t\t\t\t\t\t\tt.backspaceDelete(e, e.keyCode == 8);\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Workaround for missing shift+enter support, http://bugs.webkit.org/show_bug.cgi?id=16973\r\n\t\t\tif (tinymce.isWebKit) {\r\n\t\t\t\tfunction insertBr(ed) {\r\n\t\t\t\t\tvar rng = selection.getRng(), br, div = dom.create('div', null, ' '), divYPos, vpHeight = dom.getViewPort(ed.getWin()).h;\r\n\r\n\t\t\t\t\t// Insert BR element\r\n\t\t\t\t\trng.insertNode(br = dom.create('br'));\r\n\r\n\t\t\t\t\t// Place caret after BR\r\n\t\t\t\t\trng.setStartAfter(br);\r\n\t\t\t\t\trng.setEndAfter(br);\r\n\t\t\t\t\tselection.setRng(rng);\r\n\r\n\t\t\t\t\t// Could not place caret after BR then insert an nbsp entity and move the caret\r\n\t\t\t\t\tif (selection.getSel().focusNode == br.previousSibling) {\r\n\t\t\t\t\t\tselection.select(dom.insertAfter(dom.doc.createTextNode('\\u00a0'), br));\r\n\t\t\t\t\t\tselection.collapse(TRUE);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Create a temporary DIV after the BR and get the position as it\r\n\t\t\t\t\t// seems like getPos() returns 0 for text nodes and BR elements.\r\n\t\t\t\t\tdom.insertAfter(div, br);\r\n\t\t\t\t\tdivYPos = dom.getPos(div).y;\r\n\t\t\t\t\tdom.remove(div);\r\n\r\n\t\t\t\t\t// Scroll to new position, scrollIntoView can't be used due to bug: http://bugs.webkit.org/show_bug.cgi?id=16117\r\n\t\t\t\t\tif (divYPos > vpHeight) // It is not necessary to scroll if the DIV is inside the view port.\r\n\t\t\t\t\t\ted.getWin().scrollTo(0, divYPos);\r\n\t\t\t\t};\r\n\r\n\t\t\t\ted.onKeyPress.add(function(ed, e) {\r\n\t\t\t\t\tif (e.keyCode == 13 && (e.shiftKey || (s.force_br_newlines && !dom.getParent(selection.getNode(), 'h1,h2,h3,h4,h5,h6,ol,ul')))) {\r\n\t\t\t\t\t\tinsertBr(ed);\r\n\t\t\t\t\t\tEvent.cancel(e);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// IE specific fixes\r\n\t\t\tif (isIE) {\r\n\t\t\t\t// Replaces IE:s auto generated paragraphs with the specified element name\r\n\t\t\t\tif (s.element != 'P') {\r\n\t\t\t\t\ted.onKeyPress.add(function(ed, e) {\r\n\t\t\t\t\t\tt.lastElm = selection.getNode().nodeName;\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\ted.onKeyUp.add(function(ed, e) {\r\n\t\t\t\t\t\tvar bl, n = selection.getNode(), b = ed.getBody();\r\n\r\n\t\t\t\t\t\tif (b.childNodes.length === 1 && n.nodeName == 'P') {\r\n\t\t\t\t\t\t\tn = dom.rename(n, s.element);\r\n\t\t\t\t\t\t\tselection.select(n);\r\n\t\t\t\t\t\t\tselection.collapse();\r\n\t\t\t\t\t\t\ted.nodeChanged();\r\n\t\t\t\t\t\t} else if (e.keyCode == 13 && !e.shiftKey && t.lastElm != 'P') {\r\n\t\t\t\t\t\t\tbl = dom.getParent(n, 'p');\r\n\r\n\t\t\t\t\t\t\tif (bl) {\r\n\t\t\t\t\t\t\t\tdom.rename(bl, s.element);\r\n\t\t\t\t\t\t\t\ted.nodeChanged();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tgetParentBlock : function(n) {\r\n\t\t\tvar d = this.dom;\r\n\r\n\t\t\treturn d.getParent(n, d.isBlock);\r\n\t\t},\r\n\r\n\t\tinsertPara : function(e) {\r\n\t\t\tvar t = this, ed = t.editor, dom = ed.dom, d = ed.getDoc(), se = ed.settings, s = ed.selection.getSel(), r = s.getRangeAt(0), b = d.body;\r\n\t\t\tvar rb, ra, dir, sn, so, en, eo, sb, eb, bn, bef, aft, sc, ec, n, vp = dom.getViewPort(ed.getWin()), y, ch, car;\r\n\r\n\t\t\ted.undoManager.beforeChange();\r\n\r\n\t\t\t// If root blocks are forced then use Operas default behavior since it's really good\r\n// Removed due to bug: #1853816\r\n//\t\t\tif (se.forced_root_block && isOpera)\r\n//\t\t\t\treturn TRUE;\r\n\r\n\t\t\t// Setup before range\r\n\t\t\trb = d.createRange();\r\n\r\n\t\t\t// If is before the first block element and in body, then move it into first block element\r\n\t\t\trb.setStart(s.anchorNode, s.anchorOffset);\r\n\t\t\trb.collapse(TRUE);\r\n\r\n\t\t\t// Setup after range\r\n\t\t\tra = d.createRange();\r\n\r\n\t\t\t// If is before the first block element and in body, then move it into first block element\r\n\t\t\tra.setStart(s.focusNode, s.focusOffset);\r\n\t\t\tra.collapse(TRUE);\r\n\r\n\t\t\t// Setup start/end points\r\n\t\t\tdir = rb.compareBoundaryPoints(rb.START_TO_END, ra) < 0;\r\n\t\t\tsn = dir ? s.anchorNode : s.focusNode;\r\n\t\t\tso = dir ? s.anchorOffset : s.focusOffset;\r\n\t\t\ten = dir ? s.focusNode : s.anchorNode;\r\n\t\t\teo = dir ? s.focusOffset : s.anchorOffset;\r\n\r\n\t\t\t// If selection is in empty table cell\r\n\t\t\tif (sn === en && /^(TD|TH)$/.test(sn.nodeName)) {\r\n\t\t\t\tif (sn.firstChild.nodeName == 'BR')\r\n\t\t\t\t\tdom.remove(sn.firstChild); // Remove BR\r\n\r\n\t\t\t\t// Create two new block elements\r\n\t\t\t\tif (sn.childNodes.length == 0) {\r\n\t\t\t\t\ted.dom.add(sn, se.element, null, '<br />');\r\n\t\t\t\t\taft = ed.dom.add(sn, se.element, null, '<br />');\r\n\t\t\t\t} else {\r\n\t\t\t\t\tn = sn.innerHTML;\r\n\t\t\t\t\tsn.innerHTML = '';\r\n\t\t\t\t\ted.dom.add(sn, se.element, null, n);\r\n\t\t\t\t\taft = ed.dom.add(sn, se.element, null, '<br />');\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Move caret into the last one\r\n\t\t\t\tr = d.createRange();\r\n\t\t\t\tr.selectNodeContents(aft);\r\n\t\t\t\tr.collapse(1);\r\n\t\t\t\ted.selection.setRng(r);\r\n\r\n\t\t\t\treturn FALSE;\r\n\t\t\t}\r\n\r\n\t\t\t// If the caret is in an invalid location in FF we need to move it into the first block\r\n\t\t\tif (sn == b && en == b && b.firstChild && ed.dom.isBlock(b.firstChild)) {\r\n\t\t\t\tsn = en = sn.firstChild;\r\n\t\t\t\tso = eo = 0;\r\n\t\t\t\trb = d.createRange();\r\n\t\t\t\trb.setStart(sn, 0);\r\n\t\t\t\tra = d.createRange();\r\n\t\t\t\tra.setStart(en, 0);\r\n\t\t\t}\r\n\r\n\t\t\t// If the body is totally empty add a BR element this might happen on webkit\r\n\t\t\tif (!d.body.hasChildNodes()) {\r\n\t\t\t\td.body.appendChild(dom.create('br'));\r\n\t\t\t}\r\n\r\n\t\t\t// Never use body as start or end node\r\n\t\t\tsn = sn.nodeName == \"HTML\" ? d.body : sn; // Fix for Opera bug: https://bugs.opera.com/show_bug.cgi?id=273224&comments=yes\r\n\t\t\tsn = sn.nodeName == \"BODY\" ? sn.firstChild : sn;\r\n\t\t\ten = en.nodeName == \"HTML\" ? d.body : en; // Fix for Opera bug: https://bugs.opera.com/show_bug.cgi?id=273224&comments=yes\r\n\t\t\ten = en.nodeName == \"BODY\" ? en.firstChild : en;\r\n\r\n\t\t\t// Get start and end blocks\r\n\t\t\tsb = t.getParentBlock(sn);\r\n\t\t\teb = t.getParentBlock(en);\r\n\t\t\tbn = sb ? sb.nodeName : se.element; // Get block name to create\r\n\r\n\t\t\t// Return inside list use default browser behavior\r\n\t\t\tif (n = t.dom.getParent(sb, 'li,pre')) {\r\n\t\t\t\tif (n.nodeName == 'LI')\r\n\t\t\t\t\treturn splitList(ed.selection, t.dom, n);\r\n\r\n\t\t\t\treturn TRUE;\r\n\t\t\t}\r\n\r\n\t\t\t// If caption or absolute layers then always generate new blocks within\r\n\t\t\tif (sb && (sb.nodeName == 'CAPTION' || /absolute|relative|fixed/gi.test(dom.getStyle(sb, 'position', 1)))) {\r\n\t\t\t\tbn = se.element;\r\n\t\t\t\tsb = null;\r\n\t\t\t}\r\n\r\n\t\t\t// If caption or absolute layers then always generate new blocks within\r\n\t\t\tif (eb && (eb.nodeName == 'CAPTION' || /absolute|relative|fixed/gi.test(dom.getStyle(sb, 'position', 1)))) {\r\n\t\t\t\tbn = se.element;\r\n\t\t\t\teb = null;\r\n\t\t\t}\r\n\r\n\t\t\t// Use P instead\r\n\t\t\tif (/(TD|TABLE|TH|CAPTION)/.test(bn) || (sb && bn == \"DIV\" && /left|right/gi.test(dom.getStyle(sb, 'float', 1)))) {\r\n\t\t\t\tbn = se.element;\r\n\t\t\t\tsb = eb = null;\r\n\t\t\t}\r\n\r\n\t\t\t// Setup new before and after blocks\r\n\t\t\tbef = (sb && sb.nodeName == bn) ? sb.cloneNode(0) : ed.dom.create(bn);\r\n\t\t\taft = (eb && eb.nodeName == bn) ? eb.cloneNode(0) : ed.dom.create(bn);\r\n\r\n\t\t\t// Remove id from after clone\r\n\t\t\taft.removeAttribute('id');\r\n\r\n\t\t\t// Is header and cursor is at the end, then force paragraph under\r\n\t\t\tif (/^(H[1-6])$/.test(bn) && isAtEnd(r, sb))\r\n\t\t\t\taft = ed.dom.create(se.element);\r\n\r\n\t\t\t// Find start chop node\r\n\t\t\tn = sc = sn;\r\n\t\t\tdo {\r\n\t\t\t\tif (n == b || n.nodeType == 9 || t.dom.isBlock(n) || /(TD|TABLE|TH|CAPTION)/.test(n.nodeName))\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tsc = n;\r\n\t\t\t} while ((n = n.previousSibling ? n.previousSibling : n.parentNode));\r\n\r\n\t\t\t// Find end chop node\r\n\t\t\tn = ec = en;\r\n\t\t\tdo {\r\n\t\t\t\tif (n == b || n.nodeType == 9 || t.dom.isBlock(n) || /(TD|TABLE|TH|CAPTION)/.test(n.nodeName))\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tec = n;\r\n\t\t\t} while ((n = n.nextSibling ? n.nextSibling : n.parentNode));\r\n\r\n\t\t\t// Place first chop part into before block element\r\n\t\t\tif (sc.nodeName == bn)\r\n\t\t\t\trb.setStart(sc, 0);\r\n\t\t\telse\r\n\t\t\t\trb.setStartBefore(sc);\r\n\r\n\t\t\trb.setEnd(sn, so);\r\n\t\t\tbef.appendChild(rb.cloneContents() || d.createTextNode('')); // Empty text node needed for Safari\r\n\r\n\t\t\t// Place secnd chop part within new block element\r\n\t\t\ttry {\r\n\t\t\t\tra.setEndAfter(ec);\r\n\t\t\t} catch(ex) {\r\n\t\t\t\t//console.debug(s.focusNode, s.focusOffset);\r\n\t\t\t}\r\n\r\n\t\t\tra.setStart(en, eo);\r\n\t\t\taft.appendChild(ra.cloneContents() || d.createTextNode('')); // Empty text node needed for Safari\r\n\r\n\t\t\t// Create range around everything\r\n\t\t\tr = d.createRange();\r\n\t\t\tif (!sc.previousSibling && sc.parentNode.nodeName == bn) {\r\n\t\t\t\tr.setStartBefore(sc.parentNode);\r\n\t\t\t} else {\r\n\t\t\t\tif (rb.startContainer.nodeName == bn && rb.startOffset == 0)\r\n\t\t\t\t\tr.setStartBefore(rb.startContainer);\r\n\t\t\t\telse\r\n\t\t\t\t\tr.setStart(rb.startContainer, rb.startOffset);\r\n\t\t\t}\r\n\r\n\t\t\tif (!ec.nextSibling && ec.parentNode.nodeName == bn)\r\n\t\t\t\tr.setEndAfter(ec.parentNode);\r\n\t\t\telse\r\n\t\t\t\tr.setEnd(ra.endContainer, ra.endOffset);\r\n\r\n\t\t\t// Delete and replace it with new block elements\r\n\t\t\tr.deleteContents();\r\n\r\n\t\t\tif (isOpera)\r\n\t\t\t\ted.getWin().scrollTo(0, vp.y);\r\n\r\n\t\t\t// Never wrap blocks in blocks\r\n\t\t\tif (bef.firstChild && bef.firstChild.nodeName == bn)\r\n\t\t\t\tbef.innerHTML = bef.firstChild.innerHTML;\r\n\r\n\t\t\tif (aft.firstChild && aft.firstChild.nodeName == bn)\r\n\t\t\t\taft.innerHTML = aft.firstChild.innerHTML;\r\n\r\n\t\t\tfunction appendStyles(e, en) {\r\n\t\t\t\tvar nl = [], nn, n, i;\r\n\r\n\t\t\t\te.innerHTML = '';\r\n\r\n\t\t\t\t// Make clones of style elements\r\n\t\t\t\tif (se.keep_styles) {\r\n\t\t\t\t\tn = en;\r\n\t\t\t\t\tdo {\r\n\t\t\t\t\t\t// We only want style specific elements\r\n\t\t\t\t\t\tif (/^(SPAN|STRONG|B|EM|I|FONT|STRIKE|U)$/.test(n.nodeName)) {\r\n\t\t\t\t\t\t\tnn = n.cloneNode(FALSE);\r\n\t\t\t\t\t\t\tdom.setAttrib(nn, 'id', ''); // Remove ID since it needs to be unique\r\n\t\t\t\t\t\t\tnl.push(nn);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} while (n = n.parentNode);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Append style elements to aft\r\n\t\t\t\tif (nl.length > 0) {\r\n\t\t\t\t\tfor (i = nl.length - 1, nn = e; i >= 0; i--)\r\n\t\t\t\t\t\tnn = nn.appendChild(nl[i]);\r\n\r\n\t\t\t\t\t// Padd most inner style element\r\n\t\t\t\t\tnl[0].innerHTML = isOpera ? '\\u00a0' : '<br />'; // Extra space for Opera so that the caret can move there\r\n\t\t\t\t\treturn nl[0]; // Move caret to most inner element\r\n\t\t\t\t} else\r\n\t\t\t\t\te.innerHTML = isOpera ? '\\u00a0' : '<br />'; // Extra space for Opera so that the caret can move there\r\n\t\t\t};\r\n\r\n\t\t\t// Padd empty blocks\r\n\t\t\tif (dom.isEmpty(bef))\r\n\t\t\t\tappendStyles(bef, sn);\r\n\r\n\t\t\t// Fill empty afterblook with current style\r\n\t\t\tif (dom.isEmpty(aft))\r\n\t\t\t\tcar = appendStyles(aft, en);\r\n\r\n\t\t\t// Opera needs this one backwards for older versions\r\n\t\t\tif (isOpera && parseFloat(opera.version()) < 9.5) {\r\n\t\t\t\tr.insertNode(bef);\r\n\t\t\t\tr.insertNode(aft);\r\n\t\t\t} else {\r\n\t\t\t\tr.insertNode(aft);\r\n\t\t\t\tr.insertNode(bef);\r\n\t\t\t}\r\n\r\n\t\t\t// Normalize\r\n\t\t\taft.normalize();\r\n\t\t\tbef.normalize();\r\n\r\n\t\t\t// Move cursor and scroll into view\r\n\t\t\ted.selection.select(aft, true);\r\n\t\t\ted.selection.collapse(true);\r\n\r\n\t\t\t// scrollIntoView seems to scroll the parent window in most browsers now including FF 3.0b4 so it's time to stop using it and do it our selfs\r\n\t\t\ty = ed.dom.getPos(aft).y;\r\n\t\t\t//ch = aft.clientHeight;\r\n\r\n\t\t\t// Is element within viewport\r\n\t\t\tif (y < vp.y || y + 25 > vp.y + vp.h) {\r\n\t\t\t\ted.getWin().scrollTo(0, y < vp.y ? y : y - vp.h + 25); // Needs to be hardcoded to roughly one line of text if a huge text block is broken into two blocks\r\n\r\n\t\t\t\t/*console.debug(\r\n\t\t\t\t\t'Element: y=' + y + ', h=' + ch + ', ' +\r\n\t\t\t\t\t'Viewport: y=' + vp.y + \", h=\" + vp.h + ', bottom=' + (vp.y + vp.h)\r\n\t\t\t\t);*/\r\n\t\t\t}\r\n\r\n\t\t\ted.undoManager.add();\r\n\r\n\t\t\treturn FALSE;\r\n\t\t},\r\n\r\n\t\tbackspaceDelete : function(e, bs) {\r\n\t\t\tvar t = this, ed = t.editor, b = ed.getBody(), dom = ed.dom, n, se = ed.selection, r = se.getRng(), sc = r.startContainer, n, w, tn, walker;\r\n\r\n\t\t\t// Delete when caret is behind a element doesn't work correctly on Gecko see #3011651\r\n\t\t\tif (!bs && r.collapsed && sc.nodeType == 1 && r.startOffset == sc.childNodes.length) {\r\n\t\t\t\twalker = new tinymce.dom.TreeWalker(sc.lastChild, sc);\r\n\r\n\t\t\t\t// Walk the dom backwards until we find a text node\r\n\t\t\t\tfor (n = sc.lastChild; n; n = walker.prev()) {\r\n\t\t\t\t\tif (n.nodeType == 3) {\r\n\t\t\t\t\t\tr.setStart(n, n.nodeValue.length);\r\n\t\t\t\t\t\tr.collapse(true);\r\n\t\t\t\t\t\tse.setRng(r);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// The caret sometimes gets stuck in Gecko if you delete empty paragraphs\r\n\t\t\t// This workaround removes the element by hand and moves the caret to the previous element\r\n\t\t\tif (sc && ed.dom.isBlock(sc) && !/^(TD|TH)$/.test(sc.nodeName) && bs) {\r\n\t\t\t\tif (sc.childNodes.length == 0 || (sc.childNodes.length == 1 && sc.firstChild.nodeName == 'BR')) {\r\n\t\t\t\t\t// Find previous block element\r\n\t\t\t\t\tn = sc;\r\n\t\t\t\t\twhile ((n = n.previousSibling) && !ed.dom.isBlock(n)) ;\r\n\r\n\t\t\t\t\tif (n) {\r\n\t\t\t\t\t\tif (sc != b.firstChild) {\r\n\t\t\t\t\t\t\t// Find last text node\r\n\t\t\t\t\t\t\tw = ed.dom.doc.createTreeWalker(n, NodeFilter.SHOW_TEXT, null, FALSE);\r\n\t\t\t\t\t\t\twhile (tn = w.nextNode())\r\n\t\t\t\t\t\t\t\tn = tn;\r\n\r\n\t\t\t\t\t\t\t// Place caret at the end of last text node\r\n\t\t\t\t\t\t\tr = ed.getDoc().createRange();\r\n\t\t\t\t\t\t\tr.setStart(n, n.nodeValue ? n.nodeValue.length : 0);\r\n\t\t\t\t\t\t\tr.setEnd(n, n.nodeValue ? n.nodeValue.length : 0);\r\n\t\t\t\t\t\t\tse.setRng(r);\r\n\r\n\t\t\t\t\t\t\t// Remove the target container\r\n\t\t\t\t\t\t\ted.dom.remove(sc);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn Event.cancel(e);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n})(tinymce);\r\n\r\n(function(tinymce) {\r\n\t// Shorten names\r\n\tvar DOM = tinymce.DOM, Event = tinymce.dom.Event, each = tinymce.each, extend = tinymce.extend;\r\n\r\n\ttinymce.create('tinymce.ControlManager', {\r\n\t\tControlManager : function(ed, s) {\r\n\t\t\tvar t = this, i;\r\n\r\n\t\t\ts = s || {};\r\n\t\t\tt.editor = ed;\r\n\t\t\tt.controls = {};\r\n\t\t\tt.onAdd = new tinymce.util.Dispatcher(t);\r\n\t\t\tt.onPostRender = new tinymce.util.Dispatcher(t);\r\n\t\t\tt.prefix = s.prefix || ed.id + '_';\r\n\t\t\tt._cls = {};\r\n\r\n\t\t\tt.onPostRender.add(function() {\r\n\t\t\t\teach(t.controls, function(c) {\r\n\t\t\t\t\tc.postRender();\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\tget : function(id) {\r\n\t\t\treturn this.controls[this.prefix + id] || this.controls[id];\r\n\t\t},\r\n\r\n\t\tsetActive : function(id, s) {\r\n\t\t\tvar c = null;\r\n\r\n\t\t\tif (c = this.get(id))\r\n\t\t\t\tc.setActive(s);\r\n\r\n\t\t\treturn c;\r\n\t\t},\r\n\r\n\t\tsetDisabled : function(id, s) {\r\n\t\t\tvar c = null;\r\n\r\n\t\t\tif (c = this.get(id))\r\n\t\t\t\tc.setDisabled(s);\r\n\r\n\t\t\treturn c;\r\n\t\t},\r\n\r\n\t\tadd : function(c) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\tif (c) {\r\n\t\t\t\tt.controls[c.id] = c;\r\n\t\t\t\tt.onAdd.dispatch(c, t);\r\n\t\t\t}\r\n\r\n\t\t\treturn c;\r\n\t\t},\r\n\r\n\t\tcreateControl : function(n) {\r\n\t\t\tvar c, t = this, ed = t.editor;\r\n\r\n\t\t\teach(ed.plugins, function(p) {\r\n\t\t\t\tif (p.createControl) {\r\n\t\t\t\t\tc = p.createControl(n, t);\r\n\r\n\t\t\t\t\tif (c)\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tswitch (n) {\r\n\t\t\t\tcase \"|\":\r\n\t\t\t\tcase \"separator\":\r\n\t\t\t\t\treturn t.createSeparator();\r\n\t\t\t}\r\n\r\n\t\t\tif (!c && ed.buttons && (c = ed.buttons[n]))\r\n\t\t\t\treturn t.createButton(n, c);\r\n\r\n\t\t\treturn t.add(c);\r\n\t\t},\r\n\r\n\t\tcreateDropMenu : function(id, s, cc) {\r\n\t\t\tvar t = this, ed = t.editor, c, bm, v, cls;\r\n\r\n\t\t\ts = extend({\r\n\t\t\t\t'class' : 'mceDropDown',\r\n\t\t\t\tconstrain : ed.settings.constrain_menus\r\n\t\t\t}, s);\r\n\r\n\t\t\ts['class'] = s['class'] + ' ' + ed.getParam('skin') + 'Skin';\r\n\t\t\tif (v = ed.getParam('skin_variant'))\r\n\t\t\t\ts['class'] += ' ' + ed.getParam('skin') + 'Skin' + v.substring(0, 1).toUpperCase() + v.substring(1);\r\n\r\n\t\t\tid = t.prefix + id;\r\n\t\t\tcls = cc || t._cls.dropmenu || tinymce.ui.DropMenu;\r\n\t\t\tc = t.controls[id] = new cls(id, s);\r\n\t\t\tc.onAddItem.add(function(c, o) {\r\n\t\t\t\tvar s = o.settings;\r\n\r\n\t\t\t\ts.title = ed.getLang(s.title, s.title);\r\n\r\n\t\t\t\tif (!s.onclick) {\r\n\t\t\t\t\ts.onclick = function(v) {\r\n\t\t\t\t\t\tif (s.cmd)\r\n\t\t\t\t\t\t\ted.execCommand(s.cmd, s.ui || false, s.value);\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\ted.onRemove.add(function() {\r\n\t\t\t\tc.destroy();\r\n\t\t\t});\r\n\r\n\t\t\t// Fix for bug #1897785, #1898007\r\n\t\t\tif (tinymce.isIE) {\r\n\t\t\t\tc.onShowMenu.add(function() {\r\n\t\t\t\t\t// IE 8 needs focus in order to store away a range with the current collapsed caret location\r\n\t\t\t\t\ted.focus();\r\n\r\n\t\t\t\t\tbm = ed.selection.getBookmark(1);\r\n\t\t\t\t});\r\n\r\n\t\t\t\tc.onHideMenu.add(function() {\r\n\t\t\t\t\tif (bm) {\r\n\t\t\t\t\t\ted.selection.moveToBookmark(bm);\r\n\t\t\t\t\t\tbm = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\treturn t.add(c);\r\n\t\t},\r\n\r\n\t\tcreateListBox : function(id, s, cc) {\r\n\t\t\tvar t = this, ed = t.editor, cmd, c, cls;\r\n\r\n\t\t\tif (t.get(id))\r\n\t\t\t\treturn null;\r\n\r\n\t\t\ts.title = ed.translate(s.title);\r\n\t\t\ts.scope = s.scope || ed;\r\n\r\n\t\t\tif (!s.onselect) {\r\n\t\t\t\ts.onselect = function(v) {\r\n\t\t\t\t\ted.execCommand(s.cmd, s.ui || false, v || s.value);\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\ts = extend({\r\n\t\t\t\ttitle : s.title,\r\n\t\t\t\t'class' : 'mce_' + id,\r\n\t\t\t\tscope : s.scope,\r\n\t\t\t\tcontrol_manager : t\r\n\t\t\t}, s);\r\n\r\n\t\t\tid = t.prefix + id;\r\n\r\n\r\n\t\t\tfunction useNativeListForAccessibility(ed) {\r\n\t\t\t\treturn ed.settings.use_accessible_selects && !tinymce.isGecko\r\n\t\t\t}\r\n\r\n\t\t\tif (ed.settings.use_native_selects || useNativeListForAccessibility(ed))\r\n\t\t\t\tc = new tinymce.ui.NativeListBox(id, s);\r\n\t\t\telse {\r\n\t\t\t\tcls = cc || t._cls.listbox || tinymce.ui.ListBox;\r\n\t\t\t\tc = new cls(id, s, ed);\r\n\t\t\t}\r\n\r\n\t\t\tt.controls[id] = c;\r\n\r\n\t\t\t// Fix focus problem in Safari\r\n\t\t\tif (tinymce.isWebKit) {\r\n\t\t\t\tc.onPostRender.add(function(c, n) {\r\n\t\t\t\t\t// Store bookmark on mousedown\r\n\t\t\t\t\tEvent.add(n, 'mousedown', function() {\r\n\t\t\t\t\t\ted.bookmark = ed.selection.getBookmark(1);\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\t// Restore on focus, since it might be lost\r\n\t\t\t\t\tEvent.add(n, 'focus', function() {\r\n\t\t\t\t\t\ted.selection.moveToBookmark(ed.bookmark);\r\n\t\t\t\t\t\ted.bookmark = null;\r\n\t\t\t\t\t});\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tif (c.hideMenu)\r\n\t\t\t\ted.onMouseDown.add(c.hideMenu, c);\r\n\r\n\t\t\treturn t.add(c);\r\n\t\t},\r\n\r\n\t\tcreateButton : function(id, s, cc) {\r\n\t\t\tvar t = this, ed = t.editor, o, c, cls;\r\n\r\n\t\t\tif (t.get(id))\r\n\t\t\t\treturn null;\r\n\r\n\t\t\ts.title = ed.translate(s.title);\r\n\t\t\ts.label = ed.translate(s.label);\r\n\t\t\ts.scope = s.scope || ed;\r\n\r\n\t\t\tif (!s.onclick && !s.menu_button) {\r\n\t\t\t\ts.onclick = function() {\r\n\t\t\t\t\ted.execCommand(s.cmd, s.ui || false, s.value);\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\ts = extend({\r\n\t\t\t\ttitle : s.title,\r\n\t\t\t\t'class' : 'mce_' + id,\r\n\t\t\t\tunavailable_prefix : ed.getLang('unavailable', ''),\r\n\t\t\t\tscope : s.scope,\r\n\t\t\t\tcontrol_manager : t\r\n\t\t\t}, s);\r\n\r\n\t\t\tid = t.prefix + id;\r\n\r\n\t\t\tif (s.menu_button) {\r\n\t\t\t\tcls = cc || t._cls.menubutton || tinymce.ui.MenuButton;\r\n\t\t\t\tc = new cls(id, s, ed);\r\n\t\t\t\ted.onMouseDown.add(c.hideMenu, c);\r\n\t\t\t} else {\r\n\t\t\t\tcls = t._cls.button || tinymce.ui.Button;\r\n\t\t\t\tc = new cls(id, s, ed);\r\n\t\t\t}\r\n\r\n\t\t\treturn t.add(c);\r\n\t\t},\r\n\r\n\t\tcreateMenuButton : function(id, s, cc) {\r\n\t\t\ts = s || {};\r\n\t\t\ts.menu_button = 1;\r\n\r\n\t\t\treturn this.createButton(id, s, cc);\r\n\t\t},\r\n\r\n\t\tcreateSplitButton : function(id, s, cc) {\r\n\t\t\tvar t = this, ed = t.editor, cmd, c, cls;\r\n\r\n\t\t\tif (t.get(id))\r\n\t\t\t\treturn null;\r\n\r\n\t\t\ts.title = ed.translate(s.title);\r\n\t\t\ts.scope = s.scope || ed;\r\n\r\n\t\t\tif (!s.onclick) {\r\n\t\t\t\ts.onclick = function(v) {\r\n\t\t\t\t\ted.execCommand(s.cmd, s.ui || false, v || s.value);\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\tif (!s.onselect) {\r\n\t\t\t\ts.onselect = function(v) {\r\n\t\t\t\t\ted.execCommand(s.cmd, s.ui || false, v || s.value);\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\ts = extend({\r\n\t\t\t\ttitle : s.title,\r\n\t\t\t\t'class' : 'mce_' + id,\r\n\t\t\t\tscope : s.scope,\r\n\t\t\t\tcontrol_manager : t\r\n\t\t\t}, s);\r\n\r\n\t\t\tid = t.prefix + id;\r\n\t\t\tcls = cc || t._cls.splitbutton || tinymce.ui.SplitButton;\r\n\t\t\tc = t.add(new cls(id, s, ed));\r\n\t\t\ted.onMouseDown.add(c.hideMenu, c);\r\n\r\n\t\t\treturn c;\r\n\t\t},\r\n\r\n\t\tcreateColorSplitButton : function(id, s, cc) {\r\n\t\t\tvar t = this, ed = t.editor, cmd, c, cls, bm;\r\n\r\n\t\t\tif (t.get(id))\r\n\t\t\t\treturn null;\r\n\r\n\t\t\ts.title = ed.translate(s.title);\r\n\t\t\ts.scope = s.scope || ed;\r\n\r\n\t\t\tif (!s.onclick) {\r\n\t\t\t\ts.onclick = function(v) {\r\n\t\t\t\t\tif (tinymce.isIE)\r\n\t\t\t\t\t\tbm = ed.selection.getBookmark(1);\r\n\r\n\t\t\t\t\ted.execCommand(s.cmd, s.ui || false, v || s.value);\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\tif (!s.onselect) {\r\n\t\t\t\ts.onselect = function(v) {\r\n\t\t\t\t\ted.execCommand(s.cmd, s.ui || false, v || s.value);\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\ts = extend({\r\n\t\t\t\ttitle : s.title,\r\n\t\t\t\t'class' : 'mce_' + id,\r\n\t\t\t\t'menu_class' : ed.getParam('skin') + 'Skin',\r\n\t\t\t\tscope : s.scope,\r\n\t\t\t\tmore_colors_title : ed.getLang('more_colors')\r\n\t\t\t}, s);\r\n\r\n\t\t\tid = t.prefix + id;\r\n\t\t\tcls = cc || t._cls.colorsplitbutton || tinymce.ui.ColorSplitButton;\r\n\t\t\tc = new cls(id, s, ed);\r\n\t\t\ted.onMouseDown.add(c.hideMenu, c);\r\n\r\n\t\t\t// Remove the menu element when the editor is removed\r\n\t\t\ted.onRemove.add(function() {\r\n\t\t\t\tc.destroy();\r\n\t\t\t});\r\n\r\n\t\t\t// Fix for bug #1897785, #1898007\r\n\t\t\tif (tinymce.isIE) {\r\n\t\t\t\tc.onShowMenu.add(function() {\r\n\t\t\t\t\t// IE 8 needs focus in order to store away a range with the current collapsed caret location\r\n\t\t\t\t\ted.focus();\r\n\t\t\t\t\tbm = ed.selection.getBookmark(1);\r\n\t\t\t\t});\r\n\r\n\t\t\t\tc.onHideMenu.add(function() {\r\n\t\t\t\t\tif (bm) {\r\n\t\t\t\t\t\ted.selection.moveToBookmark(bm);\r\n\t\t\t\t\t\tbm = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\treturn t.add(c);\r\n\t\t},\r\n\r\n\t\tcreateToolbar : function(id, s, cc) {\r\n\t\t\tvar c, t = this, cls;\r\n\r\n\t\t\tid = t.prefix + id;\r\n\t\t\tcls = cc || t._cls.toolbar || tinymce.ui.Toolbar;\r\n\t\t\tc = new cls(id, s, t.editor);\r\n\r\n\t\t\tif (t.get(id))\r\n\t\t\t\treturn null;\r\n\r\n\t\t\treturn t.add(c);\r\n\t\t},\r\n\r\n\t\tcreateToolbarGroup : function(id, s, cc) {\r\n\t\t\tvar c, t = this, cls;\r\n\t\t\tid = t.prefix + id;\r\n\t\t\tcls = cc || this._cls.toolbarGroup || tinymce.ui.ToolbarGroup;\r\n\t\t\tc = new cls(id, s, t.editor);\r\n\r\n\t\t\tif (t.get(id))\r\n\t\t\t\treturn null;\r\n\r\n\t\t\treturn t.add(c);\r\n\t\t},\r\n\r\n\t\tcreateSeparator : function(cc) {\r\n\t\t\tvar cls = cc || this._cls.separator || tinymce.ui.Separator;\r\n\r\n\t\t\treturn new cls();\r\n\t\t},\r\n\r\n\t\tsetControlType : function(n, c) {\r\n\t\t\treturn this._cls[n.toLowerCase()] = c;\r\n\t\t},\r\n\r\n\t\tdestroy : function() {\r\n\t\t\teach(this.controls, function(c) {\r\n\t\t\t\tc.destroy();\r\n\t\t\t});\r\n\r\n\t\t\tthis.controls = null;\r\n\t\t}\r\n\t});\r\n})(tinymce);\r\n\r\n(function(tinymce) {\r\n\tvar Dispatcher = tinymce.util.Dispatcher, each = tinymce.each, isIE = tinymce.isIE, isOpera = tinymce.isOpera;\r\n\r\n\ttinymce.create('tinymce.WindowManager', {\r\n\t\tWindowManager : function(ed) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\tt.editor = ed;\r\n\t\t\tt.onOpen = new Dispatcher(t);\r\n\t\t\tt.onClose = new Dispatcher(t);\r\n\t\t\tt.params = {};\r\n\t\t\tt.features = {};\r\n\t\t},\r\n\r\n\t\topen : function(s, p) {\r\n\t\t\tvar t = this, f = '', x, y, mo = t.editor.settings.dialog_type == 'modal', w, sw, sh, vp = tinymce.DOM.getViewPort(), u;\r\n\r\n\t\t\t// Default some options\r\n\t\t\ts = s || {};\r\n\t\t\tp = p || {};\r\n\t\t\tsw = isOpera ? vp.w : screen.width; // Opera uses windows inside the Opera window\r\n\t\t\tsh = isOpera ? vp.h : screen.height;\r\n\t\t\ts.name = s.name || 'mc_' + new Date().getTime();\r\n\t\t\ts.width = parseInt(s.width || 320);\r\n\t\t\ts.height = parseInt(s.height || 240);\r\n\t\t\ts.resizable = true;\r\n\t\t\ts.left = s.left || parseInt(sw / 2.0) - (s.width / 2.0);\r\n\t\t\ts.top = s.top || parseInt(sh / 2.0) - (s.height / 2.0);\r\n\t\t\tp.inline = false;\r\n\t\t\tp.mce_width = s.width;\r\n\t\t\tp.mce_height = s.height;\r\n\t\t\tp.mce_auto_focus = s.auto_focus;\r\n\r\n\t\t\tif (mo) {\r\n\t\t\t\tif (isIE) {\r\n\t\t\t\t\ts.center = true;\r\n\t\t\t\t\ts.help = false;\r\n\t\t\t\t\ts.dialogWidth = s.width + 'px';\r\n\t\t\t\t\ts.dialogHeight = s.height + 'px';\r\n\t\t\t\t\ts.scroll = s.scrollbars || false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Build features string\r\n\t\t\teach(s, function(v, k) {\r\n\t\t\t\tif (tinymce.is(v, 'boolean'))\r\n\t\t\t\t\tv = v ? 'yes' : 'no';\r\n\r\n\t\t\t\tif (!/^(name|url)$/.test(k)) {\r\n\t\t\t\t\tif (isIE && mo)\r\n\t\t\t\t\t\tf += (f ? ';' : '') + k + ':' + v;\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tf += (f ? ',' : '') + k + '=' + v;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tt.features = s;\r\n\t\t\tt.params = p;\r\n\t\t\tt.onOpen.dispatch(t, s, p);\r\n\r\n\t\t\tu = s.url || s.file;\r\n\t\t\tu = tinymce._addVer(u);\r\n\r\n\t\t\ttry {\r\n\t\t\t\tif (isIE && mo) {\r\n\t\t\t\t\tw = 1;\r\n\t\t\t\t\twindow.showModalDialog(u, window, f);\r\n\t\t\t\t} else\r\n\t\t\t\t\tw = window.open(u, s.name, f);\r\n\t\t\t} catch (ex) {\r\n\t\t\t\t// Ignore\r\n\t\t\t}\r\n\r\n\t\t\tif (!w)\r\n\t\t\t\talert(t.editor.getLang('popup_blocked'));\r\n\t\t},\r\n\r\n\t\tclose : function(w) {\r\n\t\t\tw.close();\r\n\t\t\tthis.onClose.dispatch(this);\r\n\t\t},\r\n\r\n\t\tcreateInstance : function(cl, a, b, c, d, e) {\r\n\t\t\tvar f = tinymce.resolve(cl);\r\n\r\n\t\t\treturn new f(a, b, c, d, e);\r\n\t\t},\r\n\r\n\t\tconfirm : function(t, cb, s, w) {\r\n\t\t\tw = w || window;\r\n\r\n\t\t\tcb.call(s || this, w.confirm(this._decode(this.editor.getLang(t, t))));\r\n\t\t},\r\n\r\n\t\talert : function(tx, cb, s, w) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\tw = w || window;\r\n\t\t\tw.alert(t._decode(t.editor.getLang(tx, tx)));\r\n\r\n\t\t\tif (cb)\r\n\t\t\t\tcb.call(s || t);\r\n\t\t},\r\n\r\n\t\tresizeBy : function(dw, dh, win) {\r\n\t\t\twin.resizeBy(dw, dh);\r\n\t\t},\r\n\r\n\t\t// Internal functions\r\n\r\n\t\t_decode : function(s) {\r\n\t\t\treturn tinymce.DOM.decode(s).replace(/\\\\n/g, '\\n');\r\n\t\t}\r\n\t});\r\n}(tinymce));\r\n(function(tinymce) {\r\n\ttinymce.Formatter = function(ed) {\r\n\t\tvar formats = {},\r\n\t\t\teach = tinymce.each,\r\n\t\t\tdom = ed.dom,\r\n\t\t\tselection = ed.selection,\r\n\t\t\tTreeWalker = tinymce.dom.TreeWalker,\r\n\t\t\trangeUtils = new tinymce.dom.RangeUtils(dom),\r\n\t\t\tisValid = ed.schema.isValidChild,\r\n\t\t\tisBlock = dom.isBlock,\r\n\t\t\tforcedRootBlock = ed.settings.forced_root_block,\r\n\t\t\tnodeIndex = dom.nodeIndex,\r\n\t\t\tINVISIBLE_CHAR = '\\uFEFF',\r\n\t\t\tMCE_ATTR_RE = /^(src|href|style)$/,\r\n\t\t\tFALSE = false,\r\n\t\t\tTRUE = true,\r\n\t\t\tundefined;\r\n\r\n\t\tfunction isArray(obj) {\r\n\t\t\treturn obj instanceof Array;\r\n\t\t};\r\n\r\n\t\tfunction getParents(node, selector) {\r\n\t\t\treturn dom.getParents(node, selector, dom.getRoot());\r\n\t\t};\r\n\r\n\t\tfunction isCaretNode(node) {\r\n\t\t\treturn node.nodeType === 1 && (node.face === 'mceinline' || node.style.fontFamily === 'mceinline');\r\n\t\t};\r\n\r\n\t\t// Public functions\r\n\r\n\t\tfunction get(name) {\r\n\t\t\treturn name ? formats[name] : formats;\r\n\t\t};\r\n\r\n\t\tfunction register(name, format) {\r\n\t\t\tif (name) {\r\n\t\t\t\tif (typeof(name) !== 'string') {\r\n\t\t\t\t\teach(name, function(format, name) {\r\n\t\t\t\t\t\tregister(name, format);\r\n\t\t\t\t\t});\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Force format into array and add it to internal collection\r\n\t\t\t\t\tformat = format.length ? format : [format];\r\n\r\n\t\t\t\t\teach(format, function(format) {\r\n\t\t\t\t\t\t// Set deep to false by default on selector formats this to avoid removing\r\n\t\t\t\t\t\t// alignment on images inside paragraphs when alignment is changed on paragraphs\r\n\t\t\t\t\t\tif (format.deep === undefined)\r\n\t\t\t\t\t\t\tformat.deep = !format.selector;\r\n\r\n\t\t\t\t\t\t// Default to true\r\n\t\t\t\t\t\tif (format.split === undefined)\r\n\t\t\t\t\t\t\tformat.split = !format.selector || format.inline;\r\n\r\n\t\t\t\t\t\t// Default to true\r\n\t\t\t\t\t\tif (format.remove === undefined && format.selector && !format.inline)\r\n\t\t\t\t\t\t\tformat.remove = 'none';\r\n\r\n\t\t\t\t\t\t// Mark format as a mixed format inline + block level\r\n\t\t\t\t\t\tif (format.selector && format.inline) {\r\n\t\t\t\t\t\t\tformat.mixed = true;\r\n\t\t\t\t\t\t\tformat.block_expand = true;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Split classes if needed\r\n\t\t\t\t\t\tif (typeof(format.classes) === 'string')\r\n\t\t\t\t\t\t\tformat.classes = format.classes.split(/\\s+/);\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\tformats[name] = format;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tvar getTextDecoration = function(node) {\r\n\t\t\tvar decoration;\r\n\r\n\t\t\ted.dom.getParent(node, function(n) {\r\n\t\t\t\tdecoration = ed.dom.getStyle(n, 'text-decoration');\r\n\t\t\t\treturn decoration && decoration !== 'none';\r\n\t\t\t});\r\n\r\n\t\t\treturn decoration;\r\n\t\t};\r\n\r\n\t\tvar processUnderlineAndColor = function(node) {\r\n\t\t\tvar textDecoration;\r\n\t\t\tif (node.nodeType === 1 && node.parentNode && node.parentNode.nodeType === 1) {\r\n\t\t\t\ttextDecoration = getTextDecoration(node.parentNode);\r\n\t\t\t\tif (ed.dom.getStyle(node, 'color') && textDecoration) {\r\n\t\t\t\t\ted.dom.setStyle(node, 'text-decoration', textDecoration);\r\n\t\t\t\t} else if (ed.dom.getStyle(node, 'textdecoration') === textDecoration) {\r\n\t\t\t\t\ted.dom.setStyle(node, 'text-decoration', null);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tfunction apply(name, vars, node) {\r\n\t\t\tvar formatList = get(name), format = formatList[0], bookmark, rng, i, isCollapsed = selection.isCollapsed();\r\n\r\n\t\t\tfunction moveStart(rng) {\r\n\t\t\t\tvar container = rng.startContainer,\r\n\t\t\t\t\toffset = rng.startOffset,\r\n\t\t\t\t\twalker, node;\r\n\r\n\t\t\t\t// Move startContainer/startOffset in to a suitable node\r\n\t\t\t\tif (container.nodeType == 1 || container.nodeValue === \"\") {\r\n\t\t\t\t\tcontainer = container.nodeType == 1 ? container.childNodes[offset] : container;\r\n\r\n\t\t\t\t\t// Might fail if the offset is behind the last element in it's container\r\n\t\t\t\t\tif (container) {\r\n\t\t\t\t\t\twalker = new TreeWalker(container, container.parentNode);\r\n\t\t\t\t\t\tfor (node = walker.current(); node; node = walker.next()) {\r\n\t\t\t\t\t\t\tif (node.nodeType == 3 && !isWhiteSpaceNode(node)) {\r\n\t\t\t\t\t\t\t\trng.setStart(node, 0);\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn rng;\r\n\t\t\t};\r\n\r\n\t\t\tfunction setElementFormat(elm, fmt) {\r\n\t\t\t\tfmt = fmt || format;\r\n\r\n\t\t\t\tif (elm) {\r\n\t\t\t\t\tif (fmt.onformat) {\r\n\t\t\t\t\t\tfmt.onformat(elm, fmt, vars, node);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\teach(fmt.styles, function(value, name) {\r\n\t\t\t\t\t\tdom.setStyle(elm, name, replaceVars(value, vars));\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\teach(fmt.attributes, function(value, name) {\r\n\t\t\t\t\t\tdom.setAttrib(elm, name, replaceVars(value, vars));\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\teach(fmt.classes, function(value) {\r\n\t\t\t\t\t\tvalue = replaceVars(value, vars);\r\n\r\n\t\t\t\t\t\tif (!dom.hasClass(elm, value))\r\n\t\t\t\t\t\t\tdom.addClass(elm, value);\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tfunction adjustSelectionToVisibleSelection() {\r\n\t\t\t\tfunction findSelectionEnd(start, end) {\r\n\t\t\t\t\tvar walker = new TreeWalker(end);\r\n\t\t\t\t\tfor (node = walker.current(); node; node = walker.prev()) {\r\n\t\t\t\t\t\tif (node.childNodes.length > 1 || node == start) {\r\n\t\t\t\t\t\t\treturn node;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\r\n\t\t\t\t// Adjust selection so that a end container with a end offset of zero is not included in the selection\r\n\t\t\t\t// as this isn't visible to the user.\r\n\t\t\t\tvar rng = ed.selection.getRng();\r\n\t\t\t\tvar start = rng.startContainer;\r\n\t\t\t\tvar end = rng.endContainer;\r\n\r\n\t\t\t\tif (start != end && rng.endOffset == 0) {\r\n\t\t\t\t\tvar newEnd = findSelectionEnd(start, end);\r\n\t\t\t\t\tvar endOffset = newEnd.nodeType == 3 ? newEnd.length : newEnd.childNodes.length;\r\n\r\n\t\t\t\t\trng.setEnd(newEnd, endOffset);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn rng;\r\n\t\t\t}\r\n\r\n\t\t\tfunction applyStyleToList(node, bookmark, wrapElm, newWrappers, process){\r\n\t\t\t\tvar nodes = [], listIndex = -1, list, startIndex = -1, endIndex = -1, currentWrapElm;\r\n\r\n\t\t\t\t// find the index of the first child list.\r\n\t\t\t\teach(node.childNodes, function(n, index) {\r\n\t\t\t\t\tif (n.nodeName === \"UL\" || n.nodeName === \"OL\") {\r\n\t\t\t\t\t\tlistIndex = index;\r\n\t\t\t\t\t\tlist = n;\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// get the index of the bookmarks\r\n\t\t\t\teach(node.childNodes, function(n, index) {\r\n\t\t\t\t\tif (n.nodeName === \"SPAN\" && dom.getAttrib(n, \"data-mce-type\") == \"bookmark\") {\r\n\t\t\t\t\t\tif (n.id == bookmark.id + \"_start\") {\r\n\t\t\t\t\t\t\tstartIndex = index;\r\n\t\t\t\t\t\t} else if (n.id == bookmark.id + \"_end\") {\r\n\t\t\t\t\t\t\tendIndex = index;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// if the selection spans across an embedded list, or there isn't an embedded list - handle processing normally\r\n\t\t\t\tif (listIndex <= 0 || (startIndex < listIndex && endIndex > listIndex)) {\r\n\t\t\t\t\teach(tinymce.grep(node.childNodes), process);\r\n\t\t\t\t\treturn 0;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcurrentWrapElm = wrapElm.cloneNode(FALSE);\r\n\r\n\t\t\t\t\t// create a list of the nodes on the same side of the list as the selection\r\n\t\t\t\t\teach(tinymce.grep(node.childNodes), function(n, index) {\r\n\t\t\t\t\t\tif ((startIndex < listIndex && index < listIndex) || (startIndex > listIndex && index > listIndex)) {\r\n\t\t\t\t\t\t\tnodes.push(n);\r\n\t\t\t\t\t\t\tn.parentNode.removeChild(n);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\t// insert the wrapping element either before or after the list.\r\n\t\t\t\t\tif (startIndex < listIndex) {\r\n\t\t\t\t\t\tnode.insertBefore(currentWrapElm, list);\r\n\t\t\t\t\t} else if (startIndex > listIndex) {\r\n\t\t\t\t\t\tnode.insertBefore(currentWrapElm, list.nextSibling);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// add the new nodes to the list.\r\n\t\t\t\t\tnewWrappers.push(currentWrapElm);\r\n\r\n\t\t\t\t\teach(nodes, function(node) {\r\n\t\t\t\t\t\tcurrentWrapElm.appendChild(node);\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\treturn currentWrapElm;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tfunction applyRngStyle(rng, bookmark, node_specific) {\r\n\t\t\t\tvar newWrappers = [], wrapName, wrapElm;\r\n\r\n\t\t\t\t// Setup wrapper element\r\n\t\t\t\twrapName = format.inline || format.block;\r\n\t\t\t\twrapElm = dom.create(wrapName);\r\n\t\t\t\tsetElementFormat(wrapElm);\r\n\r\n\t\t\t\trangeUtils.walk(rng, function(nodes) {\r\n\t\t\t\t\tvar currentWrapElm;\r\n\r\n\t\t\t\t\tfunction process(node) {\r\n\t\t\t\t\t\tvar nodeName = node.nodeName.toLowerCase(), parentName = node.parentNode.nodeName.toLowerCase(), found;\r\n\r\n\t\t\t\t\t\t// Stop wrapping on br elements\r\n\t\t\t\t\t\tif (isEq(nodeName, 'br')) {\r\n\t\t\t\t\t\t\tcurrentWrapElm = 0;\r\n\r\n\t\t\t\t\t\t\t// Remove any br elements when we wrap things\r\n\t\t\t\t\t\t\tif (format.block)\r\n\t\t\t\t\t\t\t\tdom.remove(node);\r\n\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// If node is wrapper type\r\n\t\t\t\t\t\tif (format.wrapper && matchNode(node, name, vars)) {\r\n\t\t\t\t\t\t\tcurrentWrapElm = 0;\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Can we rename the block\r\n\t\t\t\t\t\tif (format.block && !format.wrapper && isTextBlock(nodeName)) {\r\n\t\t\t\t\t\t\tnode = dom.rename(node, wrapName);\r\n\t\t\t\t\t\t\tsetElementFormat(node);\r\n\t\t\t\t\t\t\tnewWrappers.push(node);\r\n\t\t\t\t\t\t\tcurrentWrapElm = 0;\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Handle selector patterns\r\n\t\t\t\t\t\tif (format.selector) {\r\n\t\t\t\t\t\t\t// Look for matching formats\r\n\t\t\t\t\t\t\teach(formatList, function(format) {\r\n\t\t\t\t\t\t\t\t// Check collapsed state if it exists\r\n\t\t\t\t\t\t\t\tif ('collapsed' in format && format.collapsed !== isCollapsed) {\r\n\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tif (dom.is(node, format.selector) && !isCaretNode(node)) {\r\n\t\t\t\t\t\t\t\t\tsetElementFormat(node, format);\r\n\t\t\t\t\t\t\t\t\tfound = true;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t\t// Continue processing if a selector match wasn't found and a inline element is defined\r\n\t\t\t\t\t\t\tif (!format.inline || found) {\r\n\t\t\t\t\t\t\t\tcurrentWrapElm = 0;\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Is it valid to wrap this item\r\n\t\t\t\t\t\tif (isValid(wrapName, nodeName) && isValid(parentName, wrapName) &&\r\n\t\t\t\t\t\t\t\t!(!node_specific && node.nodeType === 3 && node.nodeValue.length === 1 && node.nodeValue.charCodeAt(0) === 65279) && node.id !== '_mce_caret') {\r\n\t\t\t\t\t\t\t// Start wrapping\r\n\t\t\t\t\t\t\tif (!currentWrapElm) {\r\n\t\t\t\t\t\t\t\t// Wrap the node\r\n\t\t\t\t\t\t\t\tcurrentWrapElm = wrapElm.cloneNode(FALSE);\r\n\t\t\t\t\t\t\t\tnode.parentNode.insertBefore(currentWrapElm, node);\r\n\t\t\t\t\t\t\t\tnewWrappers.push(currentWrapElm);\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tcurrentWrapElm.appendChild(node);\r\n\t\t\t\t\t\t} else if (nodeName == 'li' && bookmark) {\r\n\t\t\t\t\t\t\t// Start wrapping - if we are in a list node and have a bookmark, then we will always begin by wrapping in a new element.\r\n\t\t\t\t\t\t\tcurrentWrapElm = applyStyleToList(node, bookmark, wrapElm, newWrappers, process);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// Start a new wrapper for possible children\r\n\t\t\t\t\t\t\tcurrentWrapElm = 0;\r\n\r\n\t\t\t\t\t\t\teach(tinymce.grep(node.childNodes), process);\r\n\r\n\t\t\t\t\t\t\t// End the last wrapper\r\n\t\t\t\t\t\t\tcurrentWrapElm = 0;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\t// Process siblings from range\r\n\t\t\t\t\teach(nodes, process);\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// Wrap links inside as well, for example color inside a link when the wrapper is around the link\r\n\t\t\t\tif (format.wrap_links === false) {\r\n\t\t\t\t\teach(newWrappers, function(node) {\r\n\t\t\t\t\t\tfunction process(node) {\r\n\t\t\t\t\t\t\tvar i, currentWrapElm, children;\r\n\r\n\t\t\t\t\t\t\tif (node.nodeName === 'A') {\r\n\t\t\t\t\t\t\t\tcurrentWrapElm = wrapElm.cloneNode(FALSE);\r\n\t\t\t\t\t\t\t\tnewWrappers.push(currentWrapElm);\r\n\r\n\t\t\t\t\t\t\t\tchildren = tinymce.grep(node.childNodes);\r\n\t\t\t\t\t\t\t\tfor (i = 0; i < children.length; i++)\r\n\t\t\t\t\t\t\t\t\tcurrentWrapElm.appendChild(children[i]);\r\n\r\n\t\t\t\t\t\t\t\tnode.appendChild(currentWrapElm);\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\teach(tinymce.grep(node.childNodes), process);\r\n\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\tprocess(node);\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Cleanup\r\n\t\t\t\teach(newWrappers, function(node) {\r\n\t\t\t\t\tvar childCount;\r\n\r\n\t\t\t\t\tfunction getChildCount(node) {\r\n\t\t\t\t\t\tvar count = 0;\r\n\r\n\t\t\t\t\t\teach(node.childNodes, function(node) {\r\n\t\t\t\t\t\t\tif (!isWhiteSpaceNode(node) && !isBookmarkNode(node))\r\n\t\t\t\t\t\t\t\tcount++;\r\n\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\treturn count;\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tfunction mergeStyles(node) {\r\n\t\t\t\t\t\tvar child, clone;\r\n\r\n\t\t\t\t\t\teach(node.childNodes, function(node) {\r\n\t\t\t\t\t\t\tif (node.nodeType == 1 && !isBookmarkNode(node) && !isCaretNode(node)) {\r\n\t\t\t\t\t\t\t\tchild = node;\r\n\t\t\t\t\t\t\t\treturn FALSE; // break loop\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t// If child was found and of the same type as the current node\r\n\t\t\t\t\t\tif (child && matchName(child, format)) {\r\n\t\t\t\t\t\t\tclone = child.cloneNode(FALSE);\r\n\t\t\t\t\t\t\tsetElementFormat(clone);\r\n\r\n\t\t\t\t\t\t\tdom.replace(clone, node, TRUE);\r\n\t\t\t\t\t\t\tdom.remove(child, 1);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn clone || node;\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tchildCount = getChildCount(node);\r\n\r\n\t\t\t\t\t// Remove empty nodes but only if there is multiple wrappers and they are not block\r\n\t\t\t\t\t// elements so never remove single <h1></h1> since that would remove the current empty block element where the caret is at\r\n\t\t\t\t\tif ((newWrappers.length > 1 || !isBlock(node)) && childCount === 0) {\r\n\t\t\t\t\t\tdom.remove(node, 1);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (format.inline || format.wrapper) {\r\n\t\t\t\t\t\t// Merges the current node with it's children of similar type to reduce the number of elements\r\n\t\t\t\t\t\tif (!format.exact && childCount === 1)\r\n\t\t\t\t\t\t\tnode = mergeStyles(node);\r\n\r\n\t\t\t\t\t\t// Remove/merge children\r\n\t\t\t\t\t\teach(formatList, function(format) {\r\n\t\t\t\t\t\t\t// Merge all children of similar type will move styles from child to parent\r\n\t\t\t\t\t\t\t// this: <span style=\"color:red\"><b><span style=\"color:red; font-size:10px\">text</span></b></span>\r\n\t\t\t\t\t\t\t// will become: <span style=\"color:red\"><b><span style=\"font-size:10px\">text</span></b></span>\r\n\t\t\t\t\t\t\teach(dom.select(format.inline, node), function(child) {\r\n\t\t\t\t\t\t\t\tvar parent;\r\n\r\n\t\t\t\t\t\t\t\t// When wrap_links is set to false we don't want\r\n\t\t\t\t\t\t\t\t// to remove the format on children within links\r\n\t\t\t\t\t\t\t\tif (format.wrap_links === false) {\r\n\t\t\t\t\t\t\t\t\tparent = child.parentNode;\r\n\r\n\t\t\t\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\t\t\t\tif (parent.nodeName === 'A')\r\n\t\t\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t\t\t} while (parent = parent.parentNode);\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tremoveFormat(format, vars, child, format.exact ? child : null);\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t// Remove child if direct parent is of same type\r\n\t\t\t\t\t\tif (matchNode(node.parentNode, name, vars)) {\r\n\t\t\t\t\t\t\tdom.remove(node, 1);\r\n\t\t\t\t\t\t\tnode = 0;\r\n\t\t\t\t\t\t\treturn TRUE;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Look for parent with similar style format\r\n\t\t\t\t\t\tif (format.merge_with_parents) {\r\n\t\t\t\t\t\t\tdom.getParent(node.parentNode, function(parent) {\r\n\t\t\t\t\t\t\t\tif (matchNode(parent, name, vars)) {\r\n\t\t\t\t\t\t\t\t\tdom.remove(node, 1);\r\n\t\t\t\t\t\t\t\t\tnode = 0;\r\n\t\t\t\t\t\t\t\t\treturn TRUE;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Merge next and previous siblings if they are similar <b>text</b><b>text</b> becomes <b>texttext</b>\r\n\t\t\t\t\t\tif (node && format.merge_siblings !== false) {\r\n\t\t\t\t\t\t\tnode = mergeSiblings(getNonWhiteSpaceSibling(node), node);\r\n\t\t\t\t\t\t\tnode = mergeSiblings(node, getNonWhiteSpaceSibling(node, TRUE));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t};\r\n\r\n\t\t\tif (format) {\r\n\t\t\t\tif (node) {\r\n\t\t\t\t\tif (node.nodeType) {\r\n\t\t\t\t\t\trng = dom.createRng();\r\n\t\t\t\t\t\trng.setStartBefore(node);\r\n\t\t\t\t\t\trng.setEndAfter(node);\r\n\t\t\t\t\t\tapplyRngStyle(expandRng(rng, formatList), null, true);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tapplyRngStyle(node, null, true);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (!isCollapsed || !format.inline || dom.select('td.mceSelected,th.mceSelected').length) {\r\n\t\t\t\t\t\t// Obtain selection node before selection is unselected by applyRngStyle()\r\n\t\t\t\t\t\tvar curSelNode = ed.selection.getNode();\r\n\r\n\t\t\t\t\t\t// Apply formatting to selection\r\n\t\t\t\t\t\ted.selection.setRng(adjustSelectionToVisibleSelection());\r\n\t\t\t\t\t\tbookmark = selection.getBookmark();\r\n\t\t\t\t\t\tapplyRngStyle(expandRng(selection.getRng(TRUE), formatList), bookmark);\r\n\r\n\t\t\t\t\t\t// Colored nodes should be underlined so that the color of the underline matches the text color.\r\n\t\t\t\t\t\tif (format.styles && (format.styles.color || format.styles.textDecoration)) {\r\n\t\t\t\t\t\t\ttinymce.walk(curSelNode, processUnderlineAndColor, 'childNodes');\r\n\t\t\t\t\t\t\tprocessUnderlineAndColor(curSelNode);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tselection.moveToBookmark(bookmark);\r\n\t\t\t\t\t\tselection.setRng(moveStart(selection.getRng(TRUE)));\r\n\t\t\t\t\t\ted.nodeChanged();\r\n\t\t\t\t\t} else\r\n\t\t\t\t\t\tperformCaretAction('apply', name, vars);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tfunction remove(name, vars, node) {\r\n\t\t\tvar formatList = get(name), format = formatList[0], bookmark, i, rng;\r\n\t\t\tfunction moveStart(rng) {\r\n\t\t\t\tvar container = rng.startContainer,\r\n\t\t\t\t\toffset = rng.startOffset,\r\n\t\t\t\t\twalker, node, nodes, tmpNode;\r\n\r\n\t\t\t\t// Convert text node into index if possible\r\n\t\t\t\tif (container.nodeType == 3 && offset >= container.nodeValue.length - 1) {\r\n\t\t\t\t\tcontainer = container.parentNode;\r\n\t\t\t\t\toffset = nodeIndex(container) + 1;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Move startContainer/startOffset in to a suitable node\r\n\t\t\t\tif (container.nodeType == 1) {\r\n\t\t\t\t\tnodes = container.childNodes;\r\n\t\t\t\t\tcontainer = nodes[Math.min(offset, nodes.length - 1)];\r\n\t\t\t\t\twalker = new TreeWalker(container);\r\n\r\n\t\t\t\t\t// If offset is at end of the parent node walk to the next one\r\n\t\t\t\t\tif (offset > nodes.length - 1)\r\n\t\t\t\t\t\twalker.next();\r\n\r\n\t\t\t\t\tfor (node = walker.current(); node; node = walker.next()) {\r\n\t\t\t\t\t\tif (node.nodeType == 3 && !isWhiteSpaceNode(node)) {\r\n\t\t\t\t\t\t\t// IE has a \"neat\" feature where it moves the start node into the closest element\r\n\t\t\t\t\t\t\t// we can avoid this by inserting an element before it and then remove it after we set the selection\r\n\t\t\t\t\t\t\ttmpNode = dom.create('a', null, INVISIBLE_CHAR);\r\n\t\t\t\t\t\t\tnode.parentNode.insertBefore(tmpNode, node);\r\n\r\n\t\t\t\t\t\t\t// Set selection and remove tmpNode\r\n\t\t\t\t\t\t\trng.setStart(node, 0);\r\n\t\t\t\t\t\t\tselection.setRng(rng);\r\n\t\t\t\t\t\t\tdom.remove(tmpNode);\r\n\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\t// Merges the styles for each node\r\n\t\t\tfunction process(node) {\r\n\t\t\t\tvar children, i, l;\r\n\r\n\t\t\t\t// Grab the children first since the nodelist might be changed\r\n\t\t\t\tchildren = tinymce.grep(node.childNodes);\r\n\r\n\t\t\t\t// Process current node\r\n\t\t\t\tfor (i = 0, l = formatList.length; i < l; i++) {\r\n\t\t\t\t\tif (removeFormat(formatList[i], vars, node, node))\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Process the children\r\n\t\t\t\tif (format.deep) {\r\n\t\t\t\t\tfor (i = 0, l = children.length; i < l; i++)\r\n\t\t\t\t\t\tprocess(children[i]);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tfunction findFormatRoot(container) {\r\n\t\t\t\tvar formatRoot;\r\n\r\n\t\t\t\t// Find format root\r\n\t\t\t\teach(getParents(container.parentNode).reverse(), function(parent) {\r\n\t\t\t\t\tvar format;\r\n\r\n\t\t\t\t\t// Find format root element\r\n\t\t\t\t\tif (!formatRoot && parent.id != '_start' && parent.id != '_end') {\r\n\t\t\t\t\t\t// Is the node matching the format we are looking for\r\n\t\t\t\t\t\tformat = matchNode(parent, name, vars);\r\n\t\t\t\t\t\tif (format && format.split !== false)\r\n\t\t\t\t\t\t\tformatRoot = parent;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\treturn formatRoot;\r\n\t\t\t};\r\n\r\n\t\t\tfunction wrapAndSplit(format_root, container, target, split) {\r\n\t\t\t\tvar parent, clone, lastClone, firstClone, i, formatRootParent;\r\n\r\n\t\t\t\t// Format root found then clone formats and split it\r\n\t\t\t\tif (format_root) {\r\n\t\t\t\t\tformatRootParent = format_root.parentNode;\r\n\r\n\t\t\t\t\tfor (parent = container.parentNode; parent && parent != formatRootParent; parent = parent.parentNode) {\r\n\t\t\t\t\t\tclone = parent.cloneNode(FALSE);\r\n\r\n\t\t\t\t\t\tfor (i = 0; i < formatList.length; i++) {\r\n\t\t\t\t\t\t\tif (removeFormat(formatList[i], vars, clone, clone)) {\r\n\t\t\t\t\t\t\t\tclone = 0;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Build wrapper node\r\n\t\t\t\t\t\tif (clone) {\r\n\t\t\t\t\t\t\tif (lastClone)\r\n\t\t\t\t\t\t\t\tclone.appendChild(lastClone);\r\n\r\n\t\t\t\t\t\t\tif (!firstClone)\r\n\t\t\t\t\t\t\t\tfirstClone = clone;\r\n\r\n\t\t\t\t\t\t\tlastClone = clone;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Never split block elements if the format is mixed\r\n\t\t\t\t\tif (split && (!format.mixed || !isBlock(format_root)))\r\n\t\t\t\t\t\tcontainer = dom.split(format_root, container);\r\n\r\n\t\t\t\t\t// Wrap container in cloned formats\r\n\t\t\t\t\tif (lastClone) {\r\n\t\t\t\t\t\ttarget.parentNode.insertBefore(lastClone, target);\r\n\t\t\t\t\t\tfirstClone.appendChild(target);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn container;\r\n\t\t\t};\r\n\r\n\t\t\tfunction splitToFormatRoot(container) {\r\n\t\t\t\treturn wrapAndSplit(findFormatRoot(container), container, container, true);\r\n\t\t\t};\r\n\r\n\t\t\tfunction unwrap(start) {\r\n\t\t\t\tvar node = dom.get(start ? '_start' : '_end'),\r\n\t\t\t\t\tout = node[start ? 'firstChild' : 'lastChild'];\r\n\r\n\t\t\t\t// If the end is placed within the start the result will be removed\r\n\t\t\t\t// So this checks if the out node is a bookmark node if it is it\r\n\t\t\t\t// checks for another more suitable node\r\n\t\t\t\tif (isBookmarkNode(out))\r\n\t\t\t\t\tout = out[start ? 'firstChild' : 'lastChild'];\r\n\r\n\t\t\t\tdom.remove(node, true);\r\n\r\n\t\t\t\treturn out;\r\n\t\t\t};\r\n\r\n\t\t\tfunction removeRngStyle(rng) {\r\n\t\t\t\tvar startContainer, endContainer;\r\n\r\n\t\t\t\trng = expandRng(rng, formatList, TRUE);\r\n\r\n\t\t\t\tif (format.split) {\r\n\t\t\t\t\tstartContainer = getContainer(rng, TRUE);\r\n\t\t\t\t\tendContainer = getContainer(rng);\r\n\r\n\t\t\t\t\tif (startContainer != endContainer) {\r\n\t\t\t\t\t\t// Wrap start/end nodes in span element since these might be cloned/moved\r\n\t\t\t\t\t\tstartContainer = wrap(startContainer, 'span', {id : '_start', 'data-mce-type' : 'bookmark'});\r\n\t\t\t\t\t\tendContainer = wrap(endContainer, 'span', {id : '_end', 'data-mce-type' : 'bookmark'});\r\n\r\n\t\t\t\t\t\t// Split start/end\r\n\t\t\t\t\t\tsplitToFormatRoot(startContainer);\r\n\t\t\t\t\t\tsplitToFormatRoot(endContainer);\r\n\r\n\t\t\t\t\t\t// Unwrap start/end to get real elements again\r\n\t\t\t\t\t\tstartContainer = unwrap(TRUE);\r\n\t\t\t\t\t\tendContainer = unwrap();\r\n\t\t\t\t\t} else\r\n\t\t\t\t\t\tstartContainer = endContainer = splitToFormatRoot(startContainer);\r\n\r\n\t\t\t\t\t// Update range positions since they might have changed after the split operations\r\n\t\t\t\t\trng.startContainer = startContainer.parentNode;\r\n\t\t\t\t\trng.startOffset = nodeIndex(startContainer);\r\n\t\t\t\t\trng.endContainer = endContainer.parentNode;\r\n\t\t\t\t\trng.endOffset = nodeIndex(endContainer) + 1;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Remove items between start/end\r\n\t\t\t\trangeUtils.walk(rng, function(nodes) {\r\n\t\t\t\t\teach(nodes, function(node) {\r\n\t\t\t\t\t\tprocess(node);\r\n\r\n\t\t\t\t\t\t// Remove parent span if it only contains text-decoration: underline, yet a parent node is also underlined.\r\n\t\t\t\t\t\tif (node.nodeType === 1 && ed.dom.getStyle(node, 'text-decoration') === 'underline' && node.parentNode && getTextDecoration(node.parentNode) === 'underline') {\r\n\t\t\t\t\t\t\tremoveFormat({'deep': false, 'exact': true, 'inline': 'span', 'styles': {'textDecoration' : 'underline'}}, null, node);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t});\r\n\t\t\t};\r\n\r\n\t\t\t// Handle node\r\n\t\t\tif (node) {\r\n\t\t\t\tif (node.nodeType) {\r\n\t\t\t\t\trng = dom.createRng();\r\n\t\t\t\t\trng.setStartBefore(node);\r\n\t\t\t\t\trng.setEndAfter(node);\r\n\t\t\t\t\tremoveRngStyle(rng);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tremoveRngStyle(node);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (!selection.isCollapsed() || !format.inline || dom.select('td.mceSelected,th.mceSelected').length) {\r\n\t\t\t\tbookmark = selection.getBookmark();\r\n\t\t\t\tremoveRngStyle(selection.getRng(TRUE));\r\n\t\t\t\tselection.moveToBookmark(bookmark);\r\n\r\n\t\t\t\t// Check if start element still has formatting then we are at: \"<b>text|</b>text\" and need to move the start into the next text node\r\n\t\t\t\tif (format.inline && match(name, vars, selection.getStart())) {\r\n\t\t\t\t\tmoveStart(selection.getRng(true));\r\n\t\t\t\t}\r\n\r\n\t\t\t\ted.nodeChanged();\r\n\t\t\t} else\r\n\t\t\t\tperformCaretAction('remove', name, vars);\r\n\r\n\t\t\t// When you remove formatting from a table cell in WebKit (cell, not the contents of a cell) there is a rendering issue with column width\r\n\t\t\tif (tinymce.isWebKit) {\r\n\t\t\t\ted.execCommand('mceCleanup');\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tfunction toggle(name, vars, node) {\r\n\t\t\tvar fmt = get(name);\r\n\r\n\t\t\tif (match(name, vars, node) && (!('toggle' in fmt[0]) || fmt[0]['toggle']))\r\n\t\t\t\tremove(name, vars, node);\r\n\t\t\telse\r\n\t\t\t\tapply(name, vars, node);\r\n\t\t};\r\n\r\n\t\tfunction matchNode(node, name, vars, similar) {\r\n\t\t\tvar formatList = get(name), format, i, classes;\r\n\r\n\t\t\tfunction matchItems(node, format, item_name) {\r\n\t\t\t\tvar key, value, items = format[item_name], i;\r\n\r\n\t\t\t\t// Custom match\r\n\t\t\t\tif (format.onmatch) {\r\n\t\t\t\t\treturn format.onmatch(node, format, item_name);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Check all items\r\n\t\t\t\tif (items) {\r\n\t\t\t\t\t// Non indexed object\r\n\t\t\t\t\tif (items.length === undefined) {\r\n\t\t\t\t\t\tfor (key in items) {\r\n\t\t\t\t\t\t\tif (items.hasOwnProperty(key)) {\r\n\t\t\t\t\t\t\t\tif (item_name === 'attributes')\r\n\t\t\t\t\t\t\t\t\tvalue = dom.getAttrib(node, key);\r\n\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\tvalue = getStyle(node, key);\r\n\r\n\t\t\t\t\t\t\t\tif (similar && !value && !format.exact)\r\n\t\t\t\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t\t\t\tif ((!similar || format.exact) && !isEq(value, replaceVars(items[key], vars)))\r\n\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// Only one match needed for indexed arrays\r\n\t\t\t\t\t\tfor (i = 0; i < items.length; i++) {\r\n\t\t\t\t\t\t\tif (item_name === 'attributes' ? dom.getAttrib(node, items[i]) : getStyle(node, items[i]))\r\n\t\t\t\t\t\t\t\treturn format;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn format;\r\n\t\t\t};\r\n\r\n\t\t\tif (formatList && node) {\r\n\t\t\t\t// Check each format in list\r\n\t\t\t\tfor (i = 0; i < formatList.length; i++) {\r\n\t\t\t\t\tformat = formatList[i];\r\n\r\n\t\t\t\t\t// Name name, attributes, styles and classes\r\n\t\t\t\t\tif (matchName(node, format) && matchItems(node, format, 'attributes') && matchItems(node, format, 'styles')) {\r\n\t\t\t\t\t\t// Match classes\r\n\t\t\t\t\t\tif (classes = format.classes) {\r\n\t\t\t\t\t\t\tfor (i = 0; i < classes.length; i++) {\r\n\t\t\t\t\t\t\t\tif (!dom.hasClass(node, classes[i]))\r\n\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn format;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tfunction match(name, vars, node) {\r\n\t\t\tvar startNode;\r\n\r\n\t\t\tfunction matchParents(node) {\r\n\t\t\t\t// Find first node with similar format settings\r\n\t\t\t\tnode = dom.getParent(node, function(node) {\r\n\t\t\t\t\treturn !!matchNode(node, name, vars, true);\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// Do an exact check on the similar format element\r\n\t\t\t\treturn matchNode(node, name, vars);\r\n\t\t\t};\r\n\r\n\t\t\t// Check specified node\r\n\t\t\tif (node)\r\n\t\t\t\treturn matchParents(node);\r\n\r\n\t\t\t// Check selected node\r\n\t\t\tnode = selection.getNode();\r\n\t\t\tif (matchParents(node))\r\n\t\t\t\treturn TRUE;\r\n\r\n\t\t\t// Check start node if it's different\r\n\t\t\tstartNode = selection.getStart();\r\n\t\t\tif (startNode != node) {\r\n\t\t\t\tif (matchParents(startNode))\r\n\t\t\t\t\treturn TRUE;\r\n\t\t\t}\r\n\r\n\t\t\treturn FALSE;\r\n\t\t};\r\n\r\n\t\tfunction matchAll(names, vars) {\r\n\t\t\tvar startElement, matchedFormatNames = [], checkedMap = {}, i, ni, name;\r\n\r\n\t\t\t// Check start of selection for formats\r\n\t\t\tstartElement = selection.getStart();\r\n\t\t\tdom.getParent(startElement, function(node) {\r\n\t\t\t\tvar i, name;\r\n\r\n\t\t\t\tfor (i = 0; i < names.length; i++) {\r\n\t\t\t\t\tname = names[i];\r\n\r\n\t\t\t\t\tif (!checkedMap[name] && matchNode(node, name, vars)) {\r\n\t\t\t\t\t\tcheckedMap[name] = true;\r\n\t\t\t\t\t\tmatchedFormatNames.push(name);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\treturn matchedFormatNames;\r\n\t\t};\r\n\r\n\t\tfunction canApply(name) {\r\n\t\t\tvar formatList = get(name), startNode, parents, i, x, selector;\r\n\r\n\t\t\tif (formatList) {\r\n\t\t\t\tstartNode = selection.getStart();\r\n\t\t\t\tparents = getParents(startNode);\r\n\r\n\t\t\t\tfor (x = formatList.length - 1; x >= 0; x--) {\r\n\t\t\t\t\tselector = formatList[x].selector;\r\n\r\n\t\t\t\t\t// Format is not selector based, then always return TRUE\r\n\t\t\t\t\tif (!selector)\r\n\t\t\t\t\t\treturn TRUE;\r\n\r\n\t\t\t\t\tfor (i = parents.length - 1; i >= 0; i--) {\r\n\t\t\t\t\t\tif (dom.is(parents[i], selector))\r\n\t\t\t\t\t\t\treturn TRUE;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn FALSE;\r\n\t\t};\r\n\r\n\t\t// Expose to public\r\n\t\ttinymce.extend(this, {\r\n\t\t\tget : get,\r\n\t\t\tregister : register,\r\n\t\t\tapply : apply,\r\n\t\t\tremove : remove,\r\n\t\t\ttoggle : toggle,\r\n\t\t\tmatch : match,\r\n\t\t\tmatchAll : matchAll,\r\n\t\t\tmatchNode : matchNode,\r\n\t\t\tcanApply : canApply\r\n\t\t});\r\n\r\n\t\t// Private functions\r\n\r\n\t\tfunction matchName(node, format) {\r\n\t\t\t// Check for inline match\r\n\t\t\tif (isEq(node, format.inline))\r\n\t\t\t\treturn TRUE;\r\n\r\n\t\t\t// Check for block match\r\n\t\t\tif (isEq(node, format.block))\r\n\t\t\t\treturn TRUE;\r\n\r\n\t\t\t// Check for selector match\r\n\t\t\tif (format.selector)\r\n\t\t\t\treturn dom.is(node, format.selector);\r\n\t\t};\r\n\r\n\t\tfunction isEq(str1, str2) {\r\n\t\t\tstr1 = str1 || '';\r\n\t\t\tstr2 = str2 || '';\r\n\r\n\t\t\tstr1 = '' + (str1.nodeName || str1);\r\n\t\t\tstr2 = '' + (str2.nodeName || str2);\r\n\r\n\t\t\treturn str1.toLowerCase() == str2.toLowerCase();\r\n\t\t};\r\n\r\n\t\tfunction getStyle(node, name) {\r\n\t\t\tvar styleVal = dom.getStyle(node, name);\r\n\r\n\t\t\t// Force the format to hex\r\n\t\t\tif (name == 'color' || name == 'backgroundColor')\r\n\t\t\t\tstyleVal = dom.toHex(styleVal);\r\n\r\n\t\t\t// Opera will return bold as 700\r\n\t\t\tif (name == 'fontWeight' && styleVal == 700)\r\n\t\t\t\tstyleVal = 'bold';\r\n\r\n\t\t\treturn '' + styleVal;\r\n\t\t};\r\n\r\n\t\tfunction replaceVars(value, vars) {\r\n\t\t\tif (typeof(value) != \"string\")\r\n\t\t\t\tvalue = value(vars);\r\n\t\t\telse if (vars) {\r\n\t\t\t\tvalue = value.replace(/%(\\w+)/g, function(str, name) {\r\n\t\t\t\t\treturn vars[name] || str;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\treturn value;\r\n\t\t};\r\n\r\n\t\tfunction isWhiteSpaceNode(node) {\r\n\t\t\treturn node && node.nodeType === 3 && /^([\\t \\r\\n]+|)$/.test(node.nodeValue);\r\n\t\t};\r\n\r\n\t\tfunction wrap(node, name, attrs) {\r\n\t\t\tvar wrapper = dom.create(name, attrs);\r\n\r\n\t\t\tnode.parentNode.insertBefore(wrapper, node);\r\n\t\t\twrapper.appendChild(node);\r\n\r\n\t\t\treturn wrapper;\r\n\t\t};\r\n\r\n\t\tfunction expandRng(rng, format, remove) {\r\n\t\t\tvar startContainer = rng.startContainer,\r\n\t\t\t\tstartOffset = rng.startOffset,\r\n\t\t\t\tendContainer = rng.endContainer,\r\n\t\t\t\tendOffset = rng.endOffset, sibling, lastIdx, leaf, endPoint;\r\n\r\n\t\t\t// This function walks up the tree if there is no siblings before/after the node\r\n\t\t\tfunction findParentContainer(start) {\r\n\t\t\t\tvar container, parent, child, sibling, siblingName;\r\n\r\n\t\t\t\tcontainer = parent = start ? startContainer : endContainer;\r\n\t\t\t\tsiblingName = start ? 'previousSibling' : 'nextSibling';\r\n\t\t\t\troot = dom.getRoot();\r\n\r\n\t\t\t\t// If it's a text node and the offset is inside the text\r\n\t\t\t\tif (container.nodeType == 3 && !isWhiteSpaceNode(container)) {\r\n\t\t\t\t\tif (start ? startOffset > 0 : endOffset < container.nodeValue.length) {\r\n\t\t\t\t\t\treturn container;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor (;;) {\r\n\t\t\t\t\t// Stop expanding on block elements or root depending on format\r\n\t\t\t\t\tif (parent == root || (!format[0].block_expand && isBlock(parent)))\r\n\t\t\t\t\t\treturn parent;\r\n\r\n\t\t\t\t\t// Walk left/right\r\n\t\t\t\t\tfor (sibling = parent[siblingName]; sibling; sibling = sibling[siblingName]) {\r\n\t\t\t\t\t\tif (!isBookmarkNode(sibling) && !isWhiteSpaceNode(sibling)) {\r\n\t\t\t\t\t\t\treturn parent;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Check if we can move up are we at root level or body level\r\n\t\t\t\t\tparent = parent.parentNode;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn container;\r\n\t\t\t};\r\n\r\n\t\t\t// This function walks down the tree to find the leaf at the selection.\r\n\t\t\t// The offset is also returned as if node initially a leaf, the offset may be in the middle of the text node.\r\n\t\t\tfunction findLeaf(node, offset) {\r\n\t\t\t\tif (offset === undefined)\r\n\t\t\t\t\toffset = node.nodeType === 3 ? node.length : node.childNodes.length;\r\n\t\t\t\twhile (node && node.hasChildNodes()) {\r\n\t\t\t\t\tnode = node.childNodes[offset];\r\n\t\t\t\t\tif (node)\r\n\t\t\t\t\t\toffset = node.nodeType === 3 ? node.length : node.childNodes.length;\r\n\t\t\t\t}\r\n\t\t\t\treturn { node: node, offset: offset };\r\n\t\t\t}\r\n\r\n\t\t\t// If index based start position then resolve it\r\n\t\t\tif (startContainer.nodeType == 1 && startContainer.hasChildNodes()) {\r\n\t\t\t\tlastIdx = startContainer.childNodes.length - 1;\r\n\t\t\t\tstartContainer = startContainer.childNodes[startOffset > lastIdx ? lastIdx : startOffset];\r\n\r\n\t\t\t\tif (startContainer.nodeType == 3)\r\n\t\t\t\t\tstartOffset = 0;\r\n\t\t\t}\r\n\r\n\t\t\t// If index based end position then resolve it\r\n\t\t\tif (endContainer.nodeType == 1 && endContainer.hasChildNodes()) {\r\n\t\t\t\tlastIdx = endContainer.childNodes.length - 1;\r\n\t\t\t\tendContainer = endContainer.childNodes[endOffset > lastIdx ? lastIdx : endOffset - 1];\r\n\r\n\t\t\t\tif (endContainer.nodeType == 3)\r\n\t\t\t\t\tendOffset = endContainer.nodeValue.length;\r\n\t\t\t}\r\n\r\n\t\t\t// Exclude bookmark nodes if possible\r\n\t\t\tif (isBookmarkNode(startContainer.parentNode) || isBookmarkNode(startContainer)) {\r\n\t\t\t\tstartContainer = isBookmarkNode(startContainer) ? startContainer : startContainer.parentNode;\r\n\t\t\t\tstartContainer = startContainer.nextSibling || startContainer;\r\n\r\n\t\t\t\tif (startContainer.nodeType == 3)\r\n\t\t\t\t\tstartOffset = 0;\r\n\t\t\t}\r\n\r\n\t\t\tif (isBookmarkNode(endContainer.parentNode) || isBookmarkNode(endContainer)) {\r\n\t\t\t\tendContainer = isBookmarkNode(endContainer) ? endContainer : endContainer.parentNode;\r\n\t\t\t\tendContainer = endContainer.previousSibling || endContainer;\r\n\r\n\t\t\t\tif (endContainer.nodeType == 3)\r\n\t\t\t\t\tendOffset = endContainer.length;\r\n\t\t\t}\r\n\r\n\t\t\tif (format[0].inline) {\r\n\t\t\t\tif (rng.collapsed) {\r\n\t\t\t\t\tfunction findWordEndPoint(container, offset, start) {\r\n\t\t\t\t\t\tvar walker, node, pos, lastTextNode;\r\n\r\n\t\t\t\t\t\tfunction findSpace(node, offset) {\r\n\t\t\t\t\t\t\tvar pos, pos2, str = node.nodeValue;\r\n\r\n\t\t\t\t\t\t\tif (typeof(offset) == \"undefined\") {\r\n\t\t\t\t\t\t\t\toffset = start ? str.length : 0;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif (start) {\r\n\t\t\t\t\t\t\t\tpos = str.lastIndexOf(' ', offset);\r\n\t\t\t\t\t\t\t\tpos2 = str.lastIndexOf('\\u00a0', offset);\r\n\t\t\t\t\t\t\t\tpos = pos > pos2 ? pos : pos2;\r\n\r\n\t\t\t\t\t\t\t\t// Include the space on remove to avoid tag soup\r\n\t\t\t\t\t\t\t\tif (pos !== -1 && !remove) {\r\n\t\t\t\t\t\t\t\t\tpos++;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tpos = str.indexOf(' ', offset);\r\n\t\t\t\t\t\t\t\tpos2 = str.indexOf('\\u00a0', offset);\r\n\t\t\t\t\t\t\t\tpos = pos !== -1 && (pos2 === -1 || pos < pos2) ? pos : pos2;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\treturn pos;\r\n\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\tif (container.nodeType === 3) {\r\n\t\t\t\t\t\t\tpos = findSpace(container, offset);\r\n\r\n\t\t\t\t\t\t\tif (pos !== -1) {\r\n\t\t\t\t\t\t\t\treturn {container : container, offset : pos};\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tlastTextNode = container;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Walk the nodes inside the block\r\n\t\t\t\t\t\twalker = new TreeWalker(container, dom.getParent(container, isBlock) || ed.getBody());\r\n\t\t\t\t\t\twhile (node = walker[start ? 'prev' : 'next']()) {\r\n\t\t\t\t\t\t\tif (node.nodeType === 3) {\r\n\t\t\t\t\t\t\t\tlastTextNode = node;\r\n\t\t\t\t\t\t\t\tpos = findSpace(node);\r\n\r\n\t\t\t\t\t\t\t\tif (pos !== -1) {\r\n\t\t\t\t\t\t\t\t\treturn {container : node, offset : pos};\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else if (isBlock(node)) {\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (lastTextNode) {\r\n\t\t\t\t\t\t\tif (start) {\r\n\t\t\t\t\t\t\t\toffset = 0;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\toffset = lastTextNode.length;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\treturn {container: lastTextNode, offset: offset};\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Expand left to closest word boundery\r\n\t\t\t\t\tendPoint = findWordEndPoint(startContainer, startOffset, true);\r\n\t\t\t\t\tif (endPoint) {\r\n\t\t\t\t\t\tstartContainer = endPoint.container;\r\n\t\t\t\t\t\tstartOffset = endPoint.offset;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Expand right to closest word boundery\r\n\t\t\t\t\tendPoint = findWordEndPoint(endContainer, endOffset);\r\n\t\t\t\t\tif (endPoint) {\r\n\t\t\t\t\t\tendContainer = endPoint.container;\r\n\t\t\t\t\t\tendOffset = endPoint.offset;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Avoid applying formatting to a trailing space.\r\n\t\t\t\tleaf = findLeaf(endContainer, endOffset);\r\n\t\t\t\tif (leaf.node) {\r\n\t\t\t\t\twhile (leaf.node && leaf.offset === 0 && leaf.node.previousSibling)\r\n\t\t\t\t\t\tleaf = findLeaf(leaf.node.previousSibling);\r\n\r\n\t\t\t\t\tif (leaf.node && leaf.offset > 0 && leaf.node.nodeType === 3 &&\r\n\t\t\t\t\t\t\tleaf.node.nodeValue.charAt(leaf.offset - 1) === ' ') {\r\n\r\n\t\t\t\t\t\tif (leaf.offset > 1) {\r\n\t\t\t\t\t\t\tendContainer = leaf.node;\r\n\t\t\t\t\t\t\tendContainer.splitText(leaf.offset - 1);\r\n\t\t\t\t\t\t} else if (leaf.node.previousSibling) {\r\n\t\t\t\t\t\t\t// TODO: Figure out why this is in here\r\n\t\t\t\t\t\t\t//endContainer = leaf.node.previousSibling;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Move start/end point up the tree if the leaves are sharp and if we are in different containers\r\n\t\t\t// Example * becomes !: !<p><b><i>*text</i><i>text*</i></b></p>!\r\n\t\t\t// This will reduce the number of wrapper elements that needs to be created\r\n\t\t\t// Move start point up the tree\r\n\t\t\tif (format[0].inline || format[0].block_expand) {\r\n\t\t\t\tif (!format[0].inline || (startContainer.nodeType != 3 || startOffset === 0)) {\r\n\t\t\t\t\tstartContainer = findParentContainer(true);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!format[0].inline || (endContainer.nodeType != 3 || endOffset === endContainer.nodeValue.length)) {\r\n\t\t\t\t\tendContainer = findParentContainer();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Expand start/end container to matching selector\r\n\t\t\tif (format[0].selector && format[0].expand !== FALSE && !format[0].inline) {\r\n\t\t\t\tfunction findSelectorEndPoint(container, sibling_name) {\r\n\t\t\t\t\tvar parents, i, y, curFormat;\r\n\r\n\t\t\t\t\tif (container.nodeType == 3 && container.nodeValue.length == 0 && container[sibling_name])\r\n\t\t\t\t\t\tcontainer = container[sibling_name];\r\n\r\n\t\t\t\t\tparents = getParents(container);\r\n\t\t\t\t\tfor (i = 0; i < parents.length; i++) {\r\n\t\t\t\t\t\tfor (y = 0; y < format.length; y++) {\r\n\t\t\t\t\t\t\tcurFormat = format[y];\r\n\r\n\t\t\t\t\t\t\t// If collapsed state is set then skip formats that doesn't match that\r\n\t\t\t\t\t\t\tif (\"collapsed\" in curFormat && curFormat.collapsed !== rng.collapsed)\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\t\tif (dom.is(parents[i], curFormat.selector))\r\n\t\t\t\t\t\t\t\treturn parents[i];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn container;\r\n\t\t\t\t};\r\n\r\n\t\t\t\t// Find new startContainer/endContainer if there is better one\r\n\t\t\t\tstartContainer = findSelectorEndPoint(startContainer, 'previousSibling');\r\n\t\t\t\tendContainer = findSelectorEndPoint(endContainer, 'nextSibling');\r\n\t\t\t}\r\n\r\n\t\t\t// Expand start/end container to matching block element or text node\r\n\t\t\tif (format[0].block || format[0].selector) {\r\n\t\t\t\tfunction findBlockEndPoint(container, sibling_name, sibling_name2) {\r\n\t\t\t\t\tvar node;\r\n\r\n\t\t\t\t\t// Expand to block of similar type\r\n\t\t\t\t\tif (!format[0].wrapper)\r\n\t\t\t\t\t\tnode = dom.getParent(container, format[0].block);\r\n\r\n\t\t\t\t\t// Expand to first wrappable block element or any block element\r\n\t\t\t\t\tif (!node)\r\n\t\t\t\t\t\tnode = dom.getParent(container.nodeType == 3 ? container.parentNode : container, isBlock);\r\n\r\n\t\t\t\t\t// Exclude inner lists from wrapping\r\n\t\t\t\t\tif (node && format[0].wrapper)\r\n\t\t\t\t\t\tnode = getParents(node, 'ul,ol').reverse()[0] || node;\r\n\r\n\t\t\t\t\t// Didn't find a block element look for first/last wrappable element\r\n\t\t\t\t\tif (!node) {\r\n\t\t\t\t\t\tnode = container;\r\n\r\n\t\t\t\t\t\twhile (node[sibling_name] && !isBlock(node[sibling_name])) {\r\n\t\t\t\t\t\t\tnode = node[sibling_name];\r\n\r\n\t\t\t\t\t\t\t// Break on BR but include it will be removed later on\r\n\t\t\t\t\t\t\t// we can't remove it now since we need to check if it can be wrapped\r\n\t\t\t\t\t\t\tif (isEq(node, 'br'))\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn node || container;\r\n\t\t\t\t};\r\n\r\n\t\t\t\t// Find new startContainer/endContainer if there is better one\r\n\t\t\t\tstartContainer = findBlockEndPoint(startContainer, 'previousSibling');\r\n\t\t\t\tendContainer = findBlockEndPoint(endContainer, 'nextSibling');\r\n\r\n\t\t\t\t// Non block element then try to expand up the leaf\r\n\t\t\t\tif (format[0].block) {\r\n\t\t\t\t\tif (!isBlock(startContainer))\r\n\t\t\t\t\t\tstartContainer = findParentContainer(true);\r\n\r\n\t\t\t\t\tif (!isBlock(endContainer))\r\n\t\t\t\t\t\tendContainer = findParentContainer();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Setup index for startContainer\r\n\t\t\tif (startContainer.nodeType == 1) {\r\n\t\t\t\tstartOffset = nodeIndex(startContainer);\r\n\t\t\t\tstartContainer = startContainer.parentNode;\r\n\t\t\t}\r\n\r\n\t\t\t// Setup index for endContainer\r\n\t\t\tif (endContainer.nodeType == 1) {\r\n\t\t\t\tendOffset = nodeIndex(endContainer) + 1;\r\n\t\t\t\tendContainer = endContainer.parentNode;\r\n\t\t\t}\r\n\r\n\t\t\t// Return new range like object\r\n\t\t\treturn {\r\n\t\t\t\tstartContainer : startContainer,\r\n\t\t\t\tstartOffset : startOffset,\r\n\t\t\t\tendContainer : endContainer,\r\n\t\t\t\tendOffset : endOffset\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tfunction removeFormat(format, vars, node, compare_node) {\r\n\t\t\tvar i, attrs, stylesModified;\r\n\r\n\t\t\t// Check if node matches format\r\n\t\t\tif (!matchName(node, format))\r\n\t\t\t\treturn FALSE;\r\n\r\n\t\t\t// Should we compare with format attribs and styles\r\n\t\t\tif (format.remove != 'all') {\r\n\t\t\t\t// Remove styles\r\n\t\t\t\teach(format.styles, function(value, name) {\r\n\t\t\t\t\tvalue = replaceVars(value, vars);\r\n\r\n\t\t\t\t\t// Indexed array\r\n\t\t\t\t\tif (typeof(name) === 'number') {\r\n\t\t\t\t\t\tname = value;\r\n\t\t\t\t\t\tcompare_node = 0;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (!compare_node || isEq(getStyle(compare_node, name), value))\r\n\t\t\t\t\t\tdom.setStyle(node, name, '');\r\n\r\n\t\t\t\t\tstylesModified = 1;\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// Remove style attribute if it's empty\r\n\t\t\t\tif (stylesModified && dom.getAttrib(node, 'style') == '') {\r\n\t\t\t\t\tnode.removeAttribute('style');\r\n\t\t\t\t\tnode.removeAttribute('data-mce-style');\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Remove attributes\r\n\t\t\t\teach(format.attributes, function(value, name) {\r\n\t\t\t\t\tvar valueOut;\r\n\r\n\t\t\t\t\tvalue = replaceVars(value, vars);\r\n\r\n\t\t\t\t\t// Indexed array\r\n\t\t\t\t\tif (typeof(name) === 'number') {\r\n\t\t\t\t\t\tname = value;\r\n\t\t\t\t\t\tcompare_node = 0;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (!compare_node || isEq(dom.getAttrib(compare_node, name), value)) {\r\n\t\t\t\t\t\t// Keep internal classes\r\n\t\t\t\t\t\tif (name == 'class') {\r\n\t\t\t\t\t\t\tvalue = dom.getAttrib(node, name);\r\n\t\t\t\t\t\t\tif (value) {\r\n\t\t\t\t\t\t\t\t// Build new class value where everything is removed except the internal prefixed classes\r\n\t\t\t\t\t\t\t\tvalueOut = '';\r\n\t\t\t\t\t\t\t\teach(value.split(/\\s+/), function(cls) {\r\n\t\t\t\t\t\t\t\t\tif (/mce\\w+/.test(cls))\r\n\t\t\t\t\t\t\t\t\t\tvalueOut += (valueOut ? ' ' : '') + cls;\r\n\t\t\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t\t\t// We got some internal classes left\r\n\t\t\t\t\t\t\t\tif (valueOut) {\r\n\t\t\t\t\t\t\t\t\tdom.setAttrib(node, name, valueOut);\r\n\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// IE6 has a bug where the attribute doesn't get removed correctly\r\n\t\t\t\t\t\tif (name == \"class\")\r\n\t\t\t\t\t\t\tnode.removeAttribute('className');\r\n\r\n\t\t\t\t\t\t// Remove mce prefixed attributes\r\n\t\t\t\t\t\tif (MCE_ATTR_RE.test(name))\r\n\t\t\t\t\t\t\tnode.removeAttribute('data-mce-' + name);\r\n\r\n\t\t\t\t\t\tnode.removeAttribute(name);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// Remove classes\r\n\t\t\t\teach(format.classes, function(value) {\r\n\t\t\t\t\tvalue = replaceVars(value, vars);\r\n\r\n\t\t\t\t\tif (!compare_node || dom.hasClass(compare_node, value))\r\n\t\t\t\t\t\tdom.removeClass(node, value);\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// Check for non internal attributes\r\n\t\t\t\tattrs = dom.getAttribs(node);\r\n\t\t\t\tfor (i = 0; i < attrs.length; i++) {\r\n\t\t\t\t\tif (attrs[i].nodeName.indexOf('_') !== 0)\r\n\t\t\t\t\t\treturn FALSE;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Remove the inline child if it's empty for example <b> or <span>\r\n\t\t\tif (format.remove != 'none') {\r\n\t\t\t\tremoveNode(node, format);\r\n\t\t\t\treturn TRUE;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tfunction removeNode(node, format) {\r\n\t\t\tvar parentNode = node.parentNode, rootBlockElm;\r\n\r\n\t\t\tif (format.block) {\r\n\t\t\t\tif (!forcedRootBlock) {\r\n\t\t\t\t\tfunction find(node, next, inc) {\r\n\t\t\t\t\t\tnode = getNonWhiteSpaceSibling(node, next, inc);\r\n\r\n\t\t\t\t\t\treturn !node || (node.nodeName == 'BR' || isBlock(node));\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\t// Append BR elements if needed before we remove the block\r\n\t\t\t\t\tif (isBlock(node) && !isBlock(parentNode)) {\r\n\t\t\t\t\t\tif (!find(node, FALSE) && !find(node.firstChild, TRUE, 1))\r\n\t\t\t\t\t\t\tnode.insertBefore(dom.create('br'), node.firstChild);\r\n\r\n\t\t\t\t\t\tif (!find(node, TRUE) && !find(node.lastChild, FALSE, 1))\r\n\t\t\t\t\t\t\tnode.appendChild(dom.create('br'));\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Wrap the block in a forcedRootBlock if we are at the root of document\r\n\t\t\t\t\tif (parentNode == dom.getRoot()) {\r\n\t\t\t\t\t\tif (!format.list_block || !isEq(node, format.list_block)) {\r\n\t\t\t\t\t\t\teach(tinymce.grep(node.childNodes), function(node) {\r\n\t\t\t\t\t\t\t\tif (isValid(forcedRootBlock, node.nodeName.toLowerCase())) {\r\n\t\t\t\t\t\t\t\t\tif (!rootBlockElm)\r\n\t\t\t\t\t\t\t\t\t\trootBlockElm = wrap(node, forcedRootBlock);\r\n\t\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\t\trootBlockElm.appendChild(node);\r\n\t\t\t\t\t\t\t\t} else\r\n\t\t\t\t\t\t\t\t\trootBlockElm = 0;\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Never remove nodes that isn't the specified inline element if a selector is specified too\r\n\t\t\tif (format.selector && format.inline && !isEq(format.inline, node))\r\n\t\t\t\treturn;\r\n\r\n\t\t\tdom.remove(node, 1);\r\n\t\t};\r\n\r\n\t\tfunction getNonWhiteSpaceSibling(node, next, inc) {\r\n\t\t\tif (node) {\r\n\t\t\t\tnext = next ? 'nextSibling' : 'previousSibling';\r\n\r\n\t\t\t\tfor (node = inc ? node : node[next]; node; node = node[next]) {\r\n\t\t\t\t\tif (node.nodeType == 1 || !isWhiteSpaceNode(node))\r\n\t\t\t\t\t\treturn node;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tfunction isBookmarkNode(node) {\r\n\t\t\treturn node && node.nodeType == 1 && node.getAttribute('data-mce-type') == 'bookmark';\r\n\t\t};\r\n\r\n\t\tfunction mergeSiblings(prev, next) {\r\n\t\t\tvar marker, sibling, tmpSibling;\r\n\r\n\t\t\tfunction compareElements(node1, node2) {\r\n\t\t\t\t// Not the same name\r\n\t\t\t\tif (node1.nodeName != node2.nodeName)\r\n\t\t\t\t\treturn FALSE;\r\n\r\n\t\t\t\tfunction getAttribs(node) {\r\n\t\t\t\t\tvar attribs = {};\r\n\r\n\t\t\t\t\teach(dom.getAttribs(node), function(attr) {\r\n\t\t\t\t\t\tvar name = attr.nodeName.toLowerCase();\r\n\r\n\t\t\t\t\t\t// Don't compare internal attributes or style\r\n\t\t\t\t\t\tif (name.indexOf('_') !== 0 && name !== 'style')\r\n\t\t\t\t\t\t\tattribs[name] = dom.getAttrib(node, name);\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\treturn attribs;\r\n\t\t\t\t};\r\n\r\n\t\t\t\tfunction compareObjects(obj1, obj2) {\r\n\t\t\t\t\tvar value, name;\r\n\r\n\t\t\t\t\tfor (name in obj1) {\r\n\t\t\t\t\t\t// Obj1 has item obj2 doesn't have\r\n\t\t\t\t\t\tif (obj1.hasOwnProperty(name)) {\r\n\t\t\t\t\t\t\tvalue = obj2[name];\r\n\r\n\t\t\t\t\t\t\t// Obj2 doesn't have obj1 item\r\n\t\t\t\t\t\t\tif (value === undefined)\r\n\t\t\t\t\t\t\t\treturn FALSE;\r\n\r\n\t\t\t\t\t\t\t// Obj2 item has a different value\r\n\t\t\t\t\t\t\tif (obj1[name] != value)\r\n\t\t\t\t\t\t\t\treturn FALSE;\r\n\r\n\t\t\t\t\t\t\t// Delete similar value\r\n\t\t\t\t\t\t\tdelete obj2[name];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Check if obj 2 has something obj 1 doesn't have\r\n\t\t\t\t\tfor (name in obj2) {\r\n\t\t\t\t\t\t// Obj2 has item obj1 doesn't have\r\n\t\t\t\t\t\tif (obj2.hasOwnProperty(name))\r\n\t\t\t\t\t\t\treturn FALSE;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn TRUE;\r\n\t\t\t\t};\r\n\r\n\t\t\t\t// Attribs are not the same\r\n\t\t\t\tif (!compareObjects(getAttribs(node1), getAttribs(node2)))\r\n\t\t\t\t\treturn FALSE;\r\n\r\n\t\t\t\t// Styles are not the same\r\n\t\t\t\tif (!compareObjects(dom.parseStyle(dom.getAttrib(node1, 'style')), dom.parseStyle(dom.getAttrib(node2, 'style'))))\r\n\t\t\t\t\treturn FALSE;\r\n\r\n\t\t\t\treturn TRUE;\r\n\t\t\t};\r\n\r\n\t\t\t// Check if next/prev exists and that they are elements\r\n\t\t\tif (prev && next) {\r\n\t\t\t\tfunction findElementSibling(node, sibling_name) {\r\n\t\t\t\t\tfor (sibling = node; sibling; sibling = sibling[sibling_name]) {\r\n\t\t\t\t\t\tif (sibling.nodeType == 3 && sibling.nodeValue.length !== 0)\r\n\t\t\t\t\t\t\treturn node;\r\n\r\n\t\t\t\t\t\tif (sibling.nodeType == 1 && !isBookmarkNode(sibling))\r\n\t\t\t\t\t\t\treturn sibling;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn node;\r\n\t\t\t\t};\r\n\r\n\t\t\t\t// If previous sibling is empty then jump over it\r\n\t\t\t\tprev = findElementSibling(prev, 'previousSibling');\r\n\t\t\t\tnext = findElementSibling(next, 'nextSibling');\r\n\r\n\t\t\t\t// Compare next and previous nodes\r\n\t\t\t\tif (compareElements(prev, next)) {\r\n\t\t\t\t\t// Append nodes between\r\n\t\t\t\t\tfor (sibling = prev.nextSibling; sibling && sibling != next;) {\r\n\t\t\t\t\t\ttmpSibling = sibling;\r\n\t\t\t\t\t\tsibling = sibling.nextSibling;\r\n\t\t\t\t\t\tprev.appendChild(tmpSibling);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Remove next node\r\n\t\t\t\t\tdom.remove(next);\r\n\r\n\t\t\t\t\t// Move children into prev node\r\n\t\t\t\t\teach(tinymce.grep(next.childNodes), function(node) {\r\n\t\t\t\t\t\tprev.appendChild(node);\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\treturn prev;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn next;\r\n\t\t};\r\n\r\n\t\tfunction isTextBlock(name) {\r\n\t\t\treturn /^(h[1-6]|p|div|pre|address|dl|dt|dd)$/.test(name);\r\n\t\t};\r\n\r\n\t\tfunction getContainer(rng, start) {\r\n\t\t\tvar container, offset, lastIdx, walker;\r\n\r\n\t\t\tcontainer = rng[start ? 'startContainer' : 'endContainer'];\r\n\t\t\toffset = rng[start ? 'startOffset' : 'endOffset'];\r\n\r\n\t\t\tif (container.nodeType == 1) {\r\n\t\t\t\tlastIdx = container.childNodes.length - 1;\r\n\r\n\t\t\t\tif (!start && offset)\r\n\t\t\t\t\toffset--;\r\n\r\n\t\t\t\tcontainer = container.childNodes[offset > lastIdx ? lastIdx : offset];\r\n\t\t\t}\r\n\r\n\t\t\t// If start text node is excluded then walk to the next node\r\n\t\t\tif (container.nodeType === 3 && start && offset >= container.nodeValue.length) {\r\n\t\t\t\tcontainer = new TreeWalker(container, ed.getBody()).next() || container;\r\n\t\t\t}\r\n\r\n\t\t\t// If end text node is excluded then walk to the previous node\r\n\t\t\tif (container.nodeType === 3 && !start && offset == 0) {\r\n\t\t\t\tcontainer = new TreeWalker(container, ed.getBody()).prev() || container;\r\n\t\t\t}\r\n\r\n\t\t\treturn container;\r\n\t\t};\r\n\r\n\t\tfunction performCaretAction(type, name, vars) {\r\n\t\t\tvar invisibleChar, caretContainerId = '_mce_caret', debug = ed.settings.caret_debug;\r\n\r\n\t\t\t// Setup invisible character use zero width space on Gecko since it doesn't change the heigt of the container\r\n\t\t\tinvisibleChar = tinymce.isGecko ? '\\u200B' : INVISIBLE_CHAR;\r\n\r\n\t\t\t// Creates a caret container bogus element\r\n\t\t\tfunction createCaretContainer(fill) {\r\n\t\t\t\tvar caretContainer = dom.create('span', {id: caretContainerId, 'data-mce-bogus': true, style: debug ? 'color:red' : ''});\r\n\r\n\t\t\t\tif (fill) {\r\n\t\t\t\t\tcaretContainer.appendChild(ed.getDoc().createTextNode(invisibleChar));\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn caretContainer;\r\n\t\t\t};\r\n\r\n\t\t\tfunction isCaretContainerEmpty(node, nodes) {\r\n\t\t\t\twhile (node) {\r\n\t\t\t\t\tif ((node.nodeType === 3 && node.nodeValue !== invisibleChar) || node.childNodes.length > 1) {\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Collect nodes\r\n\t\t\t\t\tif (nodes && node.nodeType === 1) {\r\n\t\t\t\t\t\tnodes.push(node);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tnode = node.firstChild;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn true;\r\n\t\t\t};\r\n\r\n\t\t\t// Returns any parent caret container element\r\n\t\t\tfunction getParentCaretContainer(node) {\r\n\t\t\t\twhile (node) {\r\n\t\t\t\t\tif (node.id === caretContainerId) {\r\n\t\t\t\t\t\treturn node;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tnode = node.parentNode;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\t// Finds the first text node in the specified node\r\n\t\t\tfunction findFirstTextNode(node) {\r\n\t\t\t\tvar walker;\r\n\r\n\t\t\t\tif (node) {\r\n\t\t\t\t\twalker = new TreeWalker(node, node);\r\n\r\n\t\t\t\t\tfor (node = walker.current(); node; node = walker.next()) {\r\n\t\t\t\t\t\tif (node.nodeType === 3) {\r\n\t\t\t\t\t\t\treturn node;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\t// Removes the caret container for the specified node or all on the current document\r\n\t\t\tfunction removeCaretContainer(node, move_caret) {\r\n\t\t\t\tvar child, rng;\r\n\r\n\t\t\t\tif (!node) {\r\n\t\t\t\t\tnode = getParentCaretContainer(selection.getStart());\r\n\r\n\t\t\t\t\tif (!node) {\r\n\t\t\t\t\t\twhile (node = dom.get(caretContainerId)) {\r\n\t\t\t\t\t\t\tremoveCaretContainer(node, false);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\trng = selection.getRng(true);\r\n\r\n\t\t\t\t\tif (isCaretContainerEmpty(node)) {\r\n\t\t\t\t\t\tif (move_caret !== false) {\r\n\t\t\t\t\t\t\trng.setStartBefore(node);\r\n\t\t\t\t\t\t\trng.setEndBefore(node);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tdom.remove(node);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tchild = findFirstTextNode(node);\r\n\t\t\t\t\t\tchild = child.deleteData(0, 1);\r\n\t\t\t\t\t\tdom.remove(node, 1);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tselection.setRng(rng);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\t// Applies formatting to the caret position\r\n\t\t\tfunction applyCaretFormat() {\r\n\t\t\t\tvar rng, caretContainer, textNode, offset, bookmark, container, text;\r\n\r\n\t\t\t\trng = selection.getRng(true);\r\n\t\t\t\toffset = rng.startOffset;\r\n\t\t\t\tcontainer = rng.startContainer;\r\n\t\t\t\ttext = container.nodeValue;\r\n\r\n\t\t\t\tcaretContainer = getParentCaretContainer(selection.getStart());\r\n\t\t\t\tif (caretContainer) {\r\n\t\t\t\t\ttextNode = findFirstTextNode(caretContainer);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Expand to word is caret is in the middle of a text node and the char before/after is a alpha numeric character\r\n\t\t\t\tif (text && offset > 0 && offset < text.length && /\\w/.test(text.charAt(offset)) && /\\w/.test(text.charAt(offset - 1))) {\r\n\t\t\t\t\t// Get bookmark of caret position\r\n\t\t\t\t\tbookmark = selection.getBookmark();\r\n\r\n\t\t\t\t\t// Collapse bookmark range (WebKit)\r\n\t\t\t\t\trng.collapse(true);\r\n\r\n\t\t\t\t\t// Expand the range to the closest word and split it at those points\r\n\t\t\t\t\trng = expandRng(rng, get(name));\r\n\t\t\t\t\trng = rangeUtils.split(rng);\r\n\r\n\t\t\t\t\t// Apply the format to the range\r\n\t\t\t\t\tapply(name, vars, rng);\r\n\r\n\t\t\t\t\t// Move selection back to caret position\r\n\t\t\t\t\tselection.moveToBookmark(bookmark);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (!caretContainer || textNode.nodeValue !== invisibleChar) {\r\n\t\t\t\t\t\tcaretContainer = createCaretContainer(true);\r\n\t\t\t\t\t\ttextNode = caretContainer.firstChild;\r\n\r\n\t\t\t\t\t\trng.insertNode(caretContainer);\r\n\t\t\t\t\t\toffset = 1;\r\n\r\n\t\t\t\t\t\tapply(name, vars, caretContainer);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tapply(name, vars, caretContainer);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Move selection to text node\r\n\t\t\t\t\tselection.setCursorLocation(textNode, offset);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tfunction removeCaretFormat() {\r\n\t\t\t\tvar rng = selection.getRng(true), container, offset, bookmark,\r\n\t\t\t\t\thasContentAfter, node, formatNode, parents = [], i, caretContainer;\r\n\r\n\t\t\t\tcontainer = rng.startContainer;\r\n\t\t\t\toffset = rng.startOffset;\r\n\t\t\t\tnode = container;\r\n\r\n\t\t\t\tif (container.nodeType == 3) {\r\n\t\t\t\t\tif (offset != container.nodeValue.length || container.nodeValue === invisibleChar) {\r\n\t\t\t\t\t\thasContentAfter = true;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tnode = node.parentNode;\r\n\t\t\t\t}\r\n\r\n\t\t\t\twhile (node) {\r\n\t\t\t\t\tif (matchNode(node, name, vars)) {\r\n\t\t\t\t\t\tformatNode = node;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (node.nextSibling) {\r\n\t\t\t\t\t\thasContentAfter = true;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tparents.push(node);\r\n\t\t\t\t\tnode = node.parentNode;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Node doesn't have the specified format\r\n\t\t\t\tif (!formatNode) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Is there contents after the caret then remove the format on the element\r\n\t\t\t\tif (hasContentAfter) {\r\n\t\t\t\t\t// Get bookmark of caret position\r\n\t\t\t\t\tbookmark = selection.getBookmark();\r\n\r\n\t\t\t\t\t// Collapse bookmark range (WebKit)\r\n\t\t\t\t\trng.collapse(true);\r\n\r\n\t\t\t\t\t// Expand the range to the closest word and split it at those points\r\n\t\t\t\t\trng = expandRng(rng, get(name), true);\r\n\t\t\t\t\trng = rangeUtils.split(rng);\r\n\r\n\t\t\t\t\t// Remove the format from the range\r\n\t\t\t\t\tremove(name, vars, rng);\r\n\r\n\t\t\t\t\t// Move selection back to caret position\r\n\t\t\t\t\tselection.moveToBookmark(bookmark);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcaretContainer = createCaretContainer();\r\n\r\n\t\t\t\t\tnode = caretContainer;\r\n\t\t\t\t\tfor (i = parents.length - 1; i >= 0; i--) {\r\n\t\t\t\t\t\tnode.appendChild(parents[i].cloneNode(false));\r\n\t\t\t\t\t\tnode = node.firstChild;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Insert invisible character into inner most format element\r\n\t\t\t\t\tnode.appendChild(dom.doc.createTextNode(invisibleChar));\r\n\t\t\t\t\tnode = node.firstChild;\r\n\r\n\t\t\t\t\t// Insert caret container after the formatted node\r\n\t\t\t\t\tdom.insertAfter(caretContainer, formatNode);\r\n\r\n\t\t\t\t\t// Move selection to text node\r\n\t\t\t\t\tselection.setCursorLocation(node, 1);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\t// Mark current caret container elements as bogus when getting the contents so we don't end up with empty elements\r\n\t\t\ted.onBeforeGetContent.addToTop(function() {\r\n\t\t\t\tvar nodes = [], i;\r\n\r\n\t\t\t\tif (isCaretContainerEmpty(getParentCaretContainer(selection.getStart()), nodes)) {\r\n\t\t\t\t\t// Mark children\r\n\t\t\t\t\ti = nodes.length;\r\n\t\t\t\t\twhile (i--) {\r\n\t\t\t\t\t\tdom.setAttrib(nodes[i], 'data-mce-bogus', '1');\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\t// Remove caret container on mouse up and on key up\r\n\t\t\ttinymce.each('onMouseUp onKeyUp'.split(' '), function(name) {\r\n\t\t\t\ted[name].addToTop(function() {\r\n\t\t\t\t\tremoveCaretContainer();\r\n\t\t\t\t});\r\n\t\t\t});\r\n\r\n\t\t\t// Remove caret container on keydown and it's a backspace, enter or left/right arrow keys\r\n\t\t\ted.onKeyDown.addToTop(function(ed, e) {\r\n\t\t\t\tvar keyCode = e.keyCode;\r\n\r\n\t\t\t\tif (keyCode == 8 || keyCode == 37 || keyCode == 39) {\r\n\t\t\t\t\tremoveCaretContainer(getParentCaretContainer(selection.getStart()));\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\t// Do apply or remove caret format\r\n\t\t\tif (type == \"apply\") {\r\n\t\t\t\tapplyCaretFormat();\r\n\t\t\t} else {\r\n\t\t\t\tremoveCaretFormat();\r\n\t\t\t}\r\n\t\t};\r\n\t};\r\n})(tinymce);\r\n\r\ntinymce.onAddEditor.add(function(tinymce, ed) {\r\n\tvar filters, fontSizes, dom, settings = ed.settings;\r\n\r\n\tif (settings.inline_styles) {\r\n\t\tfontSizes = tinymce.explode(settings.font_size_legacy_values);\r\n\r\n\t\tfunction replaceWithSpan(node, styles) {\r\n\t\t\ttinymce.each(styles, function(value, name) {\r\n\t\t\t\tif (value)\r\n\t\t\t\t\tdom.setStyle(node, name, value);\r\n\t\t\t});\r\n\r\n\t\t\tdom.rename(node, 'span');\r\n\t\t};\r\n\r\n\t\tfilters = {\r\n\t\t\tfont : function(dom, node) {\r\n\t\t\t\treplaceWithSpan(node, {\r\n\t\t\t\t\tbackgroundColor : node.style.backgroundColor,\r\n\t\t\t\t\tcolor : node.color,\r\n\t\t\t\t\tfontFamily : node.face,\r\n\t\t\t\t\tfontSize : fontSizes[parseInt(node.size) - 1]\r\n\t\t\t\t});\r\n\t\t\t},\r\n\r\n\t\t\tu : function(dom, node) {\r\n\t\t\t\treplaceWithSpan(node, {\r\n\t\t\t\t\ttextDecoration : 'underline'\r\n\t\t\t\t});\r\n\t\t\t},\r\n\r\n\t\t\tstrike : function(dom, node) {\r\n\t\t\t\treplaceWithSpan(node, {\r\n\t\t\t\t\ttextDecoration : 'line-through'\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tfunction convert(editor, params) {\r\n\t\t\tdom = editor.dom;\r\n\r\n\t\t\tif (settings.convert_fonts_to_spans) {\r\n\t\t\t\ttinymce.each(dom.select('font,u,strike', params.node), function(node) {\r\n\t\t\t\t\tfilters[node.nodeName.toLowerCase()](ed.dom, node);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\ted.onPreProcess.add(convert);\r\n\t\ted.onSetContent.add(convert);\r\n\r\n\t\ted.onInit.add(function() {\r\n\t\t\ted.selection.onSetContent.add(convert);\r\n\t\t});\r\n\t}\r\n});\r\n\r\n","Magento_Tinymce3/tiny_mce/classes/AddOnManager.js":"/**\r\n * AddOnManager.js\r\n *\r\n * Copyright 2009, Moxiecode Systems AB\r\n * Released under LGPL License.\r\n *\r\n * License: http://tinymce.moxiecode.com/license\r\n * Contributing: http://tinymce.moxiecode.com/contributing\r\n */\r\n\r\n(function(tinymce) {\r\n\tvar Dispatcher = tinymce.util.Dispatcher, each = tinymce.each;\r\n\r\n\t/**\r\n\t * This class handles the loading of themes/plugins or other add-ons and their language packs.\r\n\t *\r\n\t * @class tinymce.AddOnManager\r\n\t */\r\n\ttinymce.create('tinymce.AddOnManager', {\r\n\t\tAddOnManager : function() {\r\n\t\t\tvar self = this;\r\n\r\n\t\t\tself.items = [];\r\n\t\t\tself.urls = {};\r\n\t\t\tself.lookup = {};\r\n\t\t\tself.onAdd = new Dispatcher(self);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Fires when a item is added.\r\n\t\t *\r\n\t\t * @event onAdd\r\n\t\t */\r\n\r\n\t\t/**\r\n\t\t * Returns the specified add on by the short name.\r\n\t\t *\r\n\t\t * @method get\r\n\t\t * @param {String} n Add-on to look for.\r\n\t\t * @return {tinymce.Theme/tinymce.Plugin} Theme or plugin add-on instance or undefined.\r\n\t\t */\r\n\t\tget : function(n) {\r\n\t\t\tif (this.lookup[n]) {\r\n\t\t\t\treturn this.lookup[n].instance;\r\n\t\t\t} else {\r\n\t\t\t\treturn undefined;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tdependencies : function(n) {\r\n\t\t\tvar result;\r\n\t\t\tif (this.lookup[n]) {\r\n\t\t\t\tresult = this.lookup[n].dependencies;\r\n\t\t\t}\r\n\t\t\treturn result || [];\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Loads a language pack for the specified add-on.\r\n\t\t *\r\n\t\t * @method requireLangPack\r\n\t\t * @param {String} n Short name of the add-on.\r\n\t\t */\r\n\t\trequireLangPack : function(n) {\r\n\t\t\tvar s = tinymce.settings;\r\n\r\n\t\t\tif (s && s.language && s.language_load !== false)\r\n\t\t\t\ttinymce.ScriptLoader.add(this.urls[n] + '/langs/' + s.language + '.js');\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Adds a instance of the add-on by it's short name.\r\n\t\t *\r\n\t\t * @method add\r\n\t\t * @param {String} id Short name/id for the add-on.\r\n\t\t * @param {tinymce.Theme/tinymce.Plugin} o Theme or plugin to add.\r\n\t\t * @return {tinymce.Theme/tinymce.Plugin} The same theme or plugin instance that got passed in.\r\n\t\t * @example\r\n\t\t * // Create a simple plugin\r\n\t\t * tinymce.create('tinymce.plugins.TestPlugin', {\r\n\t\t *     TestPlugin : function(ed, url) {\r\n\t\t *         ed.onClick.add(function(ed, e) {\r\n\t\t *             ed.windowManager.alert('Hello World!');\r\n\t\t *         });\r\n\t\t *     }\r\n\t\t * });\r\n\t\t * \r\n\t\t * // Register plugin using the add method\r\n\t\t * tinymce.PluginManager.add('test', tinymce.plugins.TestPlugin);\r\n\t\t * \r\n\t\t * // Initialize TinyMCE\r\n\t\t * tinyMCE.init({\r\n\t\t *    ...\r\n\t\t *    plugins : '-test' // Init the plugin but don't try to load it\r\n\t\t * });\r\n\t\t */\r\n\t\tadd : function(id, o, dependencies) {\r\n\t\t\tthis.items.push(o);\r\n\t\t\tthis.lookup[id] = {instance:o, dependencies:dependencies};\r\n\t\t\tthis.onAdd.dispatch(this, id, o);\r\n\r\n\t\t\treturn o;\r\n\t\t},\r\n\t\tcreateUrl: function(baseUrl, dep) {\r\n\t\t\tif (typeof dep === \"object\") {\r\n\t\t\t\treturn dep\r\n\t\t\t} else {\r\n\t\t\t\treturn {prefix: baseUrl.prefix, resource: dep, suffix: baseUrl.suffix};\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t \t * Add a set of components that will make up the add-on. Using the url of the add-on name as the base url.\r\n\t\t * This should be used in development mode.  A new compressor/javascript munger process will ensure that the \r\n\t\t * components are put together into the editor_plugin.js file and compressed correctly.\r\n\t\t * @param pluginName {String} name of the plugin to load scripts from (will be used to get the base url for the plugins).\r\n\t\t * @param scripts {Array} Array containing the names of the scripts to load.\r\n\t \t */\r\n\t\taddComponents: function(pluginName, scripts) {\r\n\t\t\tvar pluginUrl = this.urls[pluginName];\r\n\t\t\ttinymce.each(scripts, function(script){\r\n\t\t\t\ttinymce.ScriptLoader.add(pluginUrl+\"/\"+script);\t\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Loads an add-on from a specific url.\r\n\t\t *\r\n\t\t * @method load\r\n\t\t * @param {String} n Short name of the add-on that gets loaded.\r\n\t\t * @param {String} u URL to the add-on that will get loaded.\r\n\t\t * @param {function} cb Optional callback to execute ones the add-on is loaded.\r\n\t\t * @param {Object} s Optional scope to execute the callback in.\r\n\t\t * @example\r\n\t\t * // Loads a plugin from an external URL\r\n\t\t * tinymce.PluginManager.load('myplugin', '/some/dir/someplugin/editor_plugin.js');\r\n\t\t *\r\n\t\t * // Initialize TinyMCE\r\n\t\t * tinyMCE.init({\r\n\t\t *    ...\r\n\t\t *    plugins : '-myplugin' // Don't try to load it again\r\n\t\t * });\r\n\t\t */\r\n\t\tload : function(n, u, cb, s) {\r\n\t\t\tvar t = this, url = u;\r\n\r\n\t\t\tfunction loadDependencies() {\r\n\t\t\t\tvar dependencies = t.dependencies(n);\r\n\t\t\t\ttinymce.each(dependencies, function(dep) {\r\n\t\t\t\t\tvar newUrl = t.createUrl(u, dep);\r\n\t\t\t\t\tt.load(newUrl.resource, newUrl, undefined, undefined);\r\n\t\t\t\t});\r\n\t\t\t\tif (cb) {\r\n\t\t\t\t\tif (s) {\r\n\t\t\t\t\t\tcb.call(s);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tcb.call(tinymce.ScriptLoader);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (t.urls[n])\r\n\t\t\t\treturn;\r\n\t\t\tif (typeof u === \"object\")\r\n\t\t\t\turl = u.prefix + u.resource + u.suffix;\r\n\r\n\t\t\tif (url.indexOf('/') != 0 && url.indexOf('://') == -1)\r\n\t\t\t\turl = tinymce.baseURL + '/' + url;\r\n\r\n\t\t\tt.urls[n] = url.substring(0, url.lastIndexOf('/'));\r\n\r\n\t\t\tif (t.lookup[n]) {\r\n\t\t\t\tloadDependencies();\r\n\t\t\t} else {\r\n\t\t\t\ttinymce.ScriptLoader.add(url, loadDependencies, s);\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\r\n\t// Create plugin and theme managers\r\n\ttinymce.PluginManager = new tinymce.AddOnManager();\r\n\ttinymce.ThemeManager = new tinymce.AddOnManager();\r\n}(tinymce));\r\n\r\n/**\r\n * TinyMCE theme class.\r\n *\r\n * @class tinymce.Theme\r\n */\r\n\r\n/**\r\n * Initializes the theme.\r\n *\r\n * @method init\r\n * @param {tinymce.Editor} editor Editor instance that created the theme instance.\r\n * @param {String} url Absolute URL where the theme is located. \r\n */\r\n\r\n/**\r\n * Meta info method, this method gets executed when TinyMCE wants to present information about the theme for example in the about/help dialog.\r\n *\r\n * @method getInfo\r\n * @return {Object} Returns an object with meta information about the theme the current items are longname, author, authorurl, infourl and version.\r\n */\r\n\r\n/**\r\n * This method is responsible for rendering/generating the overall user interface with toolbars, buttons, iframe containers etc.\r\n *\r\n * @method renderUI\r\n * @param {Object} obj Object parameter containing the targetNode DOM node that will be replaced visually with an editor instance. \r\n * @return {Object} an object with items like iframeContainer, editorContainer, sizeContainer, deltaWidth, deltaHeight. \r\n */\r\n\r\n/**\r\n * Plugin base class, this is a pseudo class that describes how a plugin is to be created for TinyMCE. The methods below are all optional.\r\n *\r\n * @class tinymce.Plugin\r\n * @example\r\n * // Create a new plugin class\r\n * tinymce.create('tinymce.plugins.ExamplePlugin', {\r\n *     init : function(ed, url) {\r\n *         // Register an example button\r\n *         ed.addButton('example', {\r\n *             title : 'example.desc',\r\n *             onclick : function() {\r\n *                  // Display an alert when the user clicks the button\r\n *                  ed.windowManager.alert('Hello world!');\r\n *             },\r\n *             'class' : 'bold' // Use the bold icon from the theme\r\n *         });\r\n *     }\r\n * });\r\n * \r\n * // Register plugin with a short name\r\n * tinymce.PluginManager.add('example', tinymce.plugins.ExamplePlugin);\r\n * \r\n * // Initialize TinyMCE with the new plugin and button\r\n * tinyMCE.init({\r\n *    ...\r\n *    plugins : '-example', // - means TinyMCE will not try to load it\r\n *    theme_advanced_buttons1 : 'example' // Add the new example button to the toolbar\r\n * });\r\n */\r\n\r\n/**\r\n * Initialization function for the plugin. This will be called when the plugin is created. \r\n *\r\n * @method init\r\n * @param {tinymce.Editor} editor Editor instance that created the plugin instance. \r\n * @param {String} url Absolute URL where the plugin is located. \r\n * @example\r\n * // Creates a new plugin class\r\n * tinymce.create('tinymce.plugins.ExamplePlugin', {\r\n *     init : function(ed, url) {\r\n *         // Register the command so that it can be invoked by using tinyMCE.activeEditor.execCommand('mceExample');\r\n *         ed.addCommand('mceExample', function() {\r\n *             ed.windowManager.open({\r\n *                 file : url + '/dialog.htm',\r\n *                 width : 320 + ed.getLang('example.delta_width', 0),\r\n *                 height : 120 + ed.getLang('example.delta_height', 0),\r\n *                 inline : 1\r\n *             }, {\r\n *                 plugin_url : url, // Plugin absolute URL\r\n *                 some_custom_arg : 'custom arg' // Custom argument\r\n *             });\r\n *         });\r\n * \r\n *         // Register example button\r\n *         ed.addButton('example', {\r\n *             title : 'example.desc',\r\n *             cmd : 'mceExample',\r\n *             image : url + '/img/example.gif'\r\n *         });\r\n * \r\n *         // Add a node change handler, selects the button in the UI when a image is selected\r\n *         ed.onNodeChange.add(function(ed, cm, n) {\r\n *             cm.setActive('example', n.nodeName == 'IMG');\r\n *         });\r\n *     }\r\n * });\r\n * \r\n * // Register plugin\r\n * tinymce.PluginManager.add('example', tinymce.plugins.ExamplePlugin);\r\n */\r\n\r\n/**\r\n * Meta info method, this method gets executed when TinyMCE wants to present information about the plugin for example in the about/help dialog.\r\n *\r\n * @method getInfo\r\n * @return {Object} Returns an object with meta information about the plugin the current items are longname, author, authorurl, infourl and version.\r\n * @example \r\n * // Creates a new plugin class\r\n * tinymce.create('tinymce.plugins.ExamplePlugin', {\r\n *     // Meta info method\r\n *     getInfo : function() {\r\n *         return {\r\n *             longname : 'Example plugin',\r\n *             author : 'Some author',\r\n *             authorurl : 'http://tinymce.moxiecode.com',\r\n *             infourl : 'http://wiki.moxiecode.com/index.php/TinyMCE:Plugins/example',\r\n *             version : \"1.0\"\r\n *         };\r\n *     }\r\n * });\r\n * \r\n * // Register plugin\r\n * tinymce.PluginManager.add('example', tinymce.plugins.ExamplePlugin);\r\n * \r\n * // Initialize TinyMCE with the new plugin\r\n * tinyMCE.init({\r\n *    ...\r\n *    plugins : '-example' // - means TinyMCE will not try to load it\r\n * });\r\n */\r\n\r\n/**\r\n * Gets called when a new control instance is created.\r\n *\r\n * @method createControl\r\n * @param {String} name Control name to create for example \"mylistbox\" \r\n * @param {tinymce.ControlManager} controlman Control manager/factory to use to create the control. \r\n * @return {tinymce.ui.Control} Returns a new control instance or null.\r\n * @example \r\n * // Creates a new plugin class\r\n * tinymce.create('tinymce.plugins.ExamplePlugin', {\r\n *     createControl: function(n, cm) {\r\n *         switch (n) {\r\n *             case 'mylistbox':\r\n *                 var mlb = cm.createListBox('mylistbox', {\r\n *                      title : 'My list box',\r\n *                      onselect : function(v) {\r\n *                          tinyMCE.activeEditor.windowManager.alert('Value selected:' + v);\r\n *                      }\r\n *                 });\r\n * \r\n *                 // Add some values to the list box\r\n *                 mlb.add('Some item 1', 'val1');\r\n *                 mlb.add('some item 2', 'val2');\r\n *                 mlb.add('some item 3', 'val3');\r\n * \r\n *                 // Return the new listbox instance\r\n *                 return mlb;\r\n *         }\r\n * \r\n *         return null;\r\n *     }\r\n * });\r\n * \r\n * // Register plugin\r\n * tinymce.PluginManager.add('example', tinymce.plugins.ExamplePlugin);\r\n * \r\n * // Initialize TinyMCE with the new plugin and button\r\n * tinyMCE.init({\r\n *    ...\r\n *    plugins : '-example', // - means TinyMCE will not try to load it\r\n *    theme_advanced_buttons1 : 'mylistbox' // Add the new mylistbox control to the toolbar\r\n * });\r\n */\r\n","Magento_Tinymce3/tiny_mce/classes/ControlManager.js":"/**\r\n * ControlManager.js\r\n *\r\n * Copyright 2009, Moxiecode Systems AB\r\n * Released under LGPL License.\r\n *\r\n * License: http://tinymce.moxiecode.com/license\r\n * Contributing: http://tinymce.moxiecode.com/contributing\r\n */\r\n\r\n(function(tinymce) {\r\n\t// Shorten names\r\n\tvar DOM = tinymce.DOM, Event = tinymce.dom.Event, each = tinymce.each, extend = tinymce.extend;\r\n\r\n\t/**\r\n\t * This class is responsible for managing UI control instances. It's both a factory and a collection for the controls.\r\n\t * @class tinymce.ControlManager\r\n\t */\r\n\ttinymce.create('tinymce.ControlManager', {\r\n\t\t/**\r\n\t\t * Constructs a new control manager instance.\r\n\t\t * Consult the Wiki for more details on this class.\r\n\t\t *\r\n\t\t * @constructor\r\n\t\t * @method ControlManager\r\n\t\t * @param {tinymce.Editor} ed TinyMCE editor instance to add the control to.\r\n\t\t * @param {Object} s Optional settings object for the control manager.\r\n\t\t */\r\n\t\tControlManager : function(ed, s) {\r\n\t\t\tvar t = this, i;\r\n\r\n\t\t\ts = s || {};\r\n\t\t\tt.editor = ed;\r\n\t\t\tt.controls = {};\r\n\t\t\tt.onAdd = new tinymce.util.Dispatcher(t);\r\n\t\t\tt.onPostRender = new tinymce.util.Dispatcher(t);\r\n\t\t\tt.prefix = s.prefix || ed.id + '_';\r\n\t\t\tt._cls = {};\r\n\r\n\t\t\tt.onPostRender.add(function() {\r\n\t\t\t\teach(t.controls, function(c) {\r\n\t\t\t\t\tc.postRender();\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns a control by id or undefined it wasn't found.\r\n\t\t *\r\n\t\t * @method get\r\n\t\t * @param {String} id Control instance name.\r\n\t\t * @return {tinymce.ui.Control} Control instance or undefined.\r\n\t\t */\r\n\t\tget : function(id) {\r\n\t\t\treturn this.controls[this.prefix + id] || this.controls[id];\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Sets the active state of a control by id.\r\n\t\t *\r\n\t\t * @method setActive\r\n\t\t * @param {String} id Control id to set state on.\r\n\t\t * @param {Boolean} s Active state true/false.\r\n\t\t * @return {tinymce.ui.Control} Control instance that got activated or null if it wasn't found.\r\n\t\t */\r\n\t\tsetActive : function(id, s) {\r\n\t\t\tvar c = null;\r\n\r\n\t\t\tif (c = this.get(id))\r\n\t\t\t\tc.setActive(s);\r\n\r\n\t\t\treturn c;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Sets the dsiabled state of a control by id.\r\n\t\t *\r\n\t\t * @method setDisabled\r\n\t\t * @param {String} id Control id to set state on.\r\n\t\t * @param {Boolean} s Active state true/false.\r\n\t\t * @return {tinymce.ui.Control} Control instance that got disabled or null if it wasn't found.\r\n\t\t */\r\n\t\tsetDisabled : function(id, s) {\r\n\t\t\tvar c = null;\r\n\r\n\t\t\tif (c = this.get(id))\r\n\t\t\t\tc.setDisabled(s);\r\n\r\n\t\t\treturn c;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Adds a control to the control collection inside the manager.\r\n\t\t *\r\n\t\t * @method add\r\n\t\t * @param {tinymce.ui.Control} Control instance to add to collection.\r\n\t\t * @return {tinymce.ui.Control} Control instance that got passed in.\r\n\t\t */\r\n\t\tadd : function(c) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\tif (c) {\r\n\t\t\t\tt.controls[c.id] = c;\r\n\t\t\t\tt.onAdd.dispatch(c, t);\r\n\t\t\t}\r\n\r\n\t\t\treturn c;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Creates a control by name, when a control is created it will automatically add it to the control collection.\r\n\t\t * It first ask all plugins for the specified control if the plugins didn't return a control then the default behavior\r\n\t\t * will be used.\r\n\t\t *\r\n\t\t * @method createControl\r\n\t\t * @param {String} n Control name to create for example \"separator\".\r\n\t\t * @return {tinymce.ui.Control} Control instance that got created and added.\r\n\t\t */\r\n\t\tcreateControl : function(n) {\r\n\t\t\tvar c, t = this, ed = t.editor;\r\n\r\n\t\t\teach(ed.plugins, function(p) {\r\n\t\t\t\tif (p.createControl) {\r\n\t\t\t\t\tc = p.createControl(n, t);\r\n\r\n\t\t\t\t\tif (c)\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tswitch (n) {\r\n\t\t\t\tcase \"|\":\r\n\t\t\t\tcase \"separator\":\r\n\t\t\t\t\treturn t.createSeparator();\r\n\t\t\t}\r\n\r\n\t\t\tif (!c && ed.buttons && (c = ed.buttons[n]))\r\n\t\t\t\treturn t.createButton(n, c);\r\n\r\n\t\t\treturn t.add(c);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Creates a drop menu control instance by id.\r\n\t\t *\r\n\t\t * @method createDropMenu\r\n\t\t * @param {String} id Unique id for the new dropdown instance. For example \"some menu\".\r\n\t\t * @param {Object} s Optional settings object for the control.\r\n\t\t * @param {Object} cc Optional control class to use instead of the default one.\r\n\t\t * @return {tinymce.ui.Control} Control instance that got created and added.\r\n\t\t */\r\n\t\tcreateDropMenu : function(id, s, cc) {\r\n\t\t\tvar t = this, ed = t.editor, c, bm, v, cls;\r\n\r\n\t\t\ts = extend({\r\n\t\t\t\t'class' : 'mceDropDown',\r\n\t\t\t\tconstrain : ed.settings.constrain_menus\r\n\t\t\t}, s);\r\n\r\n\t\t\ts['class'] = s['class'] + ' ' + ed.getParam('skin') + 'Skin';\r\n\t\t\tif (v = ed.getParam('skin_variant'))\r\n\t\t\t\ts['class'] += ' ' + ed.getParam('skin') + 'Skin' + v.substring(0, 1).toUpperCase() + v.substring(1);\r\n\r\n\t\t\tid = t.prefix + id;\r\n\t\t\tcls = cc || t._cls.dropmenu || tinymce.ui.DropMenu;\r\n\t\t\tc = t.controls[id] = new cls(id, s);\r\n\t\t\tc.onAddItem.add(function(c, o) {\r\n\t\t\t\tvar s = o.settings;\r\n\r\n\t\t\t\ts.title = ed.getLang(s.title, s.title);\r\n\r\n\t\t\t\tif (!s.onclick) {\r\n\t\t\t\t\ts.onclick = function(v) {\r\n\t\t\t\t\t\tif (s.cmd)\r\n\t\t\t\t\t\t\ted.execCommand(s.cmd, s.ui || false, s.value);\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\ted.onRemove.add(function() {\r\n\t\t\t\tc.destroy();\r\n\t\t\t});\r\n\r\n\t\t\t// Fix for bug #1897785, #1898007\r\n\t\t\tif (tinymce.isIE) {\r\n\t\t\t\tc.onShowMenu.add(function() {\r\n\t\t\t\t\t// IE 8 needs focus in order to store away a range with the current collapsed caret location\r\n\t\t\t\t\ted.focus();\r\n\r\n\t\t\t\t\tbm = ed.selection.getBookmark(1);\r\n\t\t\t\t});\r\n\r\n\t\t\t\tc.onHideMenu.add(function() {\r\n\t\t\t\t\tif (bm) {\r\n\t\t\t\t\t\ted.selection.moveToBookmark(bm);\r\n\t\t\t\t\t\tbm = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\treturn t.add(c);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Creates a list box control instance by id. A list box is either a native select element or a DOM/JS based list box control. This\r\n\t\t * depends on the use_native_selects settings state.\r\n\t\t *\r\n\t\t * @method createListBox\r\n\t\t * @param {String} id Unique id for the new listbox instance. For example \"styles\".\r\n\t\t * @param {Object} s Optional settings object for the control.\r\n\t\t * @param {Object} cc Optional control class to use instead of the default one.\r\n\t\t * @return {tinymce.ui.Control} Control instance that got created and added.\r\n\t\t */\r\n\t\tcreateListBox : function(id, s, cc) {\r\n\t\t\tvar t = this, ed = t.editor, cmd, c, cls;\r\n\r\n\t\t\tif (t.get(id))\r\n\t\t\t\treturn null;\r\n\r\n\t\t\ts.title = ed.translate(s.title);\r\n\t\t\ts.scope = s.scope || ed;\r\n\r\n\t\t\tif (!s.onselect) {\r\n\t\t\t\ts.onselect = function(v) {\r\n\t\t\t\t\ted.execCommand(s.cmd, s.ui || false, v || s.value);\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\ts = extend({\r\n\t\t\t\ttitle : s.title,\r\n\t\t\t\t'class' : 'mce_' + id,\r\n\t\t\t\tscope : s.scope,\r\n\t\t\t\tcontrol_manager : t\r\n\t\t\t}, s);\r\n\r\n\t\t\tid = t.prefix + id;\r\n\r\n\r\n\t\t\tfunction useNativeListForAccessibility(ed) {\r\n\t\t\t\treturn ed.settings.use_accessible_selects && !tinymce.isGecko\r\n\t\t\t}\r\n\r\n\t\t\tif (ed.settings.use_native_selects || useNativeListForAccessibility(ed))\r\n\t\t\t\tc = new tinymce.ui.NativeListBox(id, s);\r\n\t\t\telse {\r\n\t\t\t\tcls = cc || t._cls.listbox || tinymce.ui.ListBox;\r\n\t\t\t\tc = new cls(id, s, ed);\r\n\t\t\t}\r\n\r\n\t\t\tt.controls[id] = c;\r\n\r\n\t\t\t// Fix focus problem in Safari\r\n\t\t\tif (tinymce.isWebKit) {\r\n\t\t\t\tc.onPostRender.add(function(c, n) {\r\n\t\t\t\t\t// Store bookmark on mousedown\r\n\t\t\t\t\tEvent.add(n, 'mousedown', function() {\r\n\t\t\t\t\t\ted.bookmark = ed.selection.getBookmark(1);\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\t// Restore on focus, since it might be lost\r\n\t\t\t\t\tEvent.add(n, 'focus', function() {\r\n\t\t\t\t\t\ted.selection.moveToBookmark(ed.bookmark);\r\n\t\t\t\t\t\ted.bookmark = null;\r\n\t\t\t\t\t});\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tif (c.hideMenu)\r\n\t\t\t\ted.onMouseDown.add(c.hideMenu, c);\r\n\r\n\t\t\treturn t.add(c);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Creates a button control instance by id.\r\n\t\t *\r\n\t\t * @method createButton\r\n\t\t * @param {String} id Unique id for the new button instance. For example \"bold\".\r\n\t\t * @param {Object} s Optional settings object for the control.\r\n\t\t * @param {Object} cc Optional control class to use instead of the default one.\r\n\t\t * @return {tinymce.ui.Control} Control instance that got created and added.\r\n\t\t */\r\n\t\tcreateButton : function(id, s, cc) {\r\n\t\t\tvar t = this, ed = t.editor, o, c, cls;\r\n\r\n\t\t\tif (t.get(id))\r\n\t\t\t\treturn null;\r\n\r\n\t\t\ts.title = ed.translate(s.title);\r\n\t\t\ts.label = ed.translate(s.label);\r\n\t\t\ts.scope = s.scope || ed;\r\n\r\n\t\t\tif (!s.onclick && !s.menu_button) {\r\n\t\t\t\ts.onclick = function() {\r\n\t\t\t\t\ted.execCommand(s.cmd, s.ui || false, s.value);\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\ts = extend({\r\n\t\t\t\ttitle : s.title,\r\n\t\t\t\t'class' : 'mce_' + id,\r\n\t\t\t\tunavailable_prefix : ed.getLang('unavailable', ''),\r\n\t\t\t\tscope : s.scope,\r\n\t\t\t\tcontrol_manager : t\r\n\t\t\t}, s);\r\n\r\n\t\t\tid = t.prefix + id;\r\n\r\n\t\t\tif (s.menu_button) {\r\n\t\t\t\tcls = cc || t._cls.menubutton || tinymce.ui.MenuButton;\r\n\t\t\t\tc = new cls(id, s, ed);\r\n\t\t\t\ted.onMouseDown.add(c.hideMenu, c);\r\n\t\t\t} else {\r\n\t\t\t\tcls = t._cls.button || tinymce.ui.Button;\r\n\t\t\t\tc = new cls(id, s, ed);\r\n\t\t\t}\r\n\r\n\t\t\treturn t.add(c);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Creates a menu button control instance by id.\r\n\t\t *\r\n\t\t * @method createMenuButton\r\n\t\t * @param {String} id Unique id for the new menu button instance. For example \"menu1\".\r\n\t\t * @param {Object} s Optional settings object for the control.\r\n\t\t * @param {Object} cc Optional control class to use instead of the default one.\r\n\t\t * @return {tinymce.ui.Control} Control instance that got created and added.\r\n\t\t */\r\n\t\tcreateMenuButton : function(id, s, cc) {\r\n\t\t\ts = s || {};\r\n\t\t\ts.menu_button = 1;\r\n\r\n\t\t\treturn this.createButton(id, s, cc);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Creates a split button control instance by id.\r\n\t\t *\r\n\t\t * @method createSplitButton\r\n\t\t * @param {String} id Unique id for the new split button instance. For example \"spellchecker\".\r\n\t\t * @param {Object} s Optional settings object for the control.\r\n\t\t * @param {Object} cc Optional control class to use instead of the default one.\r\n\t\t * @return {tinymce.ui.Control} Control instance that got created and added.\r\n\t\t */\r\n\t\tcreateSplitButton : function(id, s, cc) {\r\n\t\t\tvar t = this, ed = t.editor, cmd, c, cls;\r\n\r\n\t\t\tif (t.get(id))\r\n\t\t\t\treturn null;\r\n\r\n\t\t\ts.title = ed.translate(s.title);\r\n\t\t\ts.scope = s.scope || ed;\r\n\r\n\t\t\tif (!s.onclick) {\r\n\t\t\t\ts.onclick = function(v) {\r\n\t\t\t\t\ted.execCommand(s.cmd, s.ui || false, v || s.value);\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\tif (!s.onselect) {\r\n\t\t\t\ts.onselect = function(v) {\r\n\t\t\t\t\ted.execCommand(s.cmd, s.ui || false, v || s.value);\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\ts = extend({\r\n\t\t\t\ttitle : s.title,\r\n\t\t\t\t'class' : 'mce_' + id,\r\n\t\t\t\tscope : s.scope,\r\n\t\t\t\tcontrol_manager : t\r\n\t\t\t}, s);\r\n\r\n\t\t\tid = t.prefix + id;\r\n\t\t\tcls = cc || t._cls.splitbutton || tinymce.ui.SplitButton;\r\n\t\t\tc = t.add(new cls(id, s, ed));\r\n\t\t\ted.onMouseDown.add(c.hideMenu, c);\r\n\r\n\t\t\treturn c;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Creates a color split button control instance by id.\r\n\t\t *\r\n\t\t * @method createColorSplitButton\r\n\t\t * @param {String} id Unique id for the new color split button instance. For example \"forecolor\".\r\n\t\t * @param {Object} s Optional settings object for the control.\r\n\t\t * @param {Object} cc Optional control class to use instead of the default one.\r\n\t\t * @return {tinymce.ui.Control} Control instance that got created and added.\r\n\t\t */\r\n\t\tcreateColorSplitButton : function(id, s, cc) {\r\n\t\t\tvar t = this, ed = t.editor, cmd, c, cls, bm;\r\n\r\n\t\t\tif (t.get(id))\r\n\t\t\t\treturn null;\r\n\r\n\t\t\ts.title = ed.translate(s.title);\r\n\t\t\ts.scope = s.scope || ed;\r\n\r\n\t\t\tif (!s.onclick) {\r\n\t\t\t\ts.onclick = function(v) {\r\n\t\t\t\t\tif (tinymce.isIE)\r\n\t\t\t\t\t\tbm = ed.selection.getBookmark(1);\r\n\r\n\t\t\t\t\ted.execCommand(s.cmd, s.ui || false, v || s.value);\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\tif (!s.onselect) {\r\n\t\t\t\ts.onselect = function(v) {\r\n\t\t\t\t\ted.execCommand(s.cmd, s.ui || false, v || s.value);\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\ts = extend({\r\n\t\t\t\ttitle : s.title,\r\n\t\t\t\t'class' : 'mce_' + id,\r\n\t\t\t\t'menu_class' : ed.getParam('skin') + 'Skin',\r\n\t\t\t\tscope : s.scope,\r\n\t\t\t\tmore_colors_title : ed.getLang('more_colors')\r\n\t\t\t}, s);\r\n\r\n\t\t\tid = t.prefix + id;\r\n\t\t\tcls = cc || t._cls.colorsplitbutton || tinymce.ui.ColorSplitButton;\r\n\t\t\tc = new cls(id, s, ed);\r\n\t\t\ted.onMouseDown.add(c.hideMenu, c);\r\n\r\n\t\t\t// Remove the menu element when the editor is removed\r\n\t\t\ted.onRemove.add(function() {\r\n\t\t\t\tc.destroy();\r\n\t\t\t});\r\n\r\n\t\t\t// Fix for bug #1897785, #1898007\r\n\t\t\tif (tinymce.isIE) {\r\n\t\t\t\tc.onShowMenu.add(function() {\r\n\t\t\t\t\t// IE 8 needs focus in order to store away a range with the current collapsed caret location\r\n\t\t\t\t\ted.focus();\r\n\t\t\t\t\tbm = ed.selection.getBookmark(1);\r\n\t\t\t\t});\r\n\r\n\t\t\t\tc.onHideMenu.add(function() {\r\n\t\t\t\t\tif (bm) {\r\n\t\t\t\t\t\ted.selection.moveToBookmark(bm);\r\n\t\t\t\t\t\tbm = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\treturn t.add(c);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Creates a toolbar container control instance by id.\r\n\t\t *\r\n\t\t * @method createToolbar\r\n\t\t * @param {String} id Unique id for the new toolbar container control instance. For example \"toolbar1\".\r\n\t\t * @param {Object} s Optional settings object for the control.\r\n\t\t * @param {Object} cc Optional control class to use instead of the default one.\r\n\t\t * @return {tinymce.ui.Control} Control instance that got created and added.\r\n\t\t */\r\n\t\tcreateToolbar : function(id, s, cc) {\r\n\t\t\tvar c, t = this, cls;\r\n\r\n\t\t\tid = t.prefix + id;\r\n\t\t\tcls = cc || t._cls.toolbar || tinymce.ui.Toolbar;\r\n\t\t\tc = new cls(id, s, t.editor);\r\n\r\n\t\t\tif (t.get(id))\r\n\t\t\t\treturn null;\r\n\r\n\t\t\treturn t.add(c);\r\n\t\t},\r\n\t\t\r\n\t\tcreateToolbarGroup : function(id, s, cc) {\r\n\t\t\tvar c, t = this, cls;\r\n\t\t\tid = t.prefix + id;\r\n\t\t\tcls = cc || this._cls.toolbarGroup || tinymce.ui.ToolbarGroup;\r\n\t\t\tc = new cls(id, s, t.editor);\r\n\t\t\t\r\n\t\t\tif (t.get(id))\r\n\t\t\t\treturn null;\r\n\t\t\t\r\n\t\t\treturn t.add(c);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Creates a separator control instance.\r\n\t\t *\r\n\t\t * @method createSeparator\r\n\t\t * @param {Object} cc Optional control class to use instead of the default one.\r\n\t\t * @return {tinymce.ui.Control} Control instance that got created and added.\r\n\t\t */\r\n\t\tcreateSeparator : function(cc) {\r\n\t\t\tvar cls = cc || this._cls.separator || tinymce.ui.Separator;\r\n\r\n\t\t\treturn new cls();\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Overrides a specific control type with a custom class.\r\n\t\t *\r\n\t\t * @method setControlType\r\n\t\t * @param {string} n Name of the control to override for example button or dropmenu.\r\n\t\t * @param {function} c Class reference to use instead of the default one.\r\n\t\t * @return {function} Same as the class reference.\r\n\t\t */\r\n\t\tsetControlType : function(n, c) {\r\n\t\t\treturn this._cls[n.toLowerCase()] = c;\r\n\t\t},\r\n\t\r\n\t\t/**\r\n\t\t * Destroy.\r\n\t\t *\r\n\t\t * @method destroy\r\n\t\t */\r\n\t\tdestroy : function() {\r\n\t\t\teach(this.controls, function(c) {\r\n\t\t\t\tc.destroy();\r\n\t\t\t});\r\n\r\n\t\t\tthis.controls = null;\r\n\t\t}\r\n\t});\r\n})(tinymce);\r\n","Magento_Tinymce3/tiny_mce/classes/Editor.js":"/**\r\n * Editor.js\r\n *\r\n * Copyright 2009, Moxiecode Systems AB\r\n * Released under LGPL License.\r\n *\r\n * License: http://tinymce.moxiecode.com/license\r\n * Contributing: http://tinymce.moxiecode.com/contributing\r\n */\r\n\r\n(function(tinymce) {\r\n\t// Shorten these names\r\n\tvar DOM = tinymce.DOM, Event = tinymce.dom.Event, extend = tinymce.extend,\r\n\t\tDispatcher = tinymce.util.Dispatcher, each = tinymce.each, isGecko = tinymce.isGecko,\r\n\t\tisIE = tinymce.isIE, isWebKit = tinymce.isWebKit, is = tinymce.is,\r\n\t\tThemeManager = tinymce.ThemeManager, PluginManager = tinymce.PluginManager,\r\n\t\tinArray = tinymce.inArray, grep = tinymce.grep, explode = tinymce.explode;\r\n\r\n\t/**\r\n\t * This class contains the core logic for a TinyMCE editor.\r\n\t *\r\n\t * @class tinymce.Editor\r\n\t * @example\r\n\t * // Add a class to all paragraphs in the editor.\r\n\t * tinyMCE.activeEditor.dom.addClass(tinyMCE.activeEditor.dom.select('p'), 'someclass');\r\n\t *\r\n\t * // Gets the current editors selection as text\r\n\t * tinyMCE.activeEditor.selection.getContent({format : 'text'});\r\n\t *\r\n\t * // Creates a new editor instance\r\n\t * var ed = new tinymce.Editor('textareaid', {\r\n\t *     some_setting : 1\r\n\t * });\r\n\t *\r\n\t * // Select each item the user clicks on\r\n\t * ed.onClick.add(function(ed, e) {\r\n\t *     ed.selection.select(e.target);\r\n\t * });\r\n\t *\r\n\t * ed.render();\r\n\t */\r\n\ttinymce.create('tinymce.Editor', {\r\n\t\t/**\r\n\t\t * Constructs a editor instance by id.\r\n\t\t *\r\n\t\t * @constructor\r\n\t\t * @method Editor\r\n\t\t * @param {String} id Unique id for the editor.\r\n\t\t * @param {Object} s Optional settings string for the editor.\r\n\t\t * @author Moxiecode\r\n\t\t */\r\n\t\tEditor : function(id, s) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\t/**\r\n\t\t\t * Editor instance id, normally the same as the div/textarea that was replaced.\r\n\t\t\t *\r\n\t\t\t * @property id\r\n\t\t\t * @type String\r\n\t\t\t */\r\n\t\t\tt.id = t.editorId = id;\r\n\r\n\t\t\tt.execCommands = {};\r\n\t\t\tt.queryStateCommands = {};\r\n\t\t\tt.queryValueCommands = {};\r\n\r\n\t\t\t/**\r\n\t\t\t * State to force the editor to return false on a isDirty call.\r\n\t\t\t *\r\n\t\t\t * @property isNotDirty\r\n\t\t\t * @type Boolean\r\n\t\t\t * @example\r\n\t\t\t * function ajaxSave() {\r\n\t\t\t *     var ed = tinyMCE.get('elm1');\r\n\t\t\t *\r\n\t\t\t *     // Save contents using some XHR call\r\n\t\t\t *     alert(ed.getContent());\r\n\t\t\t *\r\n\t\t\t *     ed.isNotDirty = 1; // Force not dirty state\r\n\t\t\t * }\r\n\t\t\t */\r\n\t\t\tt.isNotDirty = false;\r\n\r\n\t\t\t/**\r\n\t\t\t * Name/Value object containting plugin instances.\r\n\t\t\t *\r\n\t\t\t * @property plugins\r\n\t\t\t * @type Object\r\n\t\t\t * @example\r\n\t\t\t * // Execute a method inside a plugin directly\r\n\t\t\t * tinyMCE.activeEditor.plugins.someplugin.someMethod();\r\n\t\t\t */\r\n\t\t\tt.plugins = {};\r\n\r\n\t\t\t// Add events to the editor\r\n\t\t\teach([\r\n\t\t\t\t/**\r\n\t\t\t\t * Fires before the initialization of the editor.\r\n\t\t\t\t *\r\n\t\t\t\t * @event onPreInit\r\n\t\t\t\t * @param {tinymce.Editor} sender Editor instance.\r\n\t\t\t\t * @see #onInit\r\n\t\t\t\t * @example\r\n\t\t\t\t * // Adds an observer to the onPreInit event using tinyMCE.init\r\n\t\t\t\t * tinyMCE.init({\r\n\t\t\t\t *    ...\r\n\t\t\t\t *    setup : function(ed) {\r\n\t\t\t\t *       ed.onPreInit.add(function(ed) {\r\n\t\t\t\t *           console.debug('PreInit: ' + ed.id);\r\n\t\t\t\t *       });\r\n\t\t\t\t *    }\r\n\t\t\t\t * });\r\n\t\t\t\t */\r\n\t\t\t\t'onPreInit',\r\n\r\n\t\t\t\t/**\r\n\t\t\t\t * Fires before the initialization of the editor.\r\n\t\t\t\t *\r\n\t\t\t\t * @event onBeforeRenderUI\r\n\t\t\t\t * @param {tinymce.Editor} sender Editor instance.\r\n\t\t\t\t * @example\r\n\t\t\t\t * // Adds an observer to the onBeforeRenderUI event using tinyMCE.init\r\n\t\t\t\t * tinyMCE.init({\r\n\t\t\t\t *    ...\r\n\t\t\t\t *    setup : function(ed) {\r\n \t\t\t\t *      ed.onBeforeRenderUI.add(function(ed, cm) {\r\n \t\t\t\t *          console.debug('Before render: ' + ed.id);\r\n \t\t\t\t *      });\r\n\t\t\t\t *    }\r\n\t\t\t\t * });\r\n\t\t\t\t */\r\n\t\t\t\t'onBeforeRenderUI',\r\n\r\n\t\t\t\t/**\r\n\t\t\t\t * Fires after the rendering has completed.\r\n\t\t\t\t *\r\n\t\t\t\t * @event onPostRender\r\n\t\t\t\t * @param {tinymce.Editor} sender Editor instance.\r\n\t\t\t\t * @example\r\n\t\t\t\t * // Adds an observer to the onPostRender event using tinyMCE.init\r\n\t\t\t\t * tinyMCE.init({\r\n\t\t\t\t *    ...\r\n\t\t\t\t *    setup : function(ed) {\r\n\t\t\t\t *       ed.onPostRender.add(function(ed, cm) {\r\n\t\t\t\t *           console.debug('After render: ' + ed.id);\r\n\t\t\t\t *       });\r\n\t\t\t\t *    }\r\n\t\t\t\t * });\r\n\t\t\t\t */\r\n\t\t\t\t'onPostRender',\r\n\r\n\t\t\t\t/**\r\n\t\t\t\t * Fires after the initialization of the editor is done.\r\n\t\t\t\t *\r\n\t\t\t\t * @event onInit\r\n\t\t\t\t * @param {tinymce.Editor} sender Editor instance.\r\n\t\t\t\t * @see #onPreInit\r\n\t\t\t\t * @example\r\n\t\t\t\t * // Adds an observer to the onInit event using tinyMCE.init\r\n\t\t\t\t * tinyMCE.init({\r\n\t\t\t\t *    ...\r\n\t\t\t\t *    setup : function(ed) {\r\n\t\t\t\t *       ed.onInit.add(function(ed) {\r\n\t\t\t\t *           console.debug('Editor is done: ' + ed.id);\r\n\t\t\t\t *       });\r\n\t\t\t\t *    }\r\n\t\t\t\t * });\r\n\t\t\t\t */\r\n\t\t\t\t'onInit',\r\n\r\n\t\t\t\t/**\r\n\t\t\t\t * Fires when the editor instance is removed from page.\r\n\t\t\t\t *\r\n\t\t\t\t * @event onRemove\r\n\t\t\t\t * @param {tinymce.Editor} sender Editor instance.\r\n\t\t\t\t * @example\r\n\t\t\t\t * // Adds an observer to the onRemove event using tinyMCE.init\r\n\t\t\t\t * tinyMCE.init({\r\n\t\t\t\t *    ...\r\n\t\t\t\t *    setup : function(ed) {\r\n\t\t\t\t *       ed.onRemove.add(function(ed) {\r\n\t\t\t\t *           console.debug('Editor was removed: ' + ed.id);\r\n\t\t\t\t *       });\r\n\t\t\t\t *    }\r\n\t\t\t\t * });\r\n\t\t\t\t */\r\n\t\t\t\t'onRemove',\r\n\r\n\t\t\t\t/**\r\n\t\t\t\t * Fires when the editor is activated.\r\n\t\t\t\t *\r\n\t\t\t\t * @event onActivate\r\n\t\t\t\t * @param {tinymce.Editor} sender Editor instance.\r\n\t\t\t\t * @example\r\n\t\t\t\t * // Adds an observer to the onActivate event using tinyMCE.init\r\n\t\t\t\t * tinyMCE.init({\r\n\t\t\t\t *    ...\r\n\t\t\t\t *    setup : function(ed) {\r\n\t\t\t\t *       ed.onActivate.add(function(ed) {\r\n\t\t\t\t *           console.debug('Editor was activated: ' + ed.id);\r\n\t\t\t\t *       });\r\n\t\t\t\t *    }\r\n\t\t\t\t * });\r\n\t\t\t\t */\r\n\t\t\t\t'onActivate',\r\n\r\n\t\t\t\t/**\r\n\t\t\t\t * Fires when the editor is deactivated.\r\n\t\t\t\t *\r\n\t\t\t\t * @event onDeactivate\r\n\t\t\t\t * @param {tinymce.Editor} sender Editor instance.\r\n\t\t\t\t * @example\r\n\t\t\t\t * // Adds an observer to the onDeactivate event using tinyMCE.init\r\n\t\t\t\t * tinyMCE.init({\r\n\t\t\t\t *    ...\r\n\t\t\t\t *    setup : function(ed) {\r\n\t\t\t\t *       ed.onDeactivate.add(function(ed) {\r\n\t\t\t\t *           console.debug('Editor was deactivated: ' + ed.id);\r\n\t\t\t\t *       });\r\n\t\t\t\t *    }\r\n\t\t\t\t * });\r\n\t\t\t\t */\r\n\t\t\t\t'onDeactivate',\r\n\r\n\t\t\t\t/**\r\n\t\t\t\t * Fires when something in the body of the editor is clicked.\r\n\t\t\t\t *\r\n\t\t\t\t * @event onClick\r\n\t\t\t\t * @param {tinymce.Editor} sender Editor instance.\r\n\t\t\t\t * @param {Event} evt W3C DOM Event instance.\r\n\t\t\t\t * @example\r\n\t\t\t\t * // Adds an observer to the onClick event using tinyMCE.init\r\n\t\t\t\t * tinyMCE.init({\r\n\t\t\t\t *    ...\r\n\t\t\t\t *    setup : function(ed) {\r\n\t\t\t\t *       ed.onClick.add(function(ed, e) {\r\n\t\t\t\t *           console.debug('Editor was clicked: ' + e.target.nodeName);\r\n\t\t\t\t *       });\r\n\t\t\t\t *    }\r\n\t\t\t\t * });\r\n\t\t\t\t */\r\n\t\t\t\t'onClick',\r\n\r\n\t\t\t\t/**\r\n\t\t\t\t * Fires when a registered event is intercepted.\r\n\t\t\t\t *\r\n\t\t\t\t * @event onEvent\r\n\t\t\t\t * @param {tinymce.Editor} sender Editor instance.\r\n\t\t\t\t * @param {Event} evt W3C DOM Event instance.\r\n\t\t\t\t * @example\r\n\t\t\t\t * // Adds an observer to the onEvent event using tinyMCE.init\r\n\t\t\t\t * tinyMCE.init({\r\n\t\t\t\t *    ...\r\n\t\t\t\t *    setup : function(ed) {\r\n\t\t\t\t *       ed.onEvent.add(function(ed, e) {\r\n \t\t\t\t *          console.debug('Editor event occurred: ' + e.target.nodeName);\r\n\t\t\t\t *       });\r\n\t\t\t\t *    }\r\n\t\t\t\t * });\r\n\t\t\t\t */\r\n\t\t\t\t'onEvent',\r\n\r\n\t\t\t\t/**\r\n\t\t\t\t * Fires when a mouseup event is intercepted inside the editor.\r\n\t\t\t\t *\r\n\t\t\t\t * @event onMouseUp\r\n\t\t\t\t * @param {tinymce.Editor} sender Editor instance.\r\n\t\t\t\t * @param {Event} evt W3C DOM Event instance.\r\n\t\t\t\t * @example\r\n\t\t\t\t * // Adds an observer to the onMouseUp event using tinyMCE.init\r\n\t\t\t\t * tinyMCE.init({\r\n\t\t\t\t *    ...\r\n\t\t\t\t *    setup : function(ed) {\r\n\t\t\t\t *       ed.onMouseUp.add(function(ed, e) {\r\n\t\t\t\t *           console.debug('Mouse up event: ' + e.target.nodeName);\r\n\t\t\t\t *       });\r\n\t\t\t\t *    }\r\n\t\t\t\t * });\r\n\t\t\t\t */\r\n\t\t\t\t'onMouseUp',\r\n\r\n\t\t\t\t/**\r\n\t\t\t\t * Fires when a mousedown event is intercepted inside the editor.\r\n\t\t\t\t *\r\n\t\t\t\t * @event onMouseDown\r\n\t\t\t\t * @param {tinymce.Editor} sender Editor instance.\r\n\t\t\t\t * @param {Event} evt W3C DOM Event instance.\r\n\t\t\t\t * @example\r\n\t\t\t\t * // Adds an observer to the onMouseDown event using tinyMCE.init\r\n\t\t\t\t * tinyMCE.init({\r\n\t\t\t\t *    ...\r\n\t\t\t\t *    setup : function(ed) {\r\n\t\t\t\t *       ed.onMouseDown.add(function(ed, e) {\r\n\t\t\t\t *           console.debug('Mouse down event: ' + e.target.nodeName);\r\n\t\t\t\t *       });\r\n\t\t\t\t *    }\r\n\t\t\t\t * });\r\n\t\t\t\t */\r\n\t\t\t\t'onMouseDown',\r\n\r\n\t\t\t\t/**\r\n\t\t\t\t * Fires when a dblclick event is intercepted inside the editor.\r\n\t\t\t\t *\r\n\t\t\t\t * @event onDblClick\r\n\t\t\t\t * @param {tinymce.Editor} sender Editor instance.\r\n\t\t\t\t * @param {Event} evt W3C DOM Event instance.\r\n\t\t\t\t * @example\r\n\t\t\t\t * // Adds an observer to the onDblClick event using tinyMCE.init\r\n\t\t\t\t * tinyMCE.init({\r\n\t\t\t\t *    ...\r\n\t\t\t\t *    setup : function(ed) {\r\n\t\t\t\t *       ed.onDblClick.add(function(ed, e) {\r\n \t\t\t\t *          console.debug('Double click event: ' + e.target.nodeName);\r\n\t\t\t\t *       });\r\n\t\t\t\t *    }\r\n\t\t\t\t * });\r\n\t\t\t\t */\r\n\t\t\t\t'onDblClick',\r\n\r\n\t\t\t\t/**\r\n\t\t\t\t * Fires when a keydown event is intercepted inside the editor.\r\n\t\t\t\t *\r\n\t\t\t\t * @event onKeyDown\r\n\t\t\t\t * @param {tinymce.Editor} sender Editor instance.\r\n\t\t\t\t * @param {Event} evt W3C DOM Event instance.\r\n\t\t\t\t * @example\r\n\t\t\t\t * // Adds an observer to the onKeyDown event using tinyMCE.init\r\n\t\t\t\t * tinyMCE.init({\r\n\t\t\t\t *    ...\r\n\t\t\t\t *    setup : function(ed) {\r\n\t\t\t\t *       ed.onKeyDown.add(function(ed, e) {\r\n\t\t\t\t *           console.debug('Key down event: ' + e.keyCode);\r\n\t\t\t\t *       });\r\n\t\t\t\t *    }\r\n\t\t\t\t * });\r\n\t\t\t\t */\r\n\t\t\t\t'onKeyDown',\r\n\r\n\t\t\t\t/**\r\n\t\t\t\t * Fires when a keydown event is intercepted inside the editor.\r\n\t\t\t\t *\r\n\t\t\t\t * @event onKeyUp\r\n\t\t\t\t * @param {tinymce.Editor} sender Editor instance.\r\n\t\t\t\t * @param {Event} evt W3C DOM Event instance.\r\n\t\t\t\t * @example\r\n\t\t\t\t * // Adds an observer to the onKeyUp event using tinyMCE.init\r\n\t\t\t\t * tinyMCE.init({\r\n\t\t\t\t *    ...\r\n\t\t\t\t *    setup : function(ed) {\r\n\t\t\t\t *       ed.onKeyUp.add(function(ed, e) {\r\n\t\t\t\t *           console.debug('Key up event: ' + e.keyCode);\r\n\t\t\t\t *       });\r\n\t\t\t\t *    }\r\n\t\t\t\t * });\r\n\t\t\t\t */\r\n\t\t\t\t'onKeyUp',\r\n\r\n\t\t\t\t/**\r\n\t\t\t\t * Fires when a keypress event is intercepted inside the editor.\r\n\t\t\t\t *\r\n\t\t\t\t * @event onKeyPress\r\n\t\t\t\t * @param {tinymce.Editor} sender Editor instance.\r\n\t\t\t\t * @param {Event} evt W3C DOM Event instance.\r\n\t\t\t\t * @example\r\n\t\t\t\t * // Adds an observer to the onKeyPress event using tinyMCE.init\r\n\t\t\t\t * tinyMCE.init({\r\n\t\t\t\t *    ...\r\n\t\t\t\t *    setup : function(ed) {\r\n\t\t\t\t *       ed.onKeyPress.add(function(ed, e) {\r\n\t\t\t\t *           console.debug('Key press event: ' + e.keyCode);\r\n\t\t\t\t *       });\r\n\t\t\t\t *    }\r\n\t\t\t\t * });\r\n\t\t\t\t */\r\n\t\t\t\t'onKeyPress',\r\n\r\n\t\t\t\t/**\r\n\t\t\t\t * Fires when a contextmenu event is intercepted inside the editor.\r\n\t\t\t\t *\r\n\t\t\t\t * @event onContextMenu\r\n\t\t\t\t * @param {tinymce.Editor} sender Editor instance.\r\n\t\t\t\t * @param {Event} evt W3C DOM Event instance.\r\n\t\t\t\t * @example\r\n\t\t\t\t * // Adds an observer to the onContextMenu event using tinyMCE.init\r\n\t\t\t\t * tinyMCE.init({\r\n\t\t\t\t *    ...\r\n\t\t\t\t *    setup : function(ed) {\r\n\t\t\t\t *       ed.onContextMenu.add(function(ed, e) {\r\n\t\t\t\t *            console.debug('Context menu event:' + e.target);\r\n\t\t\t\t *       });\r\n\t\t\t\t *    }\r\n\t\t\t\t * });\r\n\t\t\t\t */\r\n\t\t\t\t'onContextMenu',\r\n\r\n\t\t\t\t/**\r\n\t\t\t\t * Fires when a form submit event is intercepted.\r\n\t\t\t\t *\r\n\t\t\t\t * @event onSubmit\r\n\t\t\t\t * @param {tinymce.Editor} sender Editor instance.\r\n\t\t\t\t * @param {Event} evt W3C DOM Event instance.\r\n\t\t\t\t * @example\r\n\t\t\t\t * // Adds an observer to the onSubmit event using tinyMCE.init\r\n\t\t\t\t * tinyMCE.init({\r\n\t\t\t\t *    ...\r\n\t\t\t\t *    setup : function(ed) {\r\n\t\t\t\t *       ed.onSubmit.add(function(ed, e) {\r\n\t\t\t\t *            console.debug('Form submit:' + e.target);\r\n\t\t\t\t *       });\r\n\t\t\t\t *    }\r\n\t\t\t\t * });\r\n\t\t\t\t */\r\n\t\t\t\t'onSubmit',\r\n\r\n\t\t\t\t/**\r\n\t\t\t\t * Fires when a form reset event is intercepted.\r\n\t\t\t\t *\r\n\t\t\t\t * @event onReset\r\n\t\t\t\t * @param {tinymce.Editor} sender Editor instance.\r\n\t\t\t\t * @param {Event} evt W3C DOM Event instance.\r\n\t\t\t\t * @example\r\n\t\t\t\t * // Adds an observer to the onReset event using tinyMCE.init\r\n\t\t\t\t * tinyMCE.init({\r\n\t\t\t\t *    ...\r\n\t\t\t\t *    setup : function(ed) {\r\n\t\t\t\t *       ed.onReset.add(function(ed, e) {\r\n\t\t\t\t *            console.debug('Form reset:' + e.target);\r\n\t\t\t\t *       });\r\n\t\t\t\t *    }\r\n\t\t\t\t * });\r\n\t\t\t\t */\r\n\t\t\t\t'onReset',\r\n\r\n\t\t\t\t/**\r\n\t\t\t\t * Fires when a paste event is intercepted inside the editor.\r\n\t\t\t\t *\r\n\t\t\t\t * @event onPaste\r\n\t\t\t\t * @param {tinymce.Editor} sender Editor instance.\r\n\t\t\t\t * @param {Event} evt W3C DOM Event instance.\r\n\t\t\t\t * @example\r\n\t\t\t\t * // Adds an observer to the onPaste event using tinyMCE.init\r\n\t\t\t\t * tinyMCE.init({\r\n\t\t\t\t *    ...\r\n\t\t\t\t *    setup : function(ed) {\r\n\t\t\t\t *       ed.onPaste.add(function(ed, e) {\r\n\t\t\t\t *            console.debug('Pasted plain text');\r\n\t\t\t\t *       });\r\n\t\t\t\t *    }\r\n\t\t\t\t * });\r\n\t\t\t\t */\r\n\t\t\t\t'onPaste',\r\n\r\n\t\t\t\t/**\r\n\t\t\t\t * Fires when the Serializer does a preProcess on the contents.\r\n\t\t\t\t *\r\n\t\t\t\t * @event onPreProcess\r\n\t\t\t\t * @param {tinymce.Editor} sender Editor instance.\r\n\t\t\t\t * @param {Object} obj PreProcess object.\r\n\t\t\t\t * @option {Node} node DOM node for the item being serialized.\r\n\t\t\t\t * @option {String} format The specified output format normally \"html\".\r\n\t\t\t\t * @option {Boolean} get Is true if the process is on a getContent operation.\r\n\t\t\t\t * @option {Boolean} set Is true if the process is on a setContent operation.\r\n\t\t\t\t * @option {Boolean} cleanup Is true if the process is on a cleanup operation.\r\n\t\t\t\t * @example\r\n\t\t\t\t * // Adds an observer to the onPreProcess event using tinyMCE.init\r\n\t\t\t\t * tinyMCE.init({\r\n\t\t\t\t *    ...\r\n\t\t\t\t *    setup : function(ed) {\r\n\t\t\t\t *       ed.onPreProcess.add(function(ed, o) {\r\n\t\t\t\t *            // Add a class to each paragraph in the editor\r\n\t\t\t\t *            ed.dom.addClass(ed.dom.select('p', o.node), 'myclass');\r\n\t\t\t\t *       });\r\n\t\t\t\t *    }\r\n\t\t\t\t * });\r\n\t\t\t\t */\r\n\t\t\t\t'onPreProcess',\r\n\r\n\t\t\t\t/**\r\n\t\t\t\t * Fires when the Serializer does a postProcess on the contents.\r\n\t\t\t\t *\r\n\t\t\t\t * @event onPostProcess\r\n\t\t\t\t * @param {tinymce.Editor} sender Editor instance.\r\n\t\t\t\t * @param {Object} obj PreProcess object.\r\n\t\t\t\t * @example\r\n\t\t\t\t * // Adds an observer to the onPostProcess event using tinyMCE.init\r\n\t\t\t\t * tinyMCE.init({\r\n\t\t\t\t *    ...\r\n\t\t\t\t *    setup : function(ed) {\r\n\t\t\t\t *       ed.onPostProcess.add(function(ed, o) {\r\n\t\t\t\t *            // Remove all paragraphs and replace with BR\r\n\t\t\t\t *            o.content = o.content.replace(/<p[^>]+>|<p>/g, '');\r\n\t\t\t\t *            o.content = o.content.replace(/<\\/p>/g, '<br />');\r\n\t\t\t\t *       });\r\n\t\t\t\t *    }\r\n\t\t\t\t * });\r\n\t\t\t\t */\r\n\t\t\t\t'onPostProcess',\r\n\r\n\t\t\t\t/**\r\n\t\t\t\t * Fires before new contents is added to the editor. Using for example setContent.\r\n\t\t\t\t *\r\n\t\t\t\t * @event onBeforeSetContent\r\n\t\t\t\t * @param {tinymce.Editor} sender Editor instance.\r\n\t\t\t\t * @example\r\n\t\t\t\t * // Adds an observer to the onBeforeSetContent event using tinyMCE.init\r\n\t\t\t\t * tinyMCE.init({\r\n\t\t\t\t *    ...\r\n\t\t\t\t *    setup : function(ed) {\r\n\t\t\t\t *       ed.onBeforeSetContent.add(function(ed, o) {\r\n\t\t\t\t *            // Replaces all a characters with b characters\r\n\t\t\t\t *            o.content = o.content.replace(/a/g, 'b');\r\n\t\t\t\t *       });\r\n\t\t\t\t *    }\r\n\t\t\t\t * });\r\n\t\t\t\t */\r\n\t\t\t\t'onBeforeSetContent',\r\n\r\n\t\t\t\t/**\r\n\t\t\t\t * Fires before contents is extracted from the editor using for example getContent.\r\n\t\t\t\t *\r\n\t\t\t\t * @event onBeforeGetContent\r\n\t\t\t\t * @param {tinymce.Editor} sender Editor instance.\r\n\t\t\t\t * @param {Event} evt W3C DOM Event instance.\r\n\t\t\t\t * @example\r\n\t\t\t\t * // Adds an observer to the onBeforeGetContent event using tinyMCE.init\r\n\t\t\t\t * tinyMCE.init({\r\n\t\t\t\t *    ...\r\n\t\t\t\t *    setup : function(ed) {\r\n\t\t\t\t *       ed.onBeforeGetContent.add(function(ed, o) {\r\n\t\t\t\t *            console.debug('Before get content.');\r\n\t\t\t\t *       });\r\n\t\t\t\t *    }\r\n\t\t\t\t * });\r\n\t\t\t\t */\r\n\t\t\t\t'onBeforeGetContent',\r\n\r\n\t\t\t\t/**\r\n\t\t\t\t * Fires after the contents has been added to the editor using for example onSetContent.\r\n\t\t\t\t *\r\n\t\t\t\t * @event onSetContent\r\n\t\t\t\t * @param {tinymce.Editor} sender Editor instance.\r\n\t\t\t\t * @example\r\n\t\t\t\t * // Adds an observer to the onSetContent event using tinyMCE.init\r\n\t\t\t\t * tinyMCE.init({\r\n\t\t\t\t *    ...\r\n\t\t\t\t *    setup : function(ed) {\r\n\t\t\t\t *       ed.onSetContent.add(function(ed, o) {\r\n\t\t\t\t *            // Replaces all a characters with b characters\r\n\t\t\t\t *            o.content = o.content.replace(/a/g, 'b');\r\n\t\t\t\t *       });\r\n\t\t\t\t *    }\r\n\t\t\t\t * });\r\n\t\t\t\t */\r\n\t\t\t\t'onSetContent',\r\n\r\n\t\t\t\t/**\r\n\t\t\t\t * Fires after the contents has been extracted from the editor using for example getContent.\r\n\t\t\t\t *\r\n\t\t\t\t * @event onGetContent\r\n\t\t\t\t * @param {tinymce.Editor} sender Editor instance.\r\n\t\t\t\t * @example\r\n\t\t\t\t * // Adds an observer to the onGetContent event using tinyMCE.init\r\n\t\t\t\t * tinyMCE.init({\r\n\t\t\t\t *    ...\r\n\t\t\t\t *    setup : function(ed) {\r\n\t\t\t\t *       ed.onGetContent.add(function(ed, o) {\r\n\t\t\t\t *           // Replace all a characters with b\r\n\t\t\t\t *           o.content = o.content.replace(/a/g, 'b');\r\n\t\t\t\t *       });\r\n\t\t\t\t *    }\r\n\t\t\t\t * });\r\n\t\t\t\t */\r\n\t\t\t\t'onGetContent',\r\n\r\n\t\t\t\t/**\r\n\t\t\t\t * Fires when the editor gets loaded with contents for example when the load method is executed.\r\n\t\t\t\t *\r\n\t\t\t\t * @event onLoadContent\r\n\t\t\t\t * @param {tinymce.Editor} sender Editor instance.\r\n\t\t\t\t * @example\r\n\t\t\t\t * // Adds an observer to the onLoadContent event using tinyMCE.init\r\n\t\t\t\t * tinyMCE.init({\r\n\t\t\t\t *    ...\r\n\t\t\t\t *    setup : function(ed) {\r\n\t\t\t\t *       ed.onLoadContent.add(function(ed, o) {\r\n\t\t\t\t *           // Output the element name\r\n\t\t\t\t *           console.debug(o.element.nodeName);\r\n\t\t\t\t *       });\r\n\t\t\t\t *    }\r\n\t\t\t\t * });\r\n\t\t\t\t */\r\n\t\t\t\t'onLoadContent',\r\n\r\n\t\t\t\t/**\r\n\t\t\t\t * Fires when the editor contents gets saved for example when the save method is executed.\r\n\t\t\t\t *\r\n\t\t\t\t * @event onSaveContent\r\n\t\t\t\t * @param {tinymce.Editor} sender Editor instance.\r\n\t\t\t\t * @example\r\n\t\t\t\t * // Adds an observer to the onSaveContent event using tinyMCE.init\r\n\t\t\t\t * tinyMCE.init({\r\n\t\t\t\t *    ...\r\n\t\t\t\t *    setup : function(ed) {\r\n\t\t\t\t *       ed.onSaveContent.add(function(ed, o) {\r\n\t\t\t\t *           // Output the element name\r\n\t\t\t\t *           console.debug(o.element.nodeName);\r\n\t\t\t\t *       });\r\n\t\t\t\t *    }\r\n\t\t\t\t * });\r\n\t\t\t\t */\r\n\t\t\t\t'onSaveContent',\r\n\r\n\t\t\t\t/**\r\n\t\t\t\t * Fires when the user changes node location using the mouse or keyboard.\r\n\t\t\t\t *\r\n\t\t\t\t * @event onNodeChange\r\n\t\t\t\t * @param {tinymce.Editor} sender Editor instance.\r\n\t\t\t\t * @example\r\n\t\t\t\t * // Adds an observer to the onNodeChange event using tinyMCE.init\r\n\t\t\t\t * tinyMCE.init({\r\n\t\t\t\t *    ...\r\n\t\t\t\t *    setup : function(ed) {\r\n\t\t\t\t *       ed.onNodeChange.add(function(ed, cm, e) {\r\n\t\t\t\t *           // Activates the link button when the caret is placed in a anchor element\r\n\t\t\t\t *           if (e.nodeName == 'A')\r\n\t\t\t\t *              cm.setActive('link', true);\r\n\t\t\t\t *       });\r\n\t\t\t\t *    }\r\n\t\t\t\t * });\r\n\t\t\t\t */\r\n\t\t\t\t'onNodeChange',\r\n\r\n\t\t\t\t/**\r\n\t\t\t\t * Fires when a new undo level is added to the editor.\r\n\t\t\t\t *\r\n\t\t\t\t * @event onChange\r\n\t\t\t\t * @param {tinymce.Editor} sender Editor instance.\r\n\t\t\t\t * @example\r\n\t\t\t\t * // Adds an observer to the onChange event using tinyMCE.init\r\n\t\t\t\t * tinyMCE.init({\r\n\t\t\t\t *    ...\r\n\t\t\t\t *    setup : function(ed) {\r\n\t\t\t\t * \t  ed.onChange.add(function(ed, l) {\r\n\t\t\t\t * \t\t  console.debug('Editor contents was modified. Contents: ' + l.content);\r\n\t\t\t\t * \t  });\r\n\t\t\t\t *    }\r\n\t\t\t\t * });\r\n\t\t\t\t */\r\n\t\t\t\t'onChange',\r\n\r\n\t\t\t\t/**\r\n\t\t\t\t * Fires before a command gets executed for example \"Bold\".\r\n\t\t\t\t *\r\n\t\t\t\t * @event onBeforeExecCommand\r\n\t\t\t\t * @param {tinymce.Editor} sender Editor instance.\r\n\t\t\t\t * @example\r\n\t\t\t\t * // Adds an observer to the onBeforeExecCommand event using tinyMCE.init\r\n\t\t\t\t * tinyMCE.init({\r\n\t\t\t\t *    ...\r\n\t\t\t\t *    setup : function(ed) {\r\n\t\t\t\t *       ed.onBeforeExecCommand.add(function(ed, cmd, ui, val) {\r\n\t\t\t\t *           console.debug('Command is to be executed: ' + cmd);\r\n\t\t\t\t *       });\r\n\t\t\t\t *    }\r\n\t\t\t\t * });\r\n\t\t\t\t */\r\n\t\t\t\t'onBeforeExecCommand',\r\n\r\n\t\t\t\t/**\r\n\t\t\t\t * Fires after a command is executed for example \"Bold\".\r\n\t\t\t\t *\r\n\t\t\t\t * @event onExecCommand\r\n\t\t\t\t * @param {tinymce.Editor} sender Editor instance.\r\n\t\t\t\t * @example\r\n\t\t\t\t * // Adds an observer to the onExecCommand event using tinyMCE.init\r\n\t\t\t\t * tinyMCE.init({\r\n\t\t\t\t *    ...\r\n\t\t\t\t *    setup : function(ed) {\r\n\t\t\t\t *       ed.onExecCommand.add(function(ed, cmd, ui, val) {\r\n\t\t\t\t *           console.debug('Command was executed: ' + cmd);\r\n\t\t\t\t *       });\r\n\t\t\t\t *    }\r\n\t\t\t\t * });\r\n\t\t\t\t */\r\n\t\t\t\t'onExecCommand',\r\n\r\n\t\t\t\t/**\r\n\t\t\t\t * Fires when the contents is undo:ed.\r\n\t\t\t\t *\r\n\t\t\t\t * @event onUndo\r\n\t\t\t\t * @param {tinymce.Editor} sender Editor instance.\r\n\t\t\t\t * @param {Object} level Undo level object.\r\n\t\t\t\t * @ example\r\n\t\t\t\t * // Adds an observer to the onUndo event using tinyMCE.init\r\n\t\t\t\t * tinyMCE.init({\r\n\t\t\t\t *    ...\r\n\t\t\t\t *    setup : function(ed) {\r\n\t\t\t\t *       ed.onUndo.add(function(ed, level) {\r\n\t\t\t\t *           console.debug('Undo was performed: ' + level.content);\r\n\t\t\t\t *       });\r\n\t\t\t\t *    }\r\n\t\t\t\t * });\r\n\t\t\t\t */\r\n\t\t\t\t'onUndo',\r\n\r\n\t\t\t\t/**\r\n\t\t\t\t * Fires when the contents is redo:ed.\r\n\t\t\t\t *\r\n\t\t\t\t * @event onRedo\r\n\t\t\t\t * @param {tinymce.Editor} sender Editor instance.\r\n\t\t\t\t * @param {Object} level Undo level object.\r\n\t\t\t\t * @example\r\n\t\t\t\t * // Adds an observer to the onRedo event using tinyMCE.init\r\n\t\t\t\t * tinyMCE.init({\r\n\t\t\t\t *    ...\r\n\t\t\t\t *    setup : function(ed) {\r\n\t\t\t\t *       ed.onRedo.add(function(ed, level) {\r\n\t\t\t\t *           console.debug('Redo was performed: ' +level.content);\r\n\t\t\t\t *       });\r\n\t\t\t\t *    }\r\n\t\t\t\t * });\r\n\t\t\t\t */\r\n\t\t\t\t'onRedo',\r\n\r\n\t\t\t\t/**\r\n\t\t\t\t * Fires when visual aids is enabled/disabled.\r\n\t\t\t\t *\r\n\t\t\t\t * @event onVisualAid\r\n\t\t\t\t * @param {tinymce.Editor} sender Editor instance.\r\n\t\t\t\t * @example\r\n\t\t\t\t * // Adds an observer to the onVisualAid event using tinyMCE.init\r\n\t\t\t\t * tinyMCE.init({\r\n\t\t\t\t *    ...\r\n\t\t\t\t *    setup : function(ed) {\r\n\t\t\t\t *       ed.onVisualAid.add(function(ed, e, s) {\r\n\t\t\t\t *           console.debug('onVisualAid event: ' + ed.id + \", State: \" + s);\r\n\t\t\t\t *       });\r\n\t\t\t\t *    }\r\n\t\t\t\t * });\r\n\t\t\t\t */\r\n\t\t\t\t'onVisualAid',\r\n\r\n\t\t\t\t/**\r\n\t\t\t\t * Fires when the progress throbber is shown above the editor.\r\n\t\t\t\t *\r\n\t\t\t\t * @event onSetProgressState\r\n\t\t\t\t * @param {tinymce.Editor} sender Editor instance.\r\n\t\t\t\t * @example\r\n\t\t\t\t * // Adds an observer to the onSetProgressState event using tinyMCE.init\r\n\t\t\t\t * tinyMCE.init({\r\n\t\t\t\t *    ...\r\n\t\t\t\t *    setup : function(ed) {\r\n\t\t\t\t *       ed.onSetProgressState.add(function(ed, b) {\r\n\t\t\t\t *            if (b)\r\n\t\t\t\t *                 console.debug('SHOW!');\r\n\t\t\t\t *            else\r\n\t\t\t\t *                 console.debug('HIDE!');\r\n\t\t\t\t *       });\r\n\t\t\t\t *    }\r\n\t\t\t\t * });\r\n\t\t\t\t */\r\n\t\t\t\t'onSetProgressState'\r\n\t\t\t], function(e) {\r\n\t\t\t\tt[e] = new Dispatcher(t);\r\n\t\t\t});\r\n\r\n\t\t\t/**\r\n\t\t\t * Name/value collection with editor settings.\r\n\t\t\t *\r\n\t\t\t * @property settings\r\n\t\t\t * @type Object\r\n\t\t\t * @example\r\n\t\t\t * // Get the value of the theme setting\r\n\t\t\t * tinyMCE.activeEditor.windowManager.alert(\"You are using the \" + tinyMCE.activeEditor.settings.theme + \" theme\");\r\n\t\t\t */\r\n\t\t\tt.settings = s = extend({\r\n\t\t\t\tid : id,\r\n\t\t\t\tlanguage : 'en',\r\n\t\t\t\tdocs_language : 'en',\r\n\t\t\t\ttheme : 'simple',\r\n\t\t\t\tskin : 'default',\r\n\t\t\t\tdelta_width : 0,\r\n\t\t\t\tdelta_height : 0,\r\n\t\t\t\tpopup_css : '',\r\n\t\t\t\tplugins : '',\r\n\t\t\t\tdocument_base_url : tinymce.documentBaseURL,\r\n\t\t\t\tadd_form_submit_trigger : 1,\r\n\t\t\t\tsubmit_patch : 1,\r\n\t\t\t\tadd_unload_trigger : 1,\r\n\t\t\t\tconvert_urls : 1,\r\n\t\t\t\trelative_urls : 1,\r\n\t\t\t\tremove_script_host : 1,\r\n\t\t\t\ttable_inline_editing : 0,\r\n\t\t\t\tobject_resizing : 1,\r\n\t\t\t\tcleanup : 1,\r\n\t\t\t\taccessibility_focus : 1,\r\n\t\t\t\tcustom_shortcuts : 1,\r\n\t\t\t\tcustom_undo_redo_keyboard_shortcuts : 1,\r\n\t\t\t\tcustom_undo_redo_restore_selection : 1,\r\n\t\t\t\tcustom_undo_redo : 1,\r\n\t\t\t\tdoctype : tinymce.isIE6 ? '<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">' : '<!DOCTYPE>', // Use old doctype on IE 6 to avoid horizontal scroll\r\n\t\t\t\tvisual_table_class : 'mceItemTable',\r\n\t\t\t\tvisual : 1,\r\n\t\t\t\tfont_size_style_values : 'xx-small,x-small,small,medium,large,x-large,xx-large',\r\n\t\t\t\tfont_size_legacy_values : 'xx-small,small,medium,large,x-large,xx-large,300%', // See: http://www.w3.org/TR/CSS2/fonts.html#propdef-font-size\r\n\t\t\t\tapply_source_formatting : 1,\r\n\t\t\t\tdirectionality : 'ltr',\r\n\t\t\t\tforced_root_block : 'p',\r\n\t\t\t\thidden_input : 1,\r\n\t\t\t\tpadd_empty_editor : 1,\r\n\t\t\t\trender_ui : 1,\r\n\t\t\t\tinit_theme : 1,\r\n\t\t\t\tforce_p_newlines : 1,\r\n\t\t\t\tindentation : '30px',\r\n\t\t\t\tkeep_styles : 1,\r\n\t\t\t\tfix_table_elements : 1,\r\n\t\t\t\tinline_styles : 1,\r\n\t\t\t\tconvert_fonts_to_spans : true,\r\n\t\t\t\tindent : 'simple',\r\n\t\t\t\tindent_before : 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,ul,li,area,table,thead,tfoot,tbody,tr',\r\n\t\t\t\tindent_after : 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,ul,li,area,table,thead,tfoot,tbody,tr',\r\n\t\t\t\tvalidate : true,\r\n\t\t\t\tentity_encoding : 'named',\r\n\t\t\t\turl_converter : t.convertURL,\r\n\t\t\t\turl_converter_scope : t,\r\n\t\t\t\tie7_compat : true\r\n\t\t\t}, s);\r\n\r\n\t\t\t/**\r\n\t\t\t * URI object to document configured for the TinyMCE instance.\r\n\t\t\t *\r\n\t\t\t * @property documentBaseURI\r\n\t\t\t * @type tinymce.util.URI\r\n\t\t\t * @example\r\n\t\t\t * // Get relative URL from the location of document_base_url\r\n\t\t\t * tinyMCE.activeEditor.documentBaseURI.toRelative('/somedir/somefile.htm');\r\n\t\t\t *\r\n\t\t\t * // Get absolute URL from the location of document_base_url\r\n\t\t\t * tinyMCE.activeEditor.documentBaseURI.toAbsolute('somefile.htm');\r\n\t\t\t */\r\n\t\t\tt.documentBaseURI = new tinymce.util.URI(s.document_base_url || tinymce.documentBaseURL, {\r\n\t\t\t\tbase_uri : tinyMCE.baseURI\r\n\t\t\t});\r\n\r\n\t\t\t/**\r\n\t\t\t * URI object to current document that holds the TinyMCE editor instance.\r\n\t\t\t *\r\n\t\t\t * @property baseURI\r\n\t\t\t * @type tinymce.util.URI\r\n\t\t\t * @example\r\n\t\t\t * // Get relative URL from the location of the API\r\n\t\t\t * tinyMCE.activeEditor.baseURI.toRelative('/somedir/somefile.htm');\r\n\t\t\t *\r\n\t\t\t * // Get absolute URL from the location of the API\r\n\t\t\t * tinyMCE.activeEditor.baseURI.toAbsolute('somefile.htm');\r\n\t\t\t */\r\n\t\t\tt.baseURI = tinymce.baseURI;\r\n\r\n\t\t\t/**\r\n\t\t\t * Array with CSS files to load into the iframe.\r\n\t\t\t *\r\n\t\t\t * @property contentCSS\r\n\t\t\t * @type Array\r\n\t\t\t */\r\n\t\t\tt.contentCSS = [];\r\n\r\n\t\t\t// Call setup\r\n\t\t\tt.execCallback('setup', t);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Renderes the editor/adds it to the page.\r\n\t\t *\r\n\t\t * @method render\r\n\t\t */\r\n\t\trender : function(nst) {\r\n\t\t\tvar t = this, s = t.settings, id = t.id, sl = tinymce.ScriptLoader;\r\n\r\n\t\t\t// Page is not loaded yet, wait for it\r\n\t\t\tif (!Event.domLoaded) {\r\n\t\t\t\tEvent.add(document, 'init', function() {\r\n\t\t\t\t\tt.render();\r\n\t\t\t\t});\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\ttinyMCE.settings = s;\r\n\r\n\t\t\t// Element not found, then skip initialization\r\n\t\t\tif (!t.getElement())\r\n\t\t\t\treturn;\r\n\r\n\t\t\t// Is a iPad/iPhone and not on iOS5, then skip initialization. We need to sniff\r\n\t\t\t// here since the browser says it has contentEditable support but there is no visible\r\n\t\t\t// caret We will remove this check ones Apple implements full contentEditable support\r\n\t\t\tif (tinymce.isIDevice && !tinymce.isIOS5)\r\n\t\t\t\treturn;\r\n\r\n\t\t\t// Add hidden input for non input elements inside form elements\r\n\t\t\tif (!/TEXTAREA|INPUT/i.test(t.getElement().nodeName) && s.hidden_input && DOM.getParent(id, 'form'))\r\n\t\t\t\tDOM.insertAfter(DOM.create('input', {type : 'hidden', name : id}), id);\r\n\r\n\t\t\t/**\r\n\t\t\t * Window manager reference, use this to open new windows and dialogs.\r\n\t\t\t *\r\n\t\t\t * @property windowManager\r\n\t\t\t * @type tinymce.WindowManager\r\n\t\t\t * @example\r\n\t\t\t * // Shows an alert message\r\n\t\t\t * tinyMCE.activeEditor.windowManager.alert('Hello world!');\r\n\t\t\t *\r\n\t\t\t * // Opens a new dialog with the file.htm file and the size 320x240\r\n\t\t\t * // It also adds a custom parameter this can be retrieved by using tinyMCEPopup.getWindowArg inside the dialog.\r\n\t\t\t * tinyMCE.activeEditor.windowManager.open({\r\n\t\t\t *    url : 'file.htm',\r\n\t\t\t *    width : 320,\r\n\t\t\t *    height : 240\r\n\t\t\t * }, {\r\n\t\t\t *    custom_param : 1\r\n\t\t\t * });\r\n\t\t\t */\r\n\t\t\tif (tinymce.WindowManager)\r\n\t\t\t\tt.windowManager = new tinymce.WindowManager(t);\r\n\r\n\t\t\tif (s.encoding == 'xml') {\r\n\t\t\t\tt.onGetContent.add(function(ed, o) {\r\n\t\t\t\t\tif (o.save)\r\n\t\t\t\t\t\to.content = DOM.encode(o.content);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tif (s.add_form_submit_trigger) {\r\n\t\t\t\tt.onSubmit.addToTop(function() {\r\n\t\t\t\t\tif (t.initialized) {\r\n\t\t\t\t\t\tt.save();\r\n\t\t\t\t\t\tt.isNotDirty = 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tif (s.add_unload_trigger) {\r\n\t\t\t\tt._beforeUnload = tinyMCE.onBeforeUnload.add(function() {\r\n\t\t\t\t\tif (t.initialized && !t.destroyed && !t.isHidden())\r\n\t\t\t\t\t\tt.save({format : 'raw', no_events : true});\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\ttinymce.addUnload(t.destroy, t);\r\n\r\n\t\t\tif (s.submit_patch) {\r\n\t\t\t\tt.onBeforeRenderUI.add(function() {\r\n\t\t\t\t\tvar n = t.getElement().form;\r\n\r\n\t\t\t\t\tif (!n)\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t// Already patched\r\n\t\t\t\t\tif (n._mceOldSubmit)\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t// Check page uses id=\"submit\" or name=\"submit\" for it's submit button\r\n\t\t\t\t\tif (!n.submit.nodeType && !n.submit.length) {\r\n\t\t\t\t\t\tt.formElement = n;\r\n\t\t\t\t\t\tn._mceOldSubmit = n.submit;\r\n\t\t\t\t\t\tn.submit = function() {\r\n\t\t\t\t\t\t\t// Save all instances\r\n\t\t\t\t\t\t\ttinymce.triggerSave();\r\n\t\t\t\t\t\t\tt.isNotDirty = 1;\r\n\r\n\t\t\t\t\t\t\treturn t.formElement._mceOldSubmit(t.formElement);\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tn = null;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// Load scripts\r\n\t\t\tfunction loadScripts() {\r\n\t\t\t\tif (s.language && s.language_load !== false)\r\n\t\t\t\t\tsl.add(tinymce.baseURL + '/langs/' + s.language + '.js');\r\n\r\n\t\t\t\tif (s.theme && s.theme.charAt(0) != '-' && !ThemeManager.urls[s.theme])\r\n\t\t\t\t\tThemeManager.load(s.theme, 'themes/' + s.theme + '/editor_template' + tinymce.suffix + '.js');\r\n\r\n\t\t\t\teach(explode(s.plugins), function(p) {\r\n\t\t\t\t\tif (p &&!PluginManager.urls[p]) {\r\n\t\t\t\t\t\tif (p.charAt(0) == '-') {\r\n\t\t\t\t\t\t\tp = p.substr(1, p.length);\r\n\t\t\t\t\t\t\tvar dependencies = PluginManager.dependencies(p);\r\n\t\t\t\t\t\t\teach(dependencies, function(dep) {\r\n\t\t\t\t\t\t\t\tvar defaultSettings = {prefix:'plugins/', resource: dep, suffix:'/editor_plugin' + tinymce.suffix + '.js'};\r\n\t\t\t\t\t\t\t\tvar dep = PluginManager.createUrl(defaultSettings, dep);\r\n\t\t\t\t\t\t\t\tPluginManager.load(dep.resource, dep);\r\n\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// Skip safari plugin, since it is removed as of 3.3b1\r\n\t\t\t\t\t\t\tif (p == 'safari') {\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tPluginManager.load(p, {prefix:'plugins/', resource: p, suffix:'/editor_plugin' + tinymce.suffix + '.js'});\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// Init when que is loaded\r\n\t\t\t\tsl.loadQueue(function() {\r\n\t\t\t\t\tif (!t.removed)\r\n\t\t\t\t\t\tt.init();\r\n\t\t\t\t});\r\n\t\t\t};\r\n\r\n\t\t\tloadScripts();\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Initializes the editor this will be called automatically when\r\n\t\t * all plugins/themes and language packs are loaded by the rendered method.\r\n\t\t * This method will setup the iframe and create the theme and plugin instances.\r\n\t\t *\r\n\t\t * @method init\r\n\t\t */\r\n\t\tinit : function() {\r\n\t\t\tvar n, t = this, s = t.settings, w, h, e = t.getElement(), o, ti, u, bi, bc, re, i, initializedPlugins = [];\r\n\r\n\t\t\ttinymce.add(t);\r\n\r\n\t\t\ts.aria_label = s.aria_label || DOM.getAttrib(e, 'aria-label', t.getLang('aria.rich_text_area'));\r\n\r\n\t\t\t/**\r\n\t\t\t * Reference to the theme instance that was used to generate the UI.\r\n\t\t\t *\r\n\t\t\t * @property theme\r\n\t\t\t * @type tinymce.Theme\r\n\t\t\t * @example\r\n\t\t\t * // Executes a method on the theme directly\r\n\t\t\t * tinyMCE.activeEditor.theme.someMethod();\r\n\t\t\t */\r\n\t\t\tif (s.theme) {\r\n\t\t\t\ts.theme = s.theme.replace(/-/, '');\r\n\t\t\t\to = ThemeManager.get(s.theme);\r\n\t\t\t\tt.theme = new o();\r\n\r\n\t\t\t\tif (t.theme.init && s.init_theme)\r\n\t\t\t\t\tt.theme.init(t, ThemeManager.urls[s.theme] || tinymce.documentBaseURL.replace(/\\/$/, ''));\r\n\t\t\t}\r\n\t\t\tfunction initPlugin(p) {\r\n\t\t\t\tvar c = PluginManager.get(p), u = PluginManager.urls[p] || tinymce.documentBaseURL.replace(/\\/$/, ''), po;\r\n\t\t\t\tif (c && tinymce.inArray(initializedPlugins,p) === -1) {\r\n\t\t\t\t\teach(PluginManager.dependencies(p), function(dep){\r\n\t\t\t\t\t\tinitPlugin(dep);\r\n\t\t\t\t\t});\r\n\t\t\t\t\tpo = new c(t, u);\r\n\r\n\t\t\t\t\tt.plugins[p] = po;\r\n\r\n\t\t\t\t\tif (po.init) {\r\n\t\t\t\t\t\tpo.init(t, u);\r\n\t\t\t\t\t\tinitializedPlugins.push(p);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Create all plugins\r\n\t\t\teach(explode(s.plugins.replace(/\\-/g, '')), initPlugin);\r\n\r\n\t\t\t// Setup popup CSS path(s)\r\n\t\t\tif (s.popup_css !== false) {\r\n\t\t\t\tif (s.popup_css)\r\n\t\t\t\t\ts.popup_css = t.documentBaseURI.toAbsolute(s.popup_css);\r\n\t\t\t\telse\r\n\t\t\t\t\ts.popup_css = t.baseURI.toAbsolute(\"themes/\" + s.theme + \"/skins/\" + s.skin + \"/dialog.css\");\r\n\t\t\t}\r\n\r\n\t\t\tif (s.popup_css_add)\r\n\t\t\t\ts.popup_css += ',' + t.documentBaseURI.toAbsolute(s.popup_css_add);\r\n\r\n\t\t\t/**\r\n\t\t\t * Control manager instance for the editor. Will enables you to create new UI elements and change their states etc.\r\n\t\t\t *\r\n\t\t\t * @property controlManager\r\n\t\t\t * @type tinymce.ControlManager\r\n\t\t\t * @example\r\n\t\t\t * // Disables the bold button\r\n\t\t\t * tinyMCE.activeEditor.controlManager.setDisabled('bold', true);\r\n\t\t\t */\r\n\t\t\tt.controlManager = new tinymce.ControlManager(t);\r\n\r\n\t\t\tif (s.custom_undo_redo) {\r\n\t\t\t\tt.onBeforeExecCommand.add(function(ed, cmd, ui, val, a) {\r\n\t\t\t\t\tif (cmd != 'Undo' && cmd != 'Redo' && cmd != 'mceRepaint' && (!a || !a.skip_undo))\r\n\t\t\t\t\t\tt.undoManager.beforeChange();\r\n\t\t\t\t});\r\n\r\n\t\t\t\tt.onExecCommand.add(function(ed, cmd, ui, val, a) {\r\n\t\t\t\t\tif (cmd != 'Undo' && cmd != 'Redo' && cmd != 'mceRepaint' && (!a || !a.skip_undo))\r\n\t\t\t\t\t\tt.undoManager.add();\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tt.onExecCommand.add(function(ed, c) {\r\n\t\t\t\t// Don't refresh the select lists until caret move\r\n\t\t\t\tif (!/^(FontName|FontSize)$/.test(c))\r\n\t\t\t\t\tt.nodeChanged();\r\n\t\t\t});\r\n\r\n\t\t\t// Remove ghost selections on images and tables in Gecko\r\n\t\t\tif (isGecko) {\r\n\t\t\t\tfunction repaint(a, o) {\r\n\t\t\t\t\tif (!o || !o.initial)\r\n\t\t\t\t\t\tt.execCommand('mceRepaint');\r\n\t\t\t\t};\r\n\r\n\t\t\t\tt.onUndo.add(repaint);\r\n\t\t\t\tt.onRedo.add(repaint);\r\n\t\t\t\tt.onSetContent.add(repaint);\r\n\t\t\t}\r\n\r\n\t\t\t// Enables users to override the control factory\r\n\t\t\tt.onBeforeRenderUI.dispatch(t, t.controlManager);\r\n\r\n\t\t\t// Measure box\r\n\t\t\tif (s.render_ui) {\r\n\t\t\t\tw = s.width || e.style.width || e.offsetWidth;\r\n\t\t\t\th = s.height || e.style.height || e.offsetHeight;\r\n\t\t\t\tt.orgDisplay = e.style.display;\r\n\t\t\t\tre = /^[0-9\\.]+(|px)$/i;\r\n\r\n\t\t\t\tif (re.test('' + w))\r\n\t\t\t\t\tw = Math.max(parseInt(w) + (o.deltaWidth || 0), 100);\r\n\r\n\t\t\t\tif (re.test('' + h))\r\n\t\t\t\t\th = Math.max(parseInt(h) + (o.deltaHeight || 0), 100);\r\n\r\n\t\t\t\t// Render UI\r\n\t\t\t\to = t.theme.renderUI({\r\n\t\t\t\t\ttargetNode : e,\r\n\t\t\t\t\twidth : w,\r\n\t\t\t\t\theight : h,\r\n\t\t\t\t\tdeltaWidth : s.delta_width,\r\n\t\t\t\t\tdeltaHeight : s.delta_height\r\n\t\t\t\t});\r\n\r\n\t\t\t\tt.editorContainer = o.editorContainer;\r\n\t\t\t}\r\n\r\n\t\t\t// #ifdef contentEditable\r\n\r\n\t\t\t// Content editable mode ends here\r\n\t\t\tif (s.content_editable) {\r\n\t\t\t\te = n = o = null; // Fix IE leak\r\n\t\t\t\treturn t.setupContentEditable();\r\n\t\t\t}\r\n\r\n\t\t\t// #endif\r\n\r\n\t\t\t// User specified a document.domain value\r\n\t\t\tif (document.domain && location.hostname != document.domain)\r\n\t\t\t\ttinymce.relaxedDomain = document.domain;\r\n\r\n\t\t\t// Resize editor\r\n\t\t\tDOM.setStyles(o.sizeContainer || o.editorContainer, {\r\n\t\t\t\twidth : w,\r\n\t\t\t\theight : h\r\n\t\t\t});\r\n\r\n\t\t\t// Load specified content CSS last\r\n\t\t\tif (s.content_css) {\r\n\t\t\t\ttinymce.each(explode(s.content_css), function(u) {\r\n\t\t\t\t\tt.contentCSS.push(t.documentBaseURI.toAbsolute(u));\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\th = (o.iframeHeight || h) + (typeof(h) == 'number' ? (o.deltaHeight || 0) : '');\r\n\t\t\tif (h < 100)\r\n\t\t\t\th = 100;\r\n\r\n\t\t\tt.iframeHTML = s.doctype + '<html><head xmlns=\"http://www.w3.org/1999/xhtml\">';\r\n\r\n\t\t\t// We only need to override paths if we have to\r\n\t\t\t// IE has a bug where it remove site absolute urls to relative ones if this is specified\r\n\t\t\tif (s.document_base_url != tinymce.documentBaseURL)\r\n\t\t\t\tt.iframeHTML += '<base href=\"' + t.documentBaseURI.getURI() + '\" />';\r\n\r\n\t\t\t// IE8 doesn't support carets behind images setting ie7_compat would force IE8+ to run in IE7 compat mode.\r\n\t\t\tif (s.ie7_compat)\r\n\t\t\t\tt.iframeHTML += '<meta http-equiv=\"X-UA-Compatible\" content=\"IE=7\" />';\r\n\t\t\telse\r\n\t\t\t\tt.iframeHTML += '<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />';\r\n\r\n\t\t\tt.iframeHTML += '<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />';\r\n\r\n\t\t\t// Load the CSS by injecting them into the HTML this will reduce \"flicker\"\r\n\t\t\tfor (i = 0; i < t.contentCSS.length; i++) {\r\n\t\t\t\tt.iframeHTML += '<link type=\"text/css\" rel=\"stylesheet\" href=\"' + t.contentCSS[i] + '\" />';\r\n\t\t\t}\r\n\r\n\t\t\tbi = s.body_id || 'tinymce';\r\n\t\t\tif (bi.indexOf('=') != -1) {\r\n\t\t\t\tbi = t.getParam('body_id', '', 'hash');\r\n\t\t\t\tbi = bi[t.id] || bi;\r\n\t\t\t}\r\n\r\n\t\t\tbc = s.body_class || '';\r\n\t\t\tif (bc.indexOf('=') != -1) {\r\n\t\t\t\tbc = t.getParam('body_class', '', 'hash');\r\n\t\t\t\tbc = bc[t.id] || '';\r\n\t\t\t}\r\n\r\n\t\t\tt.iframeHTML += '</head><body id=\"' + bi + '\" class=\"mceContentBody ' + bc + '\"><br></body></html>';\r\n\r\n\t\t\t// Domain relaxing enabled, then set document domain\r\n\t\t\tif (tinymce.relaxedDomain && (isIE || (tinymce.isOpera && parseFloat(opera.version()) < 11))) {\r\n\t\t\t\t// We need to write the contents here in IE since multiple writes messes up refresh button and back button\r\n\t\t\t\tu = 'javascript:(function(){document.open();document.domain=\"' + document.domain + '\";var ed = window.parent.tinyMCE.get(\"' + t.id + '\");document.write(ed.iframeHTML);document.close();ed.setupIframe();})()';\r\n\t\t\t}\r\n\r\n\t\t\t// Create iframe\r\n\t\t\t// TODO: ACC add the appropriate description on this.\r\n\t\t\tn = DOM.add(o.iframeContainer, 'iframe', {\r\n\t\t\t\tid : t.id + \"_ifr\",\r\n\t\t\t\tsrc : u || 'javascript:\"\"', // Workaround for HTTPS warning in IE6/7\r\n\t\t\t\tframeBorder : '0',\r\n\t\t\t\tallowTransparency : \"true\",\r\n\t\t\t\ttitle : s.aria_label,\r\n\t\t\t\tstyle : {\r\n\t\t\t\t\twidth : '100%',\r\n\t\t\t\t\theight : h,\r\n\t\t\t\t\tdisplay : 'block' // Important for Gecko to render the iframe correctly\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tt.contentAreaContainer = o.iframeContainer;\r\n\t\t\tDOM.get(o.editorContainer).style.display = t.orgDisplay;\r\n\t\t\tDOM.get(t.id).style.display = 'none';\r\n\t\t\tDOM.setAttrib(t.id, 'aria-hidden', true);\r\n\r\n\t\t\tif (!tinymce.relaxedDomain || !u)\r\n\t\t\t\tt.setupIframe();\r\n\r\n\t\t\te = n = o = null; // Cleanup\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * This method get called by the init method ones the iframe is loaded.\r\n\t\t * It will fill the iframe with contents, setups DOM and selection objects for the iframe.\r\n\t\t * This method should not be called directly.\r\n\t\t *\r\n\t\t * @method setupIframe\r\n\t\t */\r\n\t\tsetupIframe : function() {\r\n\t\t\tvar t = this, s = t.settings, e = DOM.get(t.id), d = t.getDoc(), h, b;\r\n\r\n\t\t\t// Setup iframe body\r\n\t\t\tif (!isIE || !tinymce.relaxedDomain) {\r\n\t\t\t\td.open();\r\n\t\t\t\td.write(t.iframeHTML);\r\n\t\t\t\td.close();\r\n\r\n\t\t\t\tif (tinymce.relaxedDomain)\r\n\t\t\t\t\td.domain = tinymce.relaxedDomain;\r\n\t\t\t}\r\n\r\n\t\t\t// It will not steal focus while setting contentEditable\r\n\t\t\tb = t.getBody();\r\n\t\t\tb.disabled = true;\r\n\r\n\t\t\tif (!s.readonly)\r\n\t\t\t\tb.contentEditable = true;\r\n\r\n\t\t\tb.disabled = false;\r\n\r\n\t\t\t/**\r\n\t\t\t * Schema instance, enables you to validate elements and it's children.\r\n\t\t\t *\r\n\t\t\t * @property schema\r\n\t\t\t * @type tinymce.html.Schema\r\n\t\t\t */\r\n\t\t\tt.schema = new tinymce.html.Schema(s);\r\n\r\n\t\t\t/**\r\n\t\t\t * DOM instance for the editor.\r\n\t\t\t *\r\n\t\t\t * @property dom\r\n\t\t\t * @type tinymce.dom.DOMUtils\r\n\t\t\t * @example\r\n\t\t\t * // Adds a class to all paragraphs within the editor\r\n\t\t\t * tinyMCE.activeEditor.dom.addClass(tinyMCE.activeEditor.dom.select('p'), 'someclass');\r\n\t\t\t */\r\n\t\t\tt.dom = new tinymce.dom.DOMUtils(t.getDoc(), {\r\n\t\t\t\tkeep_values : true,\r\n\t\t\t\turl_converter : t.convertURL,\r\n\t\t\t\turl_converter_scope : t,\r\n\t\t\t\thex_colors : s.force_hex_style_colors,\r\n\t\t\t\tclass_filter : s.class_filter,\r\n\t\t\t\tupdate_styles : 1,\r\n\t\t\t\tfix_ie_paragraphs : 1,\r\n\t\t\t\tschema : t.schema\r\n\t\t\t});\r\n\r\n\t\t\t/**\r\n\t\t\t * HTML parser will be used when contents is inserted into the editor.\r\n\t\t\t *\r\n\t\t\t * @property parser\r\n\t\t\t * @type tinymce.html.DomParser\r\n\t\t\t */\r\n\t\t\tt.parser = new tinymce.html.DomParser(s, t.schema);\r\n\r\n\t\t\t// Force anchor names closed, unless the setting \"allow_html_in_named_anchor\" is explicitly included.\r\n\t\t\tif (!t.settings.allow_html_in_named_anchor) {\r\n\t\t\t\tt.parser.addAttributeFilter('name', function(nodes, name) {\r\n\t\t\t\t\tvar i = nodes.length, sibling, prevSibling, parent, node;\r\n\r\n\t\t\t\t\twhile (i--) {\r\n\t\t\t\t\t\tnode = nodes[i];\r\n\t\t\t\t\t\tif (node.name === 'a' && node.firstChild) {\r\n\t\t\t\t\t\t\tparent = node.parent;\r\n\r\n\t\t\t\t\t\t\t// Move children after current node\r\n\t\t\t\t\t\t\tsibling = node.lastChild;\r\n\t\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\t\tprevSibling = sibling.prev;\r\n\t\t\t\t\t\t\t\tparent.insert(sibling, node);\r\n\t\t\t\t\t\t\t\tsibling = prevSibling;\r\n\t\t\t\t\t\t\t} while (sibling);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// Convert src and href into data-mce-src, data-mce-href and data-mce-style\r\n\t\t\tt.parser.addAttributeFilter('src,href,style', function(nodes, name) {\r\n\t\t\t\tvar i = nodes.length, node, dom = t.dom, value, internalName;\r\n\r\n\t\t\t\twhile (i--) {\r\n\t\t\t\t\tnode = nodes[i];\r\n\t\t\t\t\tvalue = node.attr(name);\r\n\t\t\t\t\tinternalName = 'data-mce-' + name;\r\n\r\n\t\t\t\t\t// Add internal attribute if we need to we don't on a refresh of the document\r\n\t\t\t\t\tif (!node.attributes.map[internalName]) {\r\n\t\t\t\t\t\tif (name === \"style\")\r\n\t\t\t\t\t\t\tnode.attr(internalName, dom.serializeStyle(dom.parseStyle(value), node.name));\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tnode.attr(internalName, t.convertURL(value, name, node.name));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\t// Keep scripts from executing\r\n\t\t\tt.parser.addNodeFilter('script', function(nodes, name) {\r\n\t\t\t\tvar i = nodes.length, node;\r\n\r\n\t\t\t\twhile (i--) {\r\n\t\t\t\t\tnode = nodes[i];\r\n\t\t\t\t\tnode.attr('type', 'mce-' + (node.attr('type') || 'text/javascript'));\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tt.parser.addNodeFilter('#cdata', function(nodes, name) {\r\n\t\t\t\tvar i = nodes.length, node;\r\n\r\n\t\t\t\twhile (i--) {\r\n\t\t\t\t\tnode = nodes[i];\r\n\t\t\t\t\tnode.type = 8;\r\n\t\t\t\t\tnode.name = '#comment';\r\n\t\t\t\t\tnode.value = '[CDATA[' + node.value + ']]';\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tt.parser.addNodeFilter('p,h1,h2,h3,h4,h5,h6,div', function(nodes, name) {\r\n\t\t\t\tvar i = nodes.length, node, nonEmptyElements = t.schema.getNonEmptyElements();\r\n\r\n\t\t\t\twhile (i--) {\r\n\t\t\t\t\tnode = nodes[i];\r\n\r\n\t\t\t\t\tif (node.isEmpty(nonEmptyElements))\r\n\t\t\t\t\t\tnode.empty().append(new tinymce.html.Node('br', 1)).shortEnded = true;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\t/**\r\n\t\t\t * DOM serializer for the editor. Will be used when contents is extracted from the editor.\r\n\t\t\t *\r\n\t\t\t * @property serializer\r\n\t\t\t * @type tinymce.dom.Serializer\r\n\t\t\t * @example\r\n\t\t\t * // Serializes the first paragraph in the editor into a string\r\n\t\t\t * tinyMCE.activeEditor.serializer.serialize(tinyMCE.activeEditor.dom.select('p')[0]);\r\n\t\t\t */\r\n\t\t\tt.serializer = new tinymce.dom.Serializer(s, t.dom, t.schema);\r\n\r\n\t\t\t/**\r\n\t\t\t * Selection instance for the editor.\r\n\t\t\t *\r\n\t\t\t * @property selection\r\n\t\t\t * @type tinymce.dom.Selection\r\n\t\t\t * @example\r\n\t\t\t * // Sets some contents to the current selection in the editor\r\n\t\t\t * tinyMCE.activeEditor.selection.setContent('Some contents');\r\n\t\t\t *\r\n\t\t\t * // Gets the current selection\r\n\t\t\t * alert(tinyMCE.activeEditor.selection.getContent());\r\n\t\t\t *\r\n\t\t\t * // Selects the first paragraph found\r\n\t\t\t * tinyMCE.activeEditor.selection.select(tinyMCE.activeEditor.dom.select('p')[0]);\r\n\t\t\t */\r\n\t\t\tt.selection = new tinymce.dom.Selection(t.dom, t.getWin(), t.serializer);\r\n\r\n\t\t\t/**\r\n\t\t\t * Formatter instance.\r\n\t\t\t *\r\n\t\t\t * @property formatter\r\n\t\t\t * @type tinymce.Formatter\r\n\t\t\t */\r\n\t\t\tt.formatter = new tinymce.Formatter(this);\r\n\r\n\t\t\t// Register default formats\r\n\t\t\tt.formatter.register({\r\n\t\t\t\talignleft : [\r\n\t\t\t\t\t{selector : 'p,h1,h2,h3,h4,h5,h6,td,th,div,ul,ol,li', styles : {textAlign : 'left'}},\r\n\t\t\t\t\t{selector : 'img,table', collapsed : false, styles : {'float' : 'left'}}\r\n\t\t\t\t],\r\n\r\n\t\t\t\taligncenter : [\r\n\t\t\t\t\t{selector : 'p,h1,h2,h3,h4,h5,h6,td,th,div,ul,ol,li', styles : {textAlign : 'center'}},\r\n\t\t\t\t\t{selector : 'img', collapsed : false, styles : {display : 'block', marginLeft : 'auto', marginRight : 'auto'}},\r\n\t\t\t\t\t{selector : 'table', collapsed : false, styles : {marginLeft : 'auto', marginRight : 'auto'}}\r\n\t\t\t\t],\r\n\r\n\t\t\t\talignright : [\r\n\t\t\t\t\t{selector : 'p,h1,h2,h3,h4,h5,h6,td,th,div,ul,ol,li', styles : {textAlign : 'right'}},\r\n\t\t\t\t\t{selector : 'img,table', collapsed : false, styles : {'float' : 'right'}}\r\n\t\t\t\t],\r\n\r\n\t\t\t\talignfull : [\r\n\t\t\t\t\t{selector : 'p,h1,h2,h3,h4,h5,h6,td,th,div,ul,ol,li', styles : {textAlign : 'justify'}}\r\n\t\t\t\t],\r\n\r\n\t\t\t\tbold : [\r\n\t\t\t\t\t{inline : 'strong', remove : 'all'},\r\n\t\t\t\t\t{inline : 'span', styles : {fontWeight : 'bold'}},\r\n\t\t\t\t\t{inline : 'b', remove : 'all'}\r\n\t\t\t\t],\r\n\r\n\t\t\t\titalic : [\r\n\t\t\t\t\t{inline : 'em', remove : 'all'},\r\n\t\t\t\t\t{inline : 'span', styles : {fontStyle : 'italic'}},\r\n\t\t\t\t\t{inline : 'i', remove : 'all'}\r\n\t\t\t\t],\r\n\r\n\t\t\t\tunderline : [\r\n\t\t\t\t\t{inline : 'span', styles : {textDecoration : 'underline'}, exact : true},\r\n\t\t\t\t\t{inline : 'u', remove : 'all'}\r\n\t\t\t\t],\r\n\r\n\t\t\t\tstrikethrough : [\r\n\t\t\t\t\t{inline : 'span', styles : {textDecoration : 'line-through'}, exact : true},\r\n\t\t\t\t\t{inline : 'strike', remove : 'all'}\r\n\t\t\t\t],\r\n\r\n\t\t\t\tforecolor : {inline : 'span', styles : {color : '%value'}, wrap_links : false},\r\n\t\t\t\thilitecolor : {inline : 'span', styles : {backgroundColor : '%value'}, wrap_links : false},\r\n\t\t\t\tfontname : {inline : 'span', styles : {fontFamily : '%value'}},\r\n\t\t\t\tfontsize : {inline : 'span', styles : {fontSize : '%value'}},\r\n\t\t\t\tfontsize_class : {inline : 'span', attributes : {'class' : '%value'}},\r\n\t\t\t\tblockquote : {block : 'blockquote', wrapper : 1, remove : 'all'},\r\n\t\t\t\tsubscript : {inline : 'sub'},\r\n\t\t\t\tsuperscript : {inline : 'sup'},\r\n\r\n\t\t\t\tlink : {inline : 'a', selector : 'a', remove : 'all', split : true, deep : true,\r\n\t\t\t\t\tonmatch : function(node) {\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tonformat : function(elm, fmt, vars) {\r\n\t\t\t\t\t\teach(vars, function(value, key) {\r\n\t\t\t\t\t\t\tt.dom.setAttrib(elm, key, value);\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\r\n\t\t\t\tremoveformat : [\r\n\t\t\t\t\t{selector : 'b,strong,em,i,font,u,strike', remove : 'all', split : true, expand : false, block_expand : true, deep : true},\r\n\t\t\t\t\t{selector : 'span', attributes : ['style', 'class'], remove : 'empty', split : true, expand : false, deep : true},\r\n\t\t\t\t\t{selector : '*', attributes : ['style', 'class'], split : false, expand : false, deep : true}\r\n\t\t\t\t]\r\n\t\t\t});\r\n\r\n\t\t\t// Register default block formats\r\n\t\t\teach('p h1 h2 h3 h4 h5 h6 div address pre div code dt dd samp'.split(/\\s/), function(name) {\r\n\t\t\t\tt.formatter.register(name, {block : name, remove : 'all'});\r\n\t\t\t});\r\n\r\n\t\t\t// Register user defined formats\r\n\t\t\tt.formatter.register(t.settings.formats);\r\n\r\n\t\t\t/**\r\n\t\t\t * Undo manager instance, responsible for handling undo levels.\r\n\t\t\t *\r\n\t\t\t * @property undoManager\r\n\t\t\t * @type tinymce.UndoManager\r\n\t\t\t * @example\r\n\t\t\t * // Undoes the last modification to the editor\r\n\t\t\t * tinyMCE.activeEditor.undoManager.undo();\r\n\t\t\t */\r\n\t\t\tt.undoManager = new tinymce.UndoManager(t);\r\n\r\n\t\t\t// Pass through\r\n\t\t\tt.undoManager.onAdd.add(function(um, l) {\r\n\t\t\t\tif (um.hasUndo())\r\n\t\t\t\t\treturn t.onChange.dispatch(t, l, um);\r\n\t\t\t});\r\n\r\n\t\t\tt.undoManager.onUndo.add(function(um, l) {\r\n\t\t\t\treturn t.onUndo.dispatch(t, l, um);\r\n\t\t\t});\r\n\r\n\t\t\tt.undoManager.onRedo.add(function(um, l) {\r\n\t\t\t\treturn t.onRedo.dispatch(t, l, um);\r\n\t\t\t});\r\n\r\n\t\t\tt.forceBlocks = new tinymce.ForceBlocks(t, {\r\n\t\t\t\tforced_root_block : s.forced_root_block\r\n\t\t\t});\r\n\r\n\t\t\tt.editorCommands = new tinymce.EditorCommands(t);\r\n\r\n\t\t\t// Pass through\r\n\t\t\tt.serializer.onPreProcess.add(function(se, o) {\r\n\t\t\t\treturn t.onPreProcess.dispatch(t, o, se);\r\n\t\t\t});\r\n\r\n\t\t\tt.serializer.onPostProcess.add(function(se, o) {\r\n\t\t\t\treturn t.onPostProcess.dispatch(t, o, se);\r\n\t\t\t});\r\n\r\n\t\t\tt.onPreInit.dispatch(t);\r\n\r\n\t\t\tif (!s.gecko_spellcheck)\r\n\t\t\t\tt.getBody().spellcheck = 0;\r\n\r\n\t\t\tif (!s.readonly)\r\n\t\t\t\tt._addEvents();\r\n\r\n\t\t\tt.controlManager.onPostRender.dispatch(t, t.controlManager);\r\n\t\t\tt.onPostRender.dispatch(t);\r\n\r\n\t\t\tt.quirks = new tinymce.util.Quirks(this);\r\n\r\n\t\t\tif (s.directionality)\r\n\t\t\t\tt.getBody().dir = s.directionality;\r\n\r\n\t\t\tif (s.nowrap)\r\n\t\t\t\tt.getBody().style.whiteSpace = \"nowrap\";\r\n\r\n\t\t\tif (s.handle_node_change_callback) {\r\n\t\t\t\tt.onNodeChange.add(function(ed, cm, n) {\r\n\t\t\t\t\tt.execCallback('handle_node_change_callback', t.id, n, -1, -1, true, t.selection.isCollapsed());\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tif (s.save_callback) {\r\n\t\t\t\tt.onSaveContent.add(function(ed, o) {\r\n\t\t\t\t\tvar h = t.execCallback('save_callback', t.id, o.content, t.getBody());\r\n\r\n\t\t\t\t\tif (h)\r\n\t\t\t\t\t\to.content = h;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tif (s.onchange_callback) {\r\n\t\t\t\tt.onChange.add(function(ed, l) {\r\n\t\t\t\t\tt.execCallback('onchange_callback', t, l);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tif (s.protect) {\r\n\t\t\t\tt.onBeforeSetContent.add(function(ed, o) {\r\n\t\t\t\t\tif (s.protect) {\r\n\t\t\t\t\t\teach(s.protect, function(pattern) {\r\n\t\t\t\t\t\t\to.content = o.content.replace(pattern, function(str) {\r\n\t\t\t\t\t\t\t\treturn '<!--mce:protected ' + escape(str) + '-->';\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tif (s.convert_newlines_to_brs) {\r\n\t\t\t\tt.onBeforeSetContent.add(function(ed, o) {\r\n\t\t\t\t\tif (o.initial)\r\n\t\t\t\t\t\to.content = o.content.replace(/\\r?\\n/g, '<br />');\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tif (s.preformatted) {\r\n\t\t\t\tt.onPostProcess.add(function(ed, o) {\r\n\t\t\t\t\to.content = o.content.replace(/^\\s*<pre.*?>/, '');\r\n\t\t\t\t\to.content = o.content.replace(/<\\/pre>\\s*$/, '');\r\n\r\n\t\t\t\t\tif (o.set)\r\n\t\t\t\t\t\to.content = '<pre class=\"mceItemHidden\">' + o.content + '</pre>';\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tif (s.verify_css_classes) {\r\n\t\t\t\tt.serializer.attribValueFilter = function(n, v) {\r\n\t\t\t\t\tvar s, cl;\r\n\r\n\t\t\t\t\tif (n == 'class') {\r\n\t\t\t\t\t\t// Build regexp for classes\r\n\t\t\t\t\t\tif (!t.classesRE) {\r\n\t\t\t\t\t\t\tcl = t.dom.getClasses();\r\n\r\n\t\t\t\t\t\t\tif (cl.length > 0) {\r\n\t\t\t\t\t\t\t\ts = '';\r\n\r\n\t\t\t\t\t\t\t\teach (cl, function(o) {\r\n\t\t\t\t\t\t\t\t\ts += (s ? '|' : '') + o['class'];\r\n\t\t\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t\t\tt.classesRE = new RegExp('(' + s + ')', 'gi');\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn !t.classesRE || /(\\bmceItem\\w+\\b|\\bmceTemp\\w+\\b)/g.test(v) || t.classesRE.test(v) ? v : '';\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn v;\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\tif (s.cleanup_callback) {\r\n\t\t\t\tt.onBeforeSetContent.add(function(ed, o) {\r\n\t\t\t\t\to.content = t.execCallback('cleanup_callback', 'insert_to_editor', o.content, o);\r\n\t\t\t\t});\r\n\r\n\t\t\t\tt.onPreProcess.add(function(ed, o) {\r\n\t\t\t\t\tif (o.set)\r\n\t\t\t\t\t\tt.execCallback('cleanup_callback', 'insert_to_editor_dom', o.node, o);\r\n\r\n\t\t\t\t\tif (o.get)\r\n\t\t\t\t\t\tt.execCallback('cleanup_callback', 'get_from_editor_dom', o.node, o);\r\n\t\t\t\t});\r\n\r\n\t\t\t\tt.onPostProcess.add(function(ed, o) {\r\n\t\t\t\t\tif (o.set)\r\n\t\t\t\t\t\to.content = t.execCallback('cleanup_callback', 'insert_to_editor', o.content, o);\r\n\r\n\t\t\t\t\tif (o.get)\r\n\t\t\t\t\t\to.content = t.execCallback('cleanup_callback', 'get_from_editor', o.content, o);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tif (s.save_callback) {\r\n\t\t\t\tt.onGetContent.add(function(ed, o) {\r\n\t\t\t\t\tif (o.save)\r\n\t\t\t\t\t\to.content = t.execCallback('save_callback', t.id, o.content, t.getBody());\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tif (s.handle_event_callback) {\r\n\t\t\t\tt.onEvent.add(function(ed, e, o) {\r\n\t\t\t\t\tif (t.execCallback('handle_event_callback', e, ed, o) === false)\r\n\t\t\t\t\t\tEvent.cancel(e);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// Add visual aids when new contents is added\r\n\t\t\tt.onSetContent.add(function() {\r\n\t\t\t\tt.addVisual(t.getBody());\r\n\t\t\t});\r\n\r\n\t\t\t// Remove empty contents\r\n\t\t\tif (s.padd_empty_editor) {\r\n\t\t\t\tt.onPostProcess.add(function(ed, o) {\r\n\t\t\t\t\to.content = o.content.replace(/^(<p[^>]*>(&nbsp;|&#160;|\\s|\\u00a0|)<\\/p>[\\r\\n]*|<br \\/>[\\r\\n]*)$/, '');\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tif (isGecko) {\r\n\t\t\t\t// Fix gecko link bug, when a link is placed at the end of block elements there is\r\n\t\t\t\t// no way to move the caret behind the link. This fix adds a bogus br element after the link\r\n\t\t\t\tfunction fixLinks(ed, o) {\r\n\t\t\t\t\teach(ed.dom.select('a'), function(n) {\r\n\t\t\t\t\t\tvar pn = n.parentNode;\r\n\r\n\t\t\t\t\t\tif (ed.dom.isBlock(pn) && pn.lastChild === n)\r\n\t\t\t\t\t\t\ted.dom.add(pn, 'br', {'data-mce-bogus' : 1});\r\n\t\t\t\t\t});\r\n\t\t\t\t};\r\n\r\n\t\t\t\tt.onExecCommand.add(function(ed, cmd) {\r\n\t\t\t\t\tif (cmd === 'CreateLink')\r\n\t\t\t\t\t\tfixLinks(ed);\r\n\t\t\t\t});\r\n\r\n\t\t\t\tt.onSetContent.add(t.selection.onSetContent.add(fixLinks));\r\n\t\t\t}\r\n\r\n\t\t\tt.load({initial : true, format : 'html'});\r\n\t\t\tt.startContent = t.getContent({format : 'raw'});\r\n\t\t\tt.undoManager.add();\r\n\t\t\tt.initialized = true;\r\n\r\n\t\t\tt.onInit.dispatch(t);\r\n\t\t\tt.execCallback('setupcontent_callback', t.id, t.getBody(), t.getDoc());\r\n\t\t\tt.execCallback('init_instance_callback', t);\r\n\t\t\tt.focus(true);\r\n\t\t\tt.nodeChanged({initial : 1});\r\n\r\n\t\t\t// Load specified content CSS last\r\n\t\t\teach(t.contentCSS, function(u) {\r\n\t\t\t\tt.dom.loadCSS(u);\r\n\t\t\t});\r\n\r\n\t\t\t// Handle auto focus\r\n\t\t\tif (s.auto_focus) {\r\n\t\t\t\tsetTimeout(function () {\r\n\t\t\t\t\tvar ed = tinymce.get(s.auto_focus);\r\n\r\n\t\t\t\t\ted.selection.select(ed.getBody(), 1);\r\n\t\t\t\t\ted.selection.collapse(1);\r\n\t\t\t\t\ted.getBody().focus();\r\n\t\t\t\t\ted.getWin().focus();\r\n\t\t\t\t}, 100);\r\n\t\t\t}\r\n\r\n\t\t\te = null;\r\n\t\t},\r\n\r\n\t\t// #ifdef contentEditable\r\n\r\n\t\t/**\r\n\t\t * Sets up the contentEditable mode.\r\n\t\t *\r\n\t\t * @method setupContentEditable\r\n\t\t */\r\n\t\tsetupContentEditable : function() {\r\n\t\t\tvar t = this, s = t.settings, e = t.getElement();\r\n\r\n\t\t\tt.contentDocument = s.content_document || document;\r\n\t\t\tt.contentWindow = s.content_window || window;\r\n\t\t\tt.bodyElement = e;\r\n\r\n\t\t\t// Prevent leak in IE\r\n\t\t\ts.content_document = s.content_window = null;\r\n\r\n\t\t\tDOM.hide(e);\r\n\t\t\te.contentEditable = t.getParam('content_editable_state', true);\r\n\t\t\tDOM.show(e);\r\n\r\n\t\t\tif (!s.gecko_spellcheck)\r\n\t\t\t\tt.getDoc().body.spellcheck = 0;\r\n\r\n\t\t\t// Setup objects\r\n\t\t\tt.dom = new tinymce.dom.DOMUtils(t.getDoc(), {\r\n\t\t\t\tkeep_values : true,\r\n\t\t\t\turl_converter : t.convertURL,\r\n\t\t\t\turl_converter_scope : t,\r\n\t\t\t\thex_colors : s.force_hex_style_colors,\r\n\t\t\t\tclass_filter : s.class_filter,\r\n\t\t\t\troot_element : t.id,\r\n\t\t\t\tfix_ie_paragraphs : 1,\r\n\t\t\t\tupdate_styles : 1\r\n\t\t\t});\r\n\r\n\t\t\tt.serializer = new tinymce.dom.Serializer(s, t.dom, schema);\r\n\r\n\t\t\tt.selection = new tinymce.dom.Selection(t.dom, t.getWin(), t.serializer);\r\n\t\t\tt.forceBlocks = new tinymce.ForceBlocks(t, {\r\n\t\t\t\tforced_root_block : s.forced_root_block\r\n\t\t\t});\r\n\r\n\t\t\tt.editorCommands = new tinymce.EditorCommands(t);\r\n\r\n\t\t\t// Pass through\r\n\t\t\tt.serializer.onPreProcess.add(function(se, o) {\r\n\t\t\t\treturn t.onPreProcess.dispatch(t, o, se);\r\n\t\t\t});\r\n\r\n\t\t\tt.serializer.onPostProcess.add(function(se, o) {\r\n\t\t\t\treturn t.onPostProcess.dispatch(t, o, se);\r\n\t\t\t});\r\n\r\n\t\t\tt.onPreInit.dispatch(t);\r\n\t\t\tt._addEvents();\r\n\r\n\t\t\tt.controlManager.onPostRender.dispatch(t, t.controlManager);\r\n\t\t\tt.onPostRender.dispatch(t);\r\n\r\n\t\t\tt.onSetContent.add(function() {\r\n\t\t\t\tt.addVisual(t.getBody());\r\n\t\t\t});\r\n\r\n\t\t\t//t.load({initial : true, format : (s.cleanup_on_startup ? 'html' : 'raw')});\r\n\t\t\tt.startContent = t.getContent({format : 'raw'});\r\n\t\t\tt.undoManager.add({initial : true});\r\n\t\t\tt.initialized = true;\r\n\r\n\t\t\tt.onInit.dispatch(t);\r\n\t\t\tt.focus(true);\r\n\t\t\tt.nodeChanged({initial : 1});\r\n\r\n\t\t\t// Load specified content CSS last\r\n\t\t\tif (s.content_css) {\r\n\t\t\t\teach(explode(s.content_css), function(u) {\r\n\t\t\t\t\tt.dom.loadCSS(t.documentBaseURI.toAbsolute(u));\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tif (isIE) {\r\n\t\t\t\t// Store away selection\r\n\t\t\t\tt.dom.bind(t.getElement(), 'beforedeactivate', function() {\r\n\t\t\t\t\tt.lastSelectionBookmark = t.selection.getBookmark(1);\r\n\t\t\t\t});\r\n\r\n\t\t\t\tt.onBeforeExecCommand.add(function(ed, cmd, ui, val, o) {\r\n\t\t\t\t\tif (!DOM.getParent(ed.selection.getStart(), function(n) {return n == ed.getBody();}))\r\n\t\t\t\t\t\to.terminate = 1;\r\n\r\n\t\t\t\t\tif (!DOM.getParent(ed.selection.getEnd(), function(n) {return n == ed.getBody();}))\r\n\t\t\t\t\t\to.terminate = 1;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\te = null; // Cleanup\r\n\t\t},\r\n\r\n\t\t// #endif\r\n\r\n\t\t/**\r\n\t\t * Focuses/activates the editor. This will set this editor as the activeEditor in the tinymce collection\r\n\t\t * it will also place DOM focus inside the editor.\r\n\t\t *\r\n\t\t * @method focus\r\n\t\t * @param {Boolean} sf Skip DOM focus. Just set is as the active editor.\r\n\t\t */\r\n\t\tfocus : function(sf) {\r\n\t\t\tvar oed, t = this, selection = t.selection, ce = t.settings.content_editable, ieRng, controlElm, doc = t.getDoc();\r\n\r\n\t\t\tif (!sf) {\r\n\t\t\t\t// Get selected control element\r\n\t\t\t\tieRng = selection.getRng();\r\n\t\t\t\tif (ieRng.item) {\r\n\t\t\t\t\tcontrolElm = ieRng.item(0);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tt._refreshContentEditable();\r\n\t\t\t\tselection.normalize();\r\n\r\n\t\t\t\t// Is not content editable\r\n\t\t\t\tif (!ce)\r\n\t\t\t\t\tt.getWin().focus();\r\n\r\n\t\t\t\t// Focus the body as well since it's contentEditable\r\n\t\t\t\tif (tinymce.isGecko) {\r\n\t\t\t\t\tt.getBody().focus();\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Restore selected control element\r\n\t\t\t\t// This is needed when for example an image is selected within a\r\n\t\t\t\t// layer a call to focus will then remove the control selection\r\n\t\t\t\tif (controlElm && controlElm.ownerDocument == doc) {\r\n\t\t\t\t\tieRng = doc.body.createControlRange();\r\n\t\t\t\t\tieRng.addElement(controlElm);\r\n\t\t\t\t\tieRng.select();\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// #ifdef contentEditable\r\n\r\n\t\t\t\t// Content editable mode ends here\r\n\t\t\t\tif (ce) {\r\n\t\t\t\t\tif (tinymce.isWebKit)\r\n\t\t\t\t\t\tt.getWin().focus();\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tif (tinymce.isIE)\r\n\t\t\t\t\t\t\tt.getElement().setActive();\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tt.getElement().focus();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// #endif\r\n\t\t\t}\r\n\r\n\t\t\tif (tinymce.activeEditor != t) {\r\n\t\t\t\tif ((oed = tinymce.activeEditor) != null)\r\n\t\t\t\t\toed.onDeactivate.dispatch(oed, t);\r\n\r\n\t\t\t\tt.onActivate.dispatch(t, oed);\r\n\t\t\t}\r\n\r\n\t\t\ttinymce._setActive(t);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Executes a legacy callback. This method is useful to call old 2.x option callbacks.\r\n\t\t * There new event model is a better way to add callback so this method might be removed in the future.\r\n\t\t *\r\n\t\t * @method execCallback\r\n\t\t * @param {String} n Name of the callback to execute.\r\n\t\t * @return {Object} Return value passed from callback function.\r\n\t\t */\r\n\t\texecCallback : function(n) {\r\n\t\t\tvar t = this, f = t.settings[n], s;\r\n\r\n\t\t\tif (!f)\r\n\t\t\t\treturn;\r\n\r\n\t\t\t// Look through lookup\r\n\t\t\tif (t.callbackLookup && (s = t.callbackLookup[n])) {\r\n\t\t\t\tf = s.func;\r\n\t\t\t\ts = s.scope;\r\n\t\t\t}\r\n\r\n\t\t\tif (is(f, 'string')) {\r\n\t\t\t\ts = f.replace(/\\.\\w+$/, '');\r\n\t\t\t\ts = s ? tinymce.resolve(s) : 0;\r\n\t\t\t\tf = tinymce.resolve(f);\r\n\t\t\t\tt.callbackLookup = t.callbackLookup || {};\r\n\t\t\t\tt.callbackLookup[n] = {func : f, scope : s};\r\n\t\t\t}\r\n\r\n\t\t\treturn f.apply(s || t, Array.prototype.slice.call(arguments, 1));\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Translates the specified string by replacing variables with language pack items it will also check if there is\r\n\t\t * a key mathcin the input.\r\n\t\t *\r\n\t\t * @method translate\r\n\t\t * @param {String} s String to translate by the language pack data.\r\n\t\t * @return {String} Translated string.\r\n\t\t */\r\n\t\ttranslate : function(s) {\r\n\t\t\tvar c = this.settings.language || 'en', i18n = tinymce.i18n;\r\n\r\n\t\t\tif (!s)\r\n\t\t\t\treturn '';\r\n\r\n\t\t\treturn i18n[c + '.' + s] || s.replace(/{\\#([^}]+)\\}/g, function(a, b) {\r\n\t\t\t\treturn i18n[c + '.' + b] || '{#' + b + '}';\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns a language pack item by name/key.\r\n\t\t *\r\n\t\t * @method getLang\r\n\t\t * @param {String} n Name/key to get from the language pack.\r\n\t\t * @param {String} dv Optional default value to retrieve.\r\n\t\t */\r\n\t\tgetLang : function(n, dv) {\r\n\t\t\treturn tinymce.i18n[(this.settings.language || 'en') + '.' + n] || (is(dv) ? dv : '{#' + n + '}');\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns a configuration parameter by name.\r\n\t\t *\r\n\t\t * @method getParam\r\n\t\t * @param {String} n Configruation parameter to retrieve.\r\n\t\t * @param {String} dv Optional default value to return.\r\n\t\t * @param {String} ty Optional type parameter.\r\n\t\t * @return {String} Configuration parameter value or default value.\r\n\t\t * @example\r\n\t\t * // Returns a specific config value from the currently active editor\r\n\t\t * var someval = tinyMCE.activeEditor.getParam('myvalue');\r\n\t\t *\r\n\t\t * // Returns a specific config value from a specific editor instance by id\r\n\t\t * var someval2 = tinyMCE.get('my_editor').getParam('myvalue');\r\n\t\t */\r\n\t\tgetParam : function(n, dv, ty) {\r\n\t\t\tvar tr = tinymce.trim, v = is(this.settings[n]) ? this.settings[n] : dv, o;\r\n\r\n\t\t\tif (ty === 'hash') {\r\n\t\t\t\to = {};\r\n\r\n\t\t\t\tif (is(v, 'string')) {\r\n\t\t\t\t\teach(v.indexOf('=') > 0 ? v.split(/[;,](?![^=;,]*(?:[;,]|$))/) : v.split(','), function(v) {\r\n\t\t\t\t\t\tv = v.split('=');\r\n\r\n\t\t\t\t\t\tif (v.length > 1)\r\n\t\t\t\t\t\t\to[tr(v[0])] = tr(v[1]);\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\to[tr(v[0])] = tr(v);\r\n\t\t\t\t\t});\r\n\t\t\t\t} else\r\n\t\t\t\t\to = v;\r\n\r\n\t\t\t\treturn o;\r\n\t\t\t}\r\n\r\n\t\t\treturn v;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Distpaches out a onNodeChange event to all observers. This method should be called when you\r\n\t\t * need to update the UI states or element path etc.\r\n\t\t *\r\n\t\t * @method nodeChanged\r\n\t\t * @param {Object} o Optional object to pass along for the node changed event.\r\n\t\t */\r\n\t\tnodeChanged : function(o) {\r\n\t\t\tvar t = this, s = t.selection, n = s.getStart() || t.getBody();\r\n\r\n\t\t\t// Fix for bug #1896577 it seems that this can not be fired while the editor is loading\r\n\t\t\tif (t.initialized) {\r\n\t\t\t\to = o || {};\r\n\t\t\t\tn = isIE && n.ownerDocument != t.getDoc() ? t.getBody() : n; // Fix for IE initial state\r\n\r\n\t\t\t\t// Get parents and add them to object\r\n\t\t\t\to.parents = [];\r\n\t\t\t\tt.dom.getParent(n, function(node) {\r\n\t\t\t\t\tif (node.nodeName == 'BODY')\r\n\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\to.parents.push(node);\r\n\t\t\t\t});\r\n\r\n\t\t\t\tt.onNodeChange.dispatch(\r\n\t\t\t\t\tt,\r\n\t\t\t\t\to ? o.controlManager || t.controlManager : t.controlManager,\r\n\t\t\t\t\tn,\r\n\t\t\t\t\ts.isCollapsed(),\r\n\t\t\t\t\to\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Adds a button that later gets created by the ControlManager. This is a shorter and easier method\r\n\t\t * of adding buttons without the need to deal with the ControlManager directly. But it's also less\r\n\t\t * powerfull if you need more control use the ControlManagers factory methods instead.\r\n\t\t *\r\n\t\t * @method addButton\r\n\t\t * @param {String} n Button name to add.\r\n\t\t * @param {Object} s Settings object with title, cmd etc.\r\n\t\t * @example\r\n\t\t * // Adds a custom button to the editor and when a user clicks the button it will open\r\n\t\t * // an alert box with the selected contents as plain text.\r\n\t\t * tinyMCE.init({\r\n\t\t *    ...\r\n\t\t *\r\n\t\t *    theme_advanced_buttons1 : 'example,..'\r\n\t\t *\r\n\t\t *    setup : function(ed) {\r\n\t\t *       // Register example button\r\n\t\t *       ed.addButton('example', {\r\n\t\t *          title : 'example.desc',\r\n\t\t *          image : '../jscripts/tiny_mce/plugins/example/img/example.gif',\r\n\t\t *          onclick : function() {\r\n\t\t *             ed.windowManager.alert('Hello world!! Selection: ' + ed.selection.getContent({format : 'text'}));\r\n\t\t *          }\r\n\t\t *       });\r\n\t\t *    }\r\n\t\t * });\r\n\t\t */\r\n\t\taddButton : function(n, s) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\tt.buttons = t.buttons || {};\r\n\t\t\tt.buttons[n] = s;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Adds a custom command to the editor, you can also override existing commands with this method.\r\n\t\t * The command that you add can be executed with execCommand.\r\n\t\t *\r\n\t\t * @method addCommand\r\n\t\t * @param {String} name Command name to add/override.\r\n\t\t * @param {addCommandCallback} callback Function to execute when the command occurs.\r\n\t\t * @param {Object} scope Optional scope to execute the function in.\r\n\t\t * @example\r\n\t\t * // Adds a custom command that later can be executed using execCommand\r\n\t\t * tinyMCE.init({\r\n\t\t *    ...\r\n\t\t *\r\n\t\t *    setup : function(ed) {\r\n\t\t *       // Register example command\r\n\t\t *       ed.addCommand('mycommand', function(ui, v) {\r\n\t\t *          ed.windowManager.alert('Hello world!! Selection: ' + ed.selection.getContent({format : 'text'}));\r\n\t\t *       });\r\n\t\t *    }\r\n\t\t * });\r\n\t\t */\r\n\t\taddCommand : function(name, callback, scope) {\r\n\t\t\t/**\r\n\t\t\t * Callback function that gets called when a command is executed.\r\n\t\t\t *\r\n\t\t\t * @callback addCommandCallback\r\n\t\t\t * @param {Boolean} ui Display UI state true/false.\r\n\t\t\t * @param {Object} value Optional value for command.\r\n\t\t\t * @return {Boolean} True/false state if the command was handled or not.\r\n\t\t\t */\r\n\t\t\tthis.execCommands[name] = {func : callback, scope : scope || this};\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Adds a custom query state command to the editor, you can also override existing commands with this method.\r\n\t\t * The command that you add can be executed with queryCommandState function.\r\n\t\t *\r\n\t\t * @method addQueryStateHandler\r\n\t\t * @param {String} name Command name to add/override.\r\n\t\t * @param {addQueryStateHandlerCallback} callback Function to execute when the command state retrival occurs.\r\n\t\t * @param {Object} scope Optional scope to execute the function in.\r\n\t\t */\r\n\t\taddQueryStateHandler : function(name, callback, scope) {\r\n\t\t\t/**\r\n\t\t\t * Callback function that gets called when a queryCommandState is executed.\r\n\t\t\t *\r\n\t\t\t * @callback addQueryStateHandlerCallback\r\n\t\t\t * @return {Boolean} True/false state if the command is enabled or not like is it bold.\r\n\t\t\t */\r\n\t\t\tthis.queryStateCommands[name] = {func : callback, scope : scope || this};\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Adds a custom query value command to the editor, you can also override existing commands with this method.\r\n\t\t * The command that you add can be executed with queryCommandValue function.\r\n\t\t *\r\n\t\t * @method addQueryValueHandler\r\n\t\t * @param {String} name Command name to add/override.\r\n\t\t * @param {addQueryValueHandlerCallback} callback Function to execute when the command value retrival occurs.\r\n\t\t * @param {Object} scope Optional scope to execute the function in.\r\n\t\t */\r\n\t\taddQueryValueHandler : function(name, callback, scope) {\r\n\t\t\t/**\r\n\t\t\t * Callback function that gets called when a queryCommandValue is executed.\r\n\t\t\t *\r\n\t\t\t * @callback addQueryValueHandlerCallback\r\n\t\t\t * @return {Object} Value of the command or undefined.\r\n\t\t\t */\r\n\t\t\tthis.queryValueCommands[name] = {func : callback, scope : scope || this};\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Adds a keyboard shortcut for some command or function.\r\n\t\t *\r\n\t\t * @method addShortcut\r\n\t\t * @param {String} pa Shortcut pattern. Like for example: ctrl+alt+o.\r\n\t\t * @param {String} desc Text description for the command.\r\n\t\t * @param {String/Function} cmd_func Command name string or function to execute when the key is pressed.\r\n\t\t * @param {Object} sc Optional scope to execute the function in.\r\n\t\t * @return {Boolean} true/false state if the shortcut was added or not.\r\n\t\t */\r\n\t\taddShortcut : function(pa, desc, cmd_func, sc) {\r\n\t\t\tvar t = this, c;\r\n\r\n\t\t\tif (!t.settings.custom_shortcuts)\r\n\t\t\t\treturn false;\r\n\r\n\t\t\tt.shortcuts = t.shortcuts || {};\r\n\r\n\t\t\tif (is(cmd_func, 'string')) {\r\n\t\t\t\tc = cmd_func;\r\n\r\n\t\t\t\tcmd_func = function() {\r\n\t\t\t\t\tt.execCommand(c, false, null);\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\tif (is(cmd_func, 'object')) {\r\n\t\t\t\tc = cmd_func;\r\n\r\n\t\t\t\tcmd_func = function() {\r\n\t\t\t\t\tt.execCommand(c[0], c[1], c[2]);\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\teach(explode(pa), function(pa) {\r\n\t\t\t\tvar o = {\r\n\t\t\t\t\tfunc : cmd_func,\r\n\t\t\t\t\tscope : sc || this,\r\n\t\t\t\t\tdesc : desc,\r\n\t\t\t\t\talt : false,\r\n\t\t\t\t\tctrl : false,\r\n\t\t\t\t\tshift : false\r\n\t\t\t\t};\r\n\r\n\t\t\t\teach(explode(pa, '+'), function(v) {\r\n\t\t\t\t\tswitch (v) {\r\n\t\t\t\t\t\tcase 'alt':\r\n\t\t\t\t\t\tcase 'ctrl':\r\n\t\t\t\t\t\tcase 'shift':\r\n\t\t\t\t\t\t\to[v] = true;\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\to.charCode = v.charCodeAt(0);\r\n\t\t\t\t\t\t\to.keyCode = v.toUpperCase().charCodeAt(0);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\tt.shortcuts[(o.ctrl ? 'ctrl' : '') + ',' + (o.alt ? 'alt' : '') + ',' + (o.shift ? 'shift' : '') + ',' + o.keyCode] = o;\r\n\t\t\t});\r\n\r\n\t\t\treturn true;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Executes a command on the current instance. These commands can be TinyMCE internal commands prefixed with \"mce\" or\r\n\t\t * they can be build in browser commands such as \"Bold\". A compleate list of browser commands is available on MSDN or Mozilla.org.\r\n\t\t * This function will dispatch the execCommand function on each plugin, theme or the execcommand_callback option if none of these\r\n\t\t * return true it will handle the command as a internal browser command.\r\n\t\t *\r\n\t\t * @method execCommand\r\n\t\t * @param {String} cmd Command name to execute, for example mceLink or Bold.\r\n\t\t * @param {Boolean} ui True/false state if a UI (dialog) should be presented or not.\r\n\t\t * @param {mixed} val Optional command value, this can be anything.\r\n\t\t * @param {Object} a Optional arguments object.\r\n\t\t * @return {Boolean} True/false if the command was executed or not.\r\n\t\t */\r\n\t\texecCommand : function(cmd, ui, val, a) {\r\n\t\t\tvar t = this, s = 0, o, st;\r\n\r\n\t\t\tif (!/^(mceAddUndoLevel|mceEndUndoLevel|mceBeginUndoLevel|mceRepaint|SelectAll)$/.test(cmd) && (!a || !a.skip_focus))\r\n\t\t\t\tt.focus();\r\n\r\n\t\t\to = {};\r\n\t\t\tt.onBeforeExecCommand.dispatch(t, cmd, ui, val, o);\r\n\t\t\tif (o.terminate)\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t// Command callback\r\n\t\t\tif (t.execCallback('execcommand_callback', t.id, t.selection.getNode(), cmd, ui, val)) {\r\n\t\t\t\tt.onExecCommand.dispatch(t, cmd, ui, val, a);\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\t// Registred commands\r\n\t\t\tif (o = t.execCommands[cmd]) {\r\n\t\t\t\tst = o.func.call(o.scope, ui, val);\r\n\r\n\t\t\t\t// Fall through on true\r\n\t\t\t\tif (st !== true) {\r\n\t\t\t\t\tt.onExecCommand.dispatch(t, cmd, ui, val, a);\r\n\t\t\t\t\treturn st;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Plugin commands\r\n\t\t\teach(t.plugins, function(p) {\r\n\t\t\t\tif (p.execCommand && p.execCommand(cmd, ui, val)) {\r\n\t\t\t\t\tt.onExecCommand.dispatch(t, cmd, ui, val, a);\r\n\t\t\t\t\ts = 1;\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tif (s)\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t// Theme commands\r\n\t\t\tif (t.theme && t.theme.execCommand && t.theme.execCommand(cmd, ui, val)) {\r\n\t\t\t\tt.onExecCommand.dispatch(t, cmd, ui, val, a);\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\t// Editor commands\r\n\t\t\tif (t.editorCommands.execCommand(cmd, ui, val)) {\r\n\t\t\t\tt.onExecCommand.dispatch(t, cmd, ui, val, a);\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\t// Browser commands\r\n\t\t\tt.getDoc().execCommand(cmd, ui, val);\r\n\t\t\tt.onExecCommand.dispatch(t, cmd, ui, val, a);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns a command specific state, for example if bold is enabled or not.\r\n\t\t *\r\n\t\t * @method queryCommandState\r\n\t\t * @param {string} cmd Command to query state from.\r\n\t\t * @return {Boolean} Command specific state, for example if bold is enabled or not.\r\n\t\t */\r\n\t\tqueryCommandState : function(cmd) {\r\n\t\t\tvar t = this, o, s;\r\n\r\n\t\t\t// Is hidden then return undefined\r\n\t\t\tif (t._isHidden())\r\n\t\t\t\treturn;\r\n\r\n\t\t\t// Registred commands\r\n\t\t\tif (o = t.queryStateCommands[cmd]) {\r\n\t\t\t\ts = o.func.call(o.scope);\r\n\r\n\t\t\t\t// Fall though on true\r\n\t\t\t\tif (s !== true)\r\n\t\t\t\t\treturn s;\r\n\t\t\t}\r\n\r\n\t\t\t// Registred commands\r\n\t\t\to = t.editorCommands.queryCommandState(cmd);\r\n\t\t\tif (o !== -1)\r\n\t\t\t\treturn o;\r\n\r\n\t\t\t// Browser commands\r\n\t\t\ttry {\r\n\t\t\t\treturn this.getDoc().queryCommandState(cmd);\r\n\t\t\t} catch (ex) {\r\n\t\t\t\t// Fails sometimes see bug: 1896577\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns a command specific value, for example the current font size.\r\n\t\t *\r\n\t\t * @method queryCommandValue\r\n\t\t * @param {string} c Command to query value from.\r\n\t\t * @return {Object} Command specific value, for example the current font size.\r\n\t\t */\r\n\t\tqueryCommandValue : function(c) {\r\n\t\t\tvar t = this, o, s;\r\n\r\n\t\t\t// Is hidden then return undefined\r\n\t\t\tif (t._isHidden())\r\n\t\t\t\treturn;\r\n\r\n\t\t\t// Registred commands\r\n\t\t\tif (o = t.queryValueCommands[c]) {\r\n\t\t\t\ts = o.func.call(o.scope);\r\n\r\n\t\t\t\t// Fall though on true\r\n\t\t\t\tif (s !== true)\r\n\t\t\t\t\treturn s;\r\n\t\t\t}\r\n\r\n\t\t\t// Registred commands\r\n\t\t\to = t.editorCommands.queryCommandValue(c);\r\n\t\t\tif (is(o))\r\n\t\t\t\treturn o;\r\n\r\n\t\t\t// Browser commands\r\n\t\t\ttry {\r\n\t\t\t\treturn this.getDoc().queryCommandValue(c);\r\n\t\t\t} catch (ex) {\r\n\t\t\t\t// Fails sometimes see bug: 1896577\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Shows the editor and hides any textarea/div that the editor is supposed to replace.\r\n\t\t *\r\n\t\t * @method show\r\n\t\t */\r\n\t\tshow : function() {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\tDOM.show(t.getContainer());\r\n\t\t\tDOM.hide(t.id);\r\n\t\t\tt.load();\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Hides the editor and shows any textarea/div that the editor is supposed to replace.\r\n\t\t *\r\n\t\t * @method hide\r\n\t\t */\r\n\t\thide : function() {\r\n\t\t\tvar t = this, d = t.getDoc();\r\n\r\n\t\t\t// Fixed bug where IE has a blinking cursor left from the editor\r\n\t\t\tif (isIE && d)\r\n\t\t\t\td.execCommand('SelectAll');\r\n\r\n\t\t\t// We must save before we hide so Safari doesn't crash\r\n\t\t\tt.save();\r\n\t\t\tDOM.hide(t.getContainer());\r\n\t\t\tDOM.setStyle(t.id, 'display', t.orgDisplay);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns true/false if the editor is hidden or not.\r\n\t\t *\r\n\t\t * @method isHidden\r\n\t\t * @return {Boolean} True/false if the editor is hidden or not.\r\n\t\t */\r\n\t\tisHidden : function() {\r\n\t\t\treturn !DOM.isHidden(this.id);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Sets the progress state, this will display a throbber/progess for the editor.\r\n\t\t * This is ideal for asycronous operations like an AJAX save call.\r\n\t\t *\r\n\t\t * @method setProgressState\r\n\t\t * @param {Boolean} b Boolean state if the progress should be shown or hidden.\r\n\t\t * @param {Number} ti Optional time to wait before the progress gets shown.\r\n\t\t * @param {Object} o Optional object to pass to the progress observers.\r\n\t\t * @return {Boolean} Same as the input state.\r\n\t\t * @example\r\n\t\t * // Show progress for the active editor\r\n\t\t * tinyMCE.activeEditor.setProgressState(true);\r\n\t\t *\r\n\t\t * // Hide progress for the active editor\r\n\t\t * tinyMCE.activeEditor.setProgressState(false);\r\n\t\t *\r\n\t\t * // Show progress after 3 seconds\r\n\t\t * tinyMCE.activeEditor.setProgressState(true, 3000);\r\n\t\t */\r\n\t\tsetProgressState : function(b, ti, o) {\r\n\t\t\tthis.onSetProgressState.dispatch(this, b, ti, o);\r\n\r\n\t\t\treturn b;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Loads contents from the textarea or div element that got converted into an editor instance.\r\n\t\t * This method will move the contents from that textarea or div into the editor by using setContent\r\n\t\t * so all events etc that method has will get dispatched as well.\r\n\t\t *\r\n\t\t * @method load\r\n\t\t * @param {Object} o Optional content object, this gets passed around through the whole load process.\r\n\t\t * @return {String} HTML string that got set into the editor.\r\n\t\t */\r\n\t\tload : function(o) {\r\n\t\t\tvar t = this, e = t.getElement(), h;\r\n\r\n\t\t\tif (e) {\r\n\t\t\t\to = o || {};\r\n\t\t\t\to.load = true;\r\n\r\n\t\t\t\t// Double encode existing entities in the value\r\n\t\t\t\th = t.setContent(is(e.value) ? e.value : e.innerHTML, o);\r\n\t\t\t\to.element = e;\r\n\r\n\t\t\t\tif (!o.no_events)\r\n\t\t\t\t\tt.onLoadContent.dispatch(t, o);\r\n\r\n\t\t\t\to.element = e = null;\r\n\r\n\t\t\t\treturn h;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Saves the contents from a editor out to the textarea or div element that got converted into an editor instance.\r\n\t\t * This method will move the HTML contents from the editor into that textarea or div by getContent\r\n\t\t * so all events etc that method has will get dispatched as well.\r\n\t\t *\r\n\t\t * @method save\r\n\t\t * @param {Object} o Optional content object, this gets passed around through the whole save process.\r\n\t\t * @return {String} HTML string that got set into the textarea/div.\r\n\t\t */\r\n\t\tsave : function(o) {\r\n\t\t\tvar t = this, e = t.getElement(), h, f;\r\n\r\n\t\t\tif (!e || !t.initialized)\r\n\t\t\t\treturn;\r\n\r\n\t\t\to = o || {};\r\n\t\t\to.save = true;\r\n\r\n\t\t\t// Add undo level will trigger onchange event\r\n\t\t\tif (!o.no_events) {\r\n\t\t\t\tt.undoManager.typing = false;\r\n\t\t\t\tt.undoManager.add();\r\n\t\t\t}\r\n\r\n\t\t\to.element = e;\r\n\t\t\th = o.content = t.getContent(o);\r\n\r\n\t\t\tif (!o.no_events)\r\n\t\t\t\tt.onSaveContent.dispatch(t, o);\r\n\r\n\t\t\th = o.content;\r\n\r\n\t\t\tif (!/TEXTAREA|INPUT/i.test(e.nodeName)) {\r\n\t\t\t\te.innerHTML = h;\r\n\r\n\t\t\t\t// Update hidden form element\r\n\t\t\t\tif (f = DOM.getParent(t.id, 'form')) {\r\n\t\t\t\t\teach(f.elements, function(e) {\r\n\t\t\t\t\t\tif (e.name == t.id) {\r\n\t\t\t\t\t\t\te.value = h;\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t} else\r\n\t\t\t\te.value = h;\r\n\r\n\t\t\to.element = e = null;\r\n\r\n\t\t\treturn h;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Sets the specified content to the editor instance, this will cleanup the content before it gets set using\r\n\t\t * the different cleanup rules options.\r\n\t\t *\r\n\t\t * @method setContent\r\n\t\t * @param {String} content Content to set to editor, normally HTML contents but can be other formats as well.\r\n\t\t * @param {Object} args Optional content object, this gets passed around through the whole set process.\r\n\t\t * @return {String} HTML string that got set into the editor.\r\n\t\t * @example\r\n\t\t * // Sets the HTML contents of the activeEditor editor\r\n\t\t * tinyMCE.activeEditor.setContent('<span>some</span> html');\r\n\t\t *\r\n\t\t * // Sets the raw contents of the activeEditor editor\r\n\t\t * tinyMCE.activeEditor.setContent('<span>some</span> html', {format : 'raw'});\r\n\t\t *\r\n\t\t * // Sets the content of a specific editor (my_editor in this example)\r\n\t\t * tinyMCE.get('my_editor').setContent(data);\r\n\t\t *\r\n\t\t * // Sets the bbcode contents of the activeEditor editor if the bbcode plugin was added\r\n\t\t * tinyMCE.activeEditor.setContent('[b]some[/b] html', {format : 'bbcode'});\r\n\t\t */\r\n\t\tsetContent : function(content, args) {\r\n\t\t\tvar self = this, rootNode, body = self.getBody(), forcedRootBlockName;\r\n\r\n\t\t\t// Setup args object\r\n\t\t\targs = args || {};\r\n\t\t\targs.format = args.format || 'html';\r\n\t\t\targs.set = true;\r\n\t\t\targs.content = content;\r\n\r\n\t\t\t// Do preprocessing\r\n\t\t\tif (!args.no_events)\r\n\t\t\t\tself.onBeforeSetContent.dispatch(self, args);\r\n\r\n\t\t\tcontent = args.content;\r\n\r\n\t\t\t// Padd empty content in Gecko and Safari. Commands will otherwise fail on the content\r\n\t\t\t// It will also be impossible to place the caret in the editor unless there is a BR element present\r\n\t\t\tif (!tinymce.isIE && (content.length === 0 || /^\\s+$/.test(content))) {\r\n\t\t\t\tforcedRootBlockName = self.settings.forced_root_block;\r\n\t\t\t\tif (forcedRootBlockName)\r\n\t\t\t\t\tcontent = '<' + forcedRootBlockName + '><br data-mce-bogus=\"1\"></' + forcedRootBlockName + '>';\r\n\t\t\t\telse\r\n\t\t\t\t\tcontent = '<br data-mce-bogus=\"1\">';\r\n\r\n\t\t\t\tbody.innerHTML = content;\r\n\t\t\t\tself.selection.select(body, true);\r\n\t\t\t\tself.selection.collapse(true);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// Parse and serialize the html\r\n\t\t\tif (args.format !== 'raw') {\r\n\t\t\t\tcontent = new tinymce.html.Serializer({}, self.schema).serialize(\r\n\t\t\t\t\tself.parser.parse(content)\r\n\t\t\t\t);\r\n\t\t\t}\r\n\r\n\t\t\t// Set the new cleaned contents to the editor\r\n\t\t\targs.content = tinymce.trim(content);\r\n\t\t\tself.dom.setHTML(body, args.content);\r\n\r\n\t\t\t// Do post processing\r\n\t\t\tif (!args.no_events)\r\n\t\t\t\tself.onSetContent.dispatch(self, args);\r\n\r\n\t\t\tself.selection.normalize();\r\n\r\n\t\t\treturn args.content;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Gets the content from the editor instance, this will cleanup the content before it gets returned using\r\n\t\t * the different cleanup rules options.\r\n\t\t *\r\n\t\t * @method getContent\r\n\t\t * @param {Object} args Optional content object, this gets passed around through the whole get process.\r\n\t\t * @return {String} Cleaned content string, normally HTML contents.\r\n\t\t * @example\r\n\t\t * // Get the HTML contents of the currently active editor\r\n\t\t * console.debug(tinyMCE.activeEditor.getContent());\r\n\t\t *\r\n\t\t * // Get the raw contents of the currently active editor\r\n\t\t * tinyMCE.activeEditor.getContent({format : 'raw'});\r\n\t\t *\r\n\t\t * // Get content of a specific editor:\r\n\t\t * tinyMCE.get('content id').getContent()\r\n\t\t */\r\n\t\tgetContent : function(args) {\r\n\t\t\tvar self = this, content;\r\n\r\n\t\t\t// Setup args object\r\n\t\t\targs = args || {};\r\n\t\t\targs.format = args.format || 'html';\r\n\t\t\targs.get = true;\r\n\r\n\t\t\t// Do preprocessing\r\n\t\t\tif (!args.no_events)\r\n\t\t\t\tself.onBeforeGetContent.dispatch(self, args);\r\n\r\n\t\t\t// Get raw contents or by default the cleaned contents\r\n\t\t\tif (args.format == 'raw')\r\n\t\t\t\tcontent = self.getBody().innerHTML;\r\n\t\t\telse\r\n\t\t\t\tcontent = self.serializer.serialize(self.getBody(), args);\r\n\r\n\t\t\targs.content = tinymce.trim(content);\r\n\r\n\t\t\t// Do post processing\r\n\t\t\tif (!args.no_events)\r\n\t\t\t\tself.onGetContent.dispatch(self, args);\r\n\r\n\t\t\treturn args.content;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns true/false if the editor is dirty or not. It will get dirty if the user has made modifications to the contents.\r\n\t\t *\r\n\t\t * @method isDirty\r\n\t\t * @return {Boolean} True/false if the editor is dirty or not. It will get dirty if the user has made modifications to the contents.\r\n\t\t * @example\r\n\t\t * if (tinyMCE.activeEditor.isDirty())\r\n\t\t *     alert(\"You must save your contents.\");\r\n\t\t */\r\n\t\tisDirty : function() {\r\n\t\t\tvar self = this;\r\n\r\n\t\t\treturn tinymce.trim(self.startContent) != tinymce.trim(self.getContent({format : 'raw', no_events : 1})) && !self.isNotDirty;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns the editors container element. The container element wrappes in\r\n\t\t * all the elements added to the page for the editor. Such as UI, iframe etc.\r\n\t\t *\r\n\t\t * @method getContainer\r\n\t\t * @return {Element} HTML DOM element for the editor container.\r\n\t\t */\r\n\t\tgetContainer : function() {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\tif (!t.container)\r\n\t\t\t\tt.container = DOM.get(t.editorContainer || t.id + '_parent');\r\n\r\n\t\t\treturn t.container;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns the editors content area container element. The this element is the one who\r\n\t\t * holds the iframe or the editable element.\r\n\t\t *\r\n\t\t * @method getContentAreaContainer\r\n\t\t * @return {Element} HTML DOM element for the editor area container.\r\n\t\t */\r\n\t\tgetContentAreaContainer : function() {\r\n\t\t\treturn this.contentAreaContainer;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns the target element/textarea that got replaced with a TinyMCE editor instance.\r\n\t\t *\r\n\t\t * @method getElement\r\n\t\t * @return {Element} HTML DOM element for the replaced element.\r\n\t\t */\r\n\t\tgetElement : function() {\r\n\t\t\treturn DOM.get(this.settings.content_element || this.id);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns the iframes window object.\r\n\t\t *\r\n\t\t * @method getWin\r\n\t\t * @return {Window} Iframe DOM window object.\r\n\t\t */\r\n\t\tgetWin : function() {\r\n\t\t\tvar t = this, e;\r\n\r\n\t\t\tif (!t.contentWindow) {\r\n\t\t\t\te = DOM.get(t.id + \"_ifr\");\r\n\r\n\t\t\t\tif (e)\r\n\t\t\t\t\tt.contentWindow = e.contentWindow;\r\n\t\t\t}\r\n\r\n\t\t\treturn t.contentWindow;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns the iframes document object.\r\n\t\t *\r\n\t\t * @method getDoc\r\n\t\t * @return {Document} Iframe DOM document object.\r\n\t\t */\r\n\t\tgetDoc : function() {\r\n\t\t\tvar t = this, w;\r\n\r\n\t\t\tif (!t.contentDocument) {\r\n\t\t\t\tw = t.getWin();\r\n\r\n\t\t\t\tif (w)\r\n\t\t\t\t\tt.contentDocument = w.document;\r\n\t\t\t}\r\n\r\n\t\t\treturn t.contentDocument;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns the iframes body element.\r\n\t\t *\r\n\t\t * @method getBody\r\n\t\t * @return {Element} Iframe body element.\r\n\t\t */\r\n\t\tgetBody : function() {\r\n\t\t\treturn this.bodyElement || this.getDoc().body;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * URL converter function this gets executed each time a user adds an img, a or\r\n\t\t * any other element that has a URL in it. This will be called both by the DOM and HTML\r\n\t\t * manipulation functions.\r\n\t\t *\r\n\t\t * @method convertURL\r\n\t\t * @param {string} u URL to convert.\r\n\t\t * @param {string} n Attribute name src, href etc.\r\n\t\t * @param {string/HTMLElement} Tag name or HTML DOM element depending on HTML or DOM insert.\r\n\t\t * @return {string} Converted URL string.\r\n\t\t */\r\n\t\tconvertURL : function(u, n, e) {\r\n\t\t\tvar t = this, s = t.settings;\r\n\r\n\t\t\t// Use callback instead\r\n\t\t\tif (s.urlconverter_callback)\r\n\t\t\t\treturn t.execCallback('urlconverter_callback', u, e, true, n);\r\n\r\n\t\t\t// Don't convert link href since thats the CSS files that gets loaded into the editor also skip local file URLs\r\n\t\t\tif (!s.convert_urls || (e && e.nodeName == 'LINK') || u.indexOf('file:') === 0)\r\n\t\t\t\treturn u;\r\n\r\n\t\t\t// Convert to relative\r\n\t\t\tif (s.relative_urls)\r\n\t\t\t\treturn t.documentBaseURI.toRelative(u);\r\n\r\n\t\t\t// Convert to absolute\r\n\t\t\tu = t.documentBaseURI.toAbsolute(u, s.remove_script_host);\r\n\r\n\t\t\treturn u;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Adds visual aid for tables, anchors etc so they can be more easily edited inside the editor.\r\n\t\t *\r\n\t\t * @method addVisual\r\n\t\t * @param {Element} e Optional root element to loop though to find tables etc that needs the visual aid.\r\n\t\t */\r\n\t\taddVisual : function(e) {\r\n\t\t\tvar t = this, s = t.settings;\r\n\r\n\t\t\te = e || t.getBody();\r\n\r\n\t\t\tif (!is(t.hasVisual))\r\n\t\t\t\tt.hasVisual = s.visual;\r\n\r\n\t\t\teach(t.dom.select('table,a', e), function(e) {\r\n\t\t\t\tvar v;\r\n\r\n\t\t\t\tswitch (e.nodeName) {\r\n\t\t\t\t\tcase 'TABLE':\r\n\t\t\t\t\t\tv = t.dom.getAttrib(e, 'border');\r\n\r\n\t\t\t\t\t\tif (!v || v == '0') {\r\n\t\t\t\t\t\t\tif (t.hasVisual)\r\n\t\t\t\t\t\t\t\tt.dom.addClass(e, s.visual_table_class);\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\tt.dom.removeClass(e, s.visual_table_class);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\tcase 'A':\r\n\t\t\t\t\t\tv = t.dom.getAttrib(e, 'name');\r\n\r\n\t\t\t\t\t\tif (v) {\r\n\t\t\t\t\t\t\tif (t.hasVisual)\r\n\t\t\t\t\t\t\t\tt.dom.addClass(e, 'mceItemAnchor');\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\tt.dom.removeClass(e, 'mceItemAnchor');\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tt.onVisualAid.dispatch(t, e, t.hasVisual);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Removes the editor from the dom and tinymce collection.\r\n\t\t *\r\n\t\t * @method remove\r\n\t\t */\r\n\t\tremove : function() {\r\n\t\t\tvar t = this, e = t.getContainer();\r\n\r\n\t\t\tt.removed = 1; // Cancels post remove event execution\r\n\t\t\tt.hide();\r\n\r\n\t\t\tt.execCallback('remove_instance_callback', t);\r\n\t\t\tt.onRemove.dispatch(t);\r\n\r\n\t\t\t// Clear all execCommand listeners this is required to avoid errors if the editor was removed inside another command\r\n\t\t\tt.onExecCommand.listeners = [];\r\n\r\n\t\t\ttinymce.remove(t);\r\n\t\t\tDOM.remove(e);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Destroys the editor instance by removing all events, element references or other resources\r\n\t\t * that could leak memory. This method will be called automatically when the page is unloaded\r\n\t\t * but you can also call it directly if you know what you are doing.\r\n\t\t *\r\n\t\t * @method destroy\r\n\t\t * @param {Boolean} s Optional state if the destroy is an automatic destroy or user called one.\r\n\t\t */\r\n\t\tdestroy : function(s) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\t// One time is enough\r\n\t\t\tif (t.destroyed)\r\n\t\t\t\treturn;\r\n\r\n\t\t\tif (!s) {\r\n\t\t\t\ttinymce.removeUnload(t.destroy);\r\n\t\t\t\ttinyMCE.onBeforeUnload.remove(t._beforeUnload);\r\n\r\n\t\t\t\t// Manual destroy\r\n\t\t\t\tif (t.theme && t.theme.destroy)\r\n\t\t\t\t\tt.theme.destroy();\r\n\r\n\t\t\t\t// Destroy controls, selection and dom\r\n\t\t\t\tt.controlManager.destroy();\r\n\t\t\t\tt.selection.destroy();\r\n\t\t\t\tt.dom.destroy();\r\n\r\n\t\t\t\t// Remove all events\r\n\r\n\t\t\t\t// Don't clear the window or document if content editable\r\n\t\t\t\t// is enabled since other instances might still be present\r\n\t\t\t\tif (!t.settings.content_editable) {\r\n\t\t\t\t\tEvent.clear(t.getWin());\r\n\t\t\t\t\tEvent.clear(t.getDoc());\r\n\t\t\t\t}\r\n\r\n\t\t\t\tEvent.clear(t.getBody());\r\n\t\t\t\tEvent.clear(t.formElement);\r\n\t\t\t}\r\n\r\n\t\t\tif (t.formElement) {\r\n\t\t\t\tt.formElement.submit = t.formElement._mceOldSubmit;\r\n\t\t\t\tt.formElement._mceOldSubmit = null;\r\n\t\t\t}\r\n\r\n\t\t\tt.contentAreaContainer = t.formElement = t.container = t.settings.content_element = t.bodyElement = t.contentDocument = t.contentWindow = null;\r\n\r\n\t\t\tif (t.selection)\r\n\t\t\t\tt.selection = t.selection.win = t.selection.dom = t.selection.dom.doc = null;\r\n\r\n\t\t\tt.destroyed = 1;\r\n\t\t},\r\n\r\n\t\t// Internal functions\r\n\r\n\t\t_addEvents : function() {\r\n\t\t\t// 'focus', 'blur', 'dblclick', 'beforedeactivate', submit, reset\r\n\t\t\tvar t = this, i, s = t.settings, dom = t.dom, lo = {\r\n\t\t\t\tmouseup : 'onMouseUp',\r\n\t\t\t\tmousedown : 'onMouseDown',\r\n\t\t\t\tclick : 'onClick',\r\n\t\t\t\tkeyup : 'onKeyUp',\r\n\t\t\t\tkeydown : 'onKeyDown',\r\n\t\t\t\tkeypress : 'onKeyPress',\r\n\t\t\t\tsubmit : 'onSubmit',\r\n\t\t\t\treset : 'onReset',\r\n\t\t\t\tcontextmenu : 'onContextMenu',\r\n\t\t\t\tdblclick : 'onDblClick',\r\n\t\t\t\tpaste : 'onPaste' // Doesn't work in all browsers yet\r\n\t\t\t};\r\n\r\n\t\t\tfunction eventHandler(e, o) {\r\n\t\t\t\tvar ty = e.type;\r\n\r\n\t\t\t\t// Don't fire events when it's removed\r\n\t\t\t\tif (t.removed)\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t// Generic event handler\r\n\t\t\t\tif (t.onEvent.dispatch(t, e, o) !== false) {\r\n\t\t\t\t\t// Specific event handler\r\n\t\t\t\t\tt[lo[e.fakeType || e.type]].dispatch(t, e, o);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\t// Add DOM events\r\n\t\t\teach(lo, function(v, k) {\r\n\t\t\t\tswitch (k) {\r\n\t\t\t\t\tcase 'contextmenu':\r\n\t\t\t\t\t\tdom.bind(t.getDoc(), k, eventHandler);\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'paste':\r\n\t\t\t\t\t\tdom.bind(t.getBody(), k, function(e) {\r\n\t\t\t\t\t\t\teventHandler(e);\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'submit':\r\n\t\t\t\t\tcase 'reset':\r\n\t\t\t\t\t\tdom.bind(t.getElement().form || DOM.getParent(t.id, 'form'), k, eventHandler);\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tdom.bind(s.content_editable ? t.getBody() : t.getDoc(), k, eventHandler);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tdom.bind(s.content_editable ? t.getBody() : (isGecko ? t.getDoc() : t.getWin()), 'focus', function(e) {\r\n\t\t\t\tt.focus(true);\r\n\t\t\t});\r\n\r\n\t\t\t// #ifdef contentEditable\r\n\r\n\t\t\tif (s.content_editable && tinymce.isOpera) {\r\n\t\t\t\t// Opera doesn't support focus event for contentEditable elements so we need to fake it\r\n\t\t\t\tfunction doFocus(e) {\r\n\t\t\t\t\tt.focus(true);\r\n\t\t\t\t};\r\n\r\n\t\t\t\tdom.bind(t.getBody(), 'click', doFocus);\r\n\t\t\t\tdom.bind(t.getBody(), 'keydown', doFocus);\r\n\t\t\t}\r\n\r\n\t\t\t// #endif\r\n\r\n\t\t\t// Fixes bug where a specified document_base_uri could result in broken images\r\n\t\t\t// This will also fix drag drop of images in Gecko\r\n\t\t\tif (tinymce.isGecko) {\r\n\t\t\t\tdom.bind(t.getDoc(), 'DOMNodeInserted', function(e) {\r\n\t\t\t\t\tvar v;\r\n\r\n\t\t\t\t\te = e.target;\r\n\r\n\t\t\t\t\tif (e.nodeType === 1 && e.nodeName === 'IMG' && (v = e.getAttribute('data-mce-src')))\r\n\t\t\t\t\t\te.src = t.documentBaseURI.toAbsolute(v);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// Set various midas options in Gecko\r\n\t\t\tif (isGecko) {\r\n\t\t\t\tfunction setOpts() {\r\n\t\t\t\t\tvar t = this, d = t.getDoc(), s = t.settings;\r\n\r\n\t\t\t\t\tif (isGecko && !s.readonly) {\r\n\t\t\t\t\t\tt._refreshContentEditable();\r\n\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t// Try new Gecko method\r\n\t\t\t\t\t\t\td.execCommand(\"styleWithCSS\", 0, false);\r\n\t\t\t\t\t\t} catch (ex) {\r\n\t\t\t\t\t\t\t// Use old method\r\n\t\t\t\t\t\t\tif (!t._isHidden())\r\n\t\t\t\t\t\t\t\ttry {d.execCommand(\"useCSS\", 0, true);} catch (ex) {}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (!s.table_inline_editing)\r\n\t\t\t\t\t\t\ttry {d.execCommand('enableInlineTableEditing', false, false);} catch (ex) {}\r\n\r\n\t\t\t\t\t\tif (!s.object_resizing)\r\n\t\t\t\t\t\t\ttry {d.execCommand('enableObjectResizing', false, false);} catch (ex) {}\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\r\n\t\t\t\tt.onBeforeExecCommand.add(setOpts);\r\n\t\t\t\tt.onMouseDown.add(setOpts);\r\n\t\t\t}\r\n\r\n\t\t\t// Add node change handlers\r\n\t\t\tt.onMouseUp.add(t.nodeChanged);\r\n\t\t\t//t.onClick.add(t.nodeChanged);\r\n\t\t\tt.onKeyUp.add(function(ed, e) {\r\n\t\t\t\tvar c = e.keyCode;\r\n\r\n\t\t\t\tif ((c >= 33 && c <= 36) || (c >= 37 && c <= 40) || c == 13 || c == 45 || c == 46 || c == 8 || (tinymce.isMac && (c == 91 || c == 93)) || e.ctrlKey)\r\n\t\t\t\t\tt.nodeChanged();\r\n\t\t\t});\r\n\r\n\r\n\t\t\t// Add block quote deletion handler\r\n\t\t\tt.onKeyDown.add(function(ed, e) {\r\n\t\t\t\t// Was the BACKSPACE key pressed?\r\n\t\t\t\tif (e.keyCode != 8)\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\tvar n = ed.selection.getRng().startContainer;\r\n\t\t\t\tvar offset = ed.selection.getRng().startOffset;\r\n\r\n\t\t\t\twhile (n && n.nodeType && n.nodeType != 1 && n.parentNode)\r\n\t\t\t\t\tn = n.parentNode;\r\n\r\n\t\t\t\t// Is the cursor at the beginning of a blockquote?\r\n\t\t\t\tif (n && n.parentNode && n.parentNode.tagName === 'BLOCKQUOTE' && n.parentNode.firstChild == n && offset == 0) {\r\n\t\t\t\t\t// Remove the blockquote\r\n\t\t\t\t\ted.formatter.toggle('blockquote', null, n.parentNode);\r\n\r\n\t\t\t\t\t// Move the caret to the beginning of n\r\n\t\t\t\t\tvar rng = ed.selection.getRng();\r\n\t\t\t\t\trng.setStart(n, 0);\r\n\t\t\t\t\trng.setEnd(n, 0);\r\n\t\t\t\t\ted.selection.setRng(rng);\r\n\t\t\t\t\ted.selection.collapse(false);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\r\n\r\n\t\t\t// Add reset handler\r\n\t\t\tt.onReset.add(function() {\r\n\t\t\t\tt.setContent(t.startContent, {format : 'raw'});\r\n\t\t\t});\r\n\r\n\t\t\t// Add shortcuts\r\n\t\t\tif (s.custom_shortcuts) {\r\n\t\t\t\tif (s.custom_undo_redo_keyboard_shortcuts) {\r\n\t\t\t\t\tt.addShortcut('ctrl+z', t.getLang('undo_desc'), 'Undo');\r\n\t\t\t\t\tt.addShortcut('ctrl+y', t.getLang('redo_desc'), 'Redo');\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Add default shortcuts for gecko\r\n\t\t\t\tt.addShortcut('ctrl+b', t.getLang('bold_desc'), 'Bold');\r\n\t\t\t\tt.addShortcut('ctrl+i', t.getLang('italic_desc'), 'Italic');\r\n\t\t\t\tt.addShortcut('ctrl+u', t.getLang('underline_desc'), 'Underline');\r\n\r\n\t\t\t\t// BlockFormat shortcuts keys\r\n\t\t\t\tfor (i=1; i<=6; i++)\r\n\t\t\t\t\tt.addShortcut('ctrl+' + i, '', ['FormatBlock', false, 'h' + i]);\r\n\r\n\t\t\t\tt.addShortcut('ctrl+7', '', ['FormatBlock', false, 'p']);\r\n\t\t\t\tt.addShortcut('ctrl+8', '', ['FormatBlock', false, 'div']);\r\n\t\t\t\tt.addShortcut('ctrl+9', '', ['FormatBlock', false, 'address']);\r\n\r\n\t\t\t\tfunction find(e) {\r\n\t\t\t\t\tvar v = null;\r\n\r\n\t\t\t\t\tif (!e.altKey && !e.ctrlKey && !e.metaKey)\r\n\t\t\t\t\t\treturn v;\r\n\r\n\t\t\t\t\teach(t.shortcuts, function(o) {\r\n\t\t\t\t\t\tif (tinymce.isMac && o.ctrl != e.metaKey)\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\telse if (!tinymce.isMac && o.ctrl != e.ctrlKey)\r\n\t\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t\tif (o.alt != e.altKey)\r\n\t\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t\tif (o.shift != e.shiftKey)\r\n\t\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t\tif (e.keyCode == o.keyCode || (e.charCode && e.charCode == o.charCode)) {\r\n\t\t\t\t\t\t\tv = o;\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\treturn v;\r\n\t\t\t\t};\r\n\r\n\t\t\t\tt.onKeyUp.add(function(ed, e) {\r\n\t\t\t\t\tvar o = find(e);\r\n\r\n\t\t\t\t\tif (o)\r\n\t\t\t\t\t\treturn Event.cancel(e);\r\n\t\t\t\t});\r\n\r\n\t\t\t\tt.onKeyPress.add(function(ed, e) {\r\n\t\t\t\t\tvar o = find(e);\r\n\r\n\t\t\t\t\tif (o)\r\n\t\t\t\t\t\treturn Event.cancel(e);\r\n\t\t\t\t});\r\n\r\n\t\t\t\tt.onKeyDown.add(function(ed, e) {\r\n\t\t\t\t\tvar o = find(e);\r\n\r\n\t\t\t\t\tif (o) {\r\n\t\t\t\t\t\to.func.call(o.scope);\r\n\t\t\t\t\t\treturn Event.cancel(e);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tif (tinymce.isIE) {\r\n\t\t\t\t// Fix so resize will only update the width and height attributes not the styles of an image\r\n\t\t\t\t// It will also block mceItemNoResize items\r\n\t\t\t\tdom.bind(t.getDoc(), 'controlselect', function(e) {\r\n\t\t\t\t\tvar re = t.resizeInfo, cb;\r\n\r\n\t\t\t\t\te = e.target;\r\n\r\n\t\t\t\t\t// Don't do this action for non image elements\r\n\t\t\t\t\tif (e.nodeName !== 'IMG')\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\tif (re)\r\n\t\t\t\t\t\tdom.unbind(re.node, re.ev, re.cb);\r\n\r\n\t\t\t\t\tif (!dom.hasClass(e, 'mceItemNoResize')) {\r\n\t\t\t\t\t\tev = 'resizeend';\r\n\t\t\t\t\t\tcb = dom.bind(e, ev, function(e) {\r\n\t\t\t\t\t\t\tvar v;\r\n\r\n\t\t\t\t\t\t\te = e.target;\r\n\r\n\t\t\t\t\t\t\tif (v = dom.getStyle(e, 'width')) {\r\n\t\t\t\t\t\t\t\tdom.setAttrib(e, 'width', v.replace(/[^0-9%]+/g, ''));\r\n\t\t\t\t\t\t\t\tdom.setStyle(e, 'width', '');\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif (v = dom.getStyle(e, 'height')) {\r\n\t\t\t\t\t\t\t\tdom.setAttrib(e, 'height', v.replace(/[^0-9%]+/g, ''));\r\n\t\t\t\t\t\t\t\tdom.setStyle(e, 'height', '');\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tev = 'resizestart';\r\n\t\t\t\t\t\tcb = dom.bind(e, 'resizestart', Event.cancel, Event);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tre = t.resizeInfo = {\r\n\t\t\t\t\t\tnode : e,\r\n\t\t\t\t\t\tev : ev,\r\n\t\t\t\t\t\tcb : cb\r\n\t\t\t\t\t};\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tif (tinymce.isOpera) {\r\n\t\t\t\tt.onClick.add(function(ed, e) {\r\n\t\t\t\t\tEvent.prevent(e);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// Add custom undo/redo handlers\r\n\t\t\tif (s.custom_undo_redo) {\r\n\t\t\t\tfunction addUndo() {\r\n\t\t\t\t\tt.undoManager.typing = false;\r\n\t\t\t\t\tt.undoManager.add();\r\n\t\t\t\t};\r\n\r\n\t\t\t\tdom.bind(t.getDoc(), 'focusout', function(e) {\r\n\t\t\t\t\tif (!t.removed && t.undoManager.typing)\r\n\t\t\t\t\t\taddUndo();\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// Add undo level when contents is drag/dropped within the editor\r\n\t\t\t\tt.dom.bind(t.dom.getRoot(), 'dragend', function(e) {\r\n\t\t\t\t\taddUndo();\r\n\t\t\t\t});\r\n\r\n\t\t\t\tt.onKeyUp.add(function(ed, e) {\r\n\t\t\t\t\tvar keyCode = e.keyCode;\r\n\r\n\t\t\t\t\tif ((keyCode >= 33 && keyCode <= 36) || (keyCode >= 37 && keyCode <= 40) || keyCode == 13 || keyCode == 45 || e.ctrlKey)\r\n\t\t\t\t\t\taddUndo();\r\n\t\t\t\t});\r\n\r\n\t\t\t\tt.onKeyDown.add(function(ed, e) {\r\n\t\t\t\t\tvar keyCode = e.keyCode, sel;\r\n\r\n\t\t\t\t\tif (keyCode == 8) {\r\n\t\t\t\t\t\tsel = t.getDoc().selection;\r\n\r\n\t\t\t\t\t\t// Fix IE control + backspace browser bug\r\n\t\t\t\t\t\tif (sel && sel.createRange && sel.createRange().item) {\r\n\t\t\t\t\t\t\tt.undoManager.beforeChange();\r\n\t\t\t\t\t\t\ted.dom.remove(sel.createRange().item(0));\r\n\t\t\t\t\t\t\taddUndo();\r\n\r\n\t\t\t\t\t\t\treturn Event.cancel(e);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Is caracter positon keys left,right,up,down,home,end,pgdown,pgup,enter\r\n\t\t\t\t\tif ((keyCode >= 33 && keyCode <= 36) || (keyCode >= 37 && keyCode <= 40) || keyCode == 13 || keyCode == 45) {\r\n\t\t\t\t\t\t// Add position before enter key is pressed, used by IE since it still uses the default browser behavior\r\n\t\t\t\t\t\t// Todo: Remove this once we normalize enter behavior on IE\r\n\t\t\t\t\t\tif (tinymce.isIE && keyCode == 13)\r\n\t\t\t\t\t\t\tt.undoManager.beforeChange();\r\n\r\n\t\t\t\t\t\tif (t.undoManager.typing)\r\n\t\t\t\t\t\t\taddUndo();\r\n\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// If key isn't shift,ctrl,alt,capslock,metakey\r\n\t\t\t\t\tif ((keyCode < 16 || keyCode > 20) && keyCode != 224 && keyCode != 91 && !t.undoManager.typing) {\r\n\t\t\t\t\t\tt.undoManager.beforeChange();\r\n\t\t\t\t\t\tt.undoManager.typing = true;\r\n\t\t\t\t\t\tt.undoManager.add();\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\tt.onMouseDown.add(function() {\r\n\t\t\t\t\tif (t.undoManager.typing)\r\n\t\t\t\t\t\taddUndo();\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// Bug fix for FireFox keeping styles from end of selection instead of start.\r\n\t\t\tif (tinymce.isGecko) {\r\n\t\t\t\tfunction getAttributeApplyFunction() {\r\n\t\t\t\t\tvar template = t.dom.getAttribs(t.selection.getStart().cloneNode(false));\r\n\r\n\t\t\t\t\treturn function() {\r\n\t\t\t\t\t\tvar target = t.selection.getStart();\r\n\r\n\t\t\t\t\t\tif (target !== t.getBody()) {\r\n\t\t\t\t\t\t\tt.dom.setAttrib(target, \"style\", null);\r\n\r\n\t\t\t\t\t\t\teach(template, function(attr) {\r\n\t\t\t\t\t\t\t\ttarget.setAttributeNode(attr.cloneNode(true));\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfunction isSelectionAcrossElements() {\r\n\t\t\t\t\tvar s = t.selection;\r\n\r\n\t\t\t\t\treturn !s.isCollapsed() && s.getStart() != s.getEnd();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tt.onKeyPress.add(function(ed, e) {\r\n\t\t\t\t\tvar applyAttributes;\r\n\r\n\t\t\t\t\tif ((e.keyCode == 8 || e.keyCode == 46) && isSelectionAcrossElements()) {\r\n\t\t\t\t\t\tapplyAttributes = getAttributeApplyFunction();\r\n\t\t\t\t\t\tt.getDoc().execCommand('delete', false, null);\r\n\t\t\t\t\t\tapplyAttributes();\r\n\r\n\t\t\t\t\t\treturn Event.cancel(e);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\tt.dom.bind(t.getDoc(), 'cut', function(e) {\r\n\t\t\t\t\tvar applyAttributes;\r\n\r\n\t\t\t\t\tif (isSelectionAcrossElements()) {\r\n\t\t\t\t\t\tapplyAttributes = getAttributeApplyFunction();\r\n\t\t\t\t\t\tt.onKeyUp.addToTop(Event.cancel, Event);\r\n\r\n\t\t\t\t\t\tsetTimeout(function() {\r\n\t\t\t\t\t\t\tapplyAttributes();\r\n\t\t\t\t\t\t\tt.onKeyUp.remove(Event.cancel, Event);\r\n\t\t\t\t\t\t}, 0);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_refreshContentEditable : function() {\r\n\t\t\tvar self = this, body, parent;\r\n\r\n\t\t\t// Check if the editor was hidden and the re-initalize contentEditable mode by removing and adding the body again\r\n\t\t\tif (self._isHidden()) {\r\n\t\t\t\tbody = self.getBody();\r\n\t\t\t\tparent = body.parentNode;\r\n\r\n\t\t\t\tparent.removeChild(body);\r\n\t\t\t\tparent.appendChild(body);\r\n\r\n\t\t\t\tbody.focus();\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_isHidden : function() {\r\n\t\t\tvar s;\r\n\r\n\t\t\tif (!isGecko)\r\n\t\t\t\treturn 0;\r\n\r\n\t\t\t// Weird, wheres that cursor selection?\r\n\t\t\ts = this.selection.getSel();\r\n\t\t\treturn (!s || !s.rangeCount || s.rangeCount == 0);\r\n\t\t}\r\n\t});\r\n})(tinymce);\r\n","Magento_Tinymce3/tiny_mce/classes/EditorCommands.js":"/**\r\n * EditorCommands.js\r\n *\r\n * Copyright 2009, Moxiecode Systems AB\r\n * Released under LGPL License.\r\n *\r\n * License: http://tinymce.moxiecode.com/license\r\n * Contributing: http://tinymce.moxiecode.com/contributing\r\n */\r\n\r\n(function(tinymce) {\r\n\t// Added for compression purposes\r\n\tvar each = tinymce.each, undefined, TRUE = true, FALSE = false;\r\n\r\n\t/**\r\n\t * This class enables you to add custom editor commands and it contains\r\n\t * overrides for native browser commands to address various bugs and issues.\r\n\t *\r\n\t * @class tinymce.EditorCommands\r\n\t */\r\n\ttinymce.EditorCommands = function(editor) {\r\n\t\tvar dom = editor.dom,\r\n\t\t\tselection = editor.selection,\r\n\t\t\tcommands = {state: {}, exec : {}, value : {}},\r\n\t\t\tsettings = editor.settings,\r\n\t\t\tformatter = editor.formatter,\r\n\t\t\tbookmark;\r\n\r\n\t\t/**\r\n\t\t * Executes the specified command.\r\n\t\t *\r\n\t\t * @method execCommand\r\n\t\t * @param {String} command Command to execute.\r\n\t\t * @param {Boolean} ui Optional user interface state.\r\n\t\t * @param {Object} value Optional value for command.\r\n\t\t * @return {Boolean} true/false if the command was found or not.\r\n\t\t */\r\n\t\tfunction execCommand(command, ui, value) {\r\n\t\t\tvar func;\r\n\r\n\t\t\tcommand = command.toLowerCase();\r\n\t\t\tif (func = commands.exec[command]) {\r\n\t\t\t\tfunc(command, ui, value);\r\n\t\t\t\treturn TRUE;\r\n\t\t\t}\r\n\r\n\t\t\treturn FALSE;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Queries the current state for a command for example if the current selection is \"bold\".\r\n\t\t *\r\n\t\t * @method queryCommandState\r\n\t\t * @param {String} command Command to check the state of.\r\n\t\t * @return {Boolean/Number} true/false if the selected contents is bold or not, -1 if it's not found.\r\n\t\t */\r\n\t\tfunction queryCommandState(command) {\r\n\t\t\tvar func;\r\n\r\n\t\t\tcommand = command.toLowerCase();\r\n\t\t\tif (func = commands.state[command])\r\n\t\t\t\treturn func(command);\r\n\r\n\t\t\treturn -1;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Queries the command value for example the current fontsize.\r\n\t\t *\r\n\t\t * @method queryCommandValue\r\n\t\t * @param {String} command Command to check the value of.\r\n\t\t * @return {Object} Command value of false if it's not found.\r\n\t\t */\r\n\t\tfunction queryCommandValue(command) {\r\n\t\t\tvar func;\r\n\r\n\t\t\tcommand = command.toLowerCase();\r\n\t\t\tif (func = commands.value[command])\r\n\t\t\t\treturn func(command);\r\n\r\n\t\t\treturn FALSE;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Adds commands to the command collection.\r\n\t\t *\r\n\t\t * @method addCommands\r\n\t\t * @param {Object} command_list Name/value collection with commands to add, the names can also be comma separated.\r\n\t\t * @param {String} type Optional type to add, defaults to exec. Can be value or state as well.\r\n\t\t */\r\n\t\tfunction addCommands(command_list, type) {\r\n\t\t\ttype = type || 'exec';\r\n\r\n\t\t\teach(command_list, function(callback, command) {\r\n\t\t\t\teach(command.toLowerCase().split(','), function(command) {\r\n\t\t\t\t\tcommands[type][command] = callback;\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t\t// Expose public methods\r\n\t\ttinymce.extend(this, {\r\n\t\t\texecCommand : execCommand,\r\n\t\t\tqueryCommandState : queryCommandState,\r\n\t\t\tqueryCommandValue : queryCommandValue,\r\n\t\t\taddCommands : addCommands\r\n\t\t});\r\n\r\n\t\t// Private methods\r\n\r\n\t\tfunction execNativeCommand(command, ui, value) {\r\n\t\t\tif (ui === undefined)\r\n\t\t\t\tui = FALSE;\r\n\r\n\t\t\tif (value === undefined)\r\n\t\t\t\tvalue = null;\r\n\r\n\t\t\treturn editor.getDoc().execCommand(command, ui, value);\r\n\t\t};\r\n\r\n\t\tfunction isFormatMatch(name) {\r\n\t\t\treturn formatter.match(name);\r\n\t\t};\r\n\r\n\t\tfunction toggleFormat(name, value) {\r\n\t\t\tformatter.toggle(name, value ? {value : value} : undefined);\r\n\t\t};\r\n\r\n\t\tfunction storeSelection(type) {\r\n\t\t\tbookmark = selection.getBookmark(type);\r\n\t\t};\r\n\r\n\t\tfunction restoreSelection() {\r\n\t\t\tselection.moveToBookmark(bookmark);\r\n\t\t};\r\n\r\n\t\t// Add execCommand overrides\r\n\t\taddCommands({\r\n\t\t\t// Ignore these, added for compatibility\r\n\t\t\t'mceResetDesignMode,mceBeginUndoLevel' : function() {},\r\n\r\n\t\t\t// Add undo manager logic\r\n\t\t\t'mceEndUndoLevel,mceAddUndoLevel' : function() {\r\n\t\t\t\teditor.undoManager.add();\r\n\t\t\t},\r\n\r\n\t\t\t'Cut,Copy,Paste' : function(command) {\r\n\t\t\t\tvar doc = editor.getDoc(), failed;\r\n\r\n\t\t\t\t// Try executing the native command\r\n\t\t\t\ttry {\r\n\t\t\t\t\texecNativeCommand(command);\r\n\t\t\t\t} catch (ex) {\r\n\t\t\t\t\t// Command failed\r\n\t\t\t\t\tfailed = TRUE;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Present alert message about clipboard access not being available\r\n\t\t\t\tif (failed || !doc.queryCommandSupported(command)) {\r\n\t\t\t\t\tif (tinymce.isGecko) {\r\n\t\t\t\t\t\teditor.windowManager.confirm(editor.getLang('clipboard_msg'), function(state) {\r\n\t\t\t\t\t\t\tif (state)\r\n\t\t\t\t\t\t\t\topen('http://www.mozilla.org/editor/midasdemo/securityprefs.html', '_blank');\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t} else\r\n\t\t\t\t\t\teditor.windowManager.alert(editor.getLang('clipboard_no_support'));\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\t// Override unlink command\r\n\t\t\tunlink : function(command) {\r\n\t\t\t\tif (selection.isCollapsed())\r\n\t\t\t\t\tselection.select(selection.getNode());\r\n\r\n\t\t\t\texecNativeCommand(command);\r\n\t\t\t\tselection.collapse(FALSE);\r\n\t\t\t},\r\n\r\n\t\t\t// Override justify commands to use the text formatter engine\r\n\t\t\t'JustifyLeft,JustifyCenter,JustifyRight,JustifyFull' : function(command) {\r\n\t\t\t\tvar align = command.substring(7);\r\n\r\n\t\t\t\t// Remove all other alignments first\r\n\t\t\t\teach('left,center,right,full'.split(','), function(name) {\r\n\t\t\t\t\tif (align != name)\r\n\t\t\t\t\t\tformatter.remove('align' + name);\r\n\t\t\t\t});\r\n\r\n\t\t\t\ttoggleFormat('align' + align);\r\n\t\t\t\texecCommand('mceRepaint');\r\n\t\t\t},\r\n\r\n\t\t\t// Override list commands to fix WebKit bug\r\n\t\t\t'InsertUnorderedList,InsertOrderedList' : function(command) {\r\n\t\t\t\tvar listElm, listParent;\r\n\r\n\t\t\t\texecNativeCommand(command);\r\n\r\n\t\t\t\t// WebKit produces lists within block elements so we need to split them\r\n\t\t\t\t// we will replace the native list creation logic to custom logic later on\r\n\t\t\t\t// TODO: Remove this when the list creation logic is removed\r\n\t\t\t\tlistElm = dom.getParent(selection.getNode(), 'ol,ul');\r\n\t\t\t\tif (listElm) {\r\n\t\t\t\t\tlistParent = listElm.parentNode;\r\n\r\n\t\t\t\t\t// If list is within a text block then split that block\r\n\t\t\t\t\tif (/^(H[1-6]|P|ADDRESS|PRE)$/.test(listParent.nodeName)) {\r\n\t\t\t\t\t\tstoreSelection();\r\n\t\t\t\t\t\tdom.split(listParent, listElm);\r\n\t\t\t\t\t\trestoreSelection();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\t// Override commands to use the text formatter engine\r\n\t\t\t'Bold,Italic,Underline,Strikethrough,Superscript,Subscript' : function(command) {\r\n\t\t\t\ttoggleFormat(command);\r\n\t\t\t},\r\n\r\n\t\t\t// Override commands to use the text formatter engine\r\n\t\t\t'ForeColor,HiliteColor,FontName' : function(command, ui, value) {\r\n\t\t\t\ttoggleFormat(command, value);\r\n\t\t\t},\r\n\r\n\t\t\tFontSize : function(command, ui, value) {\r\n\t\t\t\tvar fontClasses, fontSizes;\r\n\r\n\t\t\t\t// Convert font size 1-7 to styles\r\n\t\t\t\tif (value >= 1 && value <= 7) {\r\n\t\t\t\t\tfontSizes = tinymce.explode(settings.font_size_style_values);\r\n\t\t\t\t\tfontClasses = tinymce.explode(settings.font_size_classes);\r\n\r\n\t\t\t\t\tif (fontClasses)\r\n\t\t\t\t\t\tvalue = fontClasses[value - 1] || value;\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tvalue = fontSizes[value - 1] || value;\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttoggleFormat(command, value);\r\n\t\t\t},\r\n\r\n\t\t\tRemoveFormat : function(command) {\r\n\t\t\t\tformatter.remove(command);\r\n\t\t\t},\r\n\r\n\t\t\tmceBlockQuote : function(command) {\r\n\t\t\t\ttoggleFormat('blockquote');\r\n\t\t\t},\r\n\r\n\t\t\tFormatBlock : function(command, ui, value) {\r\n\t\t\t\treturn toggleFormat(value || 'p');\r\n\t\t\t},\r\n\r\n\t\t\tmceCleanup : function() {\r\n\t\t\t\tvar bookmark = selection.getBookmark();\r\n\r\n\t\t\t\teditor.setContent(editor.getContent({cleanup : TRUE}), {cleanup : TRUE});\r\n\r\n\t\t\t\tselection.moveToBookmark(bookmark);\r\n\t\t\t},\r\n\r\n\t\t\tmceRemoveNode : function(command, ui, value) {\r\n\t\t\t\tvar node = value || selection.getNode();\r\n\r\n\t\t\t\t// Make sure that the body node isn't removed\r\n\t\t\t\tif (node != editor.getBody()) {\r\n\t\t\t\t\tstoreSelection();\r\n\t\t\t\t\teditor.dom.remove(node, TRUE);\r\n\t\t\t\t\trestoreSelection();\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\tmceSelectNodeDepth : function(command, ui, value) {\r\n\t\t\t\tvar counter = 0;\r\n\r\n\t\t\t\tdom.getParent(selection.getNode(), function(node) {\r\n\t\t\t\t\tif (node.nodeType == 1 && counter++ == value) {\r\n\t\t\t\t\t\tselection.select(node);\r\n\t\t\t\t\t\treturn FALSE;\r\n\t\t\t\t\t}\r\n\t\t\t\t}, editor.getBody());\r\n\t\t\t},\r\n\r\n\t\t\tmceSelectNode : function(command, ui, value) {\r\n\t\t\t\tselection.select(value);\r\n\t\t\t},\r\n\r\n\t\t\tmceInsertContent : function(command, ui, value) {\r\n\t\t\t\tvar parser, serializer, parentNode, rootNode, fragment, args,\r\n\t\t\t\t\tmarker, nodeRect, viewPortRect, rng, node, node2, bookmarkHtml, viewportBodyElement;\r\n\r\n\t\t\t\t// Setup parser and serializer\r\n\t\t\t\tparser = editor.parser;\r\n\t\t\t\tserializer = new tinymce.html.Serializer({}, editor.schema);\r\n\t\t\t\tbookmarkHtml = '<span id=\"mce_marker\" data-mce-type=\"bookmark\">\\uFEFF</span>';\r\n\r\n\t\t\t\t// Run beforeSetContent handlers on the HTML to be inserted\r\n\t\t\t\targs = {content: value, format: 'html'};\r\n\t\t\t\tselection.onBeforeSetContent.dispatch(selection, args);\r\n\t\t\t\tvalue = args.content;\r\n\r\n\t\t\t\t// Add caret at end of contents if it's missing\r\n\t\t\t\tif (value.indexOf('{$caret}') == -1)\r\n\t\t\t\t\tvalue += '{$caret}';\r\n\r\n\t\t\t\t// Replace the caret marker with a span bookmark element\r\n\t\t\t\tvalue = value.replace(/\\{\\$caret\\}/, bookmarkHtml);\r\n\r\n\t\t\t\t// Insert node maker where we will insert the new HTML and get it's parent\r\n\t\t\t\tif (!selection.isCollapsed())\r\n\t\t\t\t\teditor.getDoc().execCommand('Delete', false, null);\r\n\r\n\t\t\t\tparentNode = selection.getNode();\r\n\r\n\t\t\t\t// Parse the fragment within the context of the parent node\r\n\t\t\t\targs = {context : parentNode.nodeName.toLowerCase()};\r\n\t\t\t\tfragment = parser.parse(value, args);\r\n\r\n\t\t\t\t// Move the caret to a more suitable location\r\n\t\t\t\tnode = fragment.lastChild;\r\n\t\t\t\tif (node.attr('id') == 'mce_marker') {\r\n\t\t\t\t\tmarker = node;\r\n\r\n\t\t\t\t\tfor (node = node.prev; node; node = node.walk(true)) {\r\n\t\t\t\t\t\tif (node.type == 3 || !dom.isBlock(node.name)) {\r\n\t\t\t\t\t\t\tnode.parent.insert(marker, node, node.name === 'br');\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// If parser says valid we can insert the contents into that parent\r\n\t\t\t\tif (!args.invalid) {\r\n\t\t\t\t\tvalue = serializer.serialize(fragment);\r\n\r\n\t\t\t\t\t// Check if parent is empty or only has one BR element then set the innerHTML of that parent\r\n\t\t\t\t\tnode = parentNode.firstChild;\r\n\t\t\t\t\tnode2 = parentNode.lastChild;\r\n\t\t\t\t\tif (!node || (node === node2 && node.nodeName === 'BR'))\r\n\t\t\t\t\t\tdom.setHTML(parentNode, value);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tselection.setContent(value);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// If the fragment was invalid within that context then we need\r\n\t\t\t\t\t// to parse and process the parent it's inserted into\r\n\r\n\t\t\t\t\t// Insert bookmark node and get the parent\r\n\t\t\t\t\tselection.setContent(bookmarkHtml);\r\n\t\t\t\t\tparentNode = editor.selection.getNode();\r\n\t\t\t\t\trootNode = editor.getBody();\r\n\r\n\t\t\t\t\t// Opera will return the document node when selection is in root\r\n\t\t\t\t\tif (parentNode.nodeType == 9)\r\n\t\t\t\t\t\tparentNode = node = rootNode;\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tnode = parentNode;\r\n\r\n\t\t\t\t\t// Find the ancestor just before the root element\r\n\t\t\t\t\twhile (node !== rootNode) {\r\n\t\t\t\t\t\tparentNode = node;\r\n\t\t\t\t\t\tnode = node.parentNode;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Get the outer/inner HTML depending on if we are in the root and parser and serialize that\r\n\t\t\t\t\tvalue = parentNode == rootNode ? rootNode.innerHTML : dom.getOuterHTML(parentNode);\r\n\t\t\t\t\tvalue = serializer.serialize(\r\n\t\t\t\t\t\tparser.parse(\r\n\t\t\t\t\t\t\t// Need to replace by using a function since $ in the contents would otherwise be a problem\r\n\t\t\t\t\t\t\tvalue.replace(/<span (id=\"mce_marker\"|id=mce_marker).+?<\\/span>/i, function() {\r\n\t\t\t\t\t\t\t\treturn serializer.serialize(fragment);\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\t// Set the inner/outer HTML depending on if we are in the root or not\r\n\t\t\t\t\tif (parentNode == rootNode)\r\n\t\t\t\t\t\tdom.setHTML(rootNode, value);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tdom.setOuterHTML(parentNode, value);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmarker = dom.get('mce_marker');\r\n\r\n\t\t\t\t// Scroll range into view scrollIntoView on element can't be used since it will scroll the main view port as well\r\n\t\t\t\tnodeRect = dom.getRect(marker);\r\n\t\t\t\tviewPortRect = dom.getViewPort(editor.getWin());\r\n\r\n\t\t\t\t// Check if node is out side the viewport if it is then scroll to it\r\n\t\t\t\tif ((nodeRect.y + nodeRect.h > viewPortRect.y + viewPortRect.h || nodeRect.y < viewPortRect.y) ||\r\n\t\t\t\t\t(nodeRect.x > viewPortRect.x + viewPortRect.w || nodeRect.x < viewPortRect.x)) {\r\n\t\t\t\t\tviewportBodyElement = tinymce.isIE ? editor.getDoc().documentElement : editor.getBody();\r\n\t\t\t\t\tviewportBodyElement.scrollLeft = nodeRect.x;\r\n\t\t\t\t\tviewportBodyElement.scrollTop = nodeRect.y - viewPortRect.h + 25;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Move selection before marker and remove it\r\n\t\t\t\trng = dom.createRng();\r\n\r\n\t\t\t\t// If previous sibling is a text node set the selection to the end of that node\r\n\t\t\t\tnode = marker.previousSibling;\r\n\t\t\t\tif (node && node.nodeType == 3) {\r\n\t\t\t\t\trng.setStart(node, node.nodeValue.length);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// If the previous sibling isn't a text node or doesn't exist set the selection before the marker node\r\n\t\t\t\t\trng.setStartBefore(marker);\r\n\t\t\t\t\trng.setEndBefore(marker);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Remove the marker node and set the new range\r\n\t\t\t\tdom.remove(marker);\r\n\t\t\t\tselection.setRng(rng);\r\n\r\n\t\t\t\t// Dispatch after event and add any visual elements needed\r\n\t\t\t\tselection.onSetContent.dispatch(selection, args);\r\n\t\t\t\teditor.addVisual();\r\n\t\t\t},\r\n\r\n\t\t\tmceInsertRawHTML : function(command, ui, value) {\r\n\t\t\t\tselection.setContent('tiny_mce_marker');\r\n\t\t\t\teditor.setContent(editor.getContent().replace(/tiny_mce_marker/g, function() { return value }));\r\n\t\t\t},\r\n\r\n\t\t\tmceSetContent : function(command, ui, value) {\r\n\t\t\t\teditor.setContent(value);\r\n\t\t\t},\r\n\r\n\t\t\t'Indent,Outdent' : function(command) {\r\n\t\t\t\tvar intentValue, indentUnit, value;\r\n\r\n\t\t\t\t// Setup indent level\r\n\t\t\t\tintentValue = settings.indentation;\r\n\t\t\t\tindentUnit = /[a-z%]+$/i.exec(intentValue);\r\n\t\t\t\tintentValue = parseInt(intentValue);\r\n\r\n\t\t\t\tif (!queryCommandState('InsertUnorderedList') && !queryCommandState('InsertOrderedList')) {\r\n\t\t\t\t\teach(selection.getSelectedBlocks(), function(element) {\r\n\t\t\t\t\t\tif (command == 'outdent') {\r\n\t\t\t\t\t\t\tvalue = Math.max(0, parseInt(element.style.paddingLeft || 0) - intentValue);\r\n\t\t\t\t\t\t\tdom.setStyle(element, 'paddingLeft', value ? value + indentUnit : '');\r\n\t\t\t\t\t\t} else\r\n\t\t\t\t\t\t\tdom.setStyle(element, 'paddingLeft', (parseInt(element.style.paddingLeft || 0) + intentValue) + indentUnit);\r\n\t\t\t\t\t});\r\n\t\t\t\t} else\r\n\t\t\t\t\texecNativeCommand(command);\r\n\t\t\t},\r\n\r\n\t\t\tmceRepaint : function() {\r\n\t\t\t\tvar bookmark;\r\n\r\n\t\t\t\tif (tinymce.isGecko) {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tstoreSelection(TRUE);\r\n\r\n\t\t\t\t\t\tif (selection.getSel())\r\n\t\t\t\t\t\t\tselection.getSel().selectAllChildren(editor.getBody());\r\n\r\n\t\t\t\t\t\tselection.collapse(TRUE);\r\n\t\t\t\t\t\trestoreSelection();\r\n\t\t\t\t\t} catch (ex) {\r\n\t\t\t\t\t\t// Ignore\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\tmceToggleFormat : function(command, ui, value) {\r\n\t\t\t\tformatter.toggle(value);\r\n\t\t\t},\r\n\r\n\t\t\tInsertHorizontalRule : function() {\r\n\t\t\t\teditor.execCommand('mceInsertContent', false, '<hr />');\r\n\t\t\t},\r\n\r\n\t\t\tmceToggleVisualAid : function() {\r\n\t\t\t\teditor.hasVisual = !editor.hasVisual;\r\n\t\t\t\teditor.addVisual();\r\n\t\t\t},\r\n\r\n\t\t\tmceReplaceContent : function(command, ui, value) {\r\n\t\t\t\teditor.execCommand('mceInsertContent', false, value.replace(/\\{\\$selection\\}/g, selection.getContent({format : 'text'})));\r\n\t\t\t},\r\n\r\n\t\t\tmceInsertLink : function(command, ui, value) {\r\n\t\t\t\tvar anchor;\r\n\r\n\t\t\t\tif (typeof(value) == 'string')\r\n\t\t\t\t\tvalue = {href : value};\r\n\r\n\t\t\t\tanchor = dom.getParent(selection.getNode(), 'a');\r\n\r\n\t\t\t\t// Spaces are never valid in URLs and it's a very common mistake for people to make so we fix it here.\r\n\t\t\t\tvalue.href = value.href.replace(' ', '%20');\r\n\r\n\t\t\t\t// Remove existing links if there could be child links or that the href isn't specified\r\n\t\t\t\tif (!anchor || !value.href) {\r\n\t\t\t\t\tformatter.remove('link');\r\n\t\t\t\t}\t\t\r\n\r\n\t\t\t\t// Apply new link to selection\r\n\t\t\t\tif (value.href) {\r\n\t\t\t\t\tformatter.apply('link', value, anchor);\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\tselectAll : function() {\r\n\t\t\t\tvar root = dom.getRoot(), rng = dom.createRng();\r\n\r\n\t\t\t\trng.setStart(root, 0);\r\n\t\t\t\trng.setEnd(root, root.childNodes.length);\r\n\r\n\t\t\t\teditor.selection.setRng(rng);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// Add queryCommandState overrides\r\n\t\taddCommands({\r\n\t\t\t// Override justify commands\r\n\t\t\t'JustifyLeft,JustifyCenter,JustifyRight,JustifyFull' : function(command) {\r\n\t\t\t\treturn isFormatMatch('align' + command.substring(7));\r\n\t\t\t},\r\n\r\n\t\t\t'Bold,Italic,Underline,Strikethrough,Superscript,Subscript' : function(command) {\r\n\t\t\t\treturn isFormatMatch(command);\r\n\t\t\t},\r\n\r\n\t\t\tmceBlockQuote : function() {\r\n\t\t\t\treturn isFormatMatch('blockquote');\r\n\t\t\t},\r\n\r\n\t\t\tOutdent : function() {\r\n\t\t\t\tvar node;\r\n\r\n\t\t\t\tif (settings.inline_styles) {\r\n\t\t\t\t\tif ((node = dom.getParent(selection.getStart(), dom.isBlock)) && parseInt(node.style.paddingLeft) > 0)\r\n\t\t\t\t\t\treturn TRUE;\r\n\r\n\t\t\t\t\tif ((node = dom.getParent(selection.getEnd(), dom.isBlock)) && parseInt(node.style.paddingLeft) > 0)\r\n\t\t\t\t\t\treturn TRUE;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn queryCommandState('InsertUnorderedList') || queryCommandState('InsertOrderedList') || (!settings.inline_styles && !!dom.getParent(selection.getNode(), 'BLOCKQUOTE'));\r\n\t\t\t},\r\n\r\n\t\t\t'InsertUnorderedList,InsertOrderedList' : function(command) {\r\n\t\t\t\treturn dom.getParent(selection.getNode(), command == 'insertunorderedlist' ? 'UL' : 'OL');\r\n\t\t\t}\r\n\t\t}, 'state');\r\n\r\n\t\t// Add queryCommandValue overrides\r\n\t\taddCommands({\r\n\t\t\t'FontSize,FontName' : function(command) {\r\n\t\t\t\tvar value = 0, parent;\r\n\r\n\t\t\t\tif (parent = dom.getParent(selection.getNode(), 'span')) {\r\n\t\t\t\t\tif (command == 'fontsize')\r\n\t\t\t\t\t\tvalue = parent.style.fontSize;\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tvalue = parent.style.fontFamily.replace(/, /g, ',').replace(/[\\'\\\"]/g, '').toLowerCase();\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn value;\r\n\t\t\t}\r\n\t\t}, 'value');\r\n\r\n\t\t// Add undo manager logic\r\n\t\tif (settings.custom_undo_redo) {\r\n\t\t\taddCommands({\r\n\t\t\t\tUndo : function() {\r\n\t\t\t\t\teditor.undoManager.undo();\r\n\t\t\t\t},\r\n\r\n\t\t\t\tRedo : function() {\r\n\t\t\t\t\teditor.undoManager.redo();\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t};\r\n})(tinymce);\r\n","Magento_Tinymce3/tiny_mce/classes/EditorManager.js":"/**\r\n * EditorManager.js\r\n *\r\n * Copyright 2009, Moxiecode Systems AB\r\n * Released under LGPL License.\r\n *\r\n * License: http://tinymce.moxiecode.com/license\r\n * Contributing: http://tinymce.moxiecode.com/contributing\r\n */\r\n\r\n(function(tinymce) {\r\n\t/**\r\n\t * @class tinymce\r\n\t */\r\n\r\n\t// Shorten names\r\n\tvar each = tinymce.each, extend = tinymce.extend,\r\n\t\tDOM = tinymce.DOM, Event = tinymce.dom.Event,\r\n\t\tThemeManager = tinymce.ThemeManager, PluginManager = tinymce.PluginManager,\r\n\t\texplode = tinymce.explode,\r\n\t\tDispatcher = tinymce.util.Dispatcher, undefined, instanceCounter = 0;\r\n\r\n\t// Setup some URLs where the editor API is located and where the document is\r\n\ttinymce.documentBaseURL = window.location.href.replace(/[\\?#].*$/, '').replace(/[\\/\\\\][^\\/]+$/, '');\r\n\tif (!/[\\/\\\\]$/.test(tinymce.documentBaseURL))\r\n\t\ttinymce.documentBaseURL += '/';\r\n\r\n\ttinymce.baseURL = new tinymce.util.URI(tinymce.documentBaseURL).toAbsolute(tinymce.baseURL);\r\n\r\n\t/**\r\n\t * Absolute baseURI for the installation path of TinyMCE.\r\n\t *\r\n\t * @property baseURI\r\n\t * @type tinymce.util.URI\r\n\t */\r\n\ttinymce.baseURI = new tinymce.util.URI(tinymce.baseURL);\r\n\r\n\t// Add before unload listener\r\n\t// This was required since IE was leaking memory if you added and removed beforeunload listeners\r\n\t// with attachEvent/detatchEvent so this only adds one listener and instances can the attach to the onBeforeUnload event\r\n\ttinymce.onBeforeUnload = new Dispatcher(tinymce);\r\n\r\n\t// Must be on window or IE will leak if the editor is placed in frame or iframe\r\n\tEvent.add(window, 'beforeunload', function(e) {\r\n\t\ttinymce.onBeforeUnload.dispatch(tinymce, e);\r\n\t});\r\n\r\n\t/**\r\n\t * Fires when a new editor instance is added to the tinymce collection.\r\n\t *\r\n\t * @event onAddEditor\r\n\t * @param {tinymce} sender TinyMCE root class/namespace.\r\n\t * @param {tinymce.Editor} editor Editor instance.\r\n\t * @example\r\n\t * tinyMCE.execCommand(\"mceAddControl\", false, \"some_textarea\");\r\n\t * tinyMCE.onAddEditor.add(function(mgr,ed) {\r\n\t *     console.debug('A new editor is available' + ed.id);\r\n\t * });\r\n\t */\r\n\ttinymce.onAddEditor = new Dispatcher(tinymce);\r\n\r\n\t/**\r\n\t * Fires when an editor instance is removed from the tinymce collection.\r\n\t *\r\n\t * @event onRemoveEditor\r\n\t * @param {tinymce} sender TinyMCE root class/namespace.\r\n\t * @param {tinymce.Editor} editor Editor instance.\r\n\t */\r\n\ttinymce.onRemoveEditor = new Dispatcher(tinymce);\r\n\r\n\ttinymce.EditorManager = extend(tinymce, {\r\n\t\t/**\r\n\t\t * Collection of editor instances.\r\n\t\t *\r\n\t\t * @property editors\r\n\t\t * @type Object\r\n\t\t * @example\r\n\t\t * for (edId in tinyMCE.editors)\r\n\t\t *     tinyMCE.editors[edId].save();\r\n\t\t */\r\n\t\teditors : [],\r\n\r\n\t\t/**\r\n\t\t * Collection of language pack data.\r\n\t\t *\r\n\t\t * @property i18n\r\n\t\t * @type Object\r\n\t\t */\r\n\t\ti18n : {},\r\n\r\n\t\t/**\r\n\t\t * Currently active editor instance.\r\n\t\t *\r\n\t\t * @property activeEditor\r\n\t\t * @type tinymce.Editor\r\n\t\t * @example\r\n\t\t * tinyMCE.activeEditor.selection.getContent();\r\n\t\t * tinymce.EditorManager.activeEditor.selection.getContent();\r\n\t\t */\r\n\t\tactiveEditor : null,\r\n\r\n\t\t/**\r\n\t\t * Initializes a set of editors. This method will create a bunch of editors based in the input.\r\n\t\t *\r\n\t\t * @method init\r\n\t\t * @param {Object} s Settings object to be passed to each editor instance.\r\n\t\t * @example\r\n\t\t * // Initializes a editor using the longer method\r\n\t\t * tinymce.EditorManager.init({\r\n\t\t *    some_settings : 'some value'\r\n\t\t * });\r\n\t\t * \r\n\t\t * // Initializes a editor instance using the shorter version\r\n\t\t * tinyMCE.init({\r\n\t\t *    some_settings : 'some value'\r\n\t\t * });\r\n\t\t */\r\n\t\tinit : function(s) {\r\n\t\t\tvar t = this, pl, sl = tinymce.ScriptLoader, e, el = [], ed;\r\n\r\n\t\t\tfunction execCallback(se, n, s) {\r\n\t\t\t\tvar f = se[n];\r\n\r\n\t\t\t\tif (!f)\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\tif (tinymce.is(f, 'string')) {\r\n\t\t\t\t\ts = f.replace(/\\.\\w+$/, '');\r\n\t\t\t\t\ts = s ? tinymce.resolve(s) : 0;\r\n\t\t\t\t\tf = tinymce.resolve(f);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn f.apply(s || this, Array.prototype.slice.call(arguments, 2));\r\n\t\t\t};\r\n\r\n\t\t\ts = extend({\r\n\t\t\t\ttheme : \"simple\",\r\n\t\t\t\tlanguage : \"en\"\r\n\t\t\t}, s);\r\n\r\n\t\t\tt.settings = s;\r\n\r\n\t\t\t// Legacy call\r\n\t\t\tEvent.add(document, 'init', function() {\r\n\t\t\t\tvar l, co;\r\n\r\n\t\t\t\texecCallback(s, 'onpageload');\r\n\r\n\t\t\t\tswitch (s.mode) {\r\n\t\t\t\t\tcase \"exact\":\r\n\t\t\t\t\t\tl = s.elements || '';\r\n\r\n\t\t\t\t\t\tif(l.length > 0) {\r\n\t\t\t\t\t\t\teach(explode(l), function(v) {\r\n\t\t\t\t\t\t\t\tif (DOM.get(v)) {\r\n\t\t\t\t\t\t\t\t\ted = new tinymce.Editor(v, s);\r\n\t\t\t\t\t\t\t\t\tel.push(ed);\r\n\t\t\t\t\t\t\t\t\ted.render(1);\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\teach(document.forms, function(f) {\r\n\t\t\t\t\t\t\t\t\t\teach(f.elements, function(e) {\r\n\t\t\t\t\t\t\t\t\t\t\tif (e.name === v) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tv = 'mce_editor_' + instanceCounter++;\r\n\t\t\t\t\t\t\t\t\t\t\t\tDOM.setAttrib(e, 'id', v);\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\ted = new tinymce.Editor(v, s);\r\n\t\t\t\t\t\t\t\t\t\t\t\tel.push(ed);\r\n\t\t\t\t\t\t\t\t\t\t\t\ted.render(1);\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase \"textareas\":\r\n\t\t\t\t\tcase \"specific_textareas\":\r\n\t\t\t\t\t\tfunction hasClass(n, c) {\r\n\t\t\t\t\t\t\treturn c.constructor === RegExp ? c.test(n.className) : DOM.hasClass(n, c);\r\n\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\teach(DOM.select('textarea'), function(v) {\r\n\t\t\t\t\t\t\tif (s.editor_deselector && hasClass(v, s.editor_deselector))\r\n\t\t\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t\t\tif (!s.editor_selector || hasClass(v, s.editor_selector)) {\r\n\t\t\t\t\t\t\t\t// Can we use the name\r\n\t\t\t\t\t\t\t\te = DOM.get(v.name);\r\n\t\t\t\t\t\t\t\tif (!v.id && !e)\r\n\t\t\t\t\t\t\t\t\tv.id = v.name;\r\n\r\n\t\t\t\t\t\t\t\t// Generate unique name if missing or already exists\r\n\t\t\t\t\t\t\t\tif (!v.id || t.get(v.id))\r\n\t\t\t\t\t\t\t\t\tv.id = DOM.uniqueId();\r\n\r\n\t\t\t\t\t\t\t\ted = new tinymce.Editor(v.id, s);\r\n\t\t\t\t\t\t\t\tel.push(ed);\r\n\t\t\t\t\t\t\t\ted.render(1);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Call onInit when all editors are initialized\r\n\t\t\t\tif (s.oninit) {\r\n\t\t\t\t\tl = co = 0;\r\n\r\n\t\t\t\t\teach(el, function(ed) {\r\n\t\t\t\t\t\tco++;\r\n\r\n\t\t\t\t\t\tif (!ed.initialized) {\r\n\t\t\t\t\t\t\t// Wait for it\r\n\t\t\t\t\t\t\ted.onInit.add(function() {\r\n\t\t\t\t\t\t\t\tl++;\r\n\r\n\t\t\t\t\t\t\t\t// All done\r\n\t\t\t\t\t\t\t\tif (l == co)\r\n\t\t\t\t\t\t\t\t\texecCallback(s, 'oninit');\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t} else\r\n\t\t\t\t\t\t\tl++;\r\n\r\n\t\t\t\t\t\t// All done\r\n\t\t\t\t\t\tif (l == co)\r\n\t\t\t\t\t\t\texecCallback(s, 'oninit');\t\t\t\t\t\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns a editor instance by id.\r\n\t\t *\r\n\t\t * @method get\r\n\t\t * @param {String/Number} id Editor instance id or index to return.\r\n\t\t * @return {tinymce.Editor} Editor instance to return.\r\n\t\t * @example\r\n\t\t * // Adds an onclick event to an editor by id (shorter version)\r\n\t\t * tinyMCE.get('mytextbox').onClick.add(function(ed, e) {\r\n\t\t *    ed.windowManager.alert('Hello world!');\r\n\t\t * });\r\n\t\t * \r\n\t\t * // Adds an onclick event to an editor by id (longer version)\r\n\t\t * tinymce.EditorManager.get('mytextbox').onClick.add(function(ed, e) {\r\n\t\t *    ed.windowManager.alert('Hello world!');\r\n\t\t * });\r\n\t\t */\r\n\t\tget : function(id) {\r\n\t\t\tif (id === undefined)\r\n\t\t\t\treturn this.editors;\r\n\r\n\t\t\treturn this.editors[id];\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns a editor instance by id. This method was added for compatibility with the 2.x branch.\r\n\t\t *\r\n\t\t * @method getInstanceById\r\n\t\t * @param {String} id Editor instance id to return.\r\n\t\t * @return {tinymce.Editor} Editor instance to return.\r\n\t\t * @deprecated Use get method instead.\r\n\t\t * @see #get\r\n\t\t */\r\n\t\tgetInstanceById : function(id) {\r\n\t\t\treturn this.get(id);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Adds an editor instance to the editor collection. This will also set it as the active editor.\r\n\t\t *\r\n\t\t * @method add\r\n\t\t * @param {tinymce.Editor} editor Editor instance to add to the collection.\r\n\t\t * @return {tinymce.Editor} The same instance that got passed in.\r\n\t\t */\r\n\t\tadd : function(editor) {\r\n\t\t\tvar self = this, editors = self.editors;\r\n\r\n\t\t\t// Add named and index editor instance\r\n\t\t\teditors[editor.id] = editor;\r\n\t\t\teditors.push(editor);\r\n\r\n\t\t\tself._setActive(editor);\r\n\t\t\tself.onAddEditor.dispatch(self, editor);\r\n\r\n\t\t\t// #ifdef jquery\r\n\r\n\t\t\t// Patch the tinymce.Editor instance with jQuery adapter logic\r\n\t\t\tif (tinymce.adapter)\r\n\t\t\t\ttinymce.adapter.patchEditor(editor);\r\n\r\n\t\t\t// #endif\r\n\r\n\t\t\treturn editor;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Removes a editor instance from the collection.\r\n\t\t *\r\n\t\t * @method remove\r\n\t\t * @param {tinymce.Editor} e Editor instance to remove.\r\n\t\t * @return {tinymce.Editor} The editor that got passed in will be return if it was found otherwise null.\r\n\t\t */\r\n\t\tremove : function(editor) {\r\n\t\t\tvar t = this, i, editors = t.editors;\r\n\r\n\t\t\t// Not in the collection\r\n\t\t\tif (!editors[editor.id])\r\n\t\t\t\treturn null;\r\n\r\n\t\t\tdelete editors[editor.id];\r\n\r\n\t\t\tfor (i = 0; i < editors.length; i++) {\r\n\t\t\t\tif (editors[i] == editor) {\r\n\t\t\t\t\teditors.splice(i, 1);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Select another editor since the active one was removed\r\n\t\t\tif (t.activeEditor == editor)\r\n\t\t\t\tt._setActive(editors[0]);\r\n\r\n\t\t\teditor.destroy();\r\n\t\t\tt.onRemoveEditor.dispatch(t, editor);\r\n\r\n\t\t\treturn editor;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Executes a specific command on the currently active editor.\r\n\t\t *\r\n\t\t * @method execCommand\r\n\t\t * @param {String} c Command to perform for example Bold.\r\n\t\t * @param {Boolean} u Optional boolean state if a UI should be presented for the command or not.\r\n\t\t * @param {String} v Optional value parameter like for example an URL to a link.\r\n\t\t * @return {Boolean} true/false if the command was executed or not.\r\n\t\t */\r\n\t\texecCommand : function(c, u, v) {\r\n\t\t\tvar t = this, ed = t.get(v), w;\r\n\r\n\t\t\t// Manager commands\r\n\t\t\tswitch (c) {\r\n\t\t\t\tcase \"mceFocus\":\r\n\t\t\t\t\ted.focus();\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\tcase \"mceAddEditor\":\r\n\t\t\t\tcase \"mceAddControl\":\r\n\t\t\t\t\tif (!t.get(v))\r\n\t\t\t\t\t\tnew tinymce.Editor(v, t.settings).render();\r\n\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\tcase \"mceAddFrameControl\":\r\n\t\t\t\t\tw = v.window;\r\n\r\n\t\t\t\t\t// Add tinyMCE global instance and tinymce namespace to specified window\r\n\t\t\t\t\tw.tinyMCE = tinyMCE;\r\n\t\t\t\t\tw.tinymce = tinymce;\r\n\r\n\t\t\t\t\ttinymce.DOM.doc = w.document;\r\n\t\t\t\t\ttinymce.DOM.win = w;\r\n\r\n\t\t\t\t\ted = new tinymce.Editor(v.element_id, v);\r\n\t\t\t\t\ted.render();\r\n\r\n\t\t\t\t\t// Fix IE memory leaks\r\n\t\t\t\t\tif (tinymce.isIE) {\r\n\t\t\t\t\t\tfunction clr() {\r\n\t\t\t\t\t\t\ted.destroy();\r\n\t\t\t\t\t\t\tw.detachEvent('onunload', clr);\r\n\t\t\t\t\t\t\tw = w.tinyMCE = w.tinymce = null; // IE leak\r\n\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\tw.attachEvent('onunload', clr);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tv.page_window = null;\r\n\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\tcase \"mceRemoveEditor\":\r\n\t\t\t\tcase \"mceRemoveControl\":\r\n\t\t\t\t\tif (ed)\r\n\t\t\t\t\t\ted.remove();\r\n\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\tcase 'mceToggleEditor':\r\n\t\t\t\t\tif (!ed) {\r\n\t\t\t\t\t\tt.execCommand('mceAddControl', 0, v);\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (ed.isHidden())\r\n\t\t\t\t\t\ted.show();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\ted.hide();\r\n\r\n\t\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\t// Run command on active editor\r\n\t\t\tif (t.activeEditor)\r\n\t\t\t\treturn t.activeEditor.execCommand(c, u, v);\r\n\r\n\t\t\treturn false;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Executes a command on a specific editor by id. This method was added for compatibility with the 2.x branch.\r\n\t\t *\r\n\t\t * @deprecated Use the execCommand method of a editor instance instead.\r\n\t\t * @method execInstanceCommand\r\n\t\t * @param {String} id Editor id to perform the command on.\r\n\t\t * @param {String} c Command to perform for example Bold.\r\n\t\t * @param {Boolean} u Optional boolean state if a UI should be presented for the command or not.\r\n\t\t * @param {String} v Optional value parameter like for example an URL to a link.\r\n\t\t * @return {Boolean} true/false if the command was executed or not.\r\n\t\t */\r\n\t\texecInstanceCommand : function(id, c, u, v) {\r\n\t\t\tvar ed = this.get(id);\r\n\r\n\t\t\tif (ed)\r\n\t\t\t\treturn ed.execCommand(c, u, v);\r\n\r\n\t\t\treturn false;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Calls the save method on all editor instances in the collection. This can be useful when a form is to be submitted.\r\n\t\t *\r\n\t\t * @method triggerSave\r\n\t\t * @example\r\n\t\t * // Saves all contents\r\n\t\t * tinyMCE.triggerSave();\r\n\t\t */\r\n\t\ttriggerSave : function() {\r\n\t\t\teach(this.editors, function(e) {\r\n\t\t\t\te.save();\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Adds a language pack, this gets called by the loaded language files like en.js.\r\n\t\t *\r\n\t\t * @method addI18n\r\n\t\t * @param {String} p Prefix for the language items. For example en.myplugin\r\n\t\t * @param {Object} o Name/Value collection with items to add to the language group.\r\n\t\t */\r\n\t\taddI18n : function(p, o) {\r\n\t\t\tvar lo, i18n = this.i18n;\r\n\r\n\t\t\tif (!tinymce.is(p, 'string')) {\r\n\t\t\t\teach(p, function(o, lc) {\r\n\t\t\t\t\teach(o, function(o, g) {\r\n\t\t\t\t\t\teach(o, function(o, k) {\r\n\t\t\t\t\t\t\tif (g === 'common')\r\n\t\t\t\t\t\t\t\ti18n[lc + '.' + k] = o;\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\ti18n[lc + '.' + g + '.' + k] = o;\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t});\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\teach(o, function(o, k) {\r\n\t\t\t\t\ti18n[p + '.' + k] = o;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t// Private methods\r\n\r\n\t\t_setActive : function(editor) {\r\n\t\t\tthis.selectedInstance = this.activeEditor = editor;\r\n\t\t}\r\n\t});\r\n})(tinymce);\r\n\r\n/**\r\n * Alternative name for tinymce added for 2.x compatibility.\r\n *\r\n * @member\r\n * @property tinyMCE\r\n * @type tinymce\r\n * @example\r\n * // To initialize editor instances\r\n * tinyMCE.init({\r\n *    ...\r\n * });\r\n */\r\n\r\n/**\r\n * Alternative name for tinymce added for compatibility.\r\n *\r\n * @member tinymce\r\n * @property EditorManager\r\n * @type tinymce\r\n * @example\r\n * // To initialize editor instances\r\n * tinymce.EditorManager.get('editor');\r\n */\r\n","Magento_Tinymce3/tiny_mce/classes/ForceBlocks.js":"/**\r\n * ForceBlocks.js\r\n *\r\n * Copyright 2009, Moxiecode Systems AB\r\n * Released under LGPL License.\r\n *\r\n * License: http://tinymce.moxiecode.com/license\r\n * Contributing: http://tinymce.moxiecode.com/contributing\r\n */\r\n\r\n(function(tinymce) {\r\n\t// Shorten names\r\n\tvar Event = tinymce.dom.Event,\r\n\t\tisIE = tinymce.isIE,\r\n\t\tisGecko = tinymce.isGecko,\r\n\t\tisOpera = tinymce.isOpera,\r\n\t\teach = tinymce.each,\r\n\t\textend = tinymce.extend,\r\n\t\tTRUE = true,\r\n\t\tFALSE = false;\r\n\r\n\tfunction cloneFormats(node) {\r\n\t\tvar clone, temp, inner;\r\n\r\n\t\tdo {\r\n\t\t\tif (/^(SPAN|STRONG|B|EM|I|FONT|STRIKE|U)$/.test(node.nodeName)) {\r\n\t\t\t\tif (clone) {\r\n\t\t\t\t\ttemp = node.cloneNode(false);\r\n\t\t\t\t\ttemp.appendChild(clone);\r\n\t\t\t\t\tclone = temp;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tclone = inner = node.cloneNode(false);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tclone.removeAttribute('id');\r\n\t\t\t}\r\n\t\t} while (node = node.parentNode);\r\n\r\n\t\tif (clone)\r\n\t\t\treturn {wrapper : clone, inner : inner};\r\n\t};\r\n\r\n\t// Checks if the selection/caret is at the end of the specified block element\r\n\tfunction isAtEnd(rng, par) {\r\n\t\tvar rng2 = par.ownerDocument.createRange();\r\n\r\n\t\trng2.setStart(rng.endContainer, rng.endOffset);\r\n\t\trng2.setEndAfter(par);\r\n\r\n\t\t// Get number of characters to the right of the cursor if it's zero then we are at the end and need to merge the next block element\r\n\t\treturn rng2.cloneContents().textContent.length == 0;\r\n\t};\r\n\r\n\tfunction splitList(selection, dom, li) {\r\n\t\tvar listBlock, block;\r\n\r\n\t\tif (dom.isEmpty(li)) {\r\n\t\t\tlistBlock = dom.getParent(li, 'ul,ol');\r\n\r\n\t\t\tif (!dom.getParent(listBlock.parentNode, 'ul,ol')) {\r\n\t\t\t\tdom.split(listBlock, li);\r\n\t\t\t\tblock = dom.create('p', 0, '<br data-mce-bogus=\"1\" />');\r\n\t\t\t\tdom.replace(block, li);\r\n\t\t\t\tselection.select(block, 1);\r\n\t\t\t}\r\n\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\r\n\t\treturn TRUE;\r\n\t};\r\n\r\n\t/**\r\n\t * This is a internal class and no method in this class should be called directly form the out side.\r\n\t */\r\n\ttinymce.create('tinymce.ForceBlocks', {\r\n\t\tForceBlocks : function(ed) {\r\n\t\t\tvar t = this, s = ed.settings, elm;\r\n\r\n\t\t\tt.editor = ed;\r\n\t\t\tt.dom = ed.dom;\r\n\t\t\telm = (s.forced_root_block || 'p').toLowerCase();\r\n\t\t\ts.element = elm.toUpperCase();\r\n\r\n\t\t\ted.onPreInit.add(t.setup, t);\r\n\t\t},\r\n\r\n\t\tsetup : function() {\r\n\t\t\tvar t = this, ed = t.editor, s = ed.settings, dom = ed.dom, selection = ed.selection, blockElements = ed.schema.getBlockElements();\r\n\r\n\t\t\t// Force root blocks\r\n\t\t\tif (s.forced_root_block) {\r\n\t\t\t\tfunction addRootBlocks() {\r\n\t\t\t\t\tvar node = selection.getStart(), rootNode = ed.getBody(), rng, startContainer, startOffset, endContainer, endOffset, rootBlockNode, tempNode, offset = -0xFFFFFF;\r\n\r\n\t\t\t\t\tif (!node || node.nodeType !== 1)\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t// Check if node is wrapped in block\r\n\t\t\t\t\twhile (node != rootNode) {\r\n\t\t\t\t\t\tif (blockElements[node.nodeName])\r\n\t\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t\tnode = node.parentNode;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Get current selection\r\n\t\t\t\t\trng = selection.getRng();\r\n\t\t\t\t\tif (rng.setStart) {\r\n\t\t\t\t\t\tstartContainer = rng.startContainer;\r\n\t\t\t\t\t\tstartOffset = rng.startOffset;\r\n\t\t\t\t\t\tendContainer = rng.endContainer;\r\n\t\t\t\t\t\tendOffset = rng.endOffset;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// Force control range into text range\r\n\t\t\t\t\t\tif (rng.item) {\r\n\t\t\t\t\t\t\trng = ed.getDoc().body.createTextRange();\r\n\t\t\t\t\t\t\trng.moveToElementText(rng.item(0));\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\ttmpRng = rng.duplicate();\r\n\t\t\t\t\t\ttmpRng.collapse(true);\r\n\t\t\t\t\t\tstartOffset = tmpRng.move('character', offset) * -1;\r\n\r\n\t\t\t\t\t\tif (!tmpRng.collapsed) {\r\n\t\t\t\t\t\t\ttmpRng = rng.duplicate();\r\n\t\t\t\t\t\t\ttmpRng.collapse(false);\r\n\t\t\t\t\t\t\tendOffset = (tmpRng.move('character', offset) * -1) - startOffset;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Wrap non block elements and text nodes\r\n\t\t\t\t\tfor (node = rootNode.firstChild; node; node) {\r\n\t\t\t\t\t\tif (node.nodeType === 3 || (node.nodeType == 1 && !blockElements[node.nodeName])) {\r\n\t\t\t\t\t\t\tif (!rootBlockNode) {\r\n\t\t\t\t\t\t\t\trootBlockNode = dom.create(s.forced_root_block);\r\n\t\t\t\t\t\t\t\tnode.parentNode.insertBefore(rootBlockNode, node);\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\ttempNode = node;\r\n\t\t\t\t\t\t\tnode = node.nextSibling;\r\n\t\t\t\t\t\t\trootBlockNode.appendChild(tempNode);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\trootBlockNode = null;\r\n\t\t\t\t\t\t\tnode = node.nextSibling;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (rng.setStart) {\r\n\t\t\t\t\t\trng.setStart(startContainer, startOffset);\r\n\t\t\t\t\t\trng.setEnd(endContainer, endOffset);\r\n\t\t\t\t\t\tselection.setRng(rng);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\trng = ed.getDoc().body.createTextRange();\r\n\t\t\t\t\t\t\trng.moveToElementText(rootNode);\r\n\t\t\t\t\t\t\trng.collapse(true);\r\n\t\t\t\t\t\t\trng.moveStart('character', startOffset);\r\n\r\n\t\t\t\t\t\t\tif (endOffset > 0)\r\n\t\t\t\t\t\t\t\trng.moveEnd('character', endOffset);\r\n\r\n\t\t\t\t\t\t\trng.select();\r\n\t\t\t\t\t\t} catch (ex) {\r\n\t\t\t\t\t\t\t// Ignore\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ted.nodeChanged();\r\n\t\t\t\t};\r\n\r\n\t\t\t\ted.onKeyUp.add(addRootBlocks);\r\n\t\t\t\ted.onClick.add(addRootBlocks);\r\n\t\t\t}\r\n\r\n\t\t\tif (s.force_br_newlines) {\r\n\t\t\t\t// Force IE to produce BRs on enter\r\n\t\t\t\tif (isIE) {\r\n\t\t\t\t\ted.onKeyPress.add(function(ed, e) {\r\n\t\t\t\t\t\tvar n;\r\n\r\n\t\t\t\t\t\tif (e.keyCode == 13 && selection.getNode().nodeName != 'LI') {\r\n\t\t\t\t\t\t\tselection.setContent('<br id=\"__\" /> ', {format : 'raw'});\r\n\t\t\t\t\t\t\tn = dom.get('__');\r\n\t\t\t\t\t\t\tn.removeAttribute('id');\r\n\t\t\t\t\t\t\tselection.select(n);\r\n\t\t\t\t\t\t\tselection.collapse();\r\n\t\t\t\t\t\t\treturn Event.cancel(e);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (s.force_p_newlines) {\r\n\t\t\t\tif (!isIE) {\r\n\t\t\t\t\ted.onKeyPress.add(function(ed, e) {\r\n\t\t\t\t\t\tif (e.keyCode == 13 && !e.shiftKey && !t.insertPara(e))\r\n\t\t\t\t\t\t\tEvent.cancel(e);\r\n\t\t\t\t\t});\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Ungly hack to for IE to preserve the formatting when you press\r\n\t\t\t\t\t// enter at the end of a block element with formatted contents\r\n\t\t\t\t\t// This logic overrides the browsers default logic with\r\n\t\t\t\t\t// custom logic that enables us to control the output\r\n\t\t\t\t\ttinymce.addUnload(function() {\r\n\t\t\t\t\t\tt._previousFormats = 0; // Fix IE leak\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\ted.onKeyPress.add(function(ed, e) {\r\n\t\t\t\t\t\tt._previousFormats = 0;\r\n\r\n\t\t\t\t\t\t// Clone the current formats, this will later be applied to the new block contents\r\n\t\t\t\t\t\tif (e.keyCode == 13 && !e.shiftKey && ed.selection.isCollapsed() && s.keep_styles)\r\n\t\t\t\t\t\t\tt._previousFormats = cloneFormats(ed.selection.getStart());\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\ted.onKeyUp.add(function(ed, e) {\r\n\t\t\t\t\t\t// Let IE break the element and the wrap the new caret location in the previous formats\r\n\t\t\t\t\t\tif (e.keyCode == 13 && !e.shiftKey) {\r\n\t\t\t\t\t\t\tvar parent = ed.selection.getStart(), fmt = t._previousFormats;\r\n\r\n\t\t\t\t\t\t\t// Parent is an empty block\r\n\t\t\t\t\t\t\tif (!parent.hasChildNodes() && fmt) {\r\n\t\t\t\t\t\t\t\tparent = dom.getParent(parent, dom.isBlock);\r\n\r\n\t\t\t\t\t\t\t\tif (parent && parent.nodeName != 'LI') {\r\n\t\t\t\t\t\t\t\t\tparent.innerHTML = '';\r\n\r\n\t\t\t\t\t\t\t\t\tif (t._previousFormats) {\r\n\t\t\t\t\t\t\t\t\t\tparent.appendChild(fmt.wrapper);\r\n\t\t\t\t\t\t\t\t\t\tfmt.inner.innerHTML = '\\uFEFF';\r\n\t\t\t\t\t\t\t\t\t} else\r\n\t\t\t\t\t\t\t\t\t\tparent.innerHTML = '\\uFEFF';\r\n\r\n\t\t\t\t\t\t\t\t\tselection.select(parent, 1);\r\n\t\t\t\t\t\t\t\t\tselection.collapse(true);\r\n\t\t\t\t\t\t\t\t\ted.getDoc().execCommand('Delete', false, null);\r\n\t\t\t\t\t\t\t\t\tt._previousFormats = 0;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (isGecko) {\r\n\t\t\t\t\ted.onKeyDown.add(function(ed, e) {\r\n\t\t\t\t\t\tif ((e.keyCode == 8 || e.keyCode == 46) && !e.shiftKey)\r\n\t\t\t\t\t\t\tt.backspaceDelete(e, e.keyCode == 8);\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Workaround for missing shift+enter support, http://bugs.webkit.org/show_bug.cgi?id=16973\r\n\t\t\tif (tinymce.isWebKit) {\r\n\t\t\t\tfunction insertBr(ed) {\r\n\t\t\t\t\tvar rng = selection.getRng(), br, div = dom.create('div', null, ' '), divYPos, vpHeight = dom.getViewPort(ed.getWin()).h;\r\n\r\n\t\t\t\t\t// Insert BR element\r\n\t\t\t\t\trng.insertNode(br = dom.create('br'));\r\n\r\n\t\t\t\t\t// Place caret after BR\r\n\t\t\t\t\trng.setStartAfter(br);\r\n\t\t\t\t\trng.setEndAfter(br);\r\n\t\t\t\t\tselection.setRng(rng);\r\n\r\n\t\t\t\t\t// Could not place caret after BR then insert an nbsp entity and move the caret\r\n\t\t\t\t\tif (selection.getSel().focusNode == br.previousSibling) {\r\n\t\t\t\t\t\tselection.select(dom.insertAfter(dom.doc.createTextNode('\\u00a0'), br));\r\n\t\t\t\t\t\tselection.collapse(TRUE);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Create a temporary DIV after the BR and get the position as it\r\n\t\t\t\t\t// seems like getPos() returns 0 for text nodes and BR elements.\r\n\t\t\t\t\tdom.insertAfter(div, br);\r\n\t\t\t\t\tdivYPos = dom.getPos(div).y;\r\n\t\t\t\t\tdom.remove(div);\r\n\r\n\t\t\t\t\t// Scroll to new position, scrollIntoView can't be used due to bug: http://bugs.webkit.org/show_bug.cgi?id=16117\r\n\t\t\t\t\tif (divYPos > vpHeight) // It is not necessary to scroll if the DIV is inside the view port.\r\n\t\t\t\t\t\ted.getWin().scrollTo(0, divYPos);\r\n\t\t\t\t};\r\n\r\n\t\t\t\ted.onKeyPress.add(function(ed, e) {\r\n\t\t\t\t\tif (e.keyCode == 13 && (e.shiftKey || (s.force_br_newlines && !dom.getParent(selection.getNode(), 'h1,h2,h3,h4,h5,h6,ol,ul')))) {\r\n\t\t\t\t\t\tinsertBr(ed);\r\n\t\t\t\t\t\tEvent.cancel(e);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// IE specific fixes\r\n\t\t\tif (isIE) {\r\n\t\t\t\t// Replaces IE:s auto generated paragraphs with the specified element name\r\n\t\t\t\tif (s.element != 'P') {\r\n\t\t\t\t\ted.onKeyPress.add(function(ed, e) {\r\n\t\t\t\t\t\tt.lastElm = selection.getNode().nodeName;\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\ted.onKeyUp.add(function(ed, e) {\r\n\t\t\t\t\t\tvar bl, n = selection.getNode(), b = ed.getBody();\r\n\r\n\t\t\t\t\t\tif (b.childNodes.length === 1 && n.nodeName == 'P') {\r\n\t\t\t\t\t\t\tn = dom.rename(n, s.element);\r\n\t\t\t\t\t\t\tselection.select(n);\r\n\t\t\t\t\t\t\tselection.collapse();\r\n\t\t\t\t\t\t\ted.nodeChanged();\r\n\t\t\t\t\t\t} else if (e.keyCode == 13 && !e.shiftKey && t.lastElm != 'P') {\r\n\t\t\t\t\t\t\tbl = dom.getParent(n, 'p');\r\n\r\n\t\t\t\t\t\t\tif (bl) {\r\n\t\t\t\t\t\t\t\tdom.rename(bl, s.element);\r\n\t\t\t\t\t\t\t\ted.nodeChanged();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tgetParentBlock : function(n) {\r\n\t\t\tvar d = this.dom;\r\n\r\n\t\t\treturn d.getParent(n, d.isBlock);\r\n\t\t},\r\n\r\n\t\tinsertPara : function(e) {\r\n\t\t\tvar t = this, ed = t.editor, dom = ed.dom, d = ed.getDoc(), se = ed.settings, s = ed.selection.getSel(), r = s.getRangeAt(0), b = d.body;\r\n\t\t\tvar rb, ra, dir, sn, so, en, eo, sb, eb, bn, bef, aft, sc, ec, n, vp = dom.getViewPort(ed.getWin()), y, ch, car;\r\n\r\n\t\t\ted.undoManager.beforeChange();\r\n\r\n\t\t\t// If root blocks are forced then use Operas default behavior since it's really good\r\n// Removed due to bug: #1853816\r\n//\t\t\tif (se.forced_root_block && isOpera)\r\n//\t\t\t\treturn TRUE;\r\n\r\n\t\t\t// Setup before range\r\n\t\t\trb = d.createRange();\r\n\r\n\t\t\t// If is before the first block element and in body, then move it into first block element\r\n\t\t\trb.setStart(s.anchorNode, s.anchorOffset);\r\n\t\t\trb.collapse(TRUE);\r\n\r\n\t\t\t// Setup after range\r\n\t\t\tra = d.createRange();\r\n\r\n\t\t\t// If is before the first block element and in body, then move it into first block element\r\n\t\t\tra.setStart(s.focusNode, s.focusOffset);\r\n\t\t\tra.collapse(TRUE);\r\n\r\n\t\t\t// Setup start/end points\r\n\t\t\tdir = rb.compareBoundaryPoints(rb.START_TO_END, ra) < 0;\r\n\t\t\tsn = dir ? s.anchorNode : s.focusNode;\r\n\t\t\tso = dir ? s.anchorOffset : s.focusOffset;\r\n\t\t\ten = dir ? s.focusNode : s.anchorNode;\r\n\t\t\teo = dir ? s.focusOffset : s.anchorOffset;\r\n\r\n\t\t\t// If selection is in empty table cell\r\n\t\t\tif (sn === en && /^(TD|TH)$/.test(sn.nodeName)) {\r\n\t\t\t\tif (sn.firstChild.nodeName == 'BR')\r\n\t\t\t\t\tdom.remove(sn.firstChild); // Remove BR\r\n\r\n\t\t\t\t// Create two new block elements\r\n\t\t\t\tif (sn.childNodes.length == 0) {\r\n\t\t\t\t\ted.dom.add(sn, se.element, null, '<br />');\r\n\t\t\t\t\taft = ed.dom.add(sn, se.element, null, '<br />');\r\n\t\t\t\t} else {\r\n\t\t\t\t\tn = sn.innerHTML;\r\n\t\t\t\t\tsn.innerHTML = '';\r\n\t\t\t\t\ted.dom.add(sn, se.element, null, n);\r\n\t\t\t\t\taft = ed.dom.add(sn, se.element, null, '<br />');\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Move caret into the last one\r\n\t\t\t\tr = d.createRange();\r\n\t\t\t\tr.selectNodeContents(aft);\r\n\t\t\t\tr.collapse(1);\r\n\t\t\t\ted.selection.setRng(r);\r\n\r\n\t\t\t\treturn FALSE;\r\n\t\t\t}\r\n\r\n\t\t\t// If the caret is in an invalid location in FF we need to move it into the first block\r\n\t\t\tif (sn == b && en == b && b.firstChild && ed.dom.isBlock(b.firstChild)) {\r\n\t\t\t\tsn = en = sn.firstChild;\r\n\t\t\t\tso = eo = 0;\r\n\t\t\t\trb = d.createRange();\r\n\t\t\t\trb.setStart(sn, 0);\r\n\t\t\t\tra = d.createRange();\r\n\t\t\t\tra.setStart(en, 0);\r\n\t\t\t}\r\n\r\n\t\t\t// If the body is totally empty add a BR element this might happen on webkit\r\n\t\t\tif (!d.body.hasChildNodes()) {\r\n\t\t\t\td.body.appendChild(dom.create('br'));\r\n\t\t\t}\r\n\r\n\t\t\t// Never use body as start or end node\r\n\t\t\tsn = sn.nodeName == \"HTML\" ? d.body : sn; // Fix for Opera bug: https://bugs.opera.com/show_bug.cgi?id=273224&comments=yes\r\n\t\t\tsn = sn.nodeName == \"BODY\" ? sn.firstChild : sn;\r\n\t\t\ten = en.nodeName == \"HTML\" ? d.body : en; // Fix for Opera bug: https://bugs.opera.com/show_bug.cgi?id=273224&comments=yes\r\n\t\t\ten = en.nodeName == \"BODY\" ? en.firstChild : en;\r\n\r\n\t\t\t// Get start and end blocks\r\n\t\t\tsb = t.getParentBlock(sn);\r\n\t\t\teb = t.getParentBlock(en);\r\n\t\t\tbn = sb ? sb.nodeName : se.element; // Get block name to create\r\n\r\n\t\t\t// Return inside list use default browser behavior\r\n\t\t\tif (n = t.dom.getParent(sb, 'li,pre')) {\r\n\t\t\t\tif (n.nodeName == 'LI')\r\n\t\t\t\t\treturn splitList(ed.selection, t.dom, n);\r\n\r\n\t\t\t\treturn TRUE;\r\n\t\t\t}\r\n\r\n\t\t\t// If caption or absolute layers then always generate new blocks within\r\n\t\t\tif (sb && (sb.nodeName == 'CAPTION' || /absolute|relative|fixed/gi.test(dom.getStyle(sb, 'position', 1)))) {\r\n\t\t\t\tbn = se.element;\r\n\t\t\t\tsb = null;\r\n\t\t\t}\r\n\r\n\t\t\t// If caption or absolute layers then always generate new blocks within\r\n\t\t\tif (eb && (eb.nodeName == 'CAPTION' || /absolute|relative|fixed/gi.test(dom.getStyle(sb, 'position', 1)))) {\r\n\t\t\t\tbn = se.element;\r\n\t\t\t\teb = null;\r\n\t\t\t}\r\n\r\n\t\t\t// Use P instead\r\n\t\t\tif (/(TD|TABLE|TH|CAPTION)/.test(bn) || (sb && bn == \"DIV\" && /left|right/gi.test(dom.getStyle(sb, 'float', 1)))) {\r\n\t\t\t\tbn = se.element;\r\n\t\t\t\tsb = eb = null;\r\n\t\t\t}\r\n\r\n\t\t\t// Setup new before and after blocks\r\n\t\t\tbef = (sb && sb.nodeName == bn) ? sb.cloneNode(0) : ed.dom.create(bn);\r\n\t\t\taft = (eb && eb.nodeName == bn) ? eb.cloneNode(0) : ed.dom.create(bn);\r\n\r\n\t\t\t// Remove id from after clone\r\n\t\t\taft.removeAttribute('id');\r\n\r\n\t\t\t// Is header and cursor is at the end, then force paragraph under\r\n\t\t\tif (/^(H[1-6])$/.test(bn) && isAtEnd(r, sb))\r\n\t\t\t\taft = ed.dom.create(se.element);\r\n\r\n\t\t\t// Find start chop node\r\n\t\t\tn = sc = sn;\r\n\t\t\tdo {\r\n\t\t\t\tif (n == b || n.nodeType == 9 || t.dom.isBlock(n) || /(TD|TABLE|TH|CAPTION)/.test(n.nodeName))\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tsc = n;\r\n\t\t\t} while ((n = n.previousSibling ? n.previousSibling : n.parentNode));\r\n\r\n\t\t\t// Find end chop node\r\n\t\t\tn = ec = en;\r\n\t\t\tdo {\r\n\t\t\t\tif (n == b || n.nodeType == 9 || t.dom.isBlock(n) || /(TD|TABLE|TH|CAPTION)/.test(n.nodeName))\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tec = n;\r\n\t\t\t} while ((n = n.nextSibling ? n.nextSibling : n.parentNode));\r\n\r\n\t\t\t// Place first chop part into before block element\r\n\t\t\tif (sc.nodeName == bn)\r\n\t\t\t\trb.setStart(sc, 0);\r\n\t\t\telse\r\n\t\t\t\trb.setStartBefore(sc);\r\n\r\n\t\t\trb.setEnd(sn, so);\r\n\t\t\tbef.appendChild(rb.cloneContents() || d.createTextNode('')); // Empty text node needed for Safari\r\n\r\n\t\t\t// Place secnd chop part within new block element\r\n\t\t\ttry {\r\n\t\t\t\tra.setEndAfter(ec);\r\n\t\t\t} catch(ex) {\r\n\t\t\t\t//console.debug(s.focusNode, s.focusOffset);\r\n\t\t\t}\r\n\r\n\t\t\tra.setStart(en, eo);\r\n\t\t\taft.appendChild(ra.cloneContents() || d.createTextNode('')); // Empty text node needed for Safari\r\n\r\n\t\t\t// Create range around everything\r\n\t\t\tr = d.createRange();\r\n\t\t\tif (!sc.previousSibling && sc.parentNode.nodeName == bn) {\r\n\t\t\t\tr.setStartBefore(sc.parentNode);\r\n\t\t\t} else {\r\n\t\t\t\tif (rb.startContainer.nodeName == bn && rb.startOffset == 0)\r\n\t\t\t\t\tr.setStartBefore(rb.startContainer);\r\n\t\t\t\telse\r\n\t\t\t\t\tr.setStart(rb.startContainer, rb.startOffset);\r\n\t\t\t}\r\n\r\n\t\t\tif (!ec.nextSibling && ec.parentNode.nodeName == bn)\r\n\t\t\t\tr.setEndAfter(ec.parentNode);\r\n\t\t\telse\r\n\t\t\t\tr.setEnd(ra.endContainer, ra.endOffset);\r\n\r\n\t\t\t// Delete and replace it with new block elements\r\n\t\t\tr.deleteContents();\r\n\r\n\t\t\tif (isOpera)\r\n\t\t\t\ted.getWin().scrollTo(0, vp.y);\r\n\r\n\t\t\t// Never wrap blocks in blocks\r\n\t\t\tif (bef.firstChild && bef.firstChild.nodeName == bn)\r\n\t\t\t\tbef.innerHTML = bef.firstChild.innerHTML;\r\n\r\n\t\t\tif (aft.firstChild && aft.firstChild.nodeName == bn)\r\n\t\t\t\taft.innerHTML = aft.firstChild.innerHTML;\r\n\r\n\t\t\tfunction appendStyles(e, en) {\r\n\t\t\t\tvar nl = [], nn, n, i;\r\n\r\n\t\t\t\te.innerHTML = '';\r\n\r\n\t\t\t\t// Make clones of style elements\r\n\t\t\t\tif (se.keep_styles) {\r\n\t\t\t\t\tn = en;\r\n\t\t\t\t\tdo {\r\n\t\t\t\t\t\t// We only want style specific elements\r\n\t\t\t\t\t\tif (/^(SPAN|STRONG|B|EM|I|FONT|STRIKE|U)$/.test(n.nodeName)) {\r\n\t\t\t\t\t\t\tnn = n.cloneNode(FALSE);\r\n\t\t\t\t\t\t\tdom.setAttrib(nn, 'id', ''); // Remove ID since it needs to be unique\r\n\t\t\t\t\t\t\tnl.push(nn);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} while (n = n.parentNode);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Append style elements to aft\r\n\t\t\t\tif (nl.length > 0) {\r\n\t\t\t\t\tfor (i = nl.length - 1, nn = e; i >= 0; i--)\r\n\t\t\t\t\t\tnn = nn.appendChild(nl[i]);\r\n\r\n\t\t\t\t\t// Padd most inner style element\r\n\t\t\t\t\tnl[0].innerHTML = isOpera ? '\\u00a0' : '<br />'; // Extra space for Opera so that the caret can move there\r\n\t\t\t\t\treturn nl[0]; // Move caret to most inner element\r\n\t\t\t\t} else\r\n\t\t\t\t\te.innerHTML = isOpera ? '\\u00a0' : '<br />'; // Extra space for Opera so that the caret can move there\r\n\t\t\t};\r\n\t\t\t\t\r\n\t\t\t// Padd empty blocks\r\n\t\t\tif (dom.isEmpty(bef))\r\n\t\t\t\tappendStyles(bef, sn);\r\n\r\n\t\t\t// Fill empty afterblook with current style\r\n\t\t\tif (dom.isEmpty(aft))\r\n\t\t\t\tcar = appendStyles(aft, en);\r\n\r\n\t\t\t// Opera needs this one backwards for older versions\r\n\t\t\tif (isOpera && parseFloat(opera.version()) < 9.5) {\r\n\t\t\t\tr.insertNode(bef);\r\n\t\t\t\tr.insertNode(aft);\r\n\t\t\t} else {\r\n\t\t\t\tr.insertNode(aft);\r\n\t\t\t\tr.insertNode(bef);\r\n\t\t\t}\r\n\r\n\t\t\t// Normalize\r\n\t\t\taft.normalize();\r\n\t\t\tbef.normalize();\r\n\r\n\t\t\t// Move cursor and scroll into view\r\n\t\t\ted.selection.select(aft, true);\r\n\t\t\ted.selection.collapse(true);\r\n\r\n\t\t\t// scrollIntoView seems to scroll the parent window in most browsers now including FF 3.0b4 so it's time to stop using it and do it our selfs\r\n\t\t\ty = ed.dom.getPos(aft).y;\r\n\t\t\t//ch = aft.clientHeight;\r\n\r\n\t\t\t// Is element within viewport\r\n\t\t\tif (y < vp.y || y + 25 > vp.y + vp.h) {\r\n\t\t\t\ted.getWin().scrollTo(0, y < vp.y ? y : y - vp.h + 25); // Needs to be hardcoded to roughly one line of text if a huge text block is broken into two blocks\r\n\r\n\t\t\t\t/*console.debug(\r\n\t\t\t\t\t'Element: y=' + y + ', h=' + ch + ', ' +\r\n\t\t\t\t\t'Viewport: y=' + vp.y + \", h=\" + vp.h + ', bottom=' + (vp.y + vp.h)\r\n\t\t\t\t);*/\r\n\t\t\t}\r\n\r\n\t\t\ted.undoManager.add();\r\n\r\n\t\t\treturn FALSE;\r\n\t\t},\r\n\r\n\t\tbackspaceDelete : function(e, bs) {\r\n\t\t\tvar t = this, ed = t.editor, b = ed.getBody(), dom = ed.dom, n, se = ed.selection, r = se.getRng(), sc = r.startContainer, n, w, tn, walker;\r\n\r\n\t\t\t// Delete when caret is behind a element doesn't work correctly on Gecko see #3011651\r\n\t\t\tif (!bs && r.collapsed && sc.nodeType == 1 && r.startOffset == sc.childNodes.length) {\r\n\t\t\t\twalker = new tinymce.dom.TreeWalker(sc.lastChild, sc);\r\n\r\n\t\t\t\t// Walk the dom backwards until we find a text node\r\n\t\t\t\tfor (n = sc.lastChild; n; n = walker.prev()) {\r\n\t\t\t\t\tif (n.nodeType == 3) {\r\n\t\t\t\t\t\tr.setStart(n, n.nodeValue.length);\r\n\t\t\t\t\t\tr.collapse(true);\r\n\t\t\t\t\t\tse.setRng(r);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// The caret sometimes gets stuck in Gecko if you delete empty paragraphs\r\n\t\t\t// This workaround removes the element by hand and moves the caret to the previous element\r\n\t\t\tif (sc && ed.dom.isBlock(sc) && !/^(TD|TH)$/.test(sc.nodeName) && bs) {\r\n\t\t\t\tif (sc.childNodes.length == 0 || (sc.childNodes.length == 1 && sc.firstChild.nodeName == 'BR')) {\r\n\t\t\t\t\t// Find previous block element\r\n\t\t\t\t\tn = sc;\r\n\t\t\t\t\twhile ((n = n.previousSibling) && !ed.dom.isBlock(n)) ;\r\n\r\n\t\t\t\t\tif (n) {\r\n\t\t\t\t\t\tif (sc != b.firstChild) {\r\n\t\t\t\t\t\t\t// Find last text node\r\n\t\t\t\t\t\t\tw = ed.dom.doc.createTreeWalker(n, NodeFilter.SHOW_TEXT, null, FALSE);\r\n\t\t\t\t\t\t\twhile (tn = w.nextNode())\r\n\t\t\t\t\t\t\t\tn = tn;\r\n\r\n\t\t\t\t\t\t\t// Place caret at the end of last text node\r\n\t\t\t\t\t\t\tr = ed.getDoc().createRange();\r\n\t\t\t\t\t\t\tr.setStart(n, n.nodeValue ? n.nodeValue.length : 0);\r\n\t\t\t\t\t\t\tr.setEnd(n, n.nodeValue ? n.nodeValue.length : 0);\r\n\t\t\t\t\t\t\tse.setRng(r);\r\n\r\n\t\t\t\t\t\t\t// Remove the target container\r\n\t\t\t\t\t\t\ted.dom.remove(sc);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn Event.cancel(e);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n})(tinymce);\r\n","Magento_Tinymce3/tiny_mce/classes/Formatter.js":"/**\r\n * Formatter.js\r\n *\r\n * Copyright 2009, Moxiecode Systems AB\r\n * Released under LGPL License.\r\n *\r\n * License: http://tinymce.moxiecode.com/license\r\n * Contributing: http://tinymce.moxiecode.com/contributing\r\n */\r\n\r\n(function(tinymce) {\r\n\t/**\r\n\t * Text formatter engine class. This class is used to apply formats like bold, italic, font size\r\n\t * etc to the current selection or specific nodes. This engine was build to replace the browsers\r\n\t * default formatting logic for execCommand due to it's inconsistant and buggy behavior.\r\n\t *\r\n\t * @class tinymce.Formatter\r\n\t * @example\r\n\t *  tinymce.activeEditor.formatter.register('mycustomformat', {\r\n\t *    inline : 'span',\r\n\t *    styles : {color : '#ff0000'}\r\n\t *  });\r\n\t *\r\n\t *  tinymce.activeEditor.formatter.apply('mycustomformat');\r\n\t */\r\n\r\n\t/**\r\n\t * Constructs a new formatter instance.\r\n\t *\r\n\t * @constructor Formatter\r\n\t * @param {tinymce.Editor} ed Editor instance to construct the formatter engine to.\r\n\t */\r\n\ttinymce.Formatter = function(ed) {\r\n\t\tvar formats = {},\r\n\t\t\teach = tinymce.each,\r\n\t\t\tdom = ed.dom,\r\n\t\t\tselection = ed.selection,\r\n\t\t\tTreeWalker = tinymce.dom.TreeWalker,\r\n\t\t\trangeUtils = new tinymce.dom.RangeUtils(dom),\r\n\t\t\tisValid = ed.schema.isValidChild,\r\n\t\t\tisBlock = dom.isBlock,\r\n\t\t\tforcedRootBlock = ed.settings.forced_root_block,\r\n\t\t\tnodeIndex = dom.nodeIndex,\r\n\t\t\tINVISIBLE_CHAR = '\\uFEFF',\r\n\t\t\tMCE_ATTR_RE = /^(src|href|style)$/,\r\n\t\t\tFALSE = false,\r\n\t\t\tTRUE = true,\r\n\t\t\tundefined;\r\n\r\n\t\tfunction isArray(obj) {\r\n\t\t\treturn obj instanceof Array;\r\n\t\t};\r\n\r\n\t\tfunction getParents(node, selector) {\r\n\t\t\treturn dom.getParents(node, selector, dom.getRoot());\r\n\t\t};\r\n\r\n\t\tfunction isCaretNode(node) {\r\n\t\t\treturn node.nodeType === 1 && (node.face === 'mceinline' || node.style.fontFamily === 'mceinline');\r\n\t\t};\r\n\r\n\t\t// Public functions\r\n\r\n\t\t/**\r\n\t\t * Returns the format by name or all formats if no name is specified.\r\n\t\t *\r\n\t\t * @method get\r\n\t\t * @param {String} name Optional name to retrieve by.\r\n\t\t * @return {Array/Object} Array/Object with all registered formats or a specific format.\r\n\t\t */\r\n\t\tfunction get(name) {\r\n\t\t\treturn name ? formats[name] : formats;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Registers a specific format by name.\r\n\t\t *\r\n\t\t * @method register\r\n\t\t * @param {Object/String} name Name of the format for example \"bold\".\r\n\t\t * @param {Object/Array} format Optional format object or array of format variants can only be omitted if the first arg is an object.\r\n\t\t */\r\n\t\tfunction register(name, format) {\r\n\t\t\tif (name) {\r\n\t\t\t\tif (typeof(name) !== 'string') {\r\n\t\t\t\t\teach(name, function(format, name) {\r\n\t\t\t\t\t\tregister(name, format);\r\n\t\t\t\t\t});\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Force format into array and add it to internal collection\r\n\t\t\t\t\tformat = format.length ? format : [format];\r\n\r\n\t\t\t\t\teach(format, function(format) {\r\n\t\t\t\t\t\t// Set deep to false by default on selector formats this to avoid removing\r\n\t\t\t\t\t\t// alignment on images inside paragraphs when alignment is changed on paragraphs\r\n\t\t\t\t\t\tif (format.deep === undefined)\r\n\t\t\t\t\t\t\tformat.deep = !format.selector;\r\n\r\n\t\t\t\t\t\t// Default to true\r\n\t\t\t\t\t\tif (format.split === undefined)\r\n\t\t\t\t\t\t\tformat.split = !format.selector || format.inline;\r\n\r\n\t\t\t\t\t\t// Default to true\r\n\t\t\t\t\t\tif (format.remove === undefined && format.selector && !format.inline)\r\n\t\t\t\t\t\t\tformat.remove = 'none';\r\n\r\n\t\t\t\t\t\t// Mark format as a mixed format inline + block level\r\n\t\t\t\t\t\tif (format.selector && format.inline) {\r\n\t\t\t\t\t\t\tformat.mixed = true;\r\n\t\t\t\t\t\t\tformat.block_expand = true;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Split classes if needed\r\n\t\t\t\t\t\tif (typeof(format.classes) === 'string')\r\n\t\t\t\t\t\t\tformat.classes = format.classes.split(/\\s+/);\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\tformats[name] = format;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tvar getTextDecoration = function(node) {\r\n\t\t\tvar decoration;\r\n\r\n\t\t\ted.dom.getParent(node, function(n) {\r\n\t\t\t\tdecoration = ed.dom.getStyle(n, 'text-decoration');\r\n\t\t\t\treturn decoration && decoration !== 'none';\r\n\t\t\t});\r\n\r\n\t\t\treturn decoration;\r\n\t\t};\r\n\r\n\t\tvar processUnderlineAndColor = function(node) {\r\n\t\t\tvar textDecoration;\r\n\t\t\tif (node.nodeType === 1 && node.parentNode && node.parentNode.nodeType === 1) {\r\n\t\t\t\ttextDecoration = getTextDecoration(node.parentNode);\r\n\t\t\t\tif (ed.dom.getStyle(node, 'color') && textDecoration) {\r\n\t\t\t\t\ted.dom.setStyle(node, 'text-decoration', textDecoration);\r\n\t\t\t\t} else if (ed.dom.getStyle(node, 'textdecoration') === textDecoration) {\r\n\t\t\t\t\ted.dom.setStyle(node, 'text-decoration', null);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Applies the specified format to the current selection or specified node.\r\n\t\t *\r\n\t\t * @method apply\r\n\t\t * @param {String} name Name of format to apply.\r\n\t\t * @param {Object} vars Optional list of variables to replace within format before applying it.\r\n\t\t * @param {Node} node Optional node to apply the format to defaults to current selection.\r\n\t\t */\r\n\t\tfunction apply(name, vars, node) {\r\n\t\t\tvar formatList = get(name), format = formatList[0], bookmark, rng, i, isCollapsed = selection.isCollapsed();\r\n\r\n\t\t\t/**\r\n\t\t\t * Moves the start to the first suitable text node.\r\n\t\t\t */\r\n\t\t\tfunction moveStart(rng) {\r\n\t\t\t\tvar container = rng.startContainer,\r\n\t\t\t\t\toffset = rng.startOffset,\r\n\t\t\t\t\twalker, node;\r\n\r\n\t\t\t\t// Move startContainer/startOffset in to a suitable node\r\n\t\t\t\tif (container.nodeType == 1 || container.nodeValue === \"\") {\r\n\t\t\t\t\tcontainer = container.nodeType == 1 ? container.childNodes[offset] : container;\r\n\r\n\t\t\t\t\t// Might fail if the offset is behind the last element in it's container\r\n\t\t\t\t\tif (container) {\r\n\t\t\t\t\t\twalker = new TreeWalker(container, container.parentNode);\r\n\t\t\t\t\t\tfor (node = walker.current(); node; node = walker.next()) {\r\n\t\t\t\t\t\t\tif (node.nodeType == 3 && !isWhiteSpaceNode(node)) {\r\n\t\t\t\t\t\t\t\trng.setStart(node, 0);\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn rng;\r\n\t\t\t};\r\n\r\n\t\t\tfunction setElementFormat(elm, fmt) {\r\n\t\t\t\tfmt = fmt || format;\r\n\r\n\t\t\t\tif (elm) {\r\n\t\t\t\t\tif (fmt.onformat) {\r\n\t\t\t\t\t\tfmt.onformat(elm, fmt, vars, node);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\teach(fmt.styles, function(value, name) {\r\n\t\t\t\t\t\tdom.setStyle(elm, name, replaceVars(value, vars));\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\teach(fmt.attributes, function(value, name) {\r\n\t\t\t\t\t\tdom.setAttrib(elm, name, replaceVars(value, vars));\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\teach(fmt.classes, function(value) {\r\n\t\t\t\t\t\tvalue = replaceVars(value, vars);\r\n\r\n\t\t\t\t\t\tif (!dom.hasClass(elm, value))\r\n\t\t\t\t\t\t\tdom.addClass(elm, value);\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tfunction adjustSelectionToVisibleSelection() {\r\n\t\t\t\tfunction findSelectionEnd(start, end) {\r\n\t\t\t\t\tvar walker = new TreeWalker(end);\r\n\t\t\t\t\tfor (node = walker.current(); node; node = walker.prev()) {\r\n\t\t\t\t\t\tif (node.childNodes.length > 1 || node == start) {\r\n\t\t\t\t\t\t\treturn node;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\r\n\t\t\t\t// Adjust selection so that a end container with a end offset of zero is not included in the selection\r\n\t\t\t\t// as this isn't visible to the user.\r\n\t\t\t\tvar rng = ed.selection.getRng();\r\n\t\t\t\tvar start = rng.startContainer;\r\n\t\t\t\tvar end = rng.endContainer;\r\n\r\n\t\t\t\tif (start != end && rng.endOffset == 0) {\r\n\t\t\t\t\tvar newEnd = findSelectionEnd(start, end);\r\n\t\t\t\t\tvar endOffset = newEnd.nodeType == 3 ? newEnd.length : newEnd.childNodes.length;\r\n\r\n\t\t\t\t\trng.setEnd(newEnd, endOffset);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn rng;\r\n\t\t\t}\r\n\r\n\t\t\tfunction applyStyleToList(node, bookmark, wrapElm, newWrappers, process){\r\n\t\t\t\tvar nodes = [], listIndex = -1, list, startIndex = -1, endIndex = -1, currentWrapElm;\r\n\r\n\t\t\t\t// find the index of the first child list.\r\n\t\t\t\teach(node.childNodes, function(n, index) {\r\n\t\t\t\t\tif (n.nodeName === \"UL\" || n.nodeName === \"OL\") {\r\n\t\t\t\t\t\tlistIndex = index;\r\n\t\t\t\t\t\tlist = n;\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// get the index of the bookmarks\r\n\t\t\t\teach(node.childNodes, function(n, index) {\r\n\t\t\t\t\tif (n.nodeName === \"SPAN\" && dom.getAttrib(n, \"data-mce-type\") == \"bookmark\") {\r\n\t\t\t\t\t\tif (n.id == bookmark.id + \"_start\") {\r\n\t\t\t\t\t\t\tstartIndex = index;\r\n\t\t\t\t\t\t} else if (n.id == bookmark.id + \"_end\") {\r\n\t\t\t\t\t\t\tendIndex = index;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// if the selection spans across an embedded list, or there isn't an embedded list - handle processing normally\r\n\t\t\t\tif (listIndex <= 0 || (startIndex < listIndex && endIndex > listIndex)) {\r\n\t\t\t\t\teach(tinymce.grep(node.childNodes), process);\r\n\t\t\t\t\treturn 0;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcurrentWrapElm = wrapElm.cloneNode(FALSE);\r\n\r\n\t\t\t\t\t// create a list of the nodes on the same side of the list as the selection\r\n\t\t\t\t\teach(tinymce.grep(node.childNodes), function(n, index) {\r\n\t\t\t\t\t\tif ((startIndex < listIndex && index < listIndex) || (startIndex > listIndex && index > listIndex)) {\r\n\t\t\t\t\t\t\tnodes.push(n);\r\n\t\t\t\t\t\t\tn.parentNode.removeChild(n);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\t// insert the wrapping element either before or after the list.\r\n\t\t\t\t\tif (startIndex < listIndex) {\r\n\t\t\t\t\t\tnode.insertBefore(currentWrapElm, list);\r\n\t\t\t\t\t} else if (startIndex > listIndex) {\r\n\t\t\t\t\t\tnode.insertBefore(currentWrapElm, list.nextSibling);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// add the new nodes to the list.\r\n\t\t\t\t\tnewWrappers.push(currentWrapElm);\r\n\r\n\t\t\t\t\teach(nodes, function(node) {\r\n\t\t\t\t\t\tcurrentWrapElm.appendChild(node);\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\treturn currentWrapElm;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tfunction applyRngStyle(rng, bookmark, node_specific) {\r\n\t\t\t\tvar newWrappers = [], wrapName, wrapElm;\r\n\r\n\t\t\t\t// Setup wrapper element\r\n\t\t\t\twrapName = format.inline || format.block;\r\n\t\t\t\twrapElm = dom.create(wrapName);\r\n\t\t\t\tsetElementFormat(wrapElm);\r\n\r\n\t\t\t\trangeUtils.walk(rng, function(nodes) {\r\n\t\t\t\t\tvar currentWrapElm;\r\n\r\n\t\t\t\t\t/**\r\n\t\t\t\t\t * Process a list of nodes wrap them.\r\n\t\t\t\t\t */\r\n\t\t\t\t\tfunction process(node) {\r\n\t\t\t\t\t\tvar nodeName = node.nodeName.toLowerCase(), parentName = node.parentNode.nodeName.toLowerCase(), found;\r\n\r\n\t\t\t\t\t\t// Stop wrapping on br elements\r\n\t\t\t\t\t\tif (isEq(nodeName, 'br')) {\r\n\t\t\t\t\t\t\tcurrentWrapElm = 0;\r\n\r\n\t\t\t\t\t\t\t// Remove any br elements when we wrap things\r\n\t\t\t\t\t\t\tif (format.block)\r\n\t\t\t\t\t\t\t\tdom.remove(node);\r\n\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// If node is wrapper type\r\n\t\t\t\t\t\tif (format.wrapper && matchNode(node, name, vars)) {\r\n\t\t\t\t\t\t\tcurrentWrapElm = 0;\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Can we rename the block\r\n\t\t\t\t\t\tif (format.block && !format.wrapper && isTextBlock(nodeName)) {\r\n\t\t\t\t\t\t\tnode = dom.rename(node, wrapName);\r\n\t\t\t\t\t\t\tsetElementFormat(node);\r\n\t\t\t\t\t\t\tnewWrappers.push(node);\r\n\t\t\t\t\t\t\tcurrentWrapElm = 0;\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Handle selector patterns\r\n\t\t\t\t\t\tif (format.selector) {\r\n\t\t\t\t\t\t\t// Look for matching formats\r\n\t\t\t\t\t\t\teach(formatList, function(format) {\r\n\t\t\t\t\t\t\t\t// Check collapsed state if it exists\r\n\t\t\t\t\t\t\t\tif ('collapsed' in format && format.collapsed !== isCollapsed) {\r\n\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tif (dom.is(node, format.selector) && !isCaretNode(node)) {\r\n\t\t\t\t\t\t\t\t\tsetElementFormat(node, format);\r\n\t\t\t\t\t\t\t\t\tfound = true;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t\t// Continue processing if a selector match wasn't found and a inline element is defined\r\n\t\t\t\t\t\t\tif (!format.inline || found) {\r\n\t\t\t\t\t\t\t\tcurrentWrapElm = 0;\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Is it valid to wrap this item\r\n\t\t\t\t\t\tif (isValid(wrapName, nodeName) && isValid(parentName, wrapName) &&\r\n\t\t\t\t\t\t\t\t!(!node_specific && node.nodeType === 3 && node.nodeValue.length === 1 && node.nodeValue.charCodeAt(0) === 65279) && node.id !== '_mce_caret') {\r\n\t\t\t\t\t\t\t// Start wrapping\r\n\t\t\t\t\t\t\tif (!currentWrapElm) {\r\n\t\t\t\t\t\t\t\t// Wrap the node\r\n\t\t\t\t\t\t\t\tcurrentWrapElm = wrapElm.cloneNode(FALSE);\r\n\t\t\t\t\t\t\t\tnode.parentNode.insertBefore(currentWrapElm, node);\r\n\t\t\t\t\t\t\t\tnewWrappers.push(currentWrapElm);\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tcurrentWrapElm.appendChild(node);\r\n\t\t\t\t\t\t} else if (nodeName == 'li' && bookmark) {\r\n\t\t\t\t\t\t\t// Start wrapping - if we are in a list node and have a bookmark, then we will always begin by wrapping in a new element.\r\n\t\t\t\t\t\t\tcurrentWrapElm = applyStyleToList(node, bookmark, wrapElm, newWrappers, process);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// Start a new wrapper for possible children\r\n\t\t\t\t\t\t\tcurrentWrapElm = 0;\r\n\r\n\t\t\t\t\t\t\teach(tinymce.grep(node.childNodes), process);\r\n\r\n\t\t\t\t\t\t\t// End the last wrapper\r\n\t\t\t\t\t\t\tcurrentWrapElm = 0;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\t// Process siblings from range\r\n\t\t\t\t\teach(nodes, process);\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// Wrap links inside as well, for example color inside a link when the wrapper is around the link\r\n\t\t\t\tif (format.wrap_links === false) {\r\n\t\t\t\t\teach(newWrappers, function(node) {\r\n\t\t\t\t\t\tfunction process(node) {\r\n\t\t\t\t\t\t\tvar i, currentWrapElm, children;\r\n\r\n\t\t\t\t\t\t\tif (node.nodeName === 'A') {\r\n\t\t\t\t\t\t\t\tcurrentWrapElm = wrapElm.cloneNode(FALSE);\r\n\t\t\t\t\t\t\t\tnewWrappers.push(currentWrapElm);\r\n\r\n\t\t\t\t\t\t\t\tchildren = tinymce.grep(node.childNodes);\r\n\t\t\t\t\t\t\t\tfor (i = 0; i < children.length; i++)\r\n\t\t\t\t\t\t\t\t\tcurrentWrapElm.appendChild(children[i]);\r\n\r\n\t\t\t\t\t\t\t\tnode.appendChild(currentWrapElm);\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\teach(tinymce.grep(node.childNodes), process);\r\n\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\tprocess(node);\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Cleanup\r\n\t\t\t\teach(newWrappers, function(node) {\r\n\t\t\t\t\tvar childCount;\r\n\r\n\t\t\t\t\tfunction getChildCount(node) {\r\n\t\t\t\t\t\tvar count = 0;\r\n\r\n\t\t\t\t\t\teach(node.childNodes, function(node) {\r\n\t\t\t\t\t\t\tif (!isWhiteSpaceNode(node) && !isBookmarkNode(node))\r\n\t\t\t\t\t\t\t\tcount++;\r\n\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\treturn count;\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tfunction mergeStyles(node) {\r\n\t\t\t\t\t\tvar child, clone;\r\n\r\n\t\t\t\t\t\teach(node.childNodes, function(node) {\r\n\t\t\t\t\t\t\tif (node.nodeType == 1 && !isBookmarkNode(node) && !isCaretNode(node)) {\r\n\t\t\t\t\t\t\t\tchild = node;\r\n\t\t\t\t\t\t\t\treturn FALSE; // break loop\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t// If child was found and of the same type as the current node\r\n\t\t\t\t\t\tif (child && matchName(child, format)) {\r\n\t\t\t\t\t\t\tclone = child.cloneNode(FALSE);\r\n\t\t\t\t\t\t\tsetElementFormat(clone);\r\n\r\n\t\t\t\t\t\t\tdom.replace(clone, node, TRUE);\r\n\t\t\t\t\t\t\tdom.remove(child, 1);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn clone || node;\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tchildCount = getChildCount(node);\r\n\r\n\t\t\t\t\t// Remove empty nodes but only if there is multiple wrappers and they are not block\r\n\t\t\t\t\t// elements so never remove single <h1></h1> since that would remove the current empty block element where the caret is at\r\n\t\t\t\t\tif ((newWrappers.length > 1 || !isBlock(node)) && childCount === 0) {\r\n\t\t\t\t\t\tdom.remove(node, 1);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (format.inline || format.wrapper) {\r\n\t\t\t\t\t\t// Merges the current node with it's children of similar type to reduce the number of elements\r\n\t\t\t\t\t\tif (!format.exact && childCount === 1)\r\n\t\t\t\t\t\t\tnode = mergeStyles(node);\r\n\r\n\t\t\t\t\t\t// Remove/merge children\r\n\t\t\t\t\t\teach(formatList, function(format) {\r\n\t\t\t\t\t\t\t// Merge all children of similar type will move styles from child to parent\r\n\t\t\t\t\t\t\t// this: <span style=\"color:red\"><b><span style=\"color:red; font-size:10px\">text</span></b></span>\r\n\t\t\t\t\t\t\t// will become: <span style=\"color:red\"><b><span style=\"font-size:10px\">text</span></b></span>\r\n\t\t\t\t\t\t\teach(dom.select(format.inline, node), function(child) {\r\n\t\t\t\t\t\t\t\tvar parent;\r\n\r\n\t\t\t\t\t\t\t\t// When wrap_links is set to false we don't want\r\n\t\t\t\t\t\t\t\t// to remove the format on children within links\r\n\t\t\t\t\t\t\t\tif (format.wrap_links === false) {\r\n\t\t\t\t\t\t\t\t\tparent = child.parentNode;\r\n\r\n\t\t\t\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\t\t\t\tif (parent.nodeName === 'A')\r\n\t\t\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t\t\t} while (parent = parent.parentNode);\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tremoveFormat(format, vars, child, format.exact ? child : null);\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t// Remove child if direct parent is of same type\r\n\t\t\t\t\t\tif (matchNode(node.parentNode, name, vars)) {\r\n\t\t\t\t\t\t\tdom.remove(node, 1);\r\n\t\t\t\t\t\t\tnode = 0;\r\n\t\t\t\t\t\t\treturn TRUE;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Look for parent with similar style format\r\n\t\t\t\t\t\tif (format.merge_with_parents) {\r\n\t\t\t\t\t\t\tdom.getParent(node.parentNode, function(parent) {\r\n\t\t\t\t\t\t\t\tif (matchNode(parent, name, vars)) {\r\n\t\t\t\t\t\t\t\t\tdom.remove(node, 1);\r\n\t\t\t\t\t\t\t\t\tnode = 0;\r\n\t\t\t\t\t\t\t\t\treturn TRUE;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Merge next and previous siblings if they are similar <b>text</b><b>text</b> becomes <b>texttext</b>\r\n\t\t\t\t\t\tif (node && format.merge_siblings !== false) {\r\n\t\t\t\t\t\t\tnode = mergeSiblings(getNonWhiteSpaceSibling(node), node);\r\n\t\t\t\t\t\t\tnode = mergeSiblings(node, getNonWhiteSpaceSibling(node, TRUE));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t};\r\n\r\n\t\t\tif (format) {\r\n\t\t\t\tif (node) {\r\n\t\t\t\t\tif (node.nodeType) {\r\n\t\t\t\t\t\trng = dom.createRng();\r\n\t\t\t\t\t\trng.setStartBefore(node);\r\n\t\t\t\t\t\trng.setEndAfter(node);\r\n\t\t\t\t\t\tapplyRngStyle(expandRng(rng, formatList), null, true);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tapplyRngStyle(node, null, true);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (!isCollapsed || !format.inline || dom.select('td.mceSelected,th.mceSelected').length) {\r\n\t\t\t\t\t\t// Obtain selection node before selection is unselected by applyRngStyle()\r\n\t\t\t\t\t\tvar curSelNode = ed.selection.getNode();\r\n\r\n\t\t\t\t\t\t// Apply formatting to selection\r\n\t\t\t\t\t\ted.selection.setRng(adjustSelectionToVisibleSelection());\r\n\t\t\t\t\t\tbookmark = selection.getBookmark();\r\n\t\t\t\t\t\tapplyRngStyle(expandRng(selection.getRng(TRUE), formatList), bookmark);\r\n\r\n\t\t\t\t\t\t// Colored nodes should be underlined so that the color of the underline matches the text color.\r\n\t\t\t\t\t\tif (format.styles && (format.styles.color || format.styles.textDecoration)) {\r\n\t\t\t\t\t\t\ttinymce.walk(curSelNode, processUnderlineAndColor, 'childNodes');\r\n\t\t\t\t\t\t\tprocessUnderlineAndColor(curSelNode);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tselection.moveToBookmark(bookmark);\r\n\t\t\t\t\t\tselection.setRng(moveStart(selection.getRng(TRUE)));\r\n\t\t\t\t\t\ted.nodeChanged();\r\n\t\t\t\t\t} else\r\n\t\t\t\t\t\tperformCaretAction('apply', name, vars);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Removes the specified format from the current selection or specified node.\r\n\t\t *\r\n\t\t * @method remove\r\n\t\t * @param {String} name Name of format to remove.\r\n\t\t * @param {Object} vars Optional list of variables to replace within format before removing it.\r\n\t\t * @param {Node/Range} node Optional node or DOM range to remove the format from defaults to current selection.\r\n\t\t */\r\n\t\tfunction remove(name, vars, node) {\r\n\t\t\tvar formatList = get(name), format = formatList[0], bookmark, i, rng;\r\n\t\t\t/**\r\n\t\t\t * Moves the start to the first suitable text node.\r\n\t\t\t */\r\n\t\t\tfunction moveStart(rng) {\r\n\t\t\t\tvar container = rng.startContainer,\r\n\t\t\t\t\toffset = rng.startOffset,\r\n\t\t\t\t\twalker, node, nodes, tmpNode;\r\n\r\n\t\t\t\t// Convert text node into index if possible\r\n\t\t\t\tif (container.nodeType == 3 && offset >= container.nodeValue.length - 1) {\r\n\t\t\t\t\tcontainer = container.parentNode;\r\n\t\t\t\t\toffset = nodeIndex(container) + 1;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Move startContainer/startOffset in to a suitable node\r\n\t\t\t\tif (container.nodeType == 1) {\r\n\t\t\t\t\tnodes = container.childNodes;\r\n\t\t\t\t\tcontainer = nodes[Math.min(offset, nodes.length - 1)];\r\n\t\t\t\t\twalker = new TreeWalker(container);\r\n\r\n\t\t\t\t\t// If offset is at end of the parent node walk to the next one\r\n\t\t\t\t\tif (offset > nodes.length - 1)\r\n\t\t\t\t\t\twalker.next();\r\n\r\n\t\t\t\t\tfor (node = walker.current(); node; node = walker.next()) {\r\n\t\t\t\t\t\tif (node.nodeType == 3 && !isWhiteSpaceNode(node)) {\r\n\t\t\t\t\t\t\t// IE has a \"neat\" feature where it moves the start node into the closest element\r\n\t\t\t\t\t\t\t// we can avoid this by inserting an element before it and then remove it after we set the selection\r\n\t\t\t\t\t\t\ttmpNode = dom.create('a', null, INVISIBLE_CHAR);\r\n\t\t\t\t\t\t\tnode.parentNode.insertBefore(tmpNode, node);\r\n\r\n\t\t\t\t\t\t\t// Set selection and remove tmpNode\r\n\t\t\t\t\t\t\trng.setStart(node, 0);\r\n\t\t\t\t\t\t\tselection.setRng(rng);\r\n\t\t\t\t\t\t\tdom.remove(tmpNode);\r\n\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\t// Merges the styles for each node\r\n\t\t\tfunction process(node) {\r\n\t\t\t\tvar children, i, l;\r\n\r\n\t\t\t\t// Grab the children first since the nodelist might be changed\r\n\t\t\t\tchildren = tinymce.grep(node.childNodes);\r\n\r\n\t\t\t\t// Process current node\r\n\t\t\t\tfor (i = 0, l = formatList.length; i < l; i++) {\r\n\t\t\t\t\tif (removeFormat(formatList[i], vars, node, node))\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Process the children\r\n\t\t\t\tif (format.deep) {\r\n\t\t\t\t\tfor (i = 0, l = children.length; i < l; i++)\r\n\t\t\t\t\t\tprocess(children[i]);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tfunction findFormatRoot(container) {\r\n\t\t\t\tvar formatRoot;\r\n\r\n\t\t\t\t// Find format root\r\n\t\t\t\teach(getParents(container.parentNode).reverse(), function(parent) {\r\n\t\t\t\t\tvar format;\r\n\r\n\t\t\t\t\t// Find format root element\r\n\t\t\t\t\tif (!formatRoot && parent.id != '_start' && parent.id != '_end') {\r\n\t\t\t\t\t\t// Is the node matching the format we are looking for\r\n\t\t\t\t\t\tformat = matchNode(parent, name, vars);\r\n\t\t\t\t\t\tif (format && format.split !== false)\r\n\t\t\t\t\t\t\tformatRoot = parent;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\treturn formatRoot;\r\n\t\t\t};\r\n\r\n\t\t\tfunction wrapAndSplit(format_root, container, target, split) {\r\n\t\t\t\tvar parent, clone, lastClone, firstClone, i, formatRootParent;\r\n\r\n\t\t\t\t// Format root found then clone formats and split it\r\n\t\t\t\tif (format_root) {\r\n\t\t\t\t\tformatRootParent = format_root.parentNode;\r\n\r\n\t\t\t\t\tfor (parent = container.parentNode; parent && parent != formatRootParent; parent = parent.parentNode) {\r\n\t\t\t\t\t\tclone = parent.cloneNode(FALSE);\r\n\r\n\t\t\t\t\t\tfor (i = 0; i < formatList.length; i++) {\r\n\t\t\t\t\t\t\tif (removeFormat(formatList[i], vars, clone, clone)) {\r\n\t\t\t\t\t\t\t\tclone = 0;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Build wrapper node\r\n\t\t\t\t\t\tif (clone) {\r\n\t\t\t\t\t\t\tif (lastClone)\r\n\t\t\t\t\t\t\t\tclone.appendChild(lastClone);\r\n\r\n\t\t\t\t\t\t\tif (!firstClone)\r\n\t\t\t\t\t\t\t\tfirstClone = clone;\r\n\r\n\t\t\t\t\t\t\tlastClone = clone;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Never split block elements if the format is mixed\r\n\t\t\t\t\tif (split && (!format.mixed || !isBlock(format_root)))\r\n\t\t\t\t\t\tcontainer = dom.split(format_root, container);\r\n\r\n\t\t\t\t\t// Wrap container in cloned formats\r\n\t\t\t\t\tif (lastClone) {\r\n\t\t\t\t\t\ttarget.parentNode.insertBefore(lastClone, target);\r\n\t\t\t\t\t\tfirstClone.appendChild(target);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn container;\r\n\t\t\t};\r\n\r\n\t\t\tfunction splitToFormatRoot(container) {\r\n\t\t\t\treturn wrapAndSplit(findFormatRoot(container), container, container, true);\r\n\t\t\t};\r\n\r\n\t\t\tfunction unwrap(start) {\r\n\t\t\t\tvar node = dom.get(start ? '_start' : '_end'),\r\n\t\t\t\t\tout = node[start ? 'firstChild' : 'lastChild'];\r\n\r\n\t\t\t\t// If the end is placed within the start the result will be removed\r\n\t\t\t\t// So this checks if the out node is a bookmark node if it is it\r\n\t\t\t\t// checks for another more suitable node\r\n\t\t\t\tif (isBookmarkNode(out))\r\n\t\t\t\t\tout = out[start ? 'firstChild' : 'lastChild'];\r\n\r\n\t\t\t\tdom.remove(node, true);\r\n\r\n\t\t\t\treturn out;\r\n\t\t\t};\r\n\r\n\t\t\tfunction removeRngStyle(rng) {\r\n\t\t\t\tvar startContainer, endContainer;\r\n\r\n\t\t\t\trng = expandRng(rng, formatList, TRUE);\r\n\r\n\t\t\t\tif (format.split) {\r\n\t\t\t\t\tstartContainer = getContainer(rng, TRUE);\r\n\t\t\t\t\tendContainer = getContainer(rng);\r\n\r\n\t\t\t\t\tif (startContainer != endContainer) {\r\n\t\t\t\t\t\t// Wrap start/end nodes in span element since these might be cloned/moved\r\n\t\t\t\t\t\tstartContainer = wrap(startContainer, 'span', {id : '_start', 'data-mce-type' : 'bookmark'});\r\n\t\t\t\t\t\tendContainer = wrap(endContainer, 'span', {id : '_end', 'data-mce-type' : 'bookmark'});\r\n\r\n\t\t\t\t\t\t// Split start/end\r\n\t\t\t\t\t\tsplitToFormatRoot(startContainer);\r\n\t\t\t\t\t\tsplitToFormatRoot(endContainer);\r\n\r\n\t\t\t\t\t\t// Unwrap start/end to get real elements again\r\n\t\t\t\t\t\tstartContainer = unwrap(TRUE);\r\n\t\t\t\t\t\tendContainer = unwrap();\r\n\t\t\t\t\t} else\r\n\t\t\t\t\t\tstartContainer = endContainer = splitToFormatRoot(startContainer);\r\n\r\n\t\t\t\t\t// Update range positions since they might have changed after the split operations\r\n\t\t\t\t\trng.startContainer = startContainer.parentNode;\r\n\t\t\t\t\trng.startOffset = nodeIndex(startContainer);\r\n\t\t\t\t\trng.endContainer = endContainer.parentNode;\r\n\t\t\t\t\trng.endOffset = nodeIndex(endContainer) + 1;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Remove items between start/end\r\n\t\t\t\trangeUtils.walk(rng, function(nodes) {\r\n\t\t\t\t\teach(nodes, function(node) {\r\n\t\t\t\t\t\tprocess(node);\r\n\r\n\t\t\t\t\t\t// Remove parent span if it only contains text-decoration: underline, yet a parent node is also underlined.\r\n\t\t\t\t\t\tif (node.nodeType === 1 && ed.dom.getStyle(node, 'text-decoration') === 'underline' && node.parentNode && getTextDecoration(node.parentNode) === 'underline') {\r\n\t\t\t\t\t\t\tremoveFormat({'deep': false, 'exact': true, 'inline': 'span', 'styles': {'textDecoration' : 'underline'}}, null, node);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t});\r\n\t\t\t};\r\n\r\n\t\t\t// Handle node\r\n\t\t\tif (node) {\r\n\t\t\t\tif (node.nodeType) {\r\n\t\t\t\t\trng = dom.createRng();\r\n\t\t\t\t\trng.setStartBefore(node);\r\n\t\t\t\t\trng.setEndAfter(node);\r\n\t\t\t\t\tremoveRngStyle(rng);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tremoveRngStyle(node);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (!selection.isCollapsed() || !format.inline || dom.select('td.mceSelected,th.mceSelected').length) {\r\n\t\t\t\tbookmark = selection.getBookmark();\r\n\t\t\t\tremoveRngStyle(selection.getRng(TRUE));\r\n\t\t\t\tselection.moveToBookmark(bookmark);\r\n\r\n\t\t\t\t// Check if start element still has formatting then we are at: \"<b>text|</b>text\" and need to move the start into the next text node\r\n\t\t\t\tif (format.inline && match(name, vars, selection.getStart())) {\r\n\t\t\t\t\tmoveStart(selection.getRng(true));\r\n\t\t\t\t}\r\n\r\n\t\t\t\ted.nodeChanged();\r\n\t\t\t} else\r\n\t\t\t\tperformCaretAction('remove', name, vars);\r\n\r\n\t\t\t// When you remove formatting from a table cell in WebKit (cell, not the contents of a cell) there is a rendering issue with column width\r\n\t\t\tif (tinymce.isWebKit) {\r\n\t\t\t\ted.execCommand('mceCleanup');\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Toggles the specified format on/off.\r\n\t\t *\r\n\t\t * @method toggle\r\n\t\t * @param {String} name Name of format to apply/remove.\r\n\t\t * @param {Object} vars Optional list of variables to replace within format before applying/removing it.\r\n\t\t * @param {Node} node Optional node to apply the format to or remove from. Defaults to current selection.\r\n\t\t */\r\n\t\tfunction toggle(name, vars, node) {\r\n\t\t\tvar fmt = get(name);\r\n\r\n\t\t\tif (match(name, vars, node) && (!('toggle' in fmt[0]) || fmt[0]['toggle']))\r\n\t\t\t\tremove(name, vars, node);\r\n\t\t\telse\r\n\t\t\t\tapply(name, vars, node);\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Return true/false if the specified node has the specified format.\r\n\t\t *\r\n\t\t * @method matchNode\r\n\t\t * @param {Node} node Node to check the format on.\r\n\t\t * @param {String} name Format name to check.\r\n\t\t * @param {Object} vars Optional list of variables to replace before checking it.\r\n\t\t * @param {Boolean} similar Match format that has similar properties.\r\n\t\t * @return {Object} Returns the format object it matches or undefined if it doesn't match.\r\n\t\t */\r\n\t\tfunction matchNode(node, name, vars, similar) {\r\n\t\t\tvar formatList = get(name), format, i, classes;\r\n\r\n\t\t\tfunction matchItems(node, format, item_name) {\r\n\t\t\t\tvar key, value, items = format[item_name], i;\r\n\r\n\t\t\t\t// Custom match\r\n\t\t\t\tif (format.onmatch) {\r\n\t\t\t\t\treturn format.onmatch(node, format, item_name);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Check all items\r\n\t\t\t\tif (items) {\r\n\t\t\t\t\t// Non indexed object\r\n\t\t\t\t\tif (items.length === undefined) {\r\n\t\t\t\t\t\tfor (key in items) {\r\n\t\t\t\t\t\t\tif (items.hasOwnProperty(key)) {\r\n\t\t\t\t\t\t\t\tif (item_name === 'attributes')\r\n\t\t\t\t\t\t\t\t\tvalue = dom.getAttrib(node, key);\r\n\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\tvalue = getStyle(node, key);\r\n\r\n\t\t\t\t\t\t\t\tif (similar && !value && !format.exact)\r\n\t\t\t\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t\t\t\tif ((!similar || format.exact) && !isEq(value, replaceVars(items[key], vars)))\r\n\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// Only one match needed for indexed arrays\r\n\t\t\t\t\t\tfor (i = 0; i < items.length; i++) {\r\n\t\t\t\t\t\t\tif (item_name === 'attributes' ? dom.getAttrib(node, items[i]) : getStyle(node, items[i]))\r\n\t\t\t\t\t\t\t\treturn format;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn format;\r\n\t\t\t};\r\n\r\n\t\t\tif (formatList && node) {\r\n\t\t\t\t// Check each format in list\r\n\t\t\t\tfor (i = 0; i < formatList.length; i++) {\r\n\t\t\t\t\tformat = formatList[i];\r\n\r\n\t\t\t\t\t// Name name, attributes, styles and classes\r\n\t\t\t\t\tif (matchName(node, format) && matchItems(node, format, 'attributes') && matchItems(node, format, 'styles')) {\r\n\t\t\t\t\t\t// Match classes\r\n\t\t\t\t\t\tif (classes = format.classes) {\r\n\t\t\t\t\t\t\tfor (i = 0; i < classes.length; i++) {\r\n\t\t\t\t\t\t\t\tif (!dom.hasClass(node, classes[i]))\r\n\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn format;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Matches the current selection or specified node against the specified format name.\r\n\t\t *\r\n\t\t * @method match\r\n\t\t * @param {String} name Name of format to match.\r\n\t\t * @param {Object} vars Optional list of variables to replace before checking it.\r\n\t\t * @param {Node} node Optional node to check.\r\n\t\t * @return {boolean} true/false if the specified selection/node matches the format.\r\n\t\t */\r\n\t\tfunction match(name, vars, node) {\r\n\t\t\tvar startNode;\r\n\r\n\t\t\tfunction matchParents(node) {\r\n\t\t\t\t// Find first node with similar format settings\r\n\t\t\t\tnode = dom.getParent(node, function(node) {\r\n\t\t\t\t\treturn !!matchNode(node, name, vars, true);\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// Do an exact check on the similar format element\r\n\t\t\t\treturn matchNode(node, name, vars);\r\n\t\t\t};\r\n\r\n\t\t\t// Check specified node\r\n\t\t\tif (node)\r\n\t\t\t\treturn matchParents(node);\r\n\r\n\t\t\t// Check selected node\r\n\t\t\tnode = selection.getNode();\r\n\t\t\tif (matchParents(node))\r\n\t\t\t\treturn TRUE;\r\n\r\n\t\t\t// Check start node if it's different\r\n\t\t\tstartNode = selection.getStart();\r\n\t\t\tif (startNode != node) {\r\n\t\t\t\tif (matchParents(startNode))\r\n\t\t\t\t\treturn TRUE;\r\n\t\t\t}\r\n\r\n\t\t\treturn FALSE;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Matches the current selection against the array of formats and returns a new array with matching formats.\r\n\t\t *\r\n\t\t * @method matchAll\r\n\t\t * @param {Array} names Name of format to match.\r\n\t\t * @param {Object} vars Optional list of variables to replace before checking it.\r\n\t\t * @return {Array} Array with matched formats.\r\n\t\t */\r\n\t\tfunction matchAll(names, vars) {\r\n\t\t\tvar startElement, matchedFormatNames = [], checkedMap = {}, i, ni, name;\r\n\r\n\t\t\t// Check start of selection for formats\r\n\t\t\tstartElement = selection.getStart();\r\n\t\t\tdom.getParent(startElement, function(node) {\r\n\t\t\t\tvar i, name;\r\n\r\n\t\t\t\tfor (i = 0; i < names.length; i++) {\r\n\t\t\t\t\tname = names[i];\r\n\r\n\t\t\t\t\tif (!checkedMap[name] && matchNode(node, name, vars)) {\r\n\t\t\t\t\t\tcheckedMap[name] = true;\r\n\t\t\t\t\t\tmatchedFormatNames.push(name);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\treturn matchedFormatNames;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Returns true/false if the specified format can be applied to the current selection or not. It will currently only check the state for selector formats, it returns true on all other format types.\r\n\t\t *\r\n\t\t * @method canApply\r\n\t\t * @param {String} name Name of format to check.\r\n\t\t * @return {boolean} true/false if the specified format can be applied to the current selection/node.\r\n\t\t */\r\n\t\tfunction canApply(name) {\r\n\t\t\tvar formatList = get(name), startNode, parents, i, x, selector;\r\n\r\n\t\t\tif (formatList) {\r\n\t\t\t\tstartNode = selection.getStart();\r\n\t\t\t\tparents = getParents(startNode);\r\n\r\n\t\t\t\tfor (x = formatList.length - 1; x >= 0; x--) {\r\n\t\t\t\t\tselector = formatList[x].selector;\r\n\r\n\t\t\t\t\t// Format is not selector based, then always return TRUE\r\n\t\t\t\t\tif (!selector)\r\n\t\t\t\t\t\treturn TRUE;\r\n\r\n\t\t\t\t\tfor (i = parents.length - 1; i >= 0; i--) {\r\n\t\t\t\t\t\tif (dom.is(parents[i], selector))\r\n\t\t\t\t\t\t\treturn TRUE;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn FALSE;\r\n\t\t};\r\n\r\n\t\t// Expose to public\r\n\t\ttinymce.extend(this, {\r\n\t\t\tget : get,\r\n\t\t\tregister : register,\r\n\t\t\tapply : apply,\r\n\t\t\tremove : remove,\r\n\t\t\ttoggle : toggle,\r\n\t\t\tmatch : match,\r\n\t\t\tmatchAll : matchAll,\r\n\t\t\tmatchNode : matchNode,\r\n\t\t\tcanApply : canApply\r\n\t\t});\r\n\r\n\t\t// Private functions\r\n\r\n\t\t/**\r\n\t\t * Checks if the specified nodes name matches the format inline/block or selector.\r\n\t\t *\r\n\t\t * @private\r\n\t\t * @param {Node} node Node to match against the specified format.\r\n\t\t * @param {Object} format Format object o match with.\r\n\t\t * @return {boolean} true/false if the format matches.\r\n\t\t */\r\n\t\tfunction matchName(node, format) {\r\n\t\t\t// Check for inline match\r\n\t\t\tif (isEq(node, format.inline))\r\n\t\t\t\treturn TRUE;\r\n\r\n\t\t\t// Check for block match\r\n\t\t\tif (isEq(node, format.block))\r\n\t\t\t\treturn TRUE;\r\n\r\n\t\t\t// Check for selector match\r\n\t\t\tif (format.selector)\r\n\t\t\t\treturn dom.is(node, format.selector);\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Compares two string/nodes regardless of their case.\r\n\t\t *\r\n\t\t * @private\r\n\t\t * @param {String/Node} Node or string to compare.\r\n\t\t * @param {String/Node} Node or string to compare.\r\n\t\t * @return {boolean} True/false if they match.\r\n\t\t */\r\n\t\tfunction isEq(str1, str2) {\r\n\t\t\tstr1 = str1 || '';\r\n\t\t\tstr2 = str2 || '';\r\n\r\n\t\t\tstr1 = '' + (str1.nodeName || str1);\r\n\t\t\tstr2 = '' + (str2.nodeName || str2);\r\n\r\n\t\t\treturn str1.toLowerCase() == str2.toLowerCase();\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Returns the style by name on the specified node. This method modifies the style\r\n\t\t * contents to make it more easy to match. This will resolve a few browser issues.\r\n\t\t *\r\n\t\t * @private\r\n\t\t * @param {Node} node to get style from.\r\n\t\t * @param {String} name Style name to get.\r\n\t\t * @return {String} Style item value.\r\n\t\t */\r\n\t\tfunction getStyle(node, name) {\r\n\t\t\tvar styleVal = dom.getStyle(node, name);\r\n\r\n\t\t\t// Force the format to hex\r\n\t\t\tif (name == 'color' || name == 'backgroundColor')\r\n\t\t\t\tstyleVal = dom.toHex(styleVal);\r\n\r\n\t\t\t// Opera will return bold as 700\r\n\t\t\tif (name == 'fontWeight' && styleVal == 700)\r\n\t\t\t\tstyleVal = 'bold';\r\n\r\n\t\t\treturn '' + styleVal;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Replaces variables in the value. The variable format is %var.\r\n\t\t *\r\n\t\t * @private\r\n\t\t * @param {String} value Value to replace variables in.\r\n\t\t * @param {Object} vars Name/value array with variables to replace.\r\n\t\t * @return {String} New value with replaced variables.\r\n\t\t */\r\n\t\tfunction replaceVars(value, vars) {\r\n\t\t\tif (typeof(value) != \"string\")\r\n\t\t\t\tvalue = value(vars);\r\n\t\t\telse if (vars) {\r\n\t\t\t\tvalue = value.replace(/%(\\w+)/g, function(str, name) {\r\n\t\t\t\t\treturn vars[name] || str;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\treturn value;\r\n\t\t};\r\n\r\n\t\tfunction isWhiteSpaceNode(node) {\r\n\t\t\treturn node && node.nodeType === 3 && /^([\\t \\r\\n]+|)$/.test(node.nodeValue);\r\n\t\t};\r\n\r\n\t\tfunction wrap(node, name, attrs) {\r\n\t\t\tvar wrapper = dom.create(name, attrs);\r\n\r\n\t\t\tnode.parentNode.insertBefore(wrapper, node);\r\n\t\t\twrapper.appendChild(node);\r\n\r\n\t\t\treturn wrapper;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Expands the specified range like object to depending on format.\r\n\t\t *\r\n\t\t * For example on block formats it will move the start/end position\r\n\t\t * to the beginning of the current block.\r\n\t\t *\r\n\t\t * @private\r\n\t\t * @param {Object} rng Range like object.\r\n\t\t * @param {Array} formats Array with formats to expand by.\r\n\t\t * @return {Object} Expanded range like object.\r\n\t\t */\r\n\t\tfunction expandRng(rng, format, remove) {\r\n\t\t\tvar startContainer = rng.startContainer,\r\n\t\t\t\tstartOffset = rng.startOffset,\r\n\t\t\t\tendContainer = rng.endContainer,\r\n\t\t\t\tendOffset = rng.endOffset, sibling, lastIdx, leaf, endPoint;\r\n\r\n\t\t\t// This function walks up the tree if there is no siblings before/after the node\r\n\t\t\tfunction findParentContainer(start) {\r\n\t\t\t\tvar container, parent, child, sibling, siblingName;\r\n\r\n\t\t\t\tcontainer = parent = start ? startContainer : endContainer;\r\n\t\t\t\tsiblingName = start ? 'previousSibling' : 'nextSibling';\r\n\t\t\t\troot = dom.getRoot();\r\n\r\n\t\t\t\t// If it's a text node and the offset is inside the text\r\n\t\t\t\tif (container.nodeType == 3 && !isWhiteSpaceNode(container)) {\r\n\t\t\t\t\tif (start ? startOffset > 0 : endOffset < container.nodeValue.length) {\r\n\t\t\t\t\t\treturn container;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor (;;) {\r\n\t\t\t\t\t// Stop expanding on block elements or root depending on format\r\n\t\t\t\t\tif (parent == root || (!format[0].block_expand && isBlock(parent)))\r\n\t\t\t\t\t\treturn parent;\r\n\r\n\t\t\t\t\t// Walk left/right\r\n\t\t\t\t\tfor (sibling = parent[siblingName]; sibling; sibling = sibling[siblingName]) {\r\n\t\t\t\t\t\tif (!isBookmarkNode(sibling) && !isWhiteSpaceNode(sibling)) {\r\n\t\t\t\t\t\t\treturn parent;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Check if we can move up are we at root level or body level\r\n\t\t\t\t\tparent = parent.parentNode;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn container;\r\n\t\t\t};\r\n\r\n\t\t\t// This function walks down the tree to find the leaf at the selection.\r\n\t\t\t// The offset is also returned as if node initially a leaf, the offset may be in the middle of the text node.\r\n\t\t\tfunction findLeaf(node, offset) {\r\n\t\t\t\tif (offset === undefined)\r\n\t\t\t\t\toffset = node.nodeType === 3 ? node.length : node.childNodes.length;\r\n\t\t\t\twhile (node && node.hasChildNodes()) {\r\n\t\t\t\t\tnode = node.childNodes[offset];\r\n\t\t\t\t\tif (node)\r\n\t\t\t\t\t\toffset = node.nodeType === 3 ? node.length : node.childNodes.length;\r\n\t\t\t\t}\r\n\t\t\t\treturn { node: node, offset: offset };\r\n\t\t\t}\r\n\r\n\t\t\t// If index based start position then resolve it\r\n\t\t\tif (startContainer.nodeType == 1 && startContainer.hasChildNodes()) {\r\n\t\t\t\tlastIdx = startContainer.childNodes.length - 1;\r\n\t\t\t\tstartContainer = startContainer.childNodes[startOffset > lastIdx ? lastIdx : startOffset];\r\n\r\n\t\t\t\tif (startContainer.nodeType == 3)\r\n\t\t\t\t\tstartOffset = 0;\r\n\t\t\t}\r\n\r\n\t\t\t// If index based end position then resolve it\r\n\t\t\tif (endContainer.nodeType == 1 && endContainer.hasChildNodes()) {\r\n\t\t\t\tlastIdx = endContainer.childNodes.length - 1;\r\n\t\t\t\tendContainer = endContainer.childNodes[endOffset > lastIdx ? lastIdx : endOffset - 1];\r\n\r\n\t\t\t\tif (endContainer.nodeType == 3)\r\n\t\t\t\t\tendOffset = endContainer.nodeValue.length;\r\n\t\t\t}\r\n\r\n\t\t\t// Exclude bookmark nodes if possible\r\n\t\t\tif (isBookmarkNode(startContainer.parentNode) || isBookmarkNode(startContainer)) {\r\n\t\t\t\tstartContainer = isBookmarkNode(startContainer) ? startContainer : startContainer.parentNode;\r\n\t\t\t\tstartContainer = startContainer.nextSibling || startContainer;\r\n\r\n\t\t\t\tif (startContainer.nodeType == 3)\r\n\t\t\t\t\tstartOffset = 0;\r\n\t\t\t}\r\n\r\n\t\t\tif (isBookmarkNode(endContainer.parentNode) || isBookmarkNode(endContainer)) {\r\n\t\t\t\tendContainer = isBookmarkNode(endContainer) ? endContainer : endContainer.parentNode;\r\n\t\t\t\tendContainer = endContainer.previousSibling || endContainer;\r\n\r\n\t\t\t\tif (endContainer.nodeType == 3)\r\n\t\t\t\t\tendOffset = endContainer.length;\r\n\t\t\t}\r\n\r\n\t\t\tif (format[0].inline) {\r\n\t\t\t\tif (rng.collapsed) {\r\n\t\t\t\t\tfunction findWordEndPoint(container, offset, start) {\r\n\t\t\t\t\t\tvar walker, node, pos, lastTextNode;\r\n\r\n\t\t\t\t\t\tfunction findSpace(node, offset) {\r\n\t\t\t\t\t\t\tvar pos, pos2, str = node.nodeValue;\r\n\r\n\t\t\t\t\t\t\tif (typeof(offset) == \"undefined\") {\r\n\t\t\t\t\t\t\t\toffset = start ? str.length : 0;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif (start) {\r\n\t\t\t\t\t\t\t\tpos = str.lastIndexOf(' ', offset);\r\n\t\t\t\t\t\t\t\tpos2 = str.lastIndexOf('\\u00a0', offset);\r\n\t\t\t\t\t\t\t\tpos = pos > pos2 ? pos : pos2;\r\n\r\n\t\t\t\t\t\t\t\t// Include the space on remove to avoid tag soup\r\n\t\t\t\t\t\t\t\tif (pos !== -1 && !remove) {\r\n\t\t\t\t\t\t\t\t\tpos++;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tpos = str.indexOf(' ', offset);\r\n\t\t\t\t\t\t\t\tpos2 = str.indexOf('\\u00a0', offset);\r\n\t\t\t\t\t\t\t\tpos = pos !== -1 && (pos2 === -1 || pos < pos2) ? pos : pos2;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\treturn pos;\r\n\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\tif (container.nodeType === 3) {\r\n\t\t\t\t\t\t\tpos = findSpace(container, offset);\r\n\r\n\t\t\t\t\t\t\tif (pos !== -1) {\r\n\t\t\t\t\t\t\t\treturn {container : container, offset : pos};\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tlastTextNode = container;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Walk the nodes inside the block\r\n\t\t\t\t\t\twalker = new TreeWalker(container, dom.getParent(container, isBlock) || ed.getBody());\r\n\t\t\t\t\t\twhile (node = walker[start ? 'prev' : 'next']()) {\r\n\t\t\t\t\t\t\tif (node.nodeType === 3) {\r\n\t\t\t\t\t\t\t\tlastTextNode = node;\r\n\t\t\t\t\t\t\t\tpos = findSpace(node);\r\n\r\n\t\t\t\t\t\t\t\tif (pos !== -1) {\r\n\t\t\t\t\t\t\t\t\treturn {container : node, offset : pos};\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else if (isBlock(node)) {\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (lastTextNode) {\r\n\t\t\t\t\t\t\tif (start) {\r\n\t\t\t\t\t\t\t\toffset = 0;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\toffset = lastTextNode.length;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\treturn {container: lastTextNode, offset: offset};\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Expand left to closest word boundery\r\n\t\t\t\t\tendPoint = findWordEndPoint(startContainer, startOffset, true);\r\n\t\t\t\t\tif (endPoint) {\r\n\t\t\t\t\t\tstartContainer = endPoint.container;\r\n\t\t\t\t\t\tstartOffset = endPoint.offset;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Expand right to closest word boundery\r\n\t\t\t\t\tendPoint = findWordEndPoint(endContainer, endOffset);\r\n\t\t\t\t\tif (endPoint) {\r\n\t\t\t\t\t\tendContainer = endPoint.container;\r\n\t\t\t\t\t\tendOffset = endPoint.offset;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Avoid applying formatting to a trailing space.\r\n\t\t\t\tleaf = findLeaf(endContainer, endOffset);\r\n\t\t\t\tif (leaf.node) {\r\n\t\t\t\t\twhile (leaf.node && leaf.offset === 0 && leaf.node.previousSibling)\r\n\t\t\t\t\t\tleaf = findLeaf(leaf.node.previousSibling);\r\n\r\n\t\t\t\t\tif (leaf.node && leaf.offset > 0 && leaf.node.nodeType === 3 &&\r\n\t\t\t\t\t\t\tleaf.node.nodeValue.charAt(leaf.offset - 1) === ' ') {\r\n\r\n\t\t\t\t\t\tif (leaf.offset > 1) {\r\n\t\t\t\t\t\t\tendContainer = leaf.node;\r\n\t\t\t\t\t\t\tendContainer.splitText(leaf.offset - 1);\r\n\t\t\t\t\t\t} else if (leaf.node.previousSibling) {\r\n\t\t\t\t\t\t\t// TODO: Figure out why this is in here\r\n\t\t\t\t\t\t\t//endContainer = leaf.node.previousSibling;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Move start/end point up the tree if the leaves are sharp and if we are in different containers\r\n\t\t\t// Example * becomes !: !<p><b><i>*text</i><i>text*</i></b></p>!\r\n\t\t\t// This will reduce the number of wrapper elements that needs to be created\r\n\t\t\t// Move start point up the tree\r\n\t\t\tif (format[0].inline || format[0].block_expand) {\r\n\t\t\t\tif (!format[0].inline || (startContainer.nodeType != 3 || startOffset === 0)) {\r\n\t\t\t\t\tstartContainer = findParentContainer(true);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!format[0].inline || (endContainer.nodeType != 3 || endOffset === endContainer.nodeValue.length)) {\r\n\t\t\t\t\tendContainer = findParentContainer();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Expand start/end container to matching selector\r\n\t\t\tif (format[0].selector && format[0].expand !== FALSE && !format[0].inline) {\r\n\t\t\t\tfunction findSelectorEndPoint(container, sibling_name) {\r\n\t\t\t\t\tvar parents, i, y, curFormat;\r\n\r\n\t\t\t\t\tif (container.nodeType == 3 && container.nodeValue.length == 0 && container[sibling_name])\r\n\t\t\t\t\t\tcontainer = container[sibling_name];\r\n\r\n\t\t\t\t\tparents = getParents(container);\r\n\t\t\t\t\tfor (i = 0; i < parents.length; i++) {\r\n\t\t\t\t\t\tfor (y = 0; y < format.length; y++) {\r\n\t\t\t\t\t\t\tcurFormat = format[y];\r\n\r\n\t\t\t\t\t\t\t// If collapsed state is set then skip formats that doesn't match that\r\n\t\t\t\t\t\t\tif (\"collapsed\" in curFormat && curFormat.collapsed !== rng.collapsed)\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\t\tif (dom.is(parents[i], curFormat.selector))\r\n\t\t\t\t\t\t\t\treturn parents[i];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn container;\r\n\t\t\t\t};\r\n\r\n\t\t\t\t// Find new startContainer/endContainer if there is better one\r\n\t\t\t\tstartContainer = findSelectorEndPoint(startContainer, 'previousSibling');\r\n\t\t\t\tendContainer = findSelectorEndPoint(endContainer, 'nextSibling');\r\n\t\t\t}\r\n\r\n\t\t\t// Expand start/end container to matching block element or text node\r\n\t\t\tif (format[0].block || format[0].selector) {\r\n\t\t\t\tfunction findBlockEndPoint(container, sibling_name, sibling_name2) {\r\n\t\t\t\t\tvar node;\r\n\r\n\t\t\t\t\t// Expand to block of similar type\r\n\t\t\t\t\tif (!format[0].wrapper)\r\n\t\t\t\t\t\tnode = dom.getParent(container, format[0].block);\r\n\r\n\t\t\t\t\t// Expand to first wrappable block element or any block element\r\n\t\t\t\t\tif (!node)\r\n\t\t\t\t\t\tnode = dom.getParent(container.nodeType == 3 ? container.parentNode : container, isBlock);\r\n\r\n\t\t\t\t\t// Exclude inner lists from wrapping\r\n\t\t\t\t\tif (node && format[0].wrapper)\r\n\t\t\t\t\t\tnode = getParents(node, 'ul,ol').reverse()[0] || node;\r\n\r\n\t\t\t\t\t// Didn't find a block element look for first/last wrappable element\r\n\t\t\t\t\tif (!node) {\r\n\t\t\t\t\t\tnode = container;\r\n\r\n\t\t\t\t\t\twhile (node[sibling_name] && !isBlock(node[sibling_name])) {\r\n\t\t\t\t\t\t\tnode = node[sibling_name];\r\n\r\n\t\t\t\t\t\t\t// Break on BR but include it will be removed later on\r\n\t\t\t\t\t\t\t// we can't remove it now since we need to check if it can be wrapped\r\n\t\t\t\t\t\t\tif (isEq(node, 'br'))\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn node || container;\r\n\t\t\t\t};\r\n\r\n\t\t\t\t// Find new startContainer/endContainer if there is better one\r\n\t\t\t\tstartContainer = findBlockEndPoint(startContainer, 'previousSibling');\r\n\t\t\t\tendContainer = findBlockEndPoint(endContainer, 'nextSibling');\r\n\r\n\t\t\t\t// Non block element then try to expand up the leaf\r\n\t\t\t\tif (format[0].block) {\r\n\t\t\t\t\tif (!isBlock(startContainer))\r\n\t\t\t\t\t\tstartContainer = findParentContainer(true);\r\n\r\n\t\t\t\t\tif (!isBlock(endContainer))\r\n\t\t\t\t\t\tendContainer = findParentContainer();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Setup index for startContainer\r\n\t\t\tif (startContainer.nodeType == 1) {\r\n\t\t\t\tstartOffset = nodeIndex(startContainer);\r\n\t\t\t\tstartContainer = startContainer.parentNode;\r\n\t\t\t}\r\n\r\n\t\t\t// Setup index for endContainer\r\n\t\t\tif (endContainer.nodeType == 1) {\r\n\t\t\t\tendOffset = nodeIndex(endContainer) + 1;\r\n\t\t\t\tendContainer = endContainer.parentNode;\r\n\t\t\t}\r\n\r\n\t\t\t// Return new range like object\r\n\t\t\treturn {\r\n\t\t\t\tstartContainer : startContainer,\r\n\t\t\t\tstartOffset : startOffset,\r\n\t\t\t\tendContainer : endContainer,\r\n\t\t\t\tendOffset : endOffset\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Removes the specified format for the specified node. It will also remove the node if it doesn't have\r\n\t\t * any attributes if the format specifies it to do so.\r\n\t\t *\r\n\t\t * @private\r\n\t\t * @param {Object} format Format object with items to remove from node.\r\n\t\t * @param {Object} vars Name/value object with variables to apply to format.\r\n\t\t * @param {Node} node Node to remove the format styles on.\r\n\t\t * @param {Node} compare_node Optional compare node, if specified the styles will be compared to that node.\r\n\t\t * @return {Boolean} True/false if the node was removed or not.\r\n\t\t */\r\n\t\tfunction removeFormat(format, vars, node, compare_node) {\r\n\t\t\tvar i, attrs, stylesModified;\r\n\r\n\t\t\t// Check if node matches format\r\n\t\t\tif (!matchName(node, format))\r\n\t\t\t\treturn FALSE;\r\n\r\n\t\t\t// Should we compare with format attribs and styles\r\n\t\t\tif (format.remove != 'all') {\r\n\t\t\t\t// Remove styles\r\n\t\t\t\teach(format.styles, function(value, name) {\r\n\t\t\t\t\tvalue = replaceVars(value, vars);\r\n\r\n\t\t\t\t\t// Indexed array\r\n\t\t\t\t\tif (typeof(name) === 'number') {\r\n\t\t\t\t\t\tname = value;\r\n\t\t\t\t\t\tcompare_node = 0;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (!compare_node || isEq(getStyle(compare_node, name), value))\r\n\t\t\t\t\t\tdom.setStyle(node, name, '');\r\n\r\n\t\t\t\t\tstylesModified = 1;\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// Remove style attribute if it's empty\r\n\t\t\t\tif (stylesModified && dom.getAttrib(node, 'style') == '') {\r\n\t\t\t\t\tnode.removeAttribute('style');\r\n\t\t\t\t\tnode.removeAttribute('data-mce-style');\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Remove attributes\r\n\t\t\t\teach(format.attributes, function(value, name) {\r\n\t\t\t\t\tvar valueOut;\r\n\r\n\t\t\t\t\tvalue = replaceVars(value, vars);\r\n\r\n\t\t\t\t\t// Indexed array\r\n\t\t\t\t\tif (typeof(name) === 'number') {\r\n\t\t\t\t\t\tname = value;\r\n\t\t\t\t\t\tcompare_node = 0;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (!compare_node || isEq(dom.getAttrib(compare_node, name), value)) {\r\n\t\t\t\t\t\t// Keep internal classes\r\n\t\t\t\t\t\tif (name == 'class') {\r\n\t\t\t\t\t\t\tvalue = dom.getAttrib(node, name);\r\n\t\t\t\t\t\t\tif (value) {\r\n\t\t\t\t\t\t\t\t// Build new class value where everything is removed except the internal prefixed classes\r\n\t\t\t\t\t\t\t\tvalueOut = '';\r\n\t\t\t\t\t\t\t\teach(value.split(/\\s+/), function(cls) {\r\n\t\t\t\t\t\t\t\t\tif (/mce\\w+/.test(cls))\r\n\t\t\t\t\t\t\t\t\t\tvalueOut += (valueOut ? ' ' : '') + cls;\r\n\t\t\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t\t\t// We got some internal classes left\r\n\t\t\t\t\t\t\t\tif (valueOut) {\r\n\t\t\t\t\t\t\t\t\tdom.setAttrib(node, name, valueOut);\r\n\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// IE6 has a bug where the attribute doesn't get removed correctly\r\n\t\t\t\t\t\tif (name == \"class\")\r\n\t\t\t\t\t\t\tnode.removeAttribute('className');\r\n\r\n\t\t\t\t\t\t// Remove mce prefixed attributes\r\n\t\t\t\t\t\tif (MCE_ATTR_RE.test(name))\r\n\t\t\t\t\t\t\tnode.removeAttribute('data-mce-' + name);\r\n\r\n\t\t\t\t\t\tnode.removeAttribute(name);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// Remove classes\r\n\t\t\t\teach(format.classes, function(value) {\r\n\t\t\t\t\tvalue = replaceVars(value, vars);\r\n\r\n\t\t\t\t\tif (!compare_node || dom.hasClass(compare_node, value))\r\n\t\t\t\t\t\tdom.removeClass(node, value);\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// Check for non internal attributes\r\n\t\t\t\tattrs = dom.getAttribs(node);\r\n\t\t\t\tfor (i = 0; i < attrs.length; i++) {\r\n\t\t\t\t\tif (attrs[i].nodeName.indexOf('_') !== 0)\r\n\t\t\t\t\t\treturn FALSE;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Remove the inline child if it's empty for example <b> or <span>\r\n\t\t\tif (format.remove != 'none') {\r\n\t\t\t\tremoveNode(node, format);\r\n\t\t\t\treturn TRUE;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Removes the node and wrap it's children in paragraphs before doing so or\r\n\t\t * appends BR elements to the beginning/end of the block element if forcedRootBlocks is disabled.\r\n\t\t *\r\n\t\t * If the div in the node below gets removed:\r\n\t\t *  text<div>text</div>text\r\n\t\t *\r\n\t\t * Output becomes:\r\n\t\t *  text<div><br />text<br /></div>text\r\n\t\t *\r\n\t\t * So when the div is removed the result is:\r\n\t\t *  text<br />text<br />text\r\n\t\t *\r\n\t\t * @private\r\n\t\t * @param {Node} node Node to remove + apply BR/P elements to.\r\n\t\t * @param {Object} format Format rule.\r\n\t\t * @return {Node} Input node.\r\n\t\t */\r\n\t\tfunction removeNode(node, format) {\r\n\t\t\tvar parentNode = node.parentNode, rootBlockElm;\r\n\r\n\t\t\tif (format.block) {\r\n\t\t\t\tif (!forcedRootBlock) {\r\n\t\t\t\t\tfunction find(node, next, inc) {\r\n\t\t\t\t\t\tnode = getNonWhiteSpaceSibling(node, next, inc);\r\n\r\n\t\t\t\t\t\treturn !node || (node.nodeName == 'BR' || isBlock(node));\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\t// Append BR elements if needed before we remove the block\r\n\t\t\t\t\tif (isBlock(node) && !isBlock(parentNode)) {\r\n\t\t\t\t\t\tif (!find(node, FALSE) && !find(node.firstChild, TRUE, 1))\r\n\t\t\t\t\t\t\tnode.insertBefore(dom.create('br'), node.firstChild);\r\n\r\n\t\t\t\t\t\tif (!find(node, TRUE) && !find(node.lastChild, FALSE, 1))\r\n\t\t\t\t\t\t\tnode.appendChild(dom.create('br'));\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Wrap the block in a forcedRootBlock if we are at the root of document\r\n\t\t\t\t\tif (parentNode == dom.getRoot()) {\r\n\t\t\t\t\t\tif (!format.list_block || !isEq(node, format.list_block)) {\r\n\t\t\t\t\t\t\teach(tinymce.grep(node.childNodes), function(node) {\r\n\t\t\t\t\t\t\t\tif (isValid(forcedRootBlock, node.nodeName.toLowerCase())) {\r\n\t\t\t\t\t\t\t\t\tif (!rootBlockElm)\r\n\t\t\t\t\t\t\t\t\t\trootBlockElm = wrap(node, forcedRootBlock);\r\n\t\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\t\trootBlockElm.appendChild(node);\r\n\t\t\t\t\t\t\t\t} else\r\n\t\t\t\t\t\t\t\t\trootBlockElm = 0;\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Never remove nodes that isn't the specified inline element if a selector is specified too\r\n\t\t\tif (format.selector && format.inline && !isEq(format.inline, node))\r\n\t\t\t\treturn;\r\n\r\n\t\t\tdom.remove(node, 1);\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Returns the next/previous non whitespace node.\r\n\t\t *\r\n\t\t * @private\r\n\t\t * @param {Node} node Node to start at.\r\n\t\t * @param {boolean} next (Optional) Include next or previous node defaults to previous.\r\n\t\t * @param {boolean} inc (Optional) Include the current node in checking. Defaults to false.\r\n\t\t * @return {Node} Next or previous node or undefined if it wasn't found.\r\n\t\t */\r\n\t\tfunction getNonWhiteSpaceSibling(node, next, inc) {\r\n\t\t\tif (node) {\r\n\t\t\t\tnext = next ? 'nextSibling' : 'previousSibling';\r\n\r\n\t\t\t\tfor (node = inc ? node : node[next]; node; node = node[next]) {\r\n\t\t\t\t\tif (node.nodeType == 1 || !isWhiteSpaceNode(node))\r\n\t\t\t\t\t\treturn node;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Checks if the specified node is a bookmark node or not.\r\n\t\t *\r\n\t\t * @param {Node} node Node to check if it's a bookmark node or not.\r\n\t\t * @return {Boolean} true/false if the node is a bookmark node.\r\n\t\t */\r\n\t\tfunction isBookmarkNode(node) {\r\n\t\t\treturn node && node.nodeType == 1 && node.getAttribute('data-mce-type') == 'bookmark';\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Merges the next/previous sibling element if they match.\r\n\t\t *\r\n\t\t * @private\r\n\t\t * @param {Node} prev Previous node to compare/merge.\r\n\t\t * @param {Node} next Next node to compare/merge.\r\n\t\t * @return {Node} Next node if we didn't merge and prev node if we did.\r\n\t\t */\r\n\t\tfunction mergeSiblings(prev, next) {\r\n\t\t\tvar marker, sibling, tmpSibling;\r\n\r\n\t\t\t/**\r\n\t\t\t * Compares two nodes and checks if it's attributes and styles matches.\r\n\t\t\t * This doesn't compare classes as items since their order is significant.\r\n\t\t\t *\r\n\t\t\t * @private\r\n\t\t\t * @param {Node} node1 First node to compare with.\r\n\t\t\t * @param {Node} node2 Second node to compare with.\r\n\t\t\t * @return {boolean} True/false if the nodes are the same or not.\r\n\t\t\t */\r\n\t\t\tfunction compareElements(node1, node2) {\r\n\t\t\t\t// Not the same name\r\n\t\t\t\tif (node1.nodeName != node2.nodeName)\r\n\t\t\t\t\treturn FALSE;\r\n\r\n\t\t\t\t/**\r\n\t\t\t\t * Returns all the nodes attributes excluding internal ones, styles and classes.\r\n\t\t\t\t *\r\n\t\t\t\t * @private\r\n\t\t\t\t * @param {Node} node Node to get attributes from.\r\n\t\t\t\t * @return {Object} Name/value object with attributes and attribute values.\r\n\t\t\t\t */\r\n\t\t\t\tfunction getAttribs(node) {\r\n\t\t\t\t\tvar attribs = {};\r\n\r\n\t\t\t\t\teach(dom.getAttribs(node), function(attr) {\r\n\t\t\t\t\t\tvar name = attr.nodeName.toLowerCase();\r\n\r\n\t\t\t\t\t\t// Don't compare internal attributes or style\r\n\t\t\t\t\t\tif (name.indexOf('_') !== 0 && name !== 'style')\r\n\t\t\t\t\t\t\tattribs[name] = dom.getAttrib(node, name);\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\treturn attribs;\r\n\t\t\t\t};\r\n\r\n\t\t\t\t/**\r\n\t\t\t\t * Compares two objects checks if it's key + value exists in the other one.\r\n\t\t\t\t *\r\n\t\t\t\t * @private\r\n\t\t\t\t * @param {Object} obj1 First object to compare.\r\n\t\t\t\t * @param {Object} obj2 Second object to compare.\r\n\t\t\t\t * @return {boolean} True/false if the objects matches or not.\r\n\t\t\t\t */\r\n\t\t\t\tfunction compareObjects(obj1, obj2) {\r\n\t\t\t\t\tvar value, name;\r\n\r\n\t\t\t\t\tfor (name in obj1) {\r\n\t\t\t\t\t\t// Obj1 has item obj2 doesn't have\r\n\t\t\t\t\t\tif (obj1.hasOwnProperty(name)) {\r\n\t\t\t\t\t\t\tvalue = obj2[name];\r\n\r\n\t\t\t\t\t\t\t// Obj2 doesn't have obj1 item\r\n\t\t\t\t\t\t\tif (value === undefined)\r\n\t\t\t\t\t\t\t\treturn FALSE;\r\n\r\n\t\t\t\t\t\t\t// Obj2 item has a different value\r\n\t\t\t\t\t\t\tif (obj1[name] != value)\r\n\t\t\t\t\t\t\t\treturn FALSE;\r\n\r\n\t\t\t\t\t\t\t// Delete similar value\r\n\t\t\t\t\t\t\tdelete obj2[name];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Check if obj 2 has something obj 1 doesn't have\r\n\t\t\t\t\tfor (name in obj2) {\r\n\t\t\t\t\t\t// Obj2 has item obj1 doesn't have\r\n\t\t\t\t\t\tif (obj2.hasOwnProperty(name))\r\n\t\t\t\t\t\t\treturn FALSE;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn TRUE;\r\n\t\t\t\t};\r\n\r\n\t\t\t\t// Attribs are not the same\r\n\t\t\t\tif (!compareObjects(getAttribs(node1), getAttribs(node2)))\r\n\t\t\t\t\treturn FALSE;\r\n\r\n\t\t\t\t// Styles are not the same\r\n\t\t\t\tif (!compareObjects(dom.parseStyle(dom.getAttrib(node1, 'style')), dom.parseStyle(dom.getAttrib(node2, 'style'))))\r\n\t\t\t\t\treturn FALSE;\r\n\r\n\t\t\t\treturn TRUE;\r\n\t\t\t};\r\n\r\n\t\t\t// Check if next/prev exists and that they are elements\r\n\t\t\tif (prev && next) {\r\n\t\t\t\tfunction findElementSibling(node, sibling_name) {\r\n\t\t\t\t\tfor (sibling = node; sibling; sibling = sibling[sibling_name]) {\r\n\t\t\t\t\t\tif (sibling.nodeType == 3 && sibling.nodeValue.length !== 0)\r\n\t\t\t\t\t\t\treturn node;\r\n\r\n\t\t\t\t\t\tif (sibling.nodeType == 1 && !isBookmarkNode(sibling))\r\n\t\t\t\t\t\t\treturn sibling;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn node;\r\n\t\t\t\t};\r\n\r\n\t\t\t\t// If previous sibling is empty then jump over it\r\n\t\t\t\tprev = findElementSibling(prev, 'previousSibling');\r\n\t\t\t\tnext = findElementSibling(next, 'nextSibling');\r\n\r\n\t\t\t\t// Compare next and previous nodes\r\n\t\t\t\tif (compareElements(prev, next)) {\r\n\t\t\t\t\t// Append nodes between\r\n\t\t\t\t\tfor (sibling = prev.nextSibling; sibling && sibling != next;) {\r\n\t\t\t\t\t\ttmpSibling = sibling;\r\n\t\t\t\t\t\tsibling = sibling.nextSibling;\r\n\t\t\t\t\t\tprev.appendChild(tmpSibling);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Remove next node\r\n\t\t\t\t\tdom.remove(next);\r\n\r\n\t\t\t\t\t// Move children into prev node\r\n\t\t\t\t\teach(tinymce.grep(next.childNodes), function(node) {\r\n\t\t\t\t\t\tprev.appendChild(node);\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\treturn prev;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn next;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Returns true/false if the specified node is a text block or not.\r\n\t\t *\r\n\t\t * @private\r\n\t\t * @param {Node} node Node to check.\r\n\t\t * @return {boolean} True/false if the node is a text block.\r\n\t\t */\r\n\t\tfunction isTextBlock(name) {\r\n\t\t\treturn /^(h[1-6]|p|div|pre|address|dl|dt|dd)$/.test(name);\r\n\t\t};\r\n\r\n\t\tfunction getContainer(rng, start) {\r\n\t\t\tvar container, offset, lastIdx, walker;\r\n\r\n\t\t\tcontainer = rng[start ? 'startContainer' : 'endContainer'];\r\n\t\t\toffset = rng[start ? 'startOffset' : 'endOffset'];\r\n\r\n\t\t\tif (container.nodeType == 1) {\r\n\t\t\t\tlastIdx = container.childNodes.length - 1;\r\n\r\n\t\t\t\tif (!start && offset)\r\n\t\t\t\t\toffset--;\r\n\r\n\t\t\t\tcontainer = container.childNodes[offset > lastIdx ? lastIdx : offset];\r\n\t\t\t}\r\n\r\n\t\t\t// If start text node is excluded then walk to the next node\r\n\t\t\tif (container.nodeType === 3 && start && offset >= container.nodeValue.length) {\r\n\t\t\t\tcontainer = new TreeWalker(container, ed.getBody()).next() || container;\r\n\t\t\t}\r\n\r\n\t\t\t// If end text node is excluded then walk to the previous node\r\n\t\t\tif (container.nodeType === 3 && !start && offset == 0) {\r\n\t\t\t\tcontainer = new TreeWalker(container, ed.getBody()).prev() || container;\r\n\t\t\t}\r\n\r\n\t\t\treturn container;\r\n\t\t};\r\n\r\n\t\tfunction performCaretAction(type, name, vars) {\r\n\t\t\tvar invisibleChar, caretContainerId = '_mce_caret', debug = ed.settings.caret_debug;\r\n\r\n\t\t\t// Setup invisible character use zero width space on Gecko since it doesn't change the heigt of the container\r\n\t\t\tinvisibleChar = tinymce.isGecko ? '\\u200B' : INVISIBLE_CHAR;\r\n\r\n\t\t\t// Creates a caret container bogus element\r\n\t\t\tfunction createCaretContainer(fill) {\r\n\t\t\t\tvar caretContainer = dom.create('span', {id: caretContainerId, 'data-mce-bogus': true, style: debug ? 'color:red' : ''});\r\n\r\n\t\t\t\tif (fill) {\r\n\t\t\t\t\tcaretContainer.appendChild(ed.getDoc().createTextNode(invisibleChar));\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn caretContainer;\r\n\t\t\t};\r\n\r\n\t\t\tfunction isCaretContainerEmpty(node, nodes) {\r\n\t\t\t\twhile (node) {\r\n\t\t\t\t\tif ((node.nodeType === 3 && node.nodeValue !== invisibleChar) || node.childNodes.length > 1) {\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Collect nodes\r\n\t\t\t\t\tif (nodes && node.nodeType === 1) {\r\n\t\t\t\t\t\tnodes.push(node);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tnode = node.firstChild;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn true;\r\n\t\t\t};\r\n\r\n\t\t\t// Returns any parent caret container element\r\n\t\t\tfunction getParentCaretContainer(node) {\r\n\t\t\t\twhile (node) {\r\n\t\t\t\t\tif (node.id === caretContainerId) {\r\n\t\t\t\t\t\treturn node;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tnode = node.parentNode;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\t// Finds the first text node in the specified node\r\n\t\t\tfunction findFirstTextNode(node) {\r\n\t\t\t\tvar walker;\r\n\r\n\t\t\t\tif (node) {\r\n\t\t\t\t\twalker = new TreeWalker(node, node);\r\n\r\n\t\t\t\t\tfor (node = walker.current(); node; node = walker.next()) {\r\n\t\t\t\t\t\tif (node.nodeType === 3) {\r\n\t\t\t\t\t\t\treturn node;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\t// Removes the caret container for the specified node or all on the current document\r\n\t\t\tfunction removeCaretContainer(node, move_caret) {\r\n\t\t\t\tvar child, rng;\r\n\r\n\t\t\t\tif (!node) {\r\n\t\t\t\t\tnode = getParentCaretContainer(selection.getStart());\r\n\r\n\t\t\t\t\tif (!node) {\r\n\t\t\t\t\t\twhile (node = dom.get(caretContainerId)) {\r\n\t\t\t\t\t\t\tremoveCaretContainer(node, false);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\trng = selection.getRng(true);\r\n\r\n\t\t\t\t\tif (isCaretContainerEmpty(node)) {\r\n\t\t\t\t\t\tif (move_caret !== false) {\r\n\t\t\t\t\t\t\trng.setStartBefore(node);\r\n\t\t\t\t\t\t\trng.setEndBefore(node);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tdom.remove(node);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tchild = findFirstTextNode(node);\r\n\t\t\t\t\t\tchild = child.deleteData(0, 1);\r\n\t\t\t\t\t\tdom.remove(node, 1);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tselection.setRng(rng);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\t// Applies formatting to the caret position\r\n\t\t\tfunction applyCaretFormat() {\r\n\t\t\t\tvar rng, caretContainer, textNode, offset, bookmark, container, text;\r\n\r\n\t\t\t\trng = selection.getRng(true);\r\n\t\t\t\toffset = rng.startOffset;\r\n\t\t\t\tcontainer = rng.startContainer;\r\n\t\t\t\ttext = container.nodeValue;\r\n\r\n\t\t\t\tcaretContainer = getParentCaretContainer(selection.getStart());\r\n\t\t\t\tif (caretContainer) {\r\n\t\t\t\t\ttextNode = findFirstTextNode(caretContainer);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Expand to word is caret is in the middle of a text node and the char before/after is a alpha numeric character\r\n\t\t\t\tif (text && offset > 0 && offset < text.length && /\\w/.test(text.charAt(offset)) && /\\w/.test(text.charAt(offset - 1))) {\r\n\t\t\t\t\t// Get bookmark of caret position\r\n\t\t\t\t\tbookmark = selection.getBookmark();\r\n\r\n\t\t\t\t\t// Collapse bookmark range (WebKit)\r\n\t\t\t\t\trng.collapse(true);\r\n\r\n\t\t\t\t\t// Expand the range to the closest word and split it at those points\r\n\t\t\t\t\trng = expandRng(rng, get(name));\r\n\t\t\t\t\trng = rangeUtils.split(rng);\r\n\r\n\t\t\t\t\t// Apply the format to the range\r\n\t\t\t\t\tapply(name, vars, rng);\r\n\r\n\t\t\t\t\t// Move selection back to caret position\r\n\t\t\t\t\tselection.moveToBookmark(bookmark);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (!caretContainer || textNode.nodeValue !== invisibleChar) {\r\n\t\t\t\t\t\tcaretContainer = createCaretContainer(true);\r\n\t\t\t\t\t\ttextNode = caretContainer.firstChild;\r\n\r\n\t\t\t\t\t\trng.insertNode(caretContainer);\r\n\t\t\t\t\t\toffset = 1;\r\n\r\n\t\t\t\t\t\tapply(name, vars, caretContainer);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tapply(name, vars, caretContainer);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Move selection to text node\r\n\t\t\t\t\tselection.setCursorLocation(textNode, offset);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tfunction removeCaretFormat() {\r\n\t\t\t\tvar rng = selection.getRng(true), container, offset, bookmark,\r\n\t\t\t\t\thasContentAfter, node, formatNode, parents = [], i, caretContainer;\r\n\r\n\t\t\t\tcontainer = rng.startContainer;\r\n\t\t\t\toffset = rng.startOffset;\r\n\t\t\t\tnode = container;\r\n\r\n\t\t\t\tif (container.nodeType == 3) {\r\n\t\t\t\t\tif (offset != container.nodeValue.length || container.nodeValue === invisibleChar) {\r\n\t\t\t\t\t\thasContentAfter = true;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tnode = node.parentNode;\r\n\t\t\t\t}\r\n\r\n\t\t\t\twhile (node) {\r\n\t\t\t\t\tif (matchNode(node, name, vars)) {\r\n\t\t\t\t\t\tformatNode = node;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (node.nextSibling) {\r\n\t\t\t\t\t\thasContentAfter = true;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tparents.push(node);\r\n\t\t\t\t\tnode = node.parentNode;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Node doesn't have the specified format\r\n\t\t\t\tif (!formatNode) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Is there contents after the caret then remove the format on the element\r\n\t\t\t\tif (hasContentAfter) {\r\n\t\t\t\t\t// Get bookmark of caret position\r\n\t\t\t\t\tbookmark = selection.getBookmark();\r\n\r\n\t\t\t\t\t// Collapse bookmark range (WebKit)\r\n\t\t\t\t\trng.collapse(true);\r\n\r\n\t\t\t\t\t// Expand the range to the closest word and split it at those points\r\n\t\t\t\t\trng = expandRng(rng, get(name), true);\r\n\t\t\t\t\trng = rangeUtils.split(rng);\r\n\r\n\t\t\t\t\t// Remove the format from the range\r\n\t\t\t\t\tremove(name, vars, rng);\r\n\r\n\t\t\t\t\t// Move selection back to caret position\r\n\t\t\t\t\tselection.moveToBookmark(bookmark);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcaretContainer = createCaretContainer();\r\n\r\n\t\t\t\t\tnode = caretContainer;\r\n\t\t\t\t\tfor (i = parents.length - 1; i >= 0; i--) {\r\n\t\t\t\t\t\tnode.appendChild(parents[i].cloneNode(false));\r\n\t\t\t\t\t\tnode = node.firstChild;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Insert invisible character into inner most format element\r\n\t\t\t\t\tnode.appendChild(dom.doc.createTextNode(invisibleChar));\r\n\t\t\t\t\tnode = node.firstChild;\r\n\r\n\t\t\t\t\t// Insert caret container after the formatted node\r\n\t\t\t\t\tdom.insertAfter(caretContainer, formatNode);\r\n\r\n\t\t\t\t\t// Move selection to text node\r\n\t\t\t\t\tselection.setCursorLocation(node, 1);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\t// Mark current caret container elements as bogus when getting the contents so we don't end up with empty elements\r\n\t\t\ted.onBeforeGetContent.addToTop(function() {\r\n\t\t\t\tvar nodes = [], i;\r\n\r\n\t\t\t\tif (isCaretContainerEmpty(getParentCaretContainer(selection.getStart()), nodes)) {\r\n\t\t\t\t\t// Mark children\r\n\t\t\t\t\ti = nodes.length;\r\n\t\t\t\t\twhile (i--) {\r\n\t\t\t\t\t\tdom.setAttrib(nodes[i], 'data-mce-bogus', '1');\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\t// Remove caret container on mouse up and on key up\r\n\t\t\ttinymce.each('onMouseUp onKeyUp'.split(' '), function(name) {\r\n\t\t\t\ted[name].addToTop(function() {\r\n\t\t\t\t\tremoveCaretContainer();\r\n\t\t\t\t});\r\n\t\t\t});\r\n\r\n\t\t\t// Remove caret container on keydown and it's a backspace, enter or left/right arrow keys\r\n\t\t\ted.onKeyDown.addToTop(function(ed, e) {\r\n\t\t\t\tvar keyCode = e.keyCode;\r\n\r\n\t\t\t\tif (keyCode == 8 || keyCode == 37 || keyCode == 39) {\r\n\t\t\t\t\tremoveCaretContainer(getParentCaretContainer(selection.getStart()));\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\t// Do apply or remove caret format\r\n\t\t\tif (type == \"apply\") {\r\n\t\t\t\tapplyCaretFormat();\r\n\t\t\t} else {\r\n\t\t\t\tremoveCaretFormat();\r\n\t\t\t}\r\n\t\t};\r\n\t};\r\n})(tinymce);\r\n","Magento_Tinymce3/tiny_mce/classes/LegacyInput.js":"/**\r\n * LegacyInput.js\r\n *\r\n * Copyright 2009, Moxiecode Systems AB\r\n * Released under LGPL License.\r\n *\r\n * License: http://tinymce.moxiecode.com/license\r\n * Contributing: http://tinymce.moxiecode.com/contributing\r\n */\r\n\r\ntinymce.onAddEditor.add(function(tinymce, ed) {\r\n\tvar filters, fontSizes, dom, settings = ed.settings;\r\n\r\n\tif (settings.inline_styles) {\r\n\t\tfontSizes = tinymce.explode(settings.font_size_legacy_values);\r\n\r\n\t\tfunction replaceWithSpan(node, styles) {\r\n\t\t\ttinymce.each(styles, function(value, name) {\r\n\t\t\t\tif (value)\r\n\t\t\t\t\tdom.setStyle(node, name, value);\r\n\t\t\t});\r\n\r\n\t\t\tdom.rename(node, 'span');\r\n\t\t};\r\n\r\n\t\tfilters = {\r\n\t\t\tfont : function(dom, node) {\r\n\t\t\t\treplaceWithSpan(node, {\r\n\t\t\t\t\tbackgroundColor : node.style.backgroundColor,\r\n\t\t\t\t\tcolor : node.color,\r\n\t\t\t\t\tfontFamily : node.face,\r\n\t\t\t\t\tfontSize : fontSizes[parseInt(node.size) - 1]\r\n\t\t\t\t});\r\n\t\t\t},\r\n\r\n\t\t\tu : function(dom, node) {\r\n\t\t\t\treplaceWithSpan(node, {\r\n\t\t\t\t\ttextDecoration : 'underline'\r\n\t\t\t\t});\r\n\t\t\t},\r\n\r\n\t\t\tstrike : function(dom, node) {\r\n\t\t\t\treplaceWithSpan(node, {\r\n\t\t\t\t\ttextDecoration : 'line-through'\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tfunction convert(editor, params) {\r\n\t\t\tdom = editor.dom;\r\n\r\n\t\t\tif (settings.convert_fonts_to_spans) {\r\n\t\t\t\ttinymce.each(dom.select('font,u,strike', params.node), function(node) {\r\n\t\t\t\t\tfilters[node.nodeName.toLowerCase()](ed.dom, node);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\ted.onPreProcess.add(convert);\r\n\t\ted.onSetContent.add(convert);\r\n\r\n\t\ted.onInit.add(function() {\r\n\t\t\ted.selection.onSetContent.add(convert);\r\n\t\t});\r\n\t}\r\n});\r\n","Magento_Tinymce3/tiny_mce/classes/Popup.js":"/**\r\n * Popup.js\r\n *\r\n * Copyright 2009, Moxiecode Systems AB\r\n * Released under LGPL License.\r\n *\r\n * License: http://tinymce.moxiecode.com/license\r\n * Contributing: http://tinymce.moxiecode.com/contributing\r\n */\r\n\r\n// Some global instances\r\nvar tinymce = null, tinyMCEPopup, tinyMCE;\r\n\r\n/**\r\n * TinyMCE popup/dialog helper class. This gives you easy access to the\r\n * parent editor instance and a bunch of other things. It's higly recommended\r\n * that you load this script into your dialogs.\r\n *\r\n * @static\r\n * @class tinyMCEPopup\r\n */\r\ntinyMCEPopup = {\r\n\t/**\r\n\t * Initializes the popup this will be called automatically.\r\n\t *\r\n\t * @method init\r\n\t */\r\n\tinit : function() {\r\n\t\tvar t = this, w, ti;\r\n\r\n\t\t// Find window & API\r\n\t\tw = t.getWin();\r\n\t\ttinymce = w.tinymce;\r\n\t\ttinyMCE = w.tinyMCE;\r\n\t\tt.editor = tinymce.EditorManager.activeEditor;\r\n\t\tt.params = t.editor.windowManager.params;\r\n\t\tt.features = t.editor.windowManager.features;\r\n\r\n\t\t// Setup local DOM\r\n\t\tt.dom = t.editor.windowManager.createInstance('tinymce.dom.DOMUtils', document);\r\n\r\n\t\t// Enables you to skip loading the default css\r\n\t\tif (t.features.popup_css !== false)\r\n\t\t\tt.dom.loadCSS(t.features.popup_css || t.editor.settings.popup_css);\r\n\r\n\t\t// Setup on init listeners\r\n\t\tt.listeners = [];\r\n\r\n\t\t/**\r\n\t\t * Fires when the popup is initialized.\r\n\t\t *\r\n\t\t * @event onInit\r\n\t\t * @param {tinymce.Editor} editor Editor instance.\r\n\t\t * @example\r\n\t\t * // Alerts the selected contents when the dialog is loaded\r\n\t\t * tinyMCEPopup.onInit.add(function(ed) {\r\n\t\t *     alert(ed.selection.getContent());\r\n\t\t * });\r\n\t\t *\r\n\t\t * // Executes the init method on page load in some object using the SomeObject scope\r\n\t\t * tinyMCEPopup.onInit.add(SomeObject.init, SomeObject);\r\n\t\t */\r\n\t\tt.onInit = {\r\n\t\t\tadd : function(f, s) {\r\n\t\t\t\tt.listeners.push({func : f, scope : s});\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tt.isWindow = !t.getWindowArg('mce_inline');\r\n\t\tt.id = t.getWindowArg('mce_window_id');\r\n\t\tt.editor.windowManager.onOpen.dispatch(t.editor.windowManager, window);\r\n\t},\r\n\r\n\t/**\r\n\t * Returns the reference to the parent window that opened the dialog.\r\n\t *\r\n\t * @method getWin\r\n\t * @return {Window} Reference to the parent window that opened the dialog.\r\n\t */\r\n\tgetWin : function() {\r\n\t\t// Added frameElement check to fix bug: #2817583\r\n\t\treturn (!window.frameElement && window.dialogArguments) || opener || parent || top;\r\n\t},\r\n\r\n\t/**\r\n\t * Returns a window argument/parameter by name.\r\n\t *\r\n\t * @method getWindowArg\r\n\t * @param {String} n Name of the window argument to retrieve.\r\n\t * @param {String} dv Optional default value to return.\r\n\t * @return {String} Argument value or default value if it wasn't found.\r\n\t */\r\n\tgetWindowArg : function(n, dv) {\r\n\t\tvar v = this.params[n];\r\n\r\n\t\treturn tinymce.is(v) ? v : dv;\r\n\t},\r\n\r\n\t/**\r\n\t * Returns a editor parameter/config option value.\r\n\t *\r\n\t * @method getParam\r\n\t * @param {String} n Name of the editor config option to retrieve.\r\n\t * @param {String} dv Optional default value to return.\r\n\t * @return {String} Parameter value or default value if it wasn't found.\r\n\t */\r\n\tgetParam : function(n, dv) {\r\n\t\treturn this.editor.getParam(n, dv);\r\n\t},\r\n\r\n\t/**\r\n\t * Returns a language item by key.\r\n\t *\r\n\t * @method getLang\r\n\t * @param {String} n Language item like mydialog.something.\r\n\t * @param {String} dv Optional default value to return.\r\n\t * @return {String} Language value for the item like \"my string\" or the default value if it wasn't found.\r\n\t */\r\n\tgetLang : function(n, dv) {\r\n\t\treturn this.editor.getLang(n, dv);\r\n\t},\r\n\r\n\t/**\r\n\t * Executed a command on editor that opened the dialog/popup.\r\n\t *\r\n\t * @method execCommand\r\n\t * @param {String} cmd Command to execute.\r\n\t * @param {Boolean} ui Optional boolean value if the UI for the command should be presented or not.\r\n\t * @param {Object} val Optional value to pass with the comman like an URL.\r\n\t * @param {Object} a Optional arguments object.\r\n\t */\r\n\texecCommand : function(cmd, ui, val, a) {\r\n\t\ta = a || {};\r\n\t\ta.skip_focus = 1;\r\n\r\n\t\tthis.restoreSelection();\r\n\t\treturn this.editor.execCommand(cmd, ui, val, a);\r\n\t},\r\n\r\n\t/**\r\n\t * Resizes the dialog to the inner size of the window. This is needed since various browsers\r\n\t * have different border sizes on windows.\r\n\t *\r\n\t * @method resizeToInnerSize\r\n\t */\r\n\tresizeToInnerSize : function() {\r\n\t\tvar t = this;\r\n\r\n\t\t// Detach it to workaround a Chrome specific bug\r\n\t\t// https://sourceforge.net/tracker/?func=detail&atid=635682&aid=2926339&group_id=103281\r\n\t\tsetTimeout(function() {\r\n\t\t\tvar vp = t.dom.getViewPort(window);\r\n\r\n\t\t\tt.editor.windowManager.resizeBy(\r\n\t\t\t\tt.getWindowArg('mce_width') - vp.w,\r\n\t\t\t\tt.getWindowArg('mce_height') - vp.h,\r\n\t\t\t\tt.id || window\r\n\t\t\t);\r\n\t\t}, 10);\r\n\t},\r\n\r\n\t/**\r\n\t * Will executed the specified string when the page has been loaded. This function\r\n\t * was added for compatibility with the 2.x branch.\r\n\t *\r\n\t * @method executeOnLoad\r\n\t * @param {String} s String to evalutate on init.\r\n\t */\r\n\texecuteOnLoad : function(s) {\r\n\t\tthis.onInit.add(function() {\r\n\t\t\teval(s);\r\n\t\t});\r\n\t},\r\n\r\n\t/**\r\n\t * Stores the current editor selection for later restoration. This can be useful since some browsers\r\n\t * looses it's selection if a control element is selected/focused inside the dialogs.\r\n\t *\r\n\t * @method storeSelection\r\n\t */\r\n\tstoreSelection : function() {\r\n\t\tthis.editor.windowManager.bookmark = tinyMCEPopup.editor.selection.getBookmark(1);\r\n\t},\r\n\r\n\t/**\r\n\t * Restores any stored selection. This can be useful since some browsers\r\n\t * looses it's selection if a control element is selected/focused inside the dialogs.\r\n\t *\r\n\t * @method restoreSelection\r\n\t */\r\n\trestoreSelection : function() {\r\n\t\tvar t = tinyMCEPopup;\r\n\r\n\t\tif (!t.isWindow && tinymce.isIE)\r\n\t\t\tt.editor.selection.moveToBookmark(t.editor.windowManager.bookmark);\r\n\t},\r\n\r\n\t/**\r\n\t * Loads a specific dialog language pack. If you pass in plugin_url as a arugment\r\n\t * when you open the window it will load the <plugin url>/langs/<code>_dlg.js lang pack file.\r\n\t *\r\n\t * @method requireLangPack\r\n\t */\r\n\trequireLangPack : function() {\r\n\t\tvar t = this, u = t.getWindowArg('plugin_url') || t.getWindowArg('theme_url');\r\n\r\n\t\tif (u && t.editor.settings.language && t.features.translate_i18n !== false && t.editor.settings.language_load !== false) {\r\n\t\t\tu += '/langs/' + t.editor.settings.language + '_dlg.js';\r\n\r\n\t\t\tif (!tinymce.ScriptLoader.isDone(u)) {\r\n\t\t\t\tdocument.write('<script type=\"text/javascript\" src=\"' + tinymce._addVer(u) + '\"></script>');\r\n\t\t\t\ttinymce.ScriptLoader.markDone(u);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * Executes a color picker on the specified element id. When the user\r\n\t * then selects a color it will be set as the value of the specified element.\r\n\t *\r\n\t * @method pickColor\r\n\t * @param {DOMEvent} e DOM event object.\r\n\t * @param {string} element_id Element id to be filled with the color value from the picker.\r\n\t */\r\n\tpickColor : function(e, element_id) {\r\n\t\tthis.execCommand('mceColorPicker', true, {\r\n\t\t\tcolor : document.getElementById(element_id).value,\r\n\t\t\tfunc : function(c) {\r\n\t\t\t\tdocument.getElementById(element_id).value = c;\r\n\r\n\t\t\t\ttry {\r\n\t\t\t\t\tdocument.getElementById(element_id).onchange();\r\n\t\t\t\t} catch (ex) {\r\n\t\t\t\t\t// Try fire event, ignore errors\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t},\r\n\r\n\t/**\r\n\t * Opens a filebrowser/imagebrowser this will set the output value from\r\n\t * the browser as a value on the specified element.\r\n\t *\r\n\t * @method openBrowser\r\n\t * @param {string} element_id Id of the element to set value in.\r\n\t * @param {string} type Type of browser to open image/file/flash.\r\n\t * @param {string} option Option name to get the file_broswer_callback function name from.\r\n\t */\r\n\topenBrowser : function(element_id, type, option) {\r\n\t\ttinyMCEPopup.restoreSelection();\r\n\t\tthis.editor.execCallback('file_browser_callback', element_id, document.getElementById(element_id).value, type, window);\r\n\t},\r\n\r\n\t/**\r\n\t * Creates a confirm dialog. Please don't use the blocking behavior of this\r\n\t * native version use the callback method instead then it can be extended.\r\n\t *\r\n\t * @method confirm\r\n\t * @param {String} t Title for the new confirm dialog.\r\n\t * @param {function} cb Callback function to be executed after the user has selected ok or cancel.\r\n\t * @param {Object} s Optional scope to execute the callback in.\r\n\t */\r\n\tconfirm : function(t, cb, s) {\r\n\t\tthis.editor.windowManager.confirm(t, cb, s, window);\r\n\t},\r\n\r\n\t/**\r\n\t * Creates a alert dialog. Please don't use the blocking behavior of this\r\n\t * native version use the callback method instead then it can be extended.\r\n\t *\r\n\t * @method alert\r\n\t * @param {String} t Title for the new alert dialog.\r\n\t * @param {function} cb Callback function to be executed after the user has selected ok.\r\n\t * @param {Object} s Optional scope to execute the callback in.\r\n\t */\r\n\talert : function(tx, cb, s) {\r\n\t\tthis.editor.windowManager.alert(tx, cb, s, window);\r\n\t},\r\n\r\n\t/**\r\n\t * Closes the current window.\r\n\t *\r\n\t * @method close\r\n\t */\r\n\tclose : function() {\r\n\t\tvar t = this;\r\n\r\n\t\t// To avoid domain relaxing issue in Opera\r\n\t\tfunction close() {\r\n\t\t\tt.editor.windowManager.close(window);\r\n\t\t\ttinymce = tinyMCE = t.editor = t.params = t.dom = t.dom.doc = null; // Cleanup\r\n\t\t};\r\n\r\n\t\tif (tinymce.isOpera)\r\n\t\t\tt.getWin().setTimeout(close, 0);\r\n\t\telse\r\n\t\t\tclose();\r\n\t},\r\n\r\n\t// Internal functions\r\n\r\n\t_restoreSelection : function() {\r\n\t\tvar e = window.event.srcElement;\r\n\r\n\t\tif (e.nodeName == 'INPUT' && (e.type == 'submit' || e.type == 'button'))\r\n\t\t\ttinyMCEPopup.restoreSelection();\r\n\t},\r\n\r\n/*\t_restoreSelection : function() {\r\n\t\tvar e = window.event.srcElement;\r\n\r\n\t\t// If user focus a non text input or textarea\r\n\t\tif ((e.nodeName != 'INPUT' && e.nodeName != 'TEXTAREA') || e.type != 'text')\r\n\t\t\ttinyMCEPopup.restoreSelection();\r\n\t},*/\r\n\r\n\t_onDOMLoaded : function() {\r\n\t\tvar t = tinyMCEPopup, ti = document.title, bm, h, nv;\r\n\r\n\t\tif (t.domLoaded)\r\n\t\t\treturn;\r\n\r\n\t\tt.domLoaded = 1;\r\n\r\n\t\t// Translate page\r\n\t\tif (t.features.translate_i18n !== false) {\r\n\t\t\th = document.body.innerHTML;\r\n\r\n\t\t\t// Replace a=x with a=\"x\" in IE\r\n\t\t\tif (tinymce.isIE)\r\n\t\t\t\th = h.replace(/ (value|title|alt)=([^\"][^\\s>]+)/gi, ' $1=\"$2\"')\r\n\r\n\t\t\tdocument.dir = t.editor.getParam('directionality','');\r\n\r\n\t\t\tif ((nv = t.editor.translate(h)) && nv != h)\r\n\t\t\t\tdocument.body.innerHTML = nv;\r\n\r\n\t\t\tif ((nv = t.editor.translate(ti)) && nv != ti)\r\n\t\t\t\tdocument.title = ti = nv;\r\n\t\t}\r\n\r\n\t\tif (!t.editor.getParam('browser_preferred_colors', false) || !t.isWindow)\r\n\t\t\tt.dom.addClass(document.body, 'forceColors');\r\n\r\n\t\tdocument.body.style.display = '';\r\n\r\n\t\t// Restore selection in IE when focus is placed on a non textarea or input element of the type text\r\n\t\tif (tinymce.isIE) {\r\n\t\t\tdocument.attachEvent('onmouseup', tinyMCEPopup._restoreSelection);\r\n\r\n\t\t\t// Add base target element for it since it would fail with modal dialogs\r\n\t\t\tt.dom.add(t.dom.select('head')[0], 'base', {target : '_self'});\r\n\t\t}\r\n\r\n\t\tt.restoreSelection();\r\n\t\tt.resizeToInnerSize();\r\n\r\n\t\t// Set inline title\r\n\t\tif (!t.isWindow)\r\n\t\t\tt.editor.windowManager.setTitle(window, ti);\r\n\t\telse\r\n\t\t\twindow.focus();\r\n\r\n\t\tif (!tinymce.isIE && !t.isWindow) {\r\n\t\t\ttinymce.dom.Event._add(document, 'focus', function() {\r\n\t\t\t\tt.editor.windowManager.focus(t.id);\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\t// Patch for accessibility\r\n\t\ttinymce.each(t.dom.select('select'), function(e) {\r\n\t\t\te.onkeydown = tinyMCEPopup._accessHandler;\r\n\t\t});\r\n\r\n\t\t// Call onInit\r\n\t\t// Init must be called before focus so the selection won't get lost by the focus call\r\n\t\ttinymce.each(t.listeners, function(o) {\r\n\t\t\to.func.call(o.scope, t.editor);\r\n\t\t});\r\n\r\n\t\t// Move focus to window\r\n\t\tif (t.getWindowArg('mce_auto_focus', true)) {\r\n\t\t\twindow.focus();\r\n\r\n\t\t\t// Focus element with mceFocus class\r\n\t\t\ttinymce.each(document.forms, function(f) {\r\n\t\t\t\ttinymce.each(f.elements, function(e) {\r\n\t\t\t\t\tif (t.dom.hasClass(e, 'mceFocus') && !e.disabled) {\r\n\t\t\t\t\t\te.focus();\r\n\t\t\t\t\t\treturn false; // Break loop\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tdocument.onkeyup = tinyMCEPopup._closeWinKeyHandler;\r\n\t},\r\n\r\n\t_accessHandler : function(e) {\r\n\t\te = e || window.event;\r\n\r\n\t\tif (e.keyCode == 13 || e.keyCode == 32) {\r\n\t\t\te = e.target || e.srcElement;\r\n\r\n\t\t\tif (e.onchange)\r\n\t\t\t\te.onchange();\r\n\r\n\t\t\treturn tinymce.dom.Event.cancel(e);\r\n\t\t}\r\n\t},\r\n\r\n\t_closeWinKeyHandler : function(e) {\r\n\t\te = e || window.event;\r\n\r\n\t\tif (e.keyCode == 27)\r\n\t\t\ttinyMCEPopup.close();\r\n\t},\r\n\r\n\t_wait : function() {\r\n\t\t// Use IE method\r\n\t\tif (document.attachEvent) {\r\n\t\t\tdocument.attachEvent(\"onreadystatechange\", function() {\r\n\t\t\t\tif (document.readyState === \"complete\") {\r\n\t\t\t\t\tdocument.detachEvent(\"onreadystatechange\", arguments.callee);\r\n\t\t\t\t\ttinyMCEPopup._onDOMLoaded();\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tif (document.documentElement.doScroll && window == window.top) {\r\n\t\t\t\t(function() {\r\n\t\t\t\t\tif (tinyMCEPopup.domLoaded)\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\t// If IE is used, use the trick by Diego Perini licensed under MIT by request to the author.\r\n\t\t\t\t\t\t// http://javascript.nwbox.com/IEContentLoaded/\r\n\t\t\t\t\t\tdocument.documentElement.doScroll(\"left\");\r\n\t\t\t\t\t} catch (ex) {\r\n\t\t\t\t\t\tsetTimeout(arguments.callee, 0);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttinyMCEPopup._onDOMLoaded();\r\n\t\t\t\t})();\r\n\t\t\t}\r\n\r\n\t\t\tdocument.attachEvent('onload', tinyMCEPopup._onDOMLoaded);\r\n\t\t} else if (document.addEventListener) {\r\n\t\t\twindow.addEventListener('DOMContentLoaded', tinyMCEPopup._onDOMLoaded, false);\r\n\t\t\twindow.addEventListener('load', tinyMCEPopup._onDOMLoaded, false);\r\n\t\t}\r\n\t}\r\n};\r\n\r\ntinyMCEPopup.init();\r\ntinyMCEPopup._wait(); // Wait for DOM Content Loaded\r\n","Magento_Tinymce3/tiny_mce/classes/tinymce.js":"/**\r\n * tinymce.js\r\n *\r\n * Copyright 2009, Moxiecode Systems AB\r\n * Released under LGPL License.\r\n *\r\n * License: http://tinymce.moxiecode.com/license\r\n * Contributing: http://tinymce.moxiecode.com/contributing\r\n */\r\n\r\n(function(win) {\r\n\tvar whiteSpaceRe = /^\\s*|\\s*$/g,\r\n\t\tundefined, isRegExpBroken = 'B'.replace(/A(.)|B/, '$1') === '$1';\r\n\r\n\t/**\r\n\t * Core namespace with core functionality for the TinyMCE API all sub classes will be added to this namespace/object.\r\n\t *\r\n\t * @static\r\n\t * @class tinymce\r\n\t * @example\r\n\t * // Using each method\r\n\t * tinymce.each([1, 2, 3], function(v, i) {\r\n\t *   console.log(i + '=' + v);\r\n\t * });\r\n\t *\r\n\t * // Checking for a specific browser\r\n\t * if (tinymce.isIE)\r\n\t *   console.log(\"IE\");\r\n\t */\r\n\tvar tinymce = {\r\n\t\t/**\r\n\t\t * Major version of TinyMCE build.\r\n\t\t *\r\n\t\t * @property majorVersion\r\n\t\t * @type String\r\n\t\t */\r\n\t\tmajorVersion : '@@tinymce_major_version@@',\r\n\r\n\t\t/**\r\n\t\t * Major version of TinyMCE build.\r\n\t\t *\r\n\t\t * @property minorVersion\r\n\t\t * @type String\r\n\t\t */\r\n\t\tminorVersion : '@@tinymce_minor_version@@',\r\n\r\n\t\t/**\r\n\t\t * Release date of TinyMCE build.\r\n\t\t *\r\n\t\t * @property releaseDate\r\n\t\t * @type String\r\n\t\t */\r\n\t\treleaseDate : '@@tinymce_release_date@@',\r\n\r\n\t\t/**\r\n\t\t * Initializes the TinyMCE global namespace this will setup browser detection and figure out where TinyMCE is running from.\r\n\t\t */\r\n\t\t_init : function() {\r\n\t\t\tvar t = this, d = document, na = navigator, ua = na.userAgent, i, nl, n, base, p, v;\r\n\r\n\t\t\t/**\r\n\t\t\t * Constant that is true if the browser is Opera.\r\n\t\t\t *\r\n\t\t\t * @property isOpera\r\n\t\t\t * @type Boolean\r\n\t\t\t * @final\r\n\t\t\t */\r\n\t\t\tt.isOpera = win.opera && opera.buildNumber;\r\n\r\n\t\t\t/**\r\n\t\t\t * Constant that is true if the browser is WebKit (Safari/Chrome).\r\n\t\t\t *\r\n\t\t\t * @property isWebKit\r\n\t\t\t * @type Boolean\r\n\t\t\t * @final\r\n\t\t\t */\r\n\t\t\tt.isWebKit = /WebKit/.test(ua);\r\n\r\n\t\t\t/**\r\n\t\t\t * Constant that is true if the browser is IE.\r\n\t\t\t *\r\n\t\t\t * @property isIE\r\n\t\t\t * @type Boolean\r\n\t\t\t * @final\r\n\t\t\t */\r\n\t\t\tt.isIE = !t.isWebKit && !t.isOpera && (/MSIE/gi).test(ua) && (/Explorer/gi).test(na.appName);\r\n\r\n\t\t\t/**\r\n\t\t\t * Constant that is true if the browser is IE 6 or older.\r\n\t\t\t *\r\n\t\t\t * @property isIE6\r\n\t\t\t * @type Boolean\r\n\t\t\t * @final\r\n\t\t\t */\r\n\t\t\tt.isIE6 = t.isIE && /MSIE [56]/.test(ua);\r\n\r\n\t\t\t/**\r\n\t\t\t * Constant that is true if the browser is IE 7.\r\n\t\t\t *\r\n\t\t\t * @property isIE7\r\n\t\t\t * @type Boolean\r\n\t\t\t * @final\r\n\t\t\t */\r\n\t\t\tt.isIE7 = t.isIE && /MSIE [7]/.test(ua);\r\n\r\n\t\t\t/**\r\n\t\t\t * Constant that is true if the browser is IE 8.\r\n\t\t\t *\r\n\t\t\t * @property isIE8\r\n\t\t\t * @type Boolean\r\n\t\t\t * @final\r\n\t\t\t */\r\n\t\t\tt.isIE8 = t.isIE && /MSIE [8]/.test(ua);\r\n\r\n\t\t\t/**\r\n\t\t\t * Constant that is true if the browser is IE 9.\r\n\t\t\t *\r\n\t\t\t * @property isIE9\r\n\t\t\t * @type Boolean\r\n\t\t\t * @final\r\n\t\t\t */\r\n\t\t\tt.isIE9 = t.isIE && /MSIE [9]/.test(ua);\r\n\r\n\t\t\t/**\r\n\t\t\t * Constant that is true if the browser is Gecko.\r\n\t\t\t *\r\n\t\t\t * @property isGecko\r\n\t\t\t * @type Boolean\r\n\t\t\t * @final\r\n\t\t\t */\r\n\t\t\tt.isGecko = !t.isWebKit && /Gecko/.test(ua);\r\n\r\n\t\t\t/**\r\n\t\t\t * Constant that is true if the os is Mac OS.\r\n\t\t\t *\r\n\t\t\t * @property isMac\r\n\t\t\t * @type Boolean\r\n\t\t\t * @final\r\n\t\t\t */\r\n\t\t\tt.isMac = ua.indexOf('Mac') != -1;\r\n\r\n\t\t\t/**\r\n\t\t\t * Constant that is true if the runtime is Adobe Air.\r\n\t\t\t *\r\n\t\t\t * @property isAir\r\n\t\t\t * @type Boolean\r\n\t\t\t * @final\r\n\t\t\t */\r\n\t\t\tt.isAir = /adobeair/i.test(ua);\r\n\r\n\t\t\t/**\r\n\t\t\t * Constant that tells if the current browser is an iPhone or iPad.\r\n\t\t\t *\r\n\t\t\t * @property isIDevice\r\n\t\t\t * @type Boolean\r\n\t\t\t * @final\r\n\t\t\t */\r\n\t\t\tt.isIDevice = /(iPad|iPhone)/.test(ua);\r\n\t\t\t\r\n\t\t\t/**\r\n\t\t\t * Constant that is true if the current browser is running on iOS 5 or greater.\r\n\t\t\t *\r\n\t\t\t * @property isIOS5\r\n\t\t\t * @type Boolean\r\n\t\t\t * @final\r\n\t\t\t */\r\n\t\t\tt.isIOS5 = t.isIDevice && ua.match(/AppleWebKit\\/(\\d*)/)[1]>=534;\r\n\r\n\t\t\t// TinyMCE .NET webcontrol might be setting the values for TinyMCE\r\n\t\t\tif (win.tinyMCEPreInit) {\r\n\t\t\t\tt.suffix = tinyMCEPreInit.suffix;\r\n\t\t\t\tt.baseURL = tinyMCEPreInit.base;\r\n\t\t\t\tt.query = tinyMCEPreInit.query;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// Get suffix and base\r\n\t\t\tt.suffix = '';\r\n\r\n\t\t\t// If base element found, add that infront of baseURL\r\n\t\t\tnl = d.getElementsByTagName('base');\r\n\t\t\tfor (i=0; i<nl.length; i++) {\r\n\t\t\t\tif (v = nl[i].href) {\r\n\t\t\t\t\t// Host only value like http://site.com or http://site.com:8008\r\n\t\t\t\t\tif (/^https?:\\/\\/[^\\/]+$/.test(v))\r\n\t\t\t\t\t\tv += '/';\r\n\r\n\t\t\t\t\tbase = v ? v.match(/.*\\//)[0] : ''; // Get only directory\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tfunction getBase(n) {\r\n\t\t\t\tif (n.src && /tiny_mce(|_gzip|_jquery|_prototype|_full)(_dev|_src)?.js/.test(n.src)) {\r\n\t\t\t\t\tif (/_(src|dev)\\.js/g.test(n.src))\r\n\t\t\t\t\t\tt.suffix = '_src';\r\n\r\n\t\t\t\t\tif ((p = n.src.indexOf('?')) != -1)\r\n\t\t\t\t\t\tt.query = n.src.substring(p + 1);\r\n\r\n\t\t\t\t\tt.baseURL = n.src.substring(0, n.src.lastIndexOf('/'));\r\n\r\n\t\t\t\t\t// If path to script is relative and a base href was found add that one infront\r\n\t\t\t\t\t// the src property will always be an absolute one on non IE browsers and IE 8\r\n\t\t\t\t\t// so this logic will basically only be executed on older IE versions\r\n\t\t\t\t\tif (base && t.baseURL.indexOf('://') == -1 && t.baseURL.indexOf('/') !== 0)\r\n\t\t\t\t\t\tt.baseURL = base + t.baseURL;\r\n\r\n\t\t\t\t\treturn t.baseURL;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn null;\r\n\t\t\t};\r\n\r\n\t\t\t// Check document\r\n\t\t\tnl = d.getElementsByTagName('script');\r\n\t\t\tfor (i=0; i<nl.length; i++) {\r\n\t\t\t\tif (getBase(nl[i]))\r\n\t\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// Check head\r\n\t\t\tn = d.getElementsByTagName('head')[0];\r\n\t\t\tif (n) {\r\n\t\t\t\tnl = n.getElementsByTagName('script');\r\n\t\t\t\tfor (i=0; i<nl.length; i++) {\r\n\t\t\t\t\tif (getBase(nl[i]))\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Checks if a object is of a specific type for example an array.\r\n\t\t *\r\n\t\t * @method is\r\n\t\t * @param {Object} o Object to check type of.\r\n\t\t * @param {string} t Optional type to check for.\r\n\t\t * @return {Boolean} true/false if the object is of the specified type.\r\n\t\t */\r\n\t\tis : function(o, t) {\r\n\t\t\tif (!t)\r\n\t\t\t\treturn o !== undefined;\r\n\r\n\t\t\tif (t == 'array' && (o.hasOwnProperty && o instanceof Array))\r\n\t\t\t\treturn true;\r\n\r\n\t\t\treturn typeof(o) == t;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Makes a name/object map out of an array with names.\r\n\t\t *\r\n\t\t * @method makeMap\r\n\t\t * @param {Array/String} items Items to make map out of.\r\n\t\t * @param {String} delim Optional delimiter to split string by.\r\n\t\t * @param {Object} map Optional map to add items to.\r\n\t\t * @return {Object} Name/value map of items.\r\n\t\t */\r\n\t\tmakeMap : function(items, delim, map) {\r\n\t\t\tvar i;\r\n\r\n\t\t\titems = items || [];\r\n\t\t\tdelim = delim || ',';\r\n\r\n\t\t\tif (typeof(items) == \"string\")\r\n\t\t\t\titems = items.split(delim);\r\n\r\n\t\t\tmap = map || {};\r\n\r\n\t\t\ti = items.length;\r\n\t\t\twhile (i--)\r\n\t\t\t\tmap[items[i]] = {};\r\n\r\n\t\t\treturn map;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Performs an iteration of all items in a collection such as an object or array. This method will execure the\r\n\t\t * callback function for each item in the collection, if the callback returns false the iteration will terminate.\r\n\t\t * The callback has the following format: cb(value, key_or_index).\r\n\t\t *\r\n\t\t * @method each\r\n\t\t * @param {Object} o Collection to iterate.\r\n\t\t * @param {function} cb Callback function to execute for each item.\r\n\t\t * @param {Object} s Optional scope to execute the callback in.\r\n\t\t * @example\r\n\t\t * // Iterate an array\r\n\t\t * tinymce.each([1,2,3], function(v, i) {\r\n\t\t *     console.debug(\"Value: \" + v + \", Index: \" + i);\r\n\t\t * });\r\n\t\t * \r\n\t\t * // Iterate an object\r\n\t\t * tinymce.each({a : 1, b : 2, c: 3], function(v, k) {\r\n\t\t *     console.debug(\"Value: \" + v + \", Key: \" + k);\r\n\t\t * });\r\n\t\t */\r\n\t\teach : function(o, cb, s) {\r\n\t\t\tvar n, l;\r\n\r\n\t\t\tif (!o)\r\n\t\t\t\treturn 0;\r\n\r\n\t\t\ts = s || o;\r\n\r\n\t\t\tif (o.length !== undefined) {\r\n\t\t\t\t// Indexed arrays, needed for Safari\r\n\t\t\t\tfor (n=0, l = o.length; n < l; n++) {\r\n\t\t\t\t\tif (cb.call(s, o[n], n, o) === false)\r\n\t\t\t\t\t\treturn 0;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t// Hashtables\r\n\t\t\t\tfor (n in o) {\r\n\t\t\t\t\tif (o.hasOwnProperty(n)) {\r\n\t\t\t\t\t\tif (cb.call(s, o[n], n, o) === false)\r\n\t\t\t\t\t\t\treturn 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn 1;\r\n\t\t},\r\n\r\n\t\t// #ifndef jquery\r\n\r\n\t\t/**\r\n\t\t * Creates a new array by the return value of each iteration function call. This enables you to convert\r\n\t\t * one array list into another.\r\n\t\t *\r\n\t\t * @method map\r\n\t\t * @param {Array} a Array of items to iterate.\r\n\t\t * @param {function} f Function to call for each item. It's return value will be the new value.\r\n\t\t * @return {Array} Array with new values based on function return values.\r\n\t\t */\r\n\t\tmap : function(a, f) {\r\n\t\t\tvar o = [];\r\n\r\n\t\t\ttinymce.each(a, function(v) {\r\n\t\t\t\to.push(f(v));\r\n\t\t\t});\r\n\r\n\t\t\treturn o;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Filters out items from the input array by calling the specified function for each item.\r\n\t\t * If the function returns false the item will be excluded if it returns true it will be included.\r\n\t\t *\r\n\t\t * @method grep\r\n\t\t * @param {Array} a Array of items to loop though.\r\n\t\t * @param {function} f Function to call for each item. Include/exclude depends on it's return value.\r\n\t\t * @return {Array} New array with values imported and filtered based in input.\r\n\t\t * @example\r\n\t\t * // Filter out some items, this will return an array with 4 and 5\r\n\t\t * var items = tinymce.grep([1,2,3,4,5], function(v) {return v > 3;});\r\n\t\t */\r\n\t\tgrep : function(a, f) {\r\n\t\t\tvar o = [];\r\n\r\n\t\t\ttinymce.each(a, function(v) {\r\n\t\t\t\tif (!f || f(v))\r\n\t\t\t\t\to.push(v);\r\n\t\t\t});\r\n\r\n\t\t\treturn o;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns the index of a value in an array, this method will return -1 if the item wasn't found.\r\n\t\t *\r\n\t\t * @method inArray\r\n\t\t * @param {Array} a Array/Object to search for value in.\r\n\t\t * @param {Object} v Value to check for inside the array.\r\n\t\t * @return {Number/String} Index of item inside the array inside an object. Or -1 if it wasn't found.\r\n\t\t * @example\r\n\t\t * // Get index of value in array this will alert 1 since 2 is at that index\r\n\t\t * alert(tinymce.inArray([1,2,3], 2));\r\n\t\t */\r\n\t\tinArray : function(a, v) {\r\n\t\t\tvar i, l;\r\n\r\n\t\t\tif (a) {\r\n\t\t\t\tfor (i = 0, l = a.length; i < l; i++) {\r\n\t\t\t\t\tif (a[i] === v)\r\n\t\t\t\t\t\treturn i;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn -1;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Extends an object with the specified other object(s).\r\n\t\t *\r\n\t\t * @method extend\r\n\t\t * @param {Object} o Object to extend with new items.\r\n\t\t * @param {Object} e..n Object(s) to extend the specified object with.\r\n\t\t * @return {Object} o New extended object, same reference as the input object.\r\n\t\t * @example\r\n\t\t * // Extends obj1 with two new fields\r\n\t\t * var obj = tinymce.extend(obj1, {\r\n\t\t *     somefield1 : 'a',\r\n\t\t *     somefield2 : 'a'\r\n\t\t * });\r\n\t\t * \r\n\t\t * // Extends obj with obj2 and obj3\r\n\t\t * tinymce.extend(obj, obj2, obj3);\r\n\t\t */\r\n\t\textend : function(o, e) {\r\n\t\t\tvar i, l, a = arguments;\r\n\r\n\t\t\tfor (i = 1, l = a.length; i < l; i++) {\r\n\t\t\t\te = a[i];\r\n\r\n\t\t\t\ttinymce.each(e, function(v, n) {\r\n\t\t\t\t\tif (v !== undefined)\r\n\t\t\t\t\t\to[n] = v;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\treturn o;\r\n\t\t},\r\n\r\n\t\t// #endif\r\n\r\n\t\t/**\r\n\t\t * Removes whitespace from the beginning and end of a string.\r\n\t\t *\r\n\t\t * @method trim\r\n\t\t * @param {String} s String to remove whitespace from.\r\n\t\t * @return {String} New string with removed whitespace.\r\n\t\t */\r\n\t\ttrim : function(s) {\r\n\t\t\treturn (s ? '' + s : '').replace(whiteSpaceRe, '');\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Creates a class, subclass or static singleton.\r\n\t\t * More details on this method can be found in the Wiki.\r\n\t\t *\r\n\t\t * @method create\r\n\t\t * @param {String} s Class name, inheritage and prefix.\r\n\t\t * @param {Object} p Collection of methods to add to the class.\r\n\t\t * @param {Object} root Optional root object defaults to the global window object.\r\n\t\t * @example\r\n\t\t * // Creates a basic class\r\n\t\t * tinymce.create('tinymce.somepackage.SomeClass', {\r\n\t\t *     SomeClass : function() {\r\n\t\t *         // Class constructor\r\n\t\t *     },\r\n\t\t * \r\n\t\t *     method : function() {\r\n\t\t *         // Some method\r\n\t\t *     }\r\n\t\t * });\r\n\t\t *\r\n\t\t * // Creates a basic subclass class\r\n\t\t * tinymce.create('tinymce.somepackage.SomeSubClass:tinymce.somepackage.SomeClass', {\r\n\t\t *     SomeSubClass: function() {\r\n\t\t *         // Class constructor\r\n\t\t *         this.parent(); // Call parent constructor\r\n\t\t *     },\r\n\t\t * \r\n\t\t *     method : function() {\r\n\t\t *         // Some method\r\n\t\t *         this.parent(); // Call parent method\r\n\t\t *     },\r\n\t\t * \r\n\t\t *     'static' : {\r\n\t\t *         staticMethod : function() {\r\n\t\t *             // Static method\r\n\t\t *         }\r\n\t\t *     }\r\n\t\t * });\r\n\t\t *\r\n\t\t * // Creates a singleton/static class\r\n\t\t * tinymce.create('static tinymce.somepackage.SomeSingletonClass', {\r\n\t\t *     method : function() {\r\n\t\t *         // Some method\r\n\t\t *     }\r\n\t\t * });\r\n\t\t */\r\n\t\tcreate : function(s, p, root) {\r\n\t\t\tvar t = this, sp, ns, cn, scn, c, de = 0;\r\n\r\n\t\t\t// Parse : <prefix> <class>:<super class>\r\n\t\t\ts = /^((static) )?([\\w.]+)(:([\\w.]+))?/.exec(s);\r\n\t\t\tcn = s[3].match(/(^|\\.)(\\w+)$/i)[2]; // Class name\r\n\r\n\t\t\t// Create namespace for new class\r\n\t\t\tns = t.createNS(s[3].replace(/\\.\\w+$/, ''), root);\r\n\r\n\t\t\t// Class already exists\r\n\t\t\tif (ns[cn])\r\n\t\t\t\treturn;\r\n\r\n\t\t\t// Make pure static class\r\n\t\t\tif (s[2] == 'static') {\r\n\t\t\t\tns[cn] = p;\r\n\r\n\t\t\t\tif (this.onCreate)\r\n\t\t\t\t\tthis.onCreate(s[2], s[3], ns[cn]);\r\n\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// Create default constructor\r\n\t\t\tif (!p[cn]) {\r\n\t\t\t\tp[cn] = function() {};\r\n\t\t\t\tde = 1;\r\n\t\t\t}\r\n\r\n\t\t\t// Add constructor and methods\r\n\t\t\tns[cn] = p[cn];\r\n\t\t\tt.extend(ns[cn].prototype, p);\r\n\r\n\t\t\t// Extend\r\n\t\t\tif (s[5]) {\r\n\t\t\t\tsp = t.resolve(s[5]).prototype;\r\n\t\t\t\tscn = s[5].match(/\\.(\\w+)$/i)[1]; // Class name\r\n\r\n\t\t\t\t// Extend constructor\r\n\t\t\t\tc = ns[cn];\r\n\t\t\t\tif (de) {\r\n\t\t\t\t\t// Add passthrough constructor\r\n\t\t\t\t\tns[cn] = function() {\r\n\t\t\t\t\t\treturn sp[scn].apply(this, arguments);\r\n\t\t\t\t\t};\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Add inherit constructor\r\n\t\t\t\t\tns[cn] = function() {\r\n\t\t\t\t\t\tthis.parent = sp[scn];\r\n\t\t\t\t\t\treturn c.apply(this, arguments);\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t\tns[cn].prototype[cn] = ns[cn];\r\n\r\n\t\t\t\t// Add super methods\r\n\t\t\t\tt.each(sp, function(f, n) {\r\n\t\t\t\t\tns[cn].prototype[n] = sp[n];\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// Add overridden methods\r\n\t\t\t\tt.each(p, function(f, n) {\r\n\t\t\t\t\t// Extend methods if needed\r\n\t\t\t\t\tif (sp[n]) {\r\n\t\t\t\t\t\tns[cn].prototype[n] = function() {\r\n\t\t\t\t\t\t\tthis.parent = sp[n];\r\n\t\t\t\t\t\t\treturn f.apply(this, arguments);\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (n != cn)\r\n\t\t\t\t\t\t\tns[cn].prototype[n] = f;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// Add static methods\r\n\t\t\tt.each(p['static'], function(f, n) {\r\n\t\t\t\tns[cn][n] = f;\r\n\t\t\t});\r\n\r\n\t\t\tif (this.onCreate)\r\n\t\t\t\tthis.onCreate(s[2], s[3], ns[cn].prototype);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Executed the specified function for each item in a object tree.\r\n\t\t *\r\n\t\t * @method walk\r\n\t\t * @param {Object} o Object tree to walk though.\r\n\t\t * @param {function} f Function to call for each item.\r\n\t\t * @param {String} n Optional name of collection inside the objects to walk for example childNodes.\r\n\t\t * @param {String} s Optional scope to execute the function in.\r\n\t\t */\r\n\t\twalk : function(o, f, n, s) {\r\n\t\t\ts = s || this;\r\n\r\n\t\t\tif (o) {\r\n\t\t\t\tif (n)\r\n\t\t\t\t\to = o[n];\r\n\r\n\t\t\t\ttinymce.each(o, function(o, i) {\r\n\t\t\t\t\tif (f.call(s, o, i, n) === false)\r\n\t\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t\ttinymce.walk(o, f, n, s);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Creates a namespace on a specific object.\r\n\t\t *\r\n\t\t * @method createNS\r\n\t\t * @param {String} n Namespace to create for example a.b.c.d.\r\n\t\t * @param {Object} o Optional object to add namespace to, defaults to window.\r\n\t\t * @return {Object} New namespace object the last item in path.\r\n\t\t * @example\r\n\t\t * // Create some namespace\r\n\t\t * tinymce.createNS('tinymce.somepackage.subpackage');\r\n\t\t *\r\n\t\t * // Add a singleton\r\n\t\t * var tinymce.somepackage.subpackage.SomeSingleton = {\r\n\t\t *     method : function() {\r\n\t\t *         // Some method\r\n\t\t *     }\r\n\t\t * };\r\n\t\t */\r\n\t\tcreateNS : function(n, o) {\r\n\t\t\tvar i, v;\r\n\r\n\t\t\to = o || win;\r\n\r\n\t\t\tn = n.split('.');\r\n\t\t\tfor (i=0; i<n.length; i++) {\r\n\t\t\t\tv = n[i];\r\n\r\n\t\t\t\tif (!o[v])\r\n\t\t\t\t\to[v] = {};\r\n\r\n\t\t\t\to = o[v];\r\n\t\t\t}\r\n\r\n\t\t\treturn o;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Resolves a string and returns the object from a specific structure.\r\n\t\t *\r\n\t\t * @method resolve\r\n\t\t * @param {String} n Path to resolve for example a.b.c.d.\r\n\t\t * @param {Object} o Optional object to search though, defaults to window.\r\n\t\t * @return {Object} Last object in path or null if it couldn't be resolved.\r\n\t\t * @example\r\n\t\t * // Resolve a path into an object reference\r\n\t\t * var obj = tinymce.resolve('a.b.c.d');\r\n\t\t */\r\n\t\tresolve : function(n, o) {\r\n\t\t\tvar i, l;\r\n\r\n\t\t\to = o || win;\r\n\r\n\t\t\tn = n.split('.');\r\n\t\t\tfor (i = 0, l = n.length; i < l; i++) {\r\n\t\t\t\to = o[n[i]];\r\n\r\n\t\t\t\tif (!o)\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\treturn o;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Adds an unload handler to the document. This handler will be executed when the document gets unloaded.\r\n\t\t * This method is useful for dealing with browser memory leaks where it might be vital to remove DOM references etc.\r\n\t\t *\r\n\t\t * @method addUnload\r\n\t\t * @param {function} f Function to execute before the document gets unloaded.\r\n\t\t * @param {Object} s Optional scope to execute the function in.\r\n\t\t * @return {function} Returns the specified unload handler function.\r\n\t\t * @example\r\n\t\t * // Fixes a leak with a DOM element that was palces in the someObject\r\n\t\t * tinymce.addUnload(function() {\r\n\t\t *     // Null DOM element to reduce IE memory leak\r\n\t\t *     someObject.someElement = null;\r\n\t\t * });\r\n\t\t */\r\n\t\taddUnload : function(f, s) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\tf = {func : f, scope : s || this};\r\n\r\n\t\t\tif (!t.unloads) {\r\n\t\t\t\tfunction unload() {\r\n\t\t\t\t\tvar li = t.unloads, o, n;\r\n\r\n\t\t\t\t\tif (li) {\r\n\t\t\t\t\t\t// Call unload handlers\r\n\t\t\t\t\t\tfor (n in li) {\r\n\t\t\t\t\t\t\to = li[n];\r\n\r\n\t\t\t\t\t\t\tif (o && o.func)\r\n\t\t\t\t\t\t\t\to.func.call(o.scope, 1); // Send in one arg to distinct unload and user destroy\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Detach unload function\r\n\t\t\t\t\t\tif (win.detachEvent) {\r\n\t\t\t\t\t\t\twin.detachEvent('onbeforeunload', fakeUnload);\r\n\t\t\t\t\t\t\twin.detachEvent('onunload', unload);\r\n\t\t\t\t\t\t} else if (win.removeEventListener)\r\n\t\t\t\t\t\t\twin.removeEventListener('unload', unload, false);\r\n\r\n\t\t\t\t\t\t// Destroy references\r\n\t\t\t\t\t\tt.unloads = o = li = w = unload = 0;\r\n\r\n\t\t\t\t\t\t// Run garbarge collector on IE\r\n\t\t\t\t\t\tif (win.CollectGarbage)\r\n\t\t\t\t\t\t\tCollectGarbage();\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\r\n\t\t\t\tfunction fakeUnload() {\r\n\t\t\t\t\tvar d = document;\r\n\r\n\t\t\t\t\t// Is there things still loading, then do some magic\r\n\t\t\t\t\tif (d.readyState == 'interactive') {\r\n\t\t\t\t\t\tfunction stop() {\r\n\t\t\t\t\t\t\t// Prevent memory leak\r\n\t\t\t\t\t\t\td.detachEvent('onstop', stop);\r\n\r\n\t\t\t\t\t\t\t// Call unload handler\r\n\t\t\t\t\t\t\tif (unload)\r\n\t\t\t\t\t\t\t\tunload();\r\n\r\n\t\t\t\t\t\t\td = 0;\r\n\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\t// Fire unload when the currently loading page is stopped\r\n\t\t\t\t\t\tif (d)\r\n\t\t\t\t\t\t\td.attachEvent('onstop', stop);\r\n\r\n\t\t\t\t\t\t// Remove onstop listener after a while to prevent the unload function\r\n\t\t\t\t\t\t// to execute if the user presses cancel in an onbeforeunload\r\n\t\t\t\t\t\t// confirm dialog and then presses the browser stop button\r\n\t\t\t\t\t\twin.setTimeout(function() {\r\n\t\t\t\t\t\t\tif (d)\r\n\t\t\t\t\t\t\t\td.detachEvent('onstop', stop);\r\n\t\t\t\t\t\t}, 0);\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\r\n\t\t\t\t// Attach unload handler\r\n\t\t\t\tif (win.attachEvent) {\r\n\t\t\t\t\twin.attachEvent('onunload', unload);\r\n\t\t\t\t\twin.attachEvent('onbeforeunload', fakeUnload);\r\n\t\t\t\t} else if (win.addEventListener)\r\n\t\t\t\t\twin.addEventListener('unload', unload, false);\r\n\r\n\t\t\t\t// Setup initial unload handler array\r\n\t\t\t\tt.unloads = [f];\r\n\t\t\t} else\r\n\t\t\t\tt.unloads.push(f);\r\n\r\n\t\t\treturn f;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Removes the specified function form the unload handler list.\r\n\t\t *\r\n\t\t * @method removeUnload\r\n\t\t * @param {function} f Function to remove from unload handler list.\r\n\t\t * @return {function} Removed function name or null if it wasn't found.\r\n\t\t */\r\n\t\tremoveUnload : function(f) {\r\n\t\t\tvar u = this.unloads, r = null;\r\n\r\n\t\t\ttinymce.each(u, function(o, i) {\r\n\t\t\t\tif (o && o.func == f) {\r\n\t\t\t\t\tu.splice(i, 1);\r\n\t\t\t\t\tr = f;\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\treturn r;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Splits a string but removes the whitespace before and after each value.\r\n\t\t *\r\n\t\t * @method explode\r\n\t\t * @param {string} s String to split.\r\n\t\t * @param {string} d Delimiter to split by.\r\n\t\t * @example\r\n\t\t * // Split a string into an array with a,b,c\r\n\t\t * var arr = tinymce.explode('a, b,   c');\r\n\t\t */\r\n\t\texplode : function(s, d) {\r\n\t\t\treturn s ? tinymce.map(s.split(d || ','), tinymce.trim) : s;\r\n\t\t},\r\n\r\n\t\t_addVer : function(u) {\r\n\t\t\tvar v;\r\n\r\n\t\t\tif (!this.query)\r\n\t\t\t\treturn u;\r\n\r\n\t\t\tv = (u.indexOf('?') == -1 ? '?' : '&') + this.query;\r\n\r\n\t\t\tif (u.indexOf('#') == -1)\r\n\t\t\t\treturn u + v;\r\n\r\n\t\t\treturn u.replace('#', v + '#');\r\n\t\t},\r\n\r\n\t\t// Fix function for IE 9 where regexps isn't working correctly\r\n\t\t// Todo: remove me once MS fixes the bug\r\n\t\t_replace : function(find, replace, str) {\r\n\t\t\t// On IE9 we have to fake $x replacement\r\n\t\t\tif (isRegExpBroken) {\r\n\t\t\t\treturn str.replace(find, function() {\r\n\t\t\t\t\tvar val = replace, args = arguments, i;\r\n\r\n\t\t\t\t\tfor (i = 0; i < args.length - 2; i++) {\r\n\t\t\t\t\t\tif (args[i] === undefined) {\r\n\t\t\t\t\t\t\tval = val.replace(new RegExp('\\\\$' + i, 'g'), '');\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tval = val.replace(new RegExp('\\\\$' + i, 'g'), args[i]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn val;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\treturn str.replace(find, replace);\r\n\t\t}\r\n\r\n\t\t/**#@-*/\r\n\t};\r\n\r\n\t// Initialize the API\r\n\ttinymce._init();\r\n\r\n\t// Expose tinymce namespace to the global namespace (window)\r\n\twin.tinymce = win.tinyMCE = tinymce;\r\n\r\n\t// Describe the different namespaces\r\n\r\n\t/**\r\n\t * Root level namespace this contains classes directly releated to the TinyMCE editor.\r\n\t *\r\n\t * @namespace tinymce\r\n\t */\r\n\r\n\t/**\r\n\t * Contains classes for handling the browsers DOM.\r\n\t *\r\n\t * @namespace tinymce.dom\r\n\t */\r\n\r\n\t/**\r\n\t * Contains html parser and serializer logic.\r\n\t *\r\n\t * @namespace tinymce.html\r\n\t */\r\n\r\n\t/**\r\n\t * Contains the different UI types such as buttons, listboxes etc.\r\n\t *\r\n\t * @namespace tinymce.ui\r\n\t */\r\n\r\n\t/**\r\n\t * Contains various utility classes such as json parser, cookies etc.\r\n\t *\r\n\t * @namespace tinymce.util\r\n\t */\r\n\r\n\t/**\r\n\t * Contains plugin classes.\r\n\t *\r\n\t * @namespace tinymce.plugins\r\n\t */\r\n})(window);\r\n","Magento_Tinymce3/tiny_mce/classes/UndoManager.js":"/**\r\n * UndoManager.js\r\n *\r\n * Copyright 2009, Moxiecode Systems AB\r\n * Released under LGPL License.\r\n *\r\n * License: http://tinymce.moxiecode.com/license\r\n * Contributing: http://tinymce.moxiecode.com/contributing\r\n */\r\n\r\n(function(tinymce) {\r\n\tvar Dispatcher = tinymce.util.Dispatcher;\r\n\r\n\t/**\r\n\t * This class handles the undo/redo history levels for the editor. Since the build in undo/redo has major drawbacks a custom one was needed.\r\n\t *\r\n\t * @class tinymce.UndoManager\r\n\t */\r\n\ttinymce.UndoManager = function(editor) {\r\n\t\tvar self, index = 0, data = [], beforeBookmark;\r\n\r\n\t\tfunction getContent() {\r\n\t\t\treturn tinymce.trim(editor.getContent({format : 'raw', no_events : 1}));\r\n\t\t};\r\n\r\n\t\treturn self = {\r\n\t\t\t/**\r\n\t\t\t * State if the user is currently typing or not. This will add a typing operation into one undo\r\n\t\t\t * level instead of one new level for each keystroke.\r\n\t\t\t *\r\n\t\t\t * @field {Boolean} typing\r\n\t\t\t */\r\n\t\t\ttyping : false,\r\n\r\n\t\t\t/**\r\n\t\t\t * This event will fire each time a new undo level is added to the undo manager.\r\n\t\t\t *\r\n\t\t\t * @event onAdd\r\n\t\t\t * @param {tinymce.UndoManager} sender UndoManager instance that got the new level.\r\n\t\t\t * @param {Object} level The new level object containing a bookmark and contents.\r\n\t\t\t */\r\n\t\t\tonAdd : new Dispatcher(self),\r\n\r\n\t\t\t/**\r\n\t\t\t * This event will fire when the user make an undo of a change.\r\n\t\t\t *\r\n\t\t\t * @event onUndo\r\n\t\t\t * @param {tinymce.UndoManager} sender UndoManager instance that got the new level.\r\n\t\t\t * @param {Object} level The old level object containing a bookmark and contents.\r\n\t\t\t */\r\n\t\t\tonUndo : new Dispatcher(self),\r\n\r\n\t\t\t/**\r\n\t\t\t * This event will fire when the user make an redo of a change.\r\n\t\t\t *\r\n\t\t\t * @event onRedo\r\n\t\t\t * @param {tinymce.UndoManager} sender UndoManager instance that got the new level.\r\n\t\t\t * @param {Object} level The old level object containing a bookmark and contents.\r\n\t\t\t */\r\n\t\t\tonRedo : new Dispatcher(self),\r\n\r\n\t\t\t/**\r\n\t\t\t * Stores away a bookmark to be used when performing an undo action so that the selection is before\r\n\t\t\t * the change has been made.\r\n\t\t\t *\r\n\t\t\t * @method beforeChange\r\n\t\t\t */\r\n\t\t\tbeforeChange : function() {\r\n\t\t\t\tbeforeBookmark = editor.selection.getBookmark(2, true);\r\n\t\t\t},\r\n\r\n\t\t\t/**\r\n\t\t\t * Adds a new undo level/snapshot to the undo list.\r\n\t\t\t *\r\n\t\t\t * @method add\r\n\t\t\t * @param {Object} l Optional undo level object to add.\r\n\t\t\t * @return {Object} Undo level that got added or null it a level wasn't needed.\r\n\t\t\t */\r\n\t\t\tadd : function(level) {\r\n\t\t\t\tvar i, settings = editor.settings, lastLevel;\r\n\r\n\t\t\t\tlevel = level || {};\r\n\t\t\t\tlevel.content = getContent();\r\n\r\n\t\t\t\t// Add undo level if needed\r\n\t\t\t\tlastLevel = data[index];\r\n\t\t\t\tif (lastLevel && lastLevel.content == level.content)\r\n\t\t\t\t\treturn null;\r\n\r\n\t\t\t\t// Set before bookmark on previous level\r\n\t\t\t\tif (data[index])\r\n\t\t\t\t\tdata[index].beforeBookmark = beforeBookmark;\r\n\r\n\t\t\t\t// Time to compress\r\n\t\t\t\tif (settings.custom_undo_redo_levels) {\r\n\t\t\t\t\tif (data.length > settings.custom_undo_redo_levels) {\r\n\t\t\t\t\t\tfor (i = 0; i < data.length - 1; i++)\r\n\t\t\t\t\t\t\tdata[i] = data[i + 1];\r\n\r\n\t\t\t\t\t\tdata.length--;\r\n\t\t\t\t\t\tindex = data.length;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Get a non intrusive normalized bookmark\r\n\t\t\t\tlevel.bookmark = editor.selection.getBookmark(2, true);\r\n\r\n\t\t\t\t// Crop array if needed\r\n\t\t\t\tif (index < data.length - 1)\r\n\t\t\t\t\tdata.length = index + 1;\r\n\r\n\t\t\t\tdata.push(level);\r\n\t\t\t\tindex = data.length - 1;\r\n\r\n\t\t\t\tself.onAdd.dispatch(self, level);\r\n\t\t\t\teditor.isNotDirty = 0;\r\n\r\n\t\t\t\treturn level;\r\n\t\t\t},\r\n\r\n\t\t\t/**\r\n\t\t\t * Undoes the last action.\r\n\t\t\t *\r\n\t\t\t * @method undo\r\n\t\t\t * @return {Object} Undo level or null if no undo was performed.\r\n\t\t\t */\r\n\t\t\tundo : function() {\r\n\t\t\t\tvar level, i;\r\n\r\n\t\t\t\tif (self.typing) {\r\n\t\t\t\t\tself.add();\r\n\t\t\t\t\tself.typing = false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (index > 0) {\r\n\t\t\t\t\tlevel = data[--index];\r\n\r\n\t\t\t\t\teditor.setContent(level.content, {format : 'raw'});\r\n\t\t\t\t\teditor.selection.moveToBookmark(level.beforeBookmark);\r\n\r\n\t\t\t\t\tself.onUndo.dispatch(self, level);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn level;\r\n\t\t\t},\r\n\r\n\t\t\t/**\r\n\t\t\t * Redoes the last action.\r\n\t\t\t *\r\n\t\t\t * @method redo\r\n\t\t\t * @return {Object} Redo level or null if no redo was performed.\r\n\t\t\t */\r\n\t\t\tredo : function() {\r\n\t\t\t\tvar level;\r\n\r\n\t\t\t\tif (index < data.length - 1) {\r\n\t\t\t\t\tlevel = data[++index];\r\n\r\n\t\t\t\t\teditor.setContent(level.content, {format : 'raw'});\r\n\t\t\t\t\teditor.selection.moveToBookmark(level.bookmark);\r\n\r\n\t\t\t\t\tself.onRedo.dispatch(self, level);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn level;\r\n\t\t\t},\r\n\r\n\t\t\t/**\r\n\t\t\t * Removes all undo levels.\r\n\t\t\t *\r\n\t\t\t * @method clear\r\n\t\t\t */\r\n\t\t\tclear : function() {\r\n\t\t\t\tdata = [];\r\n\t\t\t\tindex = 0;\r\n\t\t\t\tself.typing = false;\r\n\t\t\t},\r\n\r\n\t\t\t/**\r\n\t\t\t * Returns true/false if the undo manager has any undo levels.\r\n\t\t\t *\r\n\t\t\t * @method hasUndo\r\n\t\t\t * @return {Boolean} true/false if the undo manager has any undo levels.\r\n\t\t\t */\r\n\t\t\thasUndo : function() {\r\n\t\t\t\treturn index > 0 || this.typing;\r\n\t\t\t},\r\n\r\n\t\t\t/**\r\n\t\t\t * Returns true/false if the undo manager has any redo levels.\r\n\t\t\t *\r\n\t\t\t * @method hasRedo\r\n\t\t\t * @return {Boolean} true/false if the undo manager has any redo levels.\r\n\t\t\t */\r\n\t\t\thasRedo : function() {\r\n\t\t\t\treturn index < data.length - 1 && !this.typing;\r\n\t\t\t}\r\n\t\t};\r\n\t};\r\n})(tinymce);\r\n","Magento_Tinymce3/tiny_mce/classes/WindowManager.js":"/**\r\n * WindowManager.js\r\n *\r\n * Copyright 2009, Moxiecode Systems AB\r\n * Released under LGPL License.\r\n *\r\n * License: http://tinymce.moxiecode.com/license\r\n * Contributing: http://tinymce.moxiecode.com/contributing\r\n */\r\n\r\n(function(tinymce) {\r\n\tvar Dispatcher = tinymce.util.Dispatcher, each = tinymce.each, isIE = tinymce.isIE, isOpera = tinymce.isOpera;\r\n\r\n\t/**\r\n\t * This class handles the creation of native windows and dialogs. This class can be extended to provide for example inline dialogs.\r\n\t *\r\n\t * @class tinymce.WindowManager\r\n\t * @example\r\n\t * // Opens a new dialog with the file.htm file and the size 320x240\r\n\t * // It also adds a custom parameter this can be retrieved by using tinyMCEPopup.getWindowArg inside the dialog.\r\n\t * tinyMCE.activeEditor.windowManager.open({\r\n\t *    url : 'file.htm',\r\n\t *    width : 320,\r\n\t *    height : 240\r\n\t * }, {\r\n\t *    custom_param : 1\r\n\t * });\r\n\t *\r\n\t * // Displays an alert box using the active editors window manager instance\r\n\t * tinyMCE.activeEditor.windowManager.alert('Hello world!');\r\n\t *\r\n\t * // Displays an confirm box and an alert message will be displayed depending on what you choose in the confirm\r\n\t * tinyMCE.activeEditor.windowManager.confirm(\"Do you want to do something\", function(s) {\r\n\t *    if (s)\r\n\t *       tinyMCE.activeEditor.windowManager.alert(\"Ok\");\r\n\t *    else\r\n\t *       tinyMCE.activeEditor.windowManager.alert(\"Cancel\");\r\n\t * });\r\n\t */\r\n\ttinymce.create('tinymce.WindowManager', {\r\n\t\t/**\r\n\t\t * Constructs a new window manager instance.\r\n\t\t *\r\n\t\t * @constructor\r\n\t\t * @method WindowManager\r\n\t\t * @param {tinymce.Editor} ed Editor instance that the windows are bound to.\r\n\t\t */\r\n\t\tWindowManager : function(ed) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\tt.editor = ed;\r\n\t\t\tt.onOpen = new Dispatcher(t);\r\n\t\t\tt.onClose = new Dispatcher(t);\r\n\t\t\tt.params = {};\r\n\t\t\tt.features = {};\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Opens a new window.\r\n\t\t *\r\n\t\t * @method open\r\n\t\t * @param {Object} s Optional name/value settings collection contains things like width/height/url etc.\r\n\t\t * @option {String} title Window title.\r\n\t\t * @option {String} file URL of the file to open in the window.\r\n\t\t * @option {Number} width Width in pixels.\r\n\t\t * @option {Number} height Height in pixels.\r\n\t\t * @option {Boolean} resizable Specifies whether the popup window is resizable or not.\r\n\t\t * @option {Boolean} maximizable Specifies whether the popup window has a \"maximize\" button and can get maximized or not.\r\n\t\t * @option {Boolean} inline Specifies whether to display in-line (set to 1 or true for in-line display; requires inlinepopups plugin).\r\n\t\t * @option {String/Boolean} popup_css Optional CSS to use in the popup. Set to false to remove the default one.\r\n\t\t * @option {Boolean} translate_i18n Specifies whether translation should occur or not of i18 key strings. Default is true.\r\n\t\t * @option {String/bool} close_previous Specifies whether a previously opened popup window is to be closed or not (like when calling the file browser window over the advlink popup).\r\n\t\t * @option {String/bool} scrollbars Specifies whether the popup window can have scrollbars if required (i.e. content larger than the popup size specified).\r\n\t\t * @param {Object} p Optional parameters/arguments collection can be used by the dialogs to retrieve custom parameters.\r\n\t\t * @option {String} plugin_url url to plugin if opening plugin window that calls tinyMCEPopup.requireLangPack() and needs access to the plugin language js files\r\n\t\t */\r\n\t\topen : function(s, p) {\r\n\t\t\tvar t = this, f = '', x, y, mo = t.editor.settings.dialog_type == 'modal', w, sw, sh, vp = tinymce.DOM.getViewPort(), u;\r\n\r\n\t\t\t// Default some options\r\n\t\t\ts = s || {};\r\n\t\t\tp = p || {};\r\n\t\t\tsw = isOpera ? vp.w : screen.width; // Opera uses windows inside the Opera window\r\n\t\t\tsh = isOpera ? vp.h : screen.height;\r\n\t\t\ts.name = s.name || 'mc_' + new Date().getTime();\r\n\t\t\ts.width = parseInt(s.width || 320);\r\n\t\t\ts.height = parseInt(s.height || 240);\r\n\t\t\ts.resizable = true;\r\n\t\t\ts.left = s.left || parseInt(sw / 2.0) - (s.width / 2.0);\r\n\t\t\ts.top = s.top || parseInt(sh / 2.0) - (s.height / 2.0);\r\n\t\t\tp.inline = false;\r\n\t\t\tp.mce_width = s.width;\r\n\t\t\tp.mce_height = s.height;\r\n\t\t\tp.mce_auto_focus = s.auto_focus;\r\n\r\n\t\t\tif (mo) {\r\n\t\t\t\tif (isIE) {\r\n\t\t\t\t\ts.center = true;\r\n\t\t\t\t\ts.help = false;\r\n\t\t\t\t\ts.dialogWidth = s.width + 'px';\r\n\t\t\t\t\ts.dialogHeight = s.height + 'px';\r\n\t\t\t\t\ts.scroll = s.scrollbars || false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Build features string\r\n\t\t\teach(s, function(v, k) {\r\n\t\t\t\tif (tinymce.is(v, 'boolean'))\r\n\t\t\t\t\tv = v ? 'yes' : 'no';\r\n\r\n\t\t\t\tif (!/^(name|url)$/.test(k)) {\r\n\t\t\t\t\tif (isIE && mo)\r\n\t\t\t\t\t\tf += (f ? ';' : '') + k + ':' + v;\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tf += (f ? ',' : '') + k + '=' + v;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tt.features = s;\r\n\t\t\tt.params = p;\r\n\t\t\tt.onOpen.dispatch(t, s, p);\r\n\r\n\t\t\tu = s.url || s.file;\r\n\t\t\tu = tinymce._addVer(u);\r\n\r\n\t\t\ttry {\r\n\t\t\t\tif (isIE && mo) {\r\n\t\t\t\t\tw = 1;\r\n\t\t\t\t\twindow.showModalDialog(u, window, f);\r\n\t\t\t\t} else\r\n\t\t\t\t\tw = window.open(u, s.name, f);\r\n\t\t\t} catch (ex) {\r\n\t\t\t\t// Ignore\r\n\t\t\t}\r\n\r\n\t\t\tif (!w)\r\n\t\t\t\talert(t.editor.getLang('popup_blocked'));\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Closes the specified window. This will also dispatch out a onClose event.\r\n\t\t *\r\n\t\t * @method close\r\n\t\t * @param {Window} w Native window object to close.\r\n\t\t */\r\n\t\tclose : function(w) {\r\n\t\t\tw.close();\r\n\t\t\tthis.onClose.dispatch(this);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Creates a instance of a class. This method was needed since IE can't create instances\r\n\t\t * of classes from a parent window due to some reference problem. Any arguments passed after the class name\r\n\t\t * will be passed as arguments to the constructor.\r\n\t\t *\r\n\t\t * @method createInstance\r\n\t\t * @param {String} cl Class name to create an instance of.\r\n\t\t * @return {Object} Instance of the specified class.\r\n\t\t * @example\r\n\t\t * var uri = tinyMCEPopup.editor.windowManager.createInstance('tinymce.util.URI', 'http://www.somesite.com');\r\n\t\t * alert(uri.getURI());\r\n\t\t */\r\n\t\tcreateInstance : function(cl, a, b, c, d, e) {\r\n\t\t\tvar f = tinymce.resolve(cl);\r\n\r\n\t\t\treturn new f(a, b, c, d, e);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Creates a confirm dialog. Please don't use the blocking behavior of this\r\n\t\t * native version use the callback method instead then it can be extended.\r\n\t\t *\r\n\t\t * @method confirm\r\n\t\t * @param {String} t Title for the new confirm dialog.\r\n\t\t * @param {function} cb Callback function to be executed after the user has selected ok or cancel.\r\n\t\t * @param {Object} s Optional scope to execute the callback in.\r\n\t\t * @example\r\n\t\t * // Displays an confirm box and an alert message will be displayed depending on what you choose in the confirm\r\n\t\t * tinyMCE.activeEditor.windowManager.confirm(\"Do you want to do something\", function(s) {\r\n\t\t *    if (s)\r\n\t\t *       tinyMCE.activeEditor.windowManager.alert(\"Ok\");\r\n\t\t *    else\r\n\t\t *       tinyMCE.activeEditor.windowManager.alert(\"Cancel\");\r\n\t\t * });\r\n\t\t */\r\n\t\tconfirm : function(t, cb, s, w) {\r\n\t\t\tw = w || window;\r\n\r\n\t\t\tcb.call(s || this, w.confirm(this._decode(this.editor.getLang(t, t))));\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Creates a alert dialog. Please don't use the blocking behavior of this\r\n\t\t * native version use the callback method instead then it can be extended.\r\n\t\t *\r\n\t\t * @method alert\r\n\t\t * @param {String} t Title for the new alert dialog.\r\n\t\t * @param {function} cb Callback function to be executed after the user has selected ok.\r\n\t\t * @param {Object} s Optional scope to execute the callback in.\r\n\t\t * @example\r\n\t\t * // Displays an alert box using the active editors window manager instance\r\n\t\t * tinyMCE.activeEditor.windowManager.alert('Hello world!');\r\n\t\t */\r\n\t\talert : function(tx, cb, s, w) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\tw = w || window;\r\n\t\t\tw.alert(t._decode(t.editor.getLang(tx, tx)));\r\n\r\n\t\t\tif (cb)\r\n\t\t\t\tcb.call(s || t);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Resizes the specified window or id.\r\n\t\t *\r\n\t\t * @param {Number} dw Delta width.\r\n\t\t * @param {Number} dh Delta height.\r\n\t\t * @param {window/id} win Window if the dialog isn't inline. Id if the dialog is inline.\r\n\t\t */\r\n\t\tresizeBy : function(dw, dh, win) {\r\n\t\t\twin.resizeBy(dw, dh);\r\n\t\t},\r\n\r\n\t\t// Internal functions\r\n\r\n\t\t_decode : function(s) {\r\n\t\t\treturn tinymce.DOM.decode(s).replace(/\\\\n/g, '\\n');\r\n\t\t}\r\n\t});\r\n}(tinymce));\r\n","Magento_Tinymce3/tiny_mce/classes/adapter/jquery/adapter.js":"/**\r\n * adapter.js\r\n *\r\n * Copyright 2009, Moxiecode Systems AB\r\n * Released under LGPL License.\r\n *\r\n * License: http://tinymce.moxiecode.com/license\r\n * Contributing: http://tinymce.moxiecode.com/contributing\r\n */\r\n\r\n// #ifdef jquery_adapter\r\n\r\n(function($, tinymce) {\r\n\tvar is = tinymce.is, attrRegExp = /^(href|src|style)$/i, undefined;\r\n\r\n\t// jQuery is undefined\r\n\tif (!$ && window.console) {\r\n\t\treturn console.log(\"Load jQuery first!\");\r\n\t}\r\n\r\n\t// Stick jQuery into the tinymce namespace\r\n\ttinymce.$ = $;\r\n\r\n\t// Setup adapter\r\n\ttinymce.adapter = {\r\n\t\tpatchEditor : function(editor) {\r\n\t\t\tvar fn = $.fn;\r\n\r\n\t\t\t// Adapt the css function to make sure that the data-mce-style\r\n\t\t\t// attribute gets updated with the new style information\r\n\t\t\tfunction css(name, value) {\r\n\t\t\t\tvar self = this;\r\n\r\n\t\t\t\t// Remove data-mce-style when set operation occurs\r\n\t\t\t\tif (value)\r\n\t\t\t\t\tself.removeAttr('data-mce-style');\r\n\r\n\t\t\t\treturn fn.css.apply(self, arguments);\r\n\t\t\t};\r\n\r\n\t\t\t// Apapt the attr function to make sure that it uses the data-mce- prefixed variants\r\n\t\t\tfunction attr(name, value) {\r\n\t\t\t\tvar self = this;\r\n\r\n\t\t\t\t// Update/retrieve data-mce- attribute variants\r\n\t\t\t\tif (attrRegExp.test(name)) {\r\n\t\t\t\t\tif (value !== undefined) {\r\n\t\t\t\t\t\t// Use TinyMCE behavior when setting the specifc attributes\r\n\t\t\t\t\t\tself.each(function(i, node) {\r\n\t\t\t\t\t\t\teditor.dom.setAttrib(node, name, value);\r\n\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\treturn self;\r\n\t\t\t\t\t} else\r\n\t\t\t\t\t\treturn self.attr('data-mce-' + name);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Default behavior\r\n\t\t\t\treturn fn.attr.apply(self, arguments);\r\n\t\t\t};\r\n\r\n\t\t\tfunction htmlPatchFunc(func) {\r\n\t\t\t\t// Returns a modified function that processes\r\n\t\t\t\t// the HTML before executing the action this makes sure\r\n\t\t\t\t// that href/src etc gets moved into the data-mce- variants\r\n\t\t\t\treturn function(content) {\r\n\t\t\t\t\tif (content)\r\n\t\t\t\t\t\tcontent = editor.dom.processHTML(content);\r\n\r\n\t\t\t\t\treturn func.call(this, content);\r\n\t\t\t\t};\r\n\t\t\t};\r\n\r\n\t\t\t// Patch various jQuery functions to handle tinymce specific attribute and content behavior\r\n\t\t\t// we don't patch the jQuery.fn directly since it will most likely break compatibility\r\n\t\t\t// with other jQuery logic on the page. Only instances created by TinyMCE should be patched.\r\n\t\t\tfunction patch(jq) {\r\n\t\t\t\t// Patch some functions, only patch the object once\r\n\t\t\t\tif (jq.css !== css) {\r\n\t\t\t\t\t// Patch css/attr to use the data-mce- prefixed attribute variants\r\n\t\t\t\t\tjq.css = css;\r\n\t\t\t\t\tjq.attr = attr;\r\n\r\n\t\t\t\t\t// Patch HTML functions to use the DOMUtils.processHTML filter logic\r\n\t\t\t\t\tjq.html = htmlPatchFunc(fn.html);\r\n\t\t\t\t\tjq.append = htmlPatchFunc(fn.append);\r\n\t\t\t\t\tjq.prepend = htmlPatchFunc(fn.prepend);\r\n\t\t\t\t\tjq.after = htmlPatchFunc(fn.after);\r\n\t\t\t\t\tjq.before = htmlPatchFunc(fn.before);\r\n\t\t\t\t\tjq.replaceWith = htmlPatchFunc(fn.replaceWith);\r\n\t\t\t\t\tjq.tinymce = editor;\r\n\r\n\t\t\t\t\t// Each pushed jQuery instance needs to be patched\r\n\t\t\t\t\t// as well for example when traversing the DOM\r\n\t\t\t\t\tjq.pushStack = function() {\r\n\t\t\t\t\t\treturn patch(fn.pushStack.apply(this, arguments));\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn jq;\r\n\t\t\t};\r\n\r\n\t\t\t// Add a $ function on each editor instance this one is scoped for the editor document object\r\n\t\t\t// this way you can do chaining like this tinymce.get(0).$('p').append('text').css('color', 'red');\r\n\t\t\teditor.$ = function(selector, scope) {\r\n\t\t\t\tvar doc = editor.getDoc();\r\n\r\n\t\t\t\treturn patch($(selector || doc, doc || scope));\r\n\t\t\t};\r\n\t\t}\r\n\t};\r\n\r\n\t// Patch in core NS functions\r\n\ttinymce.extend = $.extend;\r\n\ttinymce.extend(tinymce, {\r\n\t\tmap : $.map,\r\n\t\tgrep : function(a, f) {return $.grep(a, f || function(){return 1;});},\r\n\t\tinArray : function(a, v) {return $.inArray(v, a || []);}\r\n\r\n\t\t/* Didn't iterate stylesheets\r\n\t\teach : function(o, cb, s) {\r\n\t\t\tif (!o)\r\n\t\t\t\treturn 0;\r\n\r\n\t\t\tvar r = 1;\r\n\r\n\t\t\t$.each(o, function(nr, el){\r\n\t\t\t\tif (cb.call(s, el, nr, o) === false) {\r\n\t\t\t\t\tr = 0;\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\treturn r;\r\n\t\t}*/\r\n\t});\r\n\r\n\t// Patch in functions in various clases\r\n\t// Add a \"#ifndefjquery\" statement around each core API function you add below\r\n\tvar patches = {\r\n\t\t'tinymce.dom.DOMUtils' : {\r\n\t\t\t/*\r\n\t\t\taddClass : function(e, c) {\r\n\t\t\t\tif (is(e, 'array') && is(e[0], 'string'))\r\n\t\t\t\t\te = e.join(',#');\r\n\t\t\t\treturn (e && $(is(e, 'string') ? '#' + e : e)\r\n\t\t\t\t\t.addClass(c)\r\n\t\t\t\t\t.attr('class')) || false;\r\n\t\t\t},\r\n\r\n\t\t\thasClass : function(n, c) {\r\n\t\t\t\treturn $(is(n, 'string') ? '#' + n : n).hasClass(c);\r\n\t\t\t},\r\n\r\n\t\t\tremoveClass : function(e, c) {\r\n\t\t\t\tif (!e)\r\n\t\t\t\t\treturn false;\r\n\r\n\t\t\t\tvar r = [];\r\n\r\n\t\t\t\t$(is(e, 'string') ? '#' + e : e)\r\n\t\t\t\t\t.removeClass(c)\r\n\t\t\t\t\t.each(function(){\r\n\t\t\t\t\t\tr.push(this.className);\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\treturn r.length == 1 ? r[0] : r;\r\n\t\t\t},\r\n\t\t\t*/\r\n\r\n\t\t\tselect : function(pattern, scope) {\r\n\t\t\t\tvar t = this;\r\n\r\n\t\t\t\treturn $.find(pattern, t.get(scope) || t.get(t.settings.root_element) || t.doc, []);\r\n\t\t\t},\r\n\r\n\t\t\tis : function(n, patt) {\r\n\t\t\t\treturn $(this.get(n)).is(patt);\r\n\t\t\t}\r\n\r\n\t\t\t/*\r\n\t\t\tshow : function(e) {\r\n\t\t\t\tif (is(e, 'array') && is(e[0], 'string'))\r\n\t\t\t\t\te = e.join(',#');\r\n\r\n\t\t\t\t$(is(e, 'string') ? '#' + e : e).css('display', 'block');\r\n\t\t\t},\r\n\r\n\t\t\thide : function(e) {\r\n\t\t\t\tif (is(e, 'array') && is(e[0], 'string'))\r\n\t\t\t\t\te = e.join(',#');\r\n\r\n\t\t\t\t$(is(e, 'string') ? '#' + e : e).css('display', 'none');\r\n\t\t\t},\r\n\r\n\t\t\tisHidden : function(e) {\r\n\t\t\t\treturn $(is(e, 'string') ? '#' + e : e).is(':hidden');\r\n\t\t\t},\r\n\r\n\t\t\tinsertAfter : function(n, e) {\r\n\t\t\t\treturn $(is(e, 'string') ? '#' + e : e).after(n);\r\n\t\t\t},\r\n\r\n\t\t\treplace : function(o, n, k) {\r\n\t\t\t\tn = $(is(n, 'string') ? '#' + n : n);\r\n\r\n\t\t\t\tif (k)\r\n\t\t\t\t\tn.children().appendTo(o);\r\n\r\n\t\t\t\tn.replaceWith(o);\r\n\t\t\t},\r\n\r\n\t\t\tsetStyle : function(n, na, v) {\r\n\t\t\t\tif (is(n, 'array') && is(n[0], 'string'))\r\n\t\t\t\t\tn = n.join(',#');\r\n\r\n\t\t\t\t$(is(n, 'string') ? '#' + n : n).css(na, v);\r\n\t\t\t},\r\n\r\n\t\t\tgetStyle : function(n, na, c) {\r\n\t\t\t\treturn $(is(n, 'string') ? '#' + n : n).css(na);\r\n\t\t\t},\r\n\r\n\t\t\tsetStyles : function(e, o) {\r\n\t\t\t\tif (is(e, 'array') && is(e[0], 'string'))\r\n\t\t\t\t\te = e.join(',#');\r\n\t\t\t\t$(is(e, 'string') ? '#' + e : e).css(o);\r\n\t\t\t},\r\n\r\n\t\t\tsetAttrib : function(e, n, v) {\r\n\t\t\t\tvar t = this, s = t.settings;\r\n\r\n\t\t\t\tif (is(e, 'array') && is(e[0], 'string'))\r\n\t\t\t\t\te = e.join(',#');\r\n\r\n\t\t\t\te = $(is(e, 'string') ? '#' + e : e);\r\n\r\n\t\t\t\tswitch (n) {\r\n\t\t\t\t\tcase \"style\":\r\n\t\t\t\t\t\te.each(function(i, v){\r\n\t\t\t\t\t\t\tif (s.keep_values)\r\n\t\t\t\t\t\t\t\t$(v).attr('data-mce-style', v);\r\n\r\n\t\t\t\t\t\t\tv.style.cssText = v;\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase \"class\":\r\n\t\t\t\t\t\te.each(function(){\r\n\t\t\t\t\t\t\tthis.className = v;\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase \"src\":\r\n\t\t\t\t\tcase \"href\":\r\n\t\t\t\t\t\te.each(function(i, v){\r\n\t\t\t\t\t\t\tif (s.keep_values) {\r\n\t\t\t\t\t\t\t\tif (s.url_converter)\r\n\t\t\t\t\t\t\t\t\tv = s.url_converter.call(s.url_converter_scope || t, v, n, v);\r\n\r\n\t\t\t\t\t\t\t\tt.setAttrib(v, 'data-mce-' + n, v);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (v !== null && v.length !== 0)\r\n\t\t\t\t\te.attr(n, '' + v);\r\n\t\t\t\telse\r\n\t\t\t\t\te.removeAttr(n);\r\n\t\t\t},\r\n\r\n\t\t\tsetAttribs : function(e, o) {\r\n\t\t\t\tvar t = this;\r\n\r\n\t\t\t\t$.each(o, function(n, v){\r\n\t\t\t\t\tt.setAttrib(e,n,v);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\t*/\r\n\t\t}\r\n\r\n/*\r\n\t\t'tinymce.dom.Event' : {\r\n\t\t\tadd : function (o, n, f, s) {\r\n\t\t\t\tvar lo, cb;\r\n\r\n\t\t\t\tcb = function(e) {\r\n\t\t\t\t\te.target = e.target || this;\r\n\t\t\t\t\tf.call(s || this, e);\r\n\t\t\t\t};\r\n\r\n\t\t\t\tif (is(o, 'array') && is(o[0], 'string'))\r\n\t\t\t\t\to = o.join(',#');\r\n\t\t\t\to = $(is(o, 'string') ? '#' + o : o);\r\n\t\t\t\tif (n == 'init') {\r\n\t\t\t\t\to.ready(cb, s);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (s) {\r\n\t\t\t\t\t\to.bind(n, s, cb);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\to.bind(n, cb);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlo = this._jqLookup || (this._jqLookup = []);\r\n\t\t\t\tlo.push({func : f, cfunc : cb});\r\n\r\n\t\t\t\treturn cb;\r\n\t\t\t},\r\n\r\n\t\t\tremove : function(o, n, f) {\r\n\t\t\t\t// Find cfunc\r\n\t\t\t\t$(this._jqLookup).each(function() {\r\n\t\t\t\t\tif (this.func === f)\r\n\t\t\t\t\t\tf = this.cfunc;\r\n\t\t\t\t});\r\n\r\n\t\t\t\tif (is(o, 'array') && is(o[0], 'string'))\r\n\t\t\t\t\to = o.join(',#');\r\n\r\n\t\t\t\t$(is(o, 'string') ? '#' + o : o).unbind(n,f);\r\n\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n*/\r\n\t};\r\n\r\n\t// Patch functions after a class is created\r\n\ttinymce.onCreate = function(ty, c, p) {\r\n\t\ttinymce.extend(p, patches[c]);\r\n\t};\r\n})(window.jQuery, tinymce);\r\n\r\n// #endif\r\n","Magento_Tinymce3/tiny_mce/classes/adapter/jquery/jquery.tinymce.js":"/**\r\n * jquery.tinymce.js\r\n *\r\n * Copyright 2009, Moxiecode Systems AB\r\n * Released under LGPL License.\r\n *\r\n * License: http://tinymce.moxiecode.com/license\r\n * Contributing: http://tinymce.moxiecode.com/contributing\r\n */\r\n\r\n(function($) {\r\n\tvar undefined,\r\n\t\tlazyLoading,\r\n\t\tdelayedInits = [],\r\n\t\twin = window;\r\n\r\n\t$.fn.tinymce = function(settings) {\r\n\t\tvar self = this, url, ed, base, pos, lang, query = \"\", suffix = \"\";\r\n\r\n\t\t// No match then just ignore the call\r\n\t\tif (!self.length)\r\n\t\t\treturn self;\r\n\r\n\t\t// Get editor instance\r\n\t\tif (!settings)\r\n\t\t\treturn tinyMCE.get(self[0].id);\r\n\r\n\t\tself.css('visibility', 'hidden'); // Hide textarea to avoid flicker\r\n\r\n\t\tfunction init() {\r\n\t\t\tvar editors = [], initCount = 0;\r\n\r\n\t\t\t// Apply patches to the jQuery object, only once\r\n\t\t\tif (applyPatch) {\r\n\t\t\t\tapplyPatch();\r\n\t\t\t\tapplyPatch = null;\r\n\t\t\t}\r\n\r\n\t\t\t// Create an editor instance for each matched node\r\n\t\t\tself.each(function(i, node) {\r\n\t\t\t\tvar ed, id = node.id, oninit = settings.oninit;\r\n\r\n\t\t\t\t// Generate unique id for target element if needed\r\n\t\t\t\tif (!id)\r\n\t\t\t\t\tnode.id = id = tinymce.DOM.uniqueId();\r\n\r\n\t\t\t\t// Create editor instance and render it\r\n\t\t\t\ted = new tinymce.Editor(id, settings);\r\n\t\t\t\teditors.push(ed);\r\n\r\n\t\t\t\ted.onInit.add(function() {\r\n\t\t\t\t\tvar scope, func = oninit;\r\n\r\n\t\t\t\t\tself.css('visibility', '');\r\n\r\n\t\t\t\t\t// Run this if the oninit setting is defined\r\n\t\t\t\t\t// this logic will fire the oninit callback ones each\r\n\t\t\t\t\t// matched editor instance is initialized\r\n\t\t\t\t\tif (oninit) {\r\n\t\t\t\t\t\t// Fire the oninit event ones each editor instance is initialized\r\n\t\t\t\t\t\tif (++initCount == editors.length) {\r\n\t\t\t\t\t\t\tif (tinymce.is(func, \"string\")) {\r\n\t\t\t\t\t\t\t\tscope = (func.indexOf(\".\") === -1) ? null : tinymce.resolve(func.replace(/\\.\\w+$/, \"\"));\r\n\t\t\t\t\t\t\t\tfunc = tinymce.resolve(func);\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// Call the oninit function with the object\r\n\t\t\t\t\t\t\tfunc.apply(scope || tinymce, editors);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t});\r\n\r\n\t\t\t// Render the editor instances in a separate loop since we\r\n\t\t\t// need to have the full editors array used in the onInit calls\r\n\t\t\t$.each(editors, function(i, ed) {\r\n\t\t\t\ted.render();\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\t// Load TinyMCE on demand, if we need to\r\n\t\tif (!win[\"tinymce\"] && !lazyLoading && (url = settings.script_url)) {\r\n\t\t\tlazyLoading = 1;\r\n\t\t\tbase = url.substring(0, url.lastIndexOf(\"/\"));\r\n\r\n\t\t\t// Check if it's a dev/src version they want to load then\r\n\t\t\t// make sure that all plugins, themes etc are loaded in source mode aswell\r\n\t\t\tif (/_(src|dev)\\.js/g.test(url))\r\n\t\t\t\tsuffix = \"_src\";\r\n\r\n\t\t\t// Parse out query part, this will be appended to all scripts, css etc to clear browser cache\r\n\t\t\tpos = url.lastIndexOf(\"?\");\r\n\t\t\tif (pos != -1)\r\n\t\t\t\tquery = url.substring(pos + 1);\r\n\r\n\t\t\t// Setup tinyMCEPreInit object this will later be used by the TinyMCE\r\n\t\t\t// core script to locate other resources like CSS files, dialogs etc\r\n\t\t\t// You can also predefined a tinyMCEPreInit object and then it will use that instead\r\n\t\t\twin.tinyMCEPreInit = win.tinyMCEPreInit || {\r\n\t\t\t\tbase : base,\r\n\t\t\t\tsuffix : suffix,\r\n\t\t\t\tquery : query\r\n\t\t\t};\r\n\r\n\t\t\t// url contains gzip then we assume it's a compressor\r\n\t\t\tif (url.indexOf('gzip') != -1) {\r\n\t\t\t\tlang = settings.language || \"en\";\r\n\t\t\t\turl = url + (/\\?/.test(url) ? '&' : '?') + \"js=true&core=true&suffix=\" + escape(suffix) + \"&themes=\" + escape(settings.theme) + \"&plugins=\" + escape(settings.plugins) + \"&languages=\" + lang;\r\n\r\n\t\t\t\t// Check if compressor script is already loaded otherwise setup a basic one\r\n\t\t\t\tif (!win[\"tinyMCE_GZ\"]) {\r\n\t\t\t\t\ttinyMCE_GZ = {\r\n\t\t\t\t\t\tstart : function() {\r\n\t\t\t\t\t\t\ttinymce.suffix = suffix;\r\n\r\n\t\t\t\t\t\t\tfunction load(url) {\r\n\t\t\t\t\t\t\t\ttinymce.ScriptLoader.markDone(tinyMCE.baseURI.toAbsolute(url));\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// Add core languages\r\n\t\t\t\t\t\t\tload(\"langs/\" + lang + \".js\");\r\n\r\n\t\t\t\t\t\t\t// Add themes with languages\r\n\t\t\t\t\t\t\tload(\"themes/\" + settings.theme + \"/editor_template\" + suffix + \".js\");\r\n\t\t\t\t\t\t\tload(\"themes/\" + settings.theme + \"/langs/\" + lang + \".js\");\r\n\r\n\t\t\t\t\t\t\t// Add plugins with languages\r\n\t\t\t\t\t\t\t$.each(settings.plugins.split(\",\"), function(i, name) {\r\n\t\t\t\t\t\t\t\tif (name) {\r\n\t\t\t\t\t\t\t\t\tload(\"plugins/\" + name + \"/editor_plugin\" + suffix + \".js\");\r\n\t\t\t\t\t\t\t\t\tload(\"plugins/\" + name + \"/langs/\" + lang + \".js\");\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t},\r\n\r\n\t\t\t\t\t\tend : function() {\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Load the script cached and execute the inits once it's done\r\n\t\t\t$.ajax({\r\n\t\t\t\ttype : \"GET\",\r\n\t\t\t\turl : url,\r\n\t\t\t\tdataType : \"script\",\r\n\t\t\t\tcache : true,\r\n\t\t\t\tsuccess : function() {\r\n\t\t\t\t\ttinymce.dom.Event.domLoaded = 1;\r\n\t\t\t\t\tlazyLoading = 2;\r\n\r\n\t\t\t\t\t// Execute callback after mainscript has been loaded and before the initialization occurs\r\n\t\t\t\t\tif (settings.script_loaded)\r\n\t\t\t\t\t\tsettings.script_loaded();\r\n\r\n\t\t\t\t\tinit();\r\n\r\n\t\t\t\t\t$.each(delayedInits, function(i, init) {\r\n\t\t\t\t\t\tinit();\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t} else {\r\n\t\t\t// Delay the init call until tinymce is loaded\r\n\t\t\tif (lazyLoading === 1)\r\n\t\t\t\tdelayedInits.push(init);\r\n\t\t\telse\r\n\t\t\t\tinit();\r\n\t\t}\r\n\r\n\t\treturn self;\r\n\t};\r\n\r\n\t// Add :tinymce psuedo selector this will select elements that has been converted into editor instances\r\n\t// it's now possible to use things like $('*:tinymce') to get all TinyMCE bound elements.\r\n\t$.extend($.expr[\":\"], {\r\n\t\ttinymce : function(e) {\r\n\t\t\treturn e.id && !!tinyMCE.get(e.id);\r\n\t\t}\r\n\t});\r\n\r\n\t// This function patches internal jQuery functions so that if\r\n\t// you for example remove an div element containing an editor it's\r\n\t// automatically destroyed by the TinyMCE API\r\n\tfunction applyPatch() {\r\n\t\t// Removes any child editor instances by looking for editor wrapper elements\r\n\t\tfunction removeEditors(name) {\r\n\t\t\t// If the function is remove\r\n\t\t\tif (name === \"remove\") {\r\n\t\t\t\tthis.each(function(i, node) {\r\n\t\t\t\t\tvar ed = tinyMCEInstance(node);\r\n\r\n\t\t\t\t\tif (ed)\r\n\t\t\t\t\t\ted.remove();\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tthis.find(\"span.mceEditor,div.mceEditor\").each(function(i, node) {\r\n\t\t\t\tvar ed = tinyMCE.get(node.id.replace(/_parent$/, \"\"));\r\n\r\n\t\t\t\tif (ed)\r\n\t\t\t\t\ted.remove();\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\t// Loads or saves contents from/to textarea if the value\r\n\t\t// argument is defined it will set the TinyMCE internal contents\r\n\t\tfunction loadOrSave(value) {\r\n\t\t\tvar self = this, ed;\r\n\r\n\t\t\t// Handle set value\r\n\t\t\tif (value !== undefined) {\r\n\t\t\t\tremoveEditors.call(self);\r\n\r\n\t\t\t\t// Saves the contents before get/set value of textarea/div\r\n\t\t\t\tself.each(function(i, node) {\r\n\t\t\t\t\tvar ed;\r\n\r\n\t\t\t\t\tif (ed = tinyMCE.get(node.id))\r\n\t\t\t\t\t\ted.setContent(value);\r\n\t\t\t\t});\r\n\t\t\t} else if (self.length > 0) {\r\n\t\t\t\t// Handle get value\r\n\t\t\t\tif (ed = tinyMCE.get(self[0].id))\r\n\t\t\t\t\treturn ed.getContent();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Returns tinymce instance for the specified element or null if it wasn't found\r\n\t\tfunction tinyMCEInstance(element) {\r\n\t\t\tvar ed = null;\r\n\r\n\t\t\t(element) && (element.id) && (win[\"tinymce\"]) && (ed = tinyMCE.get(element.id));\r\n\r\n\t\t\treturn ed;\r\n\t\t}\r\n\r\n\t\t// Checks if the specified set contains tinymce instances\r\n\t\tfunction containsTinyMCE(matchedSet) {\r\n\t\t\treturn !!((matchedSet) && (matchedSet.length) && (win[\"tinymce\"]) && (matchedSet.is(\":tinymce\")));\r\n\t\t}\r\n\r\n\t\t// Patch various jQuery functions\r\n\t\tvar jQueryFn = {};\r\n\r\n\t\t// Patch some setter/getter functions these will\r\n\t\t// now be able to set/get the contents of editor instances for\r\n\t\t// example $('#editorid').html('Content'); will update the TinyMCE iframe instance\r\n\t\t$.each([\"text\", \"html\", \"val\"], function(i, name) {\r\n\t\t\tvar origFn = jQueryFn[name] = $.fn[name],\r\n\t\t\t\ttextProc = (name === \"text\");\r\n\r\n\t\t\t $.fn[name] = function(value) {\r\n\t\t\t\tvar self = this;\r\n\r\n\t\t\t\tif (!containsTinyMCE(self))\r\n\t\t\t\t\treturn origFn.apply(self, arguments);\r\n\r\n\t\t\t\tif (value !== undefined) {\r\n\t\t\t\t\tloadOrSave.call(self.filter(\":tinymce\"), value);\r\n\t\t\t\t\torigFn.apply(self.not(\":tinymce\"), arguments);\r\n\r\n\t\t\t\t\treturn self; // return original set for chaining\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar ret = \"\";\r\n\t\t\t\t\tvar args = arguments;\r\n\t\t\t\t\t\r\n\t\t\t\t\t(textProc ? self : self.eq(0)).each(function(i, node) {\r\n\t\t\t\t\t\tvar ed = tinyMCEInstance(node);\r\n\r\n\t\t\t\t\t\tret += ed ? (textProc ? ed.getContent().replace(/<(?:\"[^\"]*\"|'[^']*'|[^'\">])*>/g, \"\") : ed.getContent()) : origFn.apply($(node), args);\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\treturn ret;\r\n\t\t\t\t}\r\n\t\t\t };\r\n\t\t});\r\n\r\n\t\t// Makes it possible to use $('#id').append(\"content\"); to append contents to the TinyMCE editor iframe\r\n\t\t$.each([\"append\", \"prepend\"], function(i, name) {\r\n\t\t\tvar origFn = jQueryFn[name] = $.fn[name],\r\n\t\t\t\tprepend = (name === \"prepend\");\r\n\r\n\t\t\t $.fn[name] = function(value) {\r\n\t\t\t\tvar self = this;\r\n\r\n\t\t\t\tif (!containsTinyMCE(self))\r\n\t\t\t\t\treturn origFn.apply(self, arguments);\r\n\r\n\t\t\t\tif (value !== undefined) {\r\n\t\t\t\t\tself.filter(\":tinymce\").each(function(i, node) {\r\n\t\t\t\t\t\tvar ed = tinyMCEInstance(node);\r\n\r\n\t\t\t\t\t\ted && ed.setContent(prepend ? value + ed.getContent() : ed.getContent() + value);\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\torigFn.apply(self.not(\":tinymce\"), arguments);\r\n\r\n\t\t\t\t\treturn self; // return original set for chaining\r\n\t\t\t\t}\r\n\t\t\t };\r\n\t\t});\r\n\r\n\t\t// Makes sure that the editor instance gets properly destroyed when the parent element is removed\r\n\t\t$.each([\"remove\", \"replaceWith\", \"replaceAll\", \"empty\"], function(i, name) {\r\n\t\t\tvar origFn = jQueryFn[name] = $.fn[name];\r\n\r\n\t\t\t$.fn[name] = function() {\r\n\t\t\t\tremoveEditors.call(this, name);\r\n\r\n\t\t\t\treturn origFn.apply(this, arguments);\r\n\t\t\t};\r\n\t\t});\r\n\r\n\t\tjQueryFn.attr = $.fn.attr;\r\n\r\n\t\t// Makes sure that $('#tinymce_id').attr('value') gets the editors current HTML contents\r\n\t\t$.fn.attr = function(name, value, type) {\r\n\t\t\tvar self = this;\r\n\r\n\t\t\tif ((!name) || (name !== \"value\") || (!containsTinyMCE(self)))\r\n\t\t\t\treturn jQueryFn.attr.call(self, name, value, type);\r\n\r\n\t\t\tif (value !== undefined) {\r\n\t\t\t\tloadOrSave.call(self.filter(\":tinymce\"), value);\r\n\t\t\t\tjQueryFn.attr.call(self.not(\":tinymce\"), name, value, type);\r\n\r\n\t\t\t\treturn self; // return original set for chaining\r\n\t\t\t} else {\r\n\t\t\t\tvar node = self[0], ed = tinyMCEInstance(node);\r\n\r\n\t\t\t\treturn ed ? ed.getContent() : jQueryFn.attr.call($(node), name, value, type);\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n})(jQuery);","Magento_Tinymce3/tiny_mce/classes/adapter/prototype/adapter.js":"/**\r\n * adapter.js\r\n *\r\n * Copyright 2009, Moxiecode Systems AB\r\n * Released under LGPL License.\r\n *\r\n * License: http://tinymce.moxiecode.com/license\r\n * Contributing: http://tinymce.moxiecode.com/contributing\r\n */\r\n\r\n// #ifdef prototype_adapter\r\n\r\n(function() {\r\n\tif (!window.Prototype)\r\n\t\treturn alert(\"Load prototype first!\");\r\n\r\n\t// Patch in core NS functions\r\n\ttinymce.extend(tinymce, {\r\n\t\ttrim : function(s) {return s ? s.strip() : '';},\r\n\t\tinArray : function(a, v) {return a && a.indexOf ? a.indexOf(v) : -1;}\r\n\t});\r\n\r\n\t// Patch in functions in various clases\r\n\t// Add a \"#ifndefjquery\" statement around each core API function you add below\r\n\tvar patches = {\r\n\t\t'tinymce.util.JSON' : {\r\n\t\t\t/*serialize : function(o) {\r\n\t\t\t\treturn o.toJSON();\r\n\t\t\t}*/\r\n\t\t},\r\n\t};\r\n\r\n\t// Patch functions after a class is created\r\n\ttinymce.onCreate = function(ty, c, p) {\r\n\t\ttinymce.extend(p, patches[c]);\r\n\t};\r\n})();\r\n\r\n// #endif\r\n","Magento_Tinymce3/tiny_mce/classes/dom/DOMUtils.js":"/**\r\n * DOMUtils.js\r\n *\r\n * Copyright 2009, Moxiecode Systems AB\r\n * Released under LGPL License.\r\n *\r\n * License: http://tinymce.moxiecode.com/license\r\n * Contributing: http://tinymce.moxiecode.com/contributing\r\n */\r\n\r\n(function(tinymce) {\r\n\t// Shorten names\r\n\tvar each = tinymce.each,\r\n\t\tis = tinymce.is,\r\n\t\tisWebKit = tinymce.isWebKit,\r\n\t\tisIE = tinymce.isIE,\r\n\t\tEntities = tinymce.html.Entities,\r\n\t\tsimpleSelectorRe = /^([a-z0-9],?)+$/i,\r\n\t\tblockElementsMap = tinymce.html.Schema.blockElementsMap,\r\n\t\twhiteSpaceRegExp = /^[ \\t\\r\\n]*$/;\r\n\r\n\t/**\r\n\t * Utility class for various DOM manipulation and retrival functions.\r\n\t *\r\n\t * @class tinymce.dom.DOMUtils\r\n\t * @example\r\n\t * // Add a class to an element by id in the page\r\n\t * tinymce.DOM.addClass('someid', 'someclass');\r\n\t *\r\n\t * // Add a class to an element by id inside the editor\r\n\t * tinyMCE.activeEditor.dom.addClass('someid', 'someclass');\r\n\t */\r\n\ttinymce.create('tinymce.dom.DOMUtils', {\r\n\t\tdoc : null,\r\n\t\troot : null,\r\n\t\tfiles : null,\r\n\t\tpixelStyles : /^(top|left|bottom|right|width|height|borderWidth)$/,\r\n\t\tprops : {\r\n\t\t\t\"for\" : \"htmlFor\",\r\n\t\t\t\"class\" : \"className\",\r\n\t\t\tclassName : \"className\",\r\n\t\t\tchecked : \"checked\",\r\n\t\t\tdisabled : \"disabled\",\r\n\t\t\tmaxlength : \"maxLength\",\r\n\t\t\treadonly : \"readOnly\",\r\n\t\t\tselected : \"selected\",\r\n\t\t\tvalue : \"value\",\r\n\t\t\tid : \"id\",\r\n\t\t\tname : \"name\",\r\n\t\t\ttype : \"type\"\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Constructs a new DOMUtils instance. Consult the Wiki for more details on settings etc for this class.\r\n\t\t *\r\n\t\t * @constructor\r\n\t\t * @method DOMUtils\r\n\t\t * @param {Document} d Document reference to bind the utility class to.\r\n\t\t * @param {settings} s Optional settings collection.\r\n\t\t */\r\n\t\tDOMUtils : function(d, s) {\r\n\t\t\tvar t = this, globalStyle, name;\r\n\r\n\t\t\tt.doc = d;\r\n\t\t\tt.win = window;\r\n\t\t\tt.files = {};\r\n\t\t\tt.cssFlicker = false;\r\n\t\t\tt.counter = 0;\r\n\t\t\tt.stdMode = !tinymce.isIE || d.documentMode >= 8;\r\n\t\t\tt.boxModel = !tinymce.isIE || d.compatMode == \"CSS1Compat\" || t.stdMode;\r\n\t\t\tt.hasOuterHTML = \"outerHTML\" in d.createElement(\"a\");\r\n\r\n\t\t\tt.settings = s = tinymce.extend({\r\n\t\t\t\tkeep_values : false,\r\n\t\t\t\thex_colors : 1\r\n\t\t\t}, s);\r\n\t\t\t\r\n\t\t\tt.schema = s.schema;\r\n\t\t\tt.styles = new tinymce.html.Styles({\r\n\t\t\t\turl_converter : s.url_converter,\r\n\t\t\t\turl_converter_scope : s.url_converter_scope\r\n\t\t\t}, s.schema);\r\n\r\n\t\t\t// Fix IE6SP2 flicker and check it failed for pre SP2\r\n\t\t\tif (tinymce.isIE6) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\td.execCommand('BackgroundImageCache', false, true);\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tt.cssFlicker = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (isIE && s.schema) {\r\n\t\t\t\t// Add missing HTML 4/5 elements to IE\r\n\t\t\t\t('abbr article aside audio canvas ' +\r\n\t\t\t\t'details figcaption figure footer ' +\r\n\t\t\t\t'header hgroup mark menu meter nav ' +\r\n\t\t\t\t'output progress section summary ' +\r\n\t\t\t\t'time video').replace(/\\w+/g, function(name) {\r\n\t\t\t\t\td.createElement(name);\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// Create all custom elements\r\n\t\t\t\tfor (name in s.schema.getCustomElements()) {\r\n\t\t\t\t\td.createElement(name);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\ttinymce.addUnload(t.destroy, t);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns the root node of the document this is normally the body but might be a DIV. Parents like getParent will not\r\n\t\t * go above the point of this root node.\r\n\t\t *\r\n\t\t * @method getRoot\r\n\t\t * @return {Element} Root element for the utility class.\r\n\t\t */\r\n\t\tgetRoot : function() {\r\n\t\t\tvar t = this, s = t.settings;\r\n\r\n\t\t\treturn (s && t.get(s.root_element)) || t.doc.body;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns the viewport of the window.\r\n\t\t *\r\n\t\t * @method getViewPort\r\n\t\t * @param {Window} w Optional window to get viewport of.\r\n\t\t * @return {Object} Viewport object with fields x, y, w and h.\r\n\t\t */\r\n\t\tgetViewPort : function(w) {\r\n\t\t\tvar d, b;\r\n\r\n\t\t\tw = !w ? this.win : w;\r\n\t\t\td = w.document;\r\n\t\t\tb = this.boxModel ? d.documentElement : d.body;\r\n\r\n\t\t\t// Returns viewport size excluding scrollbars\r\n\t\t\treturn {\r\n\t\t\t\tx : w.pageXOffset || b.scrollLeft,\r\n\t\t\t\ty : w.pageYOffset || b.scrollTop,\r\n\t\t\t\tw : w.innerWidth || b.clientWidth,\r\n\t\t\t\th : w.innerHeight || b.clientHeight\r\n\t\t\t};\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns the rectangle for a specific element.\r\n\t\t *\r\n\t\t * @method getRect\r\n\t\t * @param {Element/String} e Element object or element ID to get rectange from.\r\n\t\t * @return {object} Rectange for specified element object with x, y, w, h fields.\r\n\t\t */\r\n\t\tgetRect : function(e) {\r\n\t\t\tvar p, t = this, sr;\r\n\r\n\t\t\te = t.get(e);\r\n\t\t\tp = t.getPos(e);\r\n\t\t\tsr = t.getSize(e);\r\n\r\n\t\t\treturn {\r\n\t\t\t\tx : p.x,\r\n\t\t\t\ty : p.y,\r\n\t\t\t\tw : sr.w,\r\n\t\t\t\th : sr.h\r\n\t\t\t};\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns the size dimensions of the specified element.\r\n\t\t *\r\n\t\t * @method getSize\r\n\t\t * @param {Element/String} e Element object or element ID to get rectange from.\r\n\t\t * @return {object} Rectange for specified element object with w, h fields.\r\n\t\t */\r\n\t\tgetSize : function(e) {\r\n\t\t\tvar t = this, w, h;\r\n\r\n\t\t\te = t.get(e);\r\n\t\t\tw = t.getStyle(e, 'width');\r\n\t\t\th = t.getStyle(e, 'height');\r\n\r\n\t\t\t// Non pixel value, then force offset/clientWidth\r\n\t\t\tif (w.indexOf('px') === -1)\r\n\t\t\t\tw = 0;\r\n\r\n\t\t\t// Non pixel value, then force offset/clientWidth\r\n\t\t\tif (h.indexOf('px') === -1)\r\n\t\t\t\th = 0;\r\n\r\n\t\t\treturn {\r\n\t\t\t\tw : parseInt(w) || e.offsetWidth || e.clientWidth,\r\n\t\t\t\th : parseInt(h) || e.offsetHeight || e.clientHeight\r\n\t\t\t};\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns a node by the specified selector function. This function will\r\n\t\t * loop through all parent nodes and call the specified function for each node.\r\n\t\t * If the function then returns true indicating that it has found what it was looking for, the loop execution will then end\r\n\t\t * and the node it found will be returned.\r\n\t\t *\r\n\t\t * @method getParent\r\n\t\t * @param {Node/String} n DOM node to search parents on or ID string.\r\n\t\t * @param {function} f Selection function to execute on each node or CSS pattern.\r\n\t\t * @param {Node} r Optional root element, never go below this point.\r\n\t\t * @return {Node} DOM Node or null if it wasn't found.\r\n\t\t */\r\n\t\tgetParent : function(n, f, r) {\r\n\t\t\treturn this.getParents(n, f, r, false);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns a node list of all parents matching the specified selector function or pattern.\r\n\t\t * If the function then returns true indicating that it has found what it was looking for and that node will be collected.\r\n\t\t *\r\n\t\t * @method getParents\r\n\t\t * @param {Node/String} n DOM node to search parents on or ID string.\r\n\t\t * @param {function} f Selection function to execute on each node or CSS pattern.\r\n\t\t * @param {Node} r Optional root element, never go below this point.\r\n\t\t * @return {Array} Array of nodes or null if it wasn't found.\r\n\t\t */\r\n\t\tgetParents : function(n, f, r, c) {\r\n\t\t\tvar t = this, na, se = t.settings, o = [];\r\n\r\n\t\t\tn = t.get(n);\r\n\t\t\tc = c === undefined;\r\n\r\n\t\t\tif (se.strict_root)\r\n\t\t\t\tr = r || t.getRoot();\r\n\r\n\t\t\t// Wrap node name as func\r\n\t\t\tif (is(f, 'string')) {\r\n\t\t\t\tna = f;\r\n\r\n\t\t\t\tif (f === '*') {\r\n\t\t\t\t\tf = function(n) {return n.nodeType == 1;};\r\n\t\t\t\t} else {\r\n\t\t\t\t\tf = function(n) {\r\n\t\t\t\t\t\treturn t.is(n, na);\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\twhile (n) {\r\n\t\t\t\tif (n == r || !n.nodeType || n.nodeType === 9)\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tif (!f || f(n)) {\r\n\t\t\t\t\tif (c)\r\n\t\t\t\t\t\to.push(n);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\treturn n;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tn = n.parentNode;\r\n\t\t\t}\r\n\r\n\t\t\treturn c ? o : null;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns the specified element by ID or the input element if it isn't a string.\r\n\t\t *\r\n\t\t * @method get\r\n\t\t * @param {String/Element} n Element id to look for or element to just pass though.\r\n\t\t * @return {Element} Element matching the specified id or null if it wasn't found.\r\n\t\t */\r\n\t\tget : function(e) {\r\n\t\t\tvar n;\r\n\r\n\t\t\tif (e && this.doc && typeof(e) == 'string') {\r\n\t\t\t\tn = e;\r\n\t\t\t\te = this.doc.getElementById(e);\r\n\r\n\t\t\t\t// IE and Opera returns meta elements when they match the specified input ID, but getElementsByName seems to do the trick\r\n\t\t\t\tif (e && e.id !== n)\r\n\t\t\t\t\treturn this.doc.getElementsByName(n)[1];\r\n\t\t\t}\r\n\r\n\t\t\treturn e;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns the next node that matches selector or function\r\n\t\t *\r\n\t\t * @method getNext\r\n\t\t * @param {Node} node Node to find siblings from.\r\n\t\t * @param {String/function} selector Selector CSS expression or function.\r\n\t\t * @return {Node} Next node item matching the selector or null if it wasn't found.\r\n\t\t */\r\n\t\tgetNext : function(node, selector) {\r\n\t\t\treturn this._findSib(node, selector, 'nextSibling');\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns the previous node that matches selector or function\r\n\t\t *\r\n\t\t * @method getPrev\r\n\t\t * @param {Node} node Node to find siblings from.\r\n\t\t * @param {String/function} selector Selector CSS expression or function.\r\n\t\t * @return {Node} Previous node item matching the selector or null if it wasn't found.\r\n\t\t */\r\n\t\tgetPrev : function(node, selector) {\r\n\t\t\treturn this._findSib(node, selector, 'previousSibling');\r\n\t\t},\r\n\r\n\t\t// #ifndef jquery\r\n\r\n\t\t/**\r\n\t\t * Selects specific elements by a CSS level 3 pattern. For example \"div#a1 p.test\".\r\n\t\t * This function is optimized for the most common patterns needed in TinyMCE but it also performes good enough\r\n\t\t * on more complex patterns.\r\n\t\t *\r\n\t\t * @method select\r\n\t\t * @param {String} p CSS level 1 pattern to select/find elements by.\r\n\t\t * @param {Object} s Optional root element/scope element to search in.\r\n\t\t * @return {Array} Array with all matched elements.\r\n\t\t * @example\r\n\t\t * // Adds a class to all paragraphs in the currently active editor\r\n\t\t * tinyMCE.activeEditor.dom.addClass(tinyMCE.activeEditor.dom.select('p'), 'someclass');\r\n\t\t * \r\n\t\t * // Adds a class to all spans that has the test class in the currently active editor\r\n\t\t * tinyMCE.activeEditor.dom.addClass(tinyMCE.activeEditor.dom.select('span.test'), 'someclass')\r\n\t\t */\r\n\t\tselect : function(pa, s) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\treturn tinymce.dom.Sizzle(pa, t.get(s) || t.get(t.settings.root_element) || t.doc, []);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns true/false if the specified element matches the specified css pattern.\r\n\t\t *\r\n\t\t * @method is\r\n\t\t * @param {Node/NodeList} n DOM node to match or an array of nodes to match.\r\n\t\t * @param {String} selector CSS pattern to match the element agains.\r\n\t\t */\r\n\t\tis : function(n, selector) {\r\n\t\t\tvar i;\r\n\r\n\t\t\t// If it isn't an array then try to do some simple selectors instead of Sizzle for to boost performance\r\n\t\t\tif (n.length === undefined) {\r\n\t\t\t\t// Simple all selector\r\n\t\t\t\tif (selector === '*')\r\n\t\t\t\t\treturn n.nodeType == 1;\r\n\r\n\t\t\t\t// Simple selector just elements\r\n\t\t\t\tif (simpleSelectorRe.test(selector)) {\r\n\t\t\t\t\tselector = selector.toLowerCase().split(/,/);\r\n\t\t\t\t\tn = n.nodeName.toLowerCase();\r\n\r\n\t\t\t\t\tfor (i = selector.length - 1; i >= 0; i--) {\r\n\t\t\t\t\t\tif (selector[i] == n)\r\n\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn tinymce.dom.Sizzle.matches(selector, n.nodeType ? [n] : n).length > 0;\r\n\t\t},\r\n\r\n\t\t// #endif\r\n\r\n\t\t/**\r\n\t\t * Adds the specified element to another element or elements.\r\n\t\t *\r\n\t\t * @method add\r\n\t\t * @param {String/Element/Array} Element id string, DOM node element or array of id's or elements to add to.\r\n\t\t * @param {String/Element} n Name of new element to add or existing element to add.\r\n\t\t * @param {Object} a Optional object collection with arguments to add to the new element(s).\r\n\t\t * @param {String} h Optional inner HTML contents to add for each element.\r\n\t\t * @param {Boolean} c Optional internal state to indicate if it should create or add.\r\n\t\t * @return {Element/Array} Element that got created or array with elements if multiple elements where passed.\r\n\t\t * @example\r\n\t\t * // Adds a new paragraph to the end of the active editor\r\n\t\t * tinyMCE.activeEditor.dom.add(tinyMCE.activeEditor.getBody(), 'p', {title : 'my title'}, 'Some content');\r\n\t\t */\r\n\t\tadd : function(p, n, a, h, c) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\treturn this.run(p, function(p) {\r\n\t\t\t\tvar e, k;\r\n\r\n\t\t\t\te = is(n, 'string') ? t.doc.createElement(n) : n;\r\n\t\t\t\tt.setAttribs(e, a);\r\n\r\n\t\t\t\tif (h) {\r\n\t\t\t\t\tif (h.nodeType)\r\n\t\t\t\t\t\te.appendChild(h);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tt.setHTML(e, h);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn !c ? p.appendChild(e) : e;\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Creates a new element.\r\n\t\t *\r\n\t\t * @method create\r\n\t\t * @param {String} n Name of new element.\r\n\t\t * @param {Object} a Optional object name/value collection with element attributes.\r\n\t\t * @param {String} h Optional HTML string to set as inner HTML of the element.\r\n\t\t * @return {Element} HTML DOM node element that got created.\r\n\t\t * @example\r\n\t\t * // Adds an element where the caret/selection is in the active editor\r\n\t\t * var el = tinyMCE.activeEditor.dom.create('div', {id : 'test', 'class' : 'myclass'}, 'some content');\r\n\t\t * tinyMCE.activeEditor.selection.setNode(el);\r\n\t\t */\r\n\t\tcreate : function(n, a, h) {\r\n\t\t\treturn this.add(this.doc.createElement(n), n, a, h, 1);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Create HTML string for element. The element will be closed unless an empty inner HTML string is passed.\r\n\t\t *\r\n\t\t * @method createHTML\r\n\t\t * @param {String} n Name of new element.\r\n\t\t * @param {Object} a Optional object name/value collection with element attributes.\r\n\t\t * @param {String} h Optional HTML string to set as inner HTML of the element.\r\n\t\t * @return {String} String with new HTML element like for example: <a href=\"#\">test</a>.\r\n\t\t * @example\r\n\t\t * // Creates a html chunk and inserts it at the current selection/caret location\r\n\t\t * tinyMCE.activeEditor.selection.setContent(tinyMCE.activeEditor.dom.createHTML('a', {href : 'test.html'}, 'some line'));\r\n\t\t */\r\n\t\tcreateHTML : function(n, a, h) {\r\n\t\t\tvar o = '', t = this, k;\r\n\r\n\t\t\to += '<' + n;\r\n\r\n\t\t\tfor (k in a) {\r\n\t\t\t\tif (a.hasOwnProperty(k))\r\n\t\t\t\t\to += ' ' + k + '=\"' + t.encode(a[k]) + '\"';\r\n\t\t\t}\r\n\r\n\t\t\t// A call to tinymce.is doesn't work for some odd reason on IE9 possible bug inside their JS runtime\r\n\t\t\tif (typeof(h) != \"undefined\")\r\n\t\t\t\treturn o + '>' + h + '</' + n + '>';\r\n\r\n\t\t\treturn o + ' />';\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Removes/deletes the specified element(s) from the DOM.\r\n\t\t *\r\n\t\t * @method remove\r\n\t\t * @param {String/Element/Array} node ID of element or DOM element object or array containing multiple elements/ids.\r\n\t\t * @param {Boolean} keep_children Optional state to keep children or not. If set to true all children will be placed at the location of the removed element.\r\n\t\t * @return {Element/Array} HTML DOM element that got removed or array of elements depending on input.\r\n\t\t * @example\r\n\t\t * // Removes all paragraphs in the active editor\r\n\t\t * tinyMCE.activeEditor.dom.remove(tinyMCE.activeEditor.dom.select('p'));\r\n\t\t * \r\n\t\t * // Removes a element by id in the document\r\n\t\t * tinyMCE.DOM.remove('mydiv');\r\n\t\t */\r\n\t\tremove : function(node, keep_children) {\r\n\t\t\treturn this.run(node, function(node) {\r\n\t\t\t\tvar child, parent = node.parentNode;\r\n\r\n\t\t\t\tif (!parent)\r\n\t\t\t\t\treturn null;\r\n\r\n\t\t\t\tif (keep_children) {\r\n\t\t\t\t\twhile (child = node.firstChild) {\r\n\t\t\t\t\t\t// IE 8 will crash if you don't remove completely empty text nodes\r\n\t\t\t\t\t\tif (!tinymce.isIE || child.nodeType !== 3 || child.nodeValue)\r\n\t\t\t\t\t\t\tparent.insertBefore(child, node);\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tnode.removeChild(child);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn parent.removeChild(node);\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Sets the CSS style value on a HTML element. The name can be a camelcase string\r\n\t\t * or the CSS style name like background-color.\r\n\t\t *\r\n\t\t * @method setStyle\r\n\t\t * @param {String/Element/Array} n HTML element/Element ID or Array of elements/ids to set CSS style value on.\r\n\t\t * @param {String} na Name of the style value to set.\r\n\t\t * @param {String} v Value to set on the style.\r\n\t\t * @example\r\n\t\t * // Sets a style value on all paragraphs in the currently active editor\r\n\t\t * tinyMCE.activeEditor.dom.setStyle(tinyMCE.activeEditor.dom.select('p'), 'background-color', 'red');\r\n\t\t * \r\n\t\t * // Sets a style value to an element by id in the current document\r\n\t\t * tinyMCE.DOM.setStyle('mydiv', 'background-color', 'red');\r\n\t\t */\r\n\t\tsetStyle : function(n, na, v) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\treturn t.run(n, function(e) {\r\n\t\t\t\tvar s, i;\r\n\r\n\t\t\t\ts = e.style;\r\n\r\n\t\t\t\t// Camelcase it, if needed\r\n\t\t\t\tna = na.replace(/-(\\D)/g, function(a, b){\r\n\t\t\t\t\treturn b.toUpperCase();\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// Default px suffix on these\r\n\t\t\t\tif (t.pixelStyles.test(na) && (tinymce.is(v, 'number') || /^[\\-0-9\\.]+$/.test(v)))\r\n\t\t\t\t\tv += 'px';\r\n\r\n\t\t\t\tswitch (na) {\r\n\t\t\t\t\tcase 'opacity':\r\n\t\t\t\t\t\t// IE specific opacity\r\n\t\t\t\t\t\tif (isIE) {\r\n\t\t\t\t\t\t\ts.filter = v === '' ? '' : \"alpha(opacity=\" + (v * 100) + \")\";\r\n\r\n\t\t\t\t\t\t\tif (!n.currentStyle || !n.currentStyle.hasLayout)\r\n\t\t\t\t\t\t\t\ts.display = 'inline-block';\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Fix for older browsers\r\n\t\t\t\t\t\ts[na] = s['-moz-opacity'] = s['-khtml-opacity'] = v || '';\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'float':\r\n\t\t\t\t\t\tisIE ? s.styleFloat = v : s.cssFloat = v;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\ts[na] = v || '';\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Force update of the style data\r\n\t\t\t\tif (t.settings.update_styles)\r\n\t\t\t\t\tt.setAttrib(e, 'data-mce-style');\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns the current style or runtime/computed value of a element.\r\n\t\t *\r\n\t\t * @method getStyle\r\n\t\t * @param {String/Element} n HTML element or element id string to get style from.\r\n\t\t * @param {String} na Style name to return.\r\n\t\t * @param {Boolean} c Computed style.\r\n\t\t * @return {String} Current style or computed style value of a element.\r\n\t\t */\r\n\t\tgetStyle : function(n, na, c) {\r\n\t\t\tn = this.get(n);\r\n\r\n\t\t\tif (!n)\r\n\t\t\t\treturn;\r\n\r\n\t\t\t// Gecko\r\n\t\t\tif (this.doc.defaultView && c) {\r\n\t\t\t\t// Remove camelcase\r\n\t\t\t\tna = na.replace(/[A-Z]/g, function(a){\r\n\t\t\t\t\treturn '-' + a;\r\n\t\t\t\t});\r\n\r\n\t\t\t\ttry {\r\n\t\t\t\t\treturn this.doc.defaultView.getComputedStyle(n, null).getPropertyValue(na);\r\n\t\t\t\t} catch (ex) {\r\n\t\t\t\t\t// Old safari might fail\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Camelcase it, if needed\r\n\t\t\tna = na.replace(/-(\\D)/g, function(a, b){\r\n\t\t\t\treturn b.toUpperCase();\r\n\t\t\t});\r\n\r\n\t\t\tif (na == 'float')\r\n\t\t\t\tna = isIE ? 'styleFloat' : 'cssFloat';\r\n\r\n\t\t\t// IE & Opera\r\n\t\t\tif (n.currentStyle && c)\r\n\t\t\t\treturn n.currentStyle[na];\r\n\r\n\t\t\treturn n.style ? n.style[na] : undefined;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Sets multiple styles on the specified element(s).\r\n\t\t *\r\n\t\t * @method setStyles\r\n\t\t * @param {Element/String/Array} e DOM element, element id string or array of elements/ids to set styles on.\r\n\t\t * @param {Object} o Name/Value collection of style items to add to the element(s).\r\n\t\t * @example\r\n\t\t * // Sets styles on all paragraphs in the currently active editor\r\n\t\t * tinyMCE.activeEditor.dom.setStyles(tinyMCE.activeEditor.dom.select('p'), {'background-color' : 'red', 'color' : 'green'});\r\n\t\t * \r\n\t\t * // Sets styles to an element by id in the current document\r\n\t\t * tinyMCE.DOM.setStyles('mydiv', {'background-color' : 'red', 'color' : 'green'});\r\n\t\t */\r\n\t\tsetStyles : function(e, o) {\r\n\t\t\tvar t = this, s = t.settings, ol;\r\n\r\n\t\t\tol = s.update_styles;\r\n\t\t\ts.update_styles = 0;\r\n\r\n\t\t\teach(o, function(v, n) {\r\n\t\t\t\tt.setStyle(e, n, v);\r\n\t\t\t});\r\n\r\n\t\t\t// Update style info\r\n\t\t\ts.update_styles = ol;\r\n\t\t\tif (s.update_styles)\r\n\t\t\t\tt.setAttrib(e, s.cssText);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Removes all attributes from an element or elements.\r\n\t\t * \r\n\t\t * @param {Element/String/Array} e DOM element, element id string or array of elements/ids to remove attributes from.\r\n\t\t */\r\n\t\tremoveAllAttribs: function(e) {\r\n\t\t\treturn this.run(e, function(e) {\r\n\t\t\t\tvar i, attrs = e.attributes;\r\n\t\t\t\tfor (i = attrs.length - 1; i >= 0; i--) {\r\n\t\t\t\t\te.removeAttributeNode(attrs.item(i));\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Sets the specified attributes value of a element or elements.\r\n\t\t *\r\n\t\t * @method setAttrib\r\n\t\t * @param {Element/String/Array} e DOM element, element id string or array of elements/ids to set attribute on.\r\n\t\t * @param {String} n Name of attribute to set.\r\n\t\t * @param {String} v Value to set on the attribute of this value is falsy like null 0 or '' it will remove the attribute instead.\r\n\t\t * @example\r\n\t\t * // Sets an attribute to all paragraphs in the active editor\r\n\t\t * tinyMCE.activeEditor.dom.setAttrib(tinyMCE.activeEditor.dom.select('p'), 'class', 'myclass');\r\n\t\t * \r\n\t\t * // Sets an attribute to a specific element in the current page\r\n\t\t * tinyMCE.dom.setAttrib('mydiv', 'class', 'myclass');\r\n\t\t */\r\n\t\tsetAttrib : function(e, n, v) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\t// Whats the point\r\n\t\t\tif (!e || !n)\r\n\t\t\t\treturn;\r\n\r\n\t\t\t// Strict XML mode\r\n\t\t\tif (t.settings.strict)\r\n\t\t\t\tn = n.toLowerCase();\r\n\r\n\t\t\treturn this.run(e, function(e) {\r\n\t\t\t\tvar s = t.settings;\r\n\t\t\t\tif (v !== null) {\r\n\t\t\t\t\tswitch (n) {\r\n\t\t\t\t\t\tcase \"style\":\r\n\t\t\t\t\t\t\tif (!is(v, 'string')) {\r\n\t\t\t\t\t\t\t\teach(v, function(v, n) {\r\n\t\t\t\t\t\t\t\t\tt.setStyle(e, n, v);\r\n\t\t\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// No mce_style for elements with these since they might get resized by the user\r\n\t\t\t\t\t\t\tif (s.keep_values) {\r\n\t\t\t\t\t\t\t\tif (v && !t._isRes(v))\r\n\t\t\t\t\t\t\t\t\te.setAttribute('data-mce-style', v, 2);\r\n\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\te.removeAttribute('data-mce-style', 2);\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\te.style.cssText = v;\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase \"class\":\r\n\t\t\t\t\t\t\te.className = v || ''; // Fix IE null bug\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase \"src\":\r\n\t\t\t\t\t\tcase \"href\":\r\n\t\t\t\t\t\t\tif (s.keep_values) {\r\n\t\t\t\t\t\t\t\tif (s.url_converter)\r\n\t\t\t\t\t\t\t\t\tv = s.url_converter.call(s.url_converter_scope || t, v, n, e);\r\n\r\n\t\t\t\t\t\t\t\tt.setAttrib(e, 'data-mce-' + n, v, 2);\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase \"shape\":\r\n\t\t\t\t\t\t\te.setAttribute('data-mce-style', v);\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (is(v) && v !== null && v.length !== 0)\r\n\t\t\t\t\te.setAttribute(n, '' + v, 2);\r\n\t\t\t\telse\r\n\t\t\t\t\te.removeAttribute(n, 2);\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Sets the specified attributes of a element or elements.\r\n\t\t *\r\n\t\t * @method setAttribs\r\n\t\t * @param {Element/String/Array} e DOM element, element id string or array of elements/ids to set attributes on.\r\n\t\t * @param {Object} o Name/Value collection of attribute items to add to the element(s).\r\n\t\t * @example\r\n\t\t * // Sets some attributes to all paragraphs in the active editor\r\n\t\t * tinyMCE.activeEditor.dom.setAttribs(tinyMCE.activeEditor.dom.select('p'), {'class' : 'myclass', title : 'some title'});\r\n\t\t * \r\n\t\t * // Sets some attributes to a specific element in the current page\r\n\t\t * tinyMCE.DOM.setAttribs('mydiv', {'class' : 'myclass', title : 'some title'});\r\n\t\t */\r\n\t\tsetAttribs : function(e, o) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\treturn this.run(e, function(e) {\r\n\t\t\t\teach(o, function(v, n) {\r\n\t\t\t\t\tt.setAttrib(e, n, v);\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns the specified attribute by name.\r\n\t\t *\r\n\t\t * @method getAttrib\r\n\t\t * @param {String/Element} e Element string id or DOM element to get attribute from.\r\n\t\t * @param {String} n Name of attribute to get.\r\n\t\t * @param {String} dv Optional default value to return if the attribute didn't exist.\r\n\t\t * @return {String} Attribute value string, default value or null if the attribute wasn't found.\r\n\t\t */\r\n\t\tgetAttrib : function(e, n, dv) {\r\n\t\t\tvar v, t = this, undef;\r\n\r\n\t\t\te = t.get(e);\r\n\r\n\t\t\tif (!e || e.nodeType !== 1)\r\n\t\t\t\treturn dv === undef ? false : dv;\r\n\r\n\t\t\tif (!is(dv))\r\n\t\t\t\tdv = '';\r\n\r\n\t\t\t// Try the mce variant for these\r\n\t\t\tif (/^(src|href|style|coords|shape)$/.test(n)) {\r\n\t\t\t\tv = e.getAttribute(\"data-mce-\" + n);\r\n\r\n\t\t\t\tif (v)\r\n\t\t\t\t\treturn v;\r\n\t\t\t}\r\n\r\n\t\t\tif (isIE && t.props[n]) {\r\n\t\t\t\tv = e[t.props[n]];\r\n\t\t\t\tv = v && v.nodeValue ? v.nodeValue : v;\r\n\t\t\t}\r\n\r\n\t\t\tif (!v)\r\n\t\t\t\tv = e.getAttribute(n, 2);\r\n\r\n\t\t\t// Check boolean attribs\r\n\t\t\tif (/^(checked|compact|declare|defer|disabled|ismap|multiple|nohref|noshade|nowrap|readonly|selected)$/.test(n)) {\r\n\t\t\t\tif (e[t.props[n]] === true && v === '')\r\n\t\t\t\t\treturn n;\r\n\r\n\t\t\t\treturn v ? n : '';\r\n\t\t\t}\r\n\r\n\t\t\t// Inner input elements will override attributes on form elements\r\n\t\t\tif (e.nodeName === \"FORM\" && e.getAttributeNode(n))\r\n\t\t\t\treturn e.getAttributeNode(n).nodeValue;\r\n\r\n\t\t\tif (n === 'style') {\r\n\t\t\t\tv = v || e.style.cssText;\r\n\r\n\t\t\t\tif (v) {\r\n\t\t\t\t\tv = t.serializeStyle(t.parseStyle(v), e.nodeName);\r\n\r\n\t\t\t\t\tif (t.settings.keep_values && !t._isRes(v))\r\n\t\t\t\t\t\te.setAttribute('data-mce-style', v);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Remove Apple and WebKit stuff\r\n\t\t\tif (isWebKit && n === \"class\" && v)\r\n\t\t\t\tv = v.replace(/(apple|webkit)\\-[a-z\\-]+/gi, '');\r\n\r\n\t\t\t// Handle IE issues\r\n\t\t\tif (isIE) {\r\n\t\t\t\tswitch (n) {\r\n\t\t\t\t\tcase 'rowspan':\r\n\t\t\t\t\tcase 'colspan':\r\n\t\t\t\t\t\t// IE returns 1 as default value\r\n\t\t\t\t\t\tif (v === 1)\r\n\t\t\t\t\t\t\tv = '';\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'size':\r\n\t\t\t\t\t\t// IE returns +0 as default value for size\r\n\t\t\t\t\t\tif (v === '+0' || v === 20 || v === 0)\r\n\t\t\t\t\t\t\tv = '';\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'width':\r\n\t\t\t\t\tcase 'height':\r\n\t\t\t\t\tcase 'vspace':\r\n\t\t\t\t\tcase 'checked':\r\n\t\t\t\t\tcase 'disabled':\r\n\t\t\t\t\tcase 'readonly':\r\n\t\t\t\t\t\tif (v === 0)\r\n\t\t\t\t\t\t\tv = '';\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'hspace':\r\n\t\t\t\t\t\t// IE returns -1 as default value\r\n\t\t\t\t\t\tif (v === -1)\r\n\t\t\t\t\t\t\tv = '';\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'maxlength':\r\n\t\t\t\t\tcase 'tabindex':\r\n\t\t\t\t\t\t// IE returns default value\r\n\t\t\t\t\t\tif (v === 32768 || v === 2147483647 || v === '32768')\r\n\t\t\t\t\t\t\tv = '';\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'multiple':\r\n\t\t\t\t\tcase 'compact':\r\n\t\t\t\t\tcase 'noshade':\r\n\t\t\t\t\tcase 'nowrap':\r\n\t\t\t\t\t\tif (v === 65535)\r\n\t\t\t\t\t\t\treturn n;\r\n\r\n\t\t\t\t\t\treturn dv;\r\n\r\n\t\t\t\t\tcase 'shape':\r\n\t\t\t\t\t\tv = v.toLowerCase();\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t// IE has odd anonymous function for event attributes\r\n\t\t\t\t\t\tif (n.indexOf('on') === 0 && v)\r\n\t\t\t\t\t\t\tv = tinymce._replace(/^function\\s+\\w+\\(\\)\\s+\\{\\s+(.*)\\s+\\}$/, '$1', '' + v);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn (v !== undef && v !== null && v !== '') ? '' + v : dv;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns the absolute x, y position of a node. The position will be returned in a object with x, y fields.\r\n\t\t *\r\n\t\t * @method getPos\r\n\t\t * @param {Element/String} n HTML element or element id to get x, y position from.\r\n\t\t * @param {Element} ro Optional root element to stop calculations at.\r\n\t\t * @return {object} Absolute position of the specified element object with x, y fields.\r\n\t\t */\r\n\t\tgetPos : function(n, ro) {\r\n\t\t\tvar t = this, x = 0, y = 0, e, d = t.doc, r;\r\n\r\n\t\t\tn = t.get(n);\r\n\t\t\tro = ro || d.body;\r\n\r\n\t\t\tif (n) {\r\n\t\t\t\t// Use getBoundingClientRect if it exists since it's faster than looping offset nodes\r\n\t\t\t\tif (n.getBoundingClientRect) {\r\n\t\t\t\t\tn = n.getBoundingClientRect();\r\n\t\t\t\t\te = t.boxModel ? d.documentElement : d.body;\r\n\r\n\t\t\t\t\t// Add scroll offsets from documentElement or body since IE with the wrong box model will use d.body and so do WebKit\r\n\t\t\t\t\t// Also remove the body/documentelement clientTop/clientLeft on IE 6, 7 since they offset the position\r\n\t\t\t\t\tx = n.left + (d.documentElement.scrollLeft || d.body.scrollLeft) - e.clientTop;\r\n\t\t\t\t\ty = n.top + (d.documentElement.scrollTop || d.body.scrollTop) - e.clientLeft;\r\n\r\n\t\t\t\t\treturn {x : x, y : y};\r\n\t\t\t\t}\r\n\r\n\t\t\t\tr = n;\r\n\t\t\t\twhile (r && r != ro && r.nodeType) {\r\n\t\t\t\t\tx += r.offsetLeft || 0;\r\n\t\t\t\t\ty += r.offsetTop || 0;\r\n\t\t\t\t\tr = r.offsetParent;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tr = n.parentNode;\r\n\t\t\t\twhile (r && r != ro && r.nodeType) {\r\n\t\t\t\t\tx -= r.scrollLeft || 0;\r\n\t\t\t\t\ty -= r.scrollTop || 0;\r\n\t\t\t\t\tr = r.parentNode;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn {x : x, y : y};\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Parses the specified style value into an object collection. This parser will also\r\n\t\t * merge and remove any redundant items that browsers might have added. It will also convert non hex\r\n\t\t * colors to hex values. Urls inside the styles will also be converted to absolute/relative based on settings.\r\n\t\t *\r\n\t\t * @method parseStyle\r\n\t\t * @param {String} st Style value to parse for example: border:1px solid red;.\r\n\t\t * @return {Object} Object representation of that style like {border : '1px solid red'}\r\n\t\t */\r\n\t\tparseStyle : function(st) {\r\n\t\t\treturn this.styles.parse(st);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Serializes the specified style object into a string.\r\n\t\t *\r\n\t\t * @method serializeStyle\r\n\t\t * @param {Object} o Object to serialize as string for example: {border : '1px solid red'}\r\n\t\t * @param {String} name Optional element name.\r\n\t\t * @return {String} String representation of the style object for example: border: 1px solid red.\r\n\t\t */\r\n\t\tserializeStyle : function(o, name) {\r\n\t\t\treturn this.styles.serialize(o, name);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Imports/loads the specified CSS file into the document bound to the class.\r\n\t\t *\r\n\t\t * @method loadCSS\r\n\t\t * @param {String} u URL to CSS file to load.\r\n\t\t * @example\r\n\t\t * // Loads a CSS file dynamically into the current document\r\n\t\t * tinymce.DOM.loadCSS('somepath/some.css');\r\n\t\t * \r\n\t\t * // Loads a CSS file into the currently active editor instance\r\n\t\t * tinyMCE.activeEditor.dom.loadCSS('somepath/some.css');\r\n\t\t * \r\n\t\t * // Loads a CSS file into an editor instance by id\r\n\t\t * tinyMCE.get('someid').dom.loadCSS('somepath/some.css');\r\n\t\t * \r\n\t\t * // Loads multiple CSS files into the current document\r\n\t\t * tinymce.DOM.loadCSS('somepath/some.css,somepath/someother.css');\r\n\t\t */\r\n\t\tloadCSS : function(u) {\r\n\t\t\tvar t = this, d = t.doc, head;\r\n\r\n\t\t\tif (!u)\r\n\t\t\t\tu = '';\r\n\r\n\t\t\thead = t.select('head')[0];\r\n\r\n\t\t\teach(u.split(','), function(u) {\r\n\t\t\t\tvar link;\r\n\r\n\t\t\t\tif (t.files[u])\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\tt.files[u] = true;\r\n\t\t\t\tlink = t.create('link', {rel : 'stylesheet', href : tinymce._addVer(u)});\r\n\r\n\t\t\t\t// IE 8 has a bug where dynamically loading stylesheets would produce a 1 item remaining bug\r\n\t\t\t\t// This fix seems to resolve that issue by realcing the document ones a stylesheet finishes loading\r\n\t\t\t\t// It's ugly but it seems to work fine.\r\n\t\t\t\tif (isIE && d.documentMode && d.recalc) {\r\n\t\t\t\t\tlink.onload = function() {\r\n\t\t\t\t\t\tif (d.recalc)\r\n\t\t\t\t\t\t\td.recalc();\r\n\r\n\t\t\t\t\t\tlink.onload = null;\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\r\n\t\t\t\thead.appendChild(link);\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Adds a class to the specified element or elements.\r\n\t\t *\r\n\t\t * @method addClass\r\n\t\t * @param {String/Element/Array} Element ID string or DOM element or array with elements or IDs.\r\n\t\t * @param {String} c Class name to add to each element.\r\n\t\t * @return {String/Array} String with new class value or array with new class values for all elements.\r\n\t\t * @example\r\n\t\t * // Adds a class to all paragraphs in the active editor\r\n\t\t * tinyMCE.activeEditor.dom.addClass(tinyMCE.activeEditor.dom.select('p'), 'myclass');\r\n\t\t * \r\n\t\t * // Adds a class to a specific element in the current page\r\n\t\t * tinyMCE.DOM.addClass('mydiv', 'myclass');\r\n\t\t */\r\n\t\taddClass : function(e, c) {\r\n\t\t\treturn this.run(e, function(e) {\r\n\t\t\t\tvar o;\r\n\r\n\t\t\t\tif (!c)\r\n\t\t\t\t\treturn 0;\r\n\r\n\t\t\t\tif (this.hasClass(e, c))\r\n\t\t\t\t\treturn e.className;\r\n\r\n\t\t\t\to = this.removeClass(e, c);\r\n\r\n\t\t\t\treturn e.className = (o != '' ? (o + ' ') : '') + c;\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Removes a class from the specified element or elements.\r\n\t\t *\r\n\t\t * @method removeClass\r\n\t\t * @param {String/Element/Array} Element ID string or DOM element or array with elements or IDs.\r\n\t\t * @param {String} c Class name to remove to each element.\r\n\t\t * @return {String/Array} String with new class value or array with new class values for all elements.\r\n\t\t * @example\r\n\t\t * // Removes a class from all paragraphs in the active editor\r\n\t\t * tinyMCE.activeEditor.dom.removeClass(tinyMCE.activeEditor.dom.select('p'), 'myclass');\r\n\t\t * \r\n\t\t * // Removes a class from a specific element in the current page\r\n\t\t * tinyMCE.DOM.removeClass('mydiv', 'myclass');\r\n\t\t */\r\n\t\tremoveClass : function(e, c) {\r\n\t\t\tvar t = this, re;\r\n\r\n\t\t\treturn t.run(e, function(e) {\r\n\t\t\t\tvar v;\r\n\r\n\t\t\t\tif (t.hasClass(e, c)) {\r\n\t\t\t\t\tif (!re)\r\n\t\t\t\t\t\tre = new RegExp(\"(^|\\\\s+)\" + c + \"(\\\\s+|$)\", \"g\");\r\n\r\n\t\t\t\t\tv = e.className.replace(re, ' ');\r\n\t\t\t\t\tv = tinymce.trim(v != ' ' ? v : '');\r\n\r\n\t\t\t\t\te.className = v;\r\n\r\n\t\t\t\t\t// Empty class attr\r\n\t\t\t\t\tif (!v) {\r\n\t\t\t\t\t\te.removeAttribute('class');\r\n\t\t\t\t\t\te.removeAttribute('className');\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn v;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn e.className;\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns true if the specified element has the specified class.\r\n\t\t *\r\n\t\t * @method hasClass\r\n\t\t * @param {String/Element} n HTML element or element id string to check CSS class on.\r\n\t\t * @param {String} c CSS class to check for.\r\n\t\t * @return {Boolean} true/false if the specified element has the specified class.\r\n\t\t */\r\n\t\thasClass : function(n, c) {\r\n\t\t\tn = this.get(n);\r\n\r\n\t\t\tif (!n || !c)\r\n\t\t\t\treturn false;\r\n\r\n\t\t\treturn (' ' + n.className + ' ').indexOf(' ' + c + ' ') !== -1;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Shows the specified element(s) by ID by setting the \"display\" style.\r\n\t\t *\r\n\t\t * @method show\r\n\t\t * @param {String/Element/Array} e ID of DOM element or DOM element or array with elements or IDs to show.\r\n\t\t */\r\n\t\tshow : function(e) {\r\n\t\t\treturn this.setStyle(e, 'display', 'block');\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Hides the specified element(s) by ID by setting the \"display\" style.\r\n\t\t *\r\n\t\t * @method hide\r\n\t\t * @param {String/Element/Array} e ID of DOM element or DOM element or array with elements or IDs to hide.\r\n\t\t * @example\r\n\t\t * // Hides a element by id in the document\r\n\t\t * tinymce.DOM.hide('myid');\r\n\t\t */\r\n\t\thide : function(e) {\r\n\t\t\treturn this.setStyle(e, 'display', 'none');\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns true/false if the element is hidden or not by checking the \"display\" style.\r\n\t\t *\r\n\t\t * @method isHidden\r\n\t\t * @param {String/Element} e Id or element to check display state on.\r\n\t\t * @return {Boolean} true/false if the element is hidden or not.\r\n\t\t */\r\n\t\tisHidden : function(e) {\r\n\t\t\te = this.get(e);\r\n\r\n\t\t\treturn !e || e.style.display == 'none' || this.getStyle(e, 'display') == 'none';\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns a unique id. This can be useful when generating elements on the fly.\r\n\t\t * This method will not check if the element already exists.\r\n\t\t *\r\n\t\t * @method uniqueId\r\n\t\t * @param {String} p Optional prefix to add infront of all ids defaults to \"mce_\".\r\n\t\t * @return {String} Unique id.\r\n\t\t */\r\n\t\tuniqueId : function(p) {\r\n\t\t\treturn (!p ? 'mce_' : p) + (this.counter++);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Sets the specified HTML content inside the element or elements. The HTML will first be processed this means\r\n\t\t * URLs will get converted, hex color values fixed etc. Check processHTML for details.\r\n\t\t *\r\n\t\t * @method setHTML\r\n\t\t * @param {Element/String/Array} e DOM element, element id string or array of elements/ids to set HTML inside.\r\n\t\t * @param {String} h HTML content to set as inner HTML of the element.\r\n\t\t * @example\r\n\t\t * // Sets the inner HTML of all paragraphs in the active editor\r\n\t\t * tinyMCE.activeEditor.dom.setHTML(tinyMCE.activeEditor.dom.select('p'), 'some inner html');\r\n\t\t * \r\n\t\t * // Sets the inner HTML of a element by id in the document\r\n\t\t * tinyMCE.DOM.setHTML('mydiv', 'some inner html');\r\n\t\t */\r\n\t\tsetHTML : function(element, html) {\r\n\t\t\tvar self = this;\r\n\r\n\t\t\treturn self.run(element, function(element) {\r\n\t\t\t\tif (isIE) {\r\n\t\t\t\t\t// Remove all child nodes, IE keeps empty text nodes in DOM\r\n\t\t\t\t\twhile (element.firstChild)\r\n\t\t\t\t\t\telement.removeChild(element.firstChild);\r\n\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\t// IE will remove comments from the beginning\r\n\t\t\t\t\t\t// unless you padd the contents with something\r\n\t\t\t\t\t\telement.innerHTML = '<br />' + html;\r\n\t\t\t\t\t\telement.removeChild(element.firstChild);\r\n\t\t\t\t\t} catch (ex) {\r\n\t\t\t\t\t\t// IE sometimes produces an unknown runtime error on innerHTML if it's an block element within a block element for example a div inside a p\r\n\t\t\t\t\t\t// This seems to fix this problem\r\n\r\n\t\t\t\t\t\t// Create new div with HTML contents and a BR infront to keep comments\r\n\t\t\t\t\t\telement = self.create('div');\r\n\t\t\t\t\t\telement.innerHTML = '<br />' + html;\r\n\r\n\t\t\t\t\t\t// Add all children from div to target\r\n\t\t\t\t\t\teach (element.childNodes, function(node, i) {\r\n\t\t\t\t\t\t\t// Skip br element\r\n\t\t\t\t\t\t\tif (i)\r\n\t\t\t\t\t\t\t\telement.appendChild(node);\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t} else\r\n\t\t\t\t\telement.innerHTML = html;\r\n\r\n\t\t\t\treturn html;\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns the outer HTML of an element.\r\n\t\t *\r\n\t\t * @method getOuterHTML\r\n\t\t * @param {String/Element} elm Element ID or element object to get outer HTML from.\r\n\t\t * @return {String} Outer HTML string.\r\n\t\t * @example\r\n\t\t * tinymce.DOM.getOuterHTML(editorElement);\r\n\t\t * tinyMCE.activeEditor.getOuterHTML(tinyMCE.activeEditor.getBody());\r\n\t\t */\r\n\t\tgetOuterHTML : function(elm) {\r\n\t\t\tvar doc, self = this;\r\n\r\n\t\t\telm = self.get(elm);\r\n\r\n\t\t\tif (!elm)\r\n\t\t\t\treturn null;\r\n\r\n\t\t\tif (elm.nodeType === 1 && self.hasOuterHTML)\r\n\t\t\t\treturn elm.outerHTML;\r\n\r\n\t\t\tdoc = (elm.ownerDocument || self.doc).createElement(\"body\");\r\n\t\t\tdoc.appendChild(elm.cloneNode(true));\r\n\r\n\t\t\treturn doc.innerHTML;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Sets the specified outer HTML on a element or elements.\r\n\t\t *\r\n\t\t * @method setOuterHTML\r\n\t\t * @param {Element/String/Array} e DOM element, element id string or array of elements/ids to set outer HTML on.\r\n\t\t * @param {Object} h HTML code to set as outer value for the element.\r\n\t\t * @param {Document} d Optional document scope to use in this process defaults to the document of the DOM class.\r\n\t\t * @example\r\n\t\t * // Sets the outer HTML of all paragraphs in the active editor\r\n\t\t * tinyMCE.activeEditor.dom.setOuterHTML(tinyMCE.activeEditor.dom.select('p'), '<div>some html</div>');\r\n\t\t * \r\n\t\t * // Sets the outer HTML of a element by id in the document\r\n\t\t * tinyMCE.DOM.setOuterHTML('mydiv', '<div>some html</div>');\r\n\t\t */\r\n\t\tsetOuterHTML : function(e, h, d) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\tfunction setHTML(e, h, d) {\r\n\t\t\t\tvar n, tp;\r\n\r\n\t\t\t\ttp = d.createElement(\"body\");\r\n\t\t\t\ttp.innerHTML = h;\r\n\r\n\t\t\t\tn = tp.lastChild;\r\n\t\t\t\twhile (n) {\r\n\t\t\t\t\tt.insertAfter(n.cloneNode(true), e);\r\n\t\t\t\t\tn = n.previousSibling;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tt.remove(e);\r\n\t\t\t};\r\n\r\n\t\t\treturn this.run(e, function(e) {\r\n\t\t\t\te = t.get(e);\r\n\r\n\t\t\t\t// Only set HTML on elements\r\n\t\t\t\tif (e.nodeType == 1) {\r\n\t\t\t\t\td = d || e.ownerDocument || t.doc;\r\n\r\n\t\t\t\t\tif (isIE) {\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t// Try outerHTML for IE it sometimes produces an unknown runtime error\r\n\t\t\t\t\t\t\tif (isIE && e.nodeType == 1)\r\n\t\t\t\t\t\t\t\te.outerHTML = h;\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\tsetHTML(e, h, d);\r\n\t\t\t\t\t\t} catch (ex) {\r\n\t\t\t\t\t\t\t// Fix for unknown runtime error\r\n\t\t\t\t\t\t\tsetHTML(e, h, d);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else\r\n\t\t\t\t\t\tsetHTML(e, h, d);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Entity decode a string, resolves any HTML entities like &aring;.\r\n\t\t *\r\n\t\t * @method decode\r\n\t\t * @param {String} s String to decode entities on.\r\n\t\t * @return {String} Entity decoded string.\r\n\t\t */\r\n\t\tdecode : Entities.decode,\r\n\r\n\t\t/**\r\n\t\t * Entity encodes a string, encodes the most common entities <>\"& into entities.\r\n\t\t *\r\n\t\t * @method encode\r\n\t\t * @param {String} text String to encode with entities.\r\n\t\t * @return {String} Entity encoded string.\r\n\t\t */\r\n\t\tencode : Entities.encodeAllRaw,\r\n\r\n\t\t/**\r\n\t\t * Inserts a element after the reference element.\r\n\t\t *\r\n\t\t * @method insertAfter\r\n\t\t * @param {Element} node Element to insert after the reference.\r\n\t\t * @param {Element/String/Array} reference_node Reference element, element id or array of elements to insert after.\r\n\t\t * @return {Element/Array} Element that got added or an array with elements. \r\n\t\t */\r\n\t\tinsertAfter : function(node, reference_node) {\r\n\t\t\treference_node = this.get(reference_node);\r\n\r\n\t\t\treturn this.run(node, function(node) {\r\n\t\t\t\tvar parent, nextSibling;\r\n\r\n\t\t\t\tparent = reference_node.parentNode;\r\n\t\t\t\tnextSibling = reference_node.nextSibling;\r\n\r\n\t\t\t\tif (nextSibling)\r\n\t\t\t\t\tparent.insertBefore(node, nextSibling);\r\n\t\t\t\telse\r\n\t\t\t\t\tparent.appendChild(node);\r\n\r\n\t\t\t\treturn node;\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns true/false if the specified element is a block element or not.\r\n\t\t *\r\n\t\t * @method isBlock\r\n\t\t * @param {Node/String} node Element/Node to check.\r\n\t\t * @return {Boolean} True/False state if the node is a block element or not.\r\n\t\t */\r\n\t\tisBlock : function(node) {\r\n\t\t\tvar type = node.nodeType;\r\n\r\n\t\t\t// If it's a node then check the type and use the nodeName\r\n\t\t\tif (type)\r\n\t\t\t\treturn !!(type === 1 && blockElementsMap[node.nodeName]);\r\n\r\n\t\t\treturn !!blockElementsMap[node];\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Replaces the specified element or elements with the specified element, the new element will\r\n\t\t * be cloned if multiple inputs elements are passed.\r\n\t\t *\r\n\t\t * @method replace\r\n\t\t * @param {Element} n New element to replace old ones with.\r\n\t\t * @param {Element/String/Array} o Element DOM node, element id or array of elements or ids to replace.\r\n\t\t * @param {Boolean} k Optional keep children state, if set to true child nodes from the old object will be added to new ones.\r\n\t\t */\r\n\t\treplace : function(n, o, k) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\tif (is(o, 'array'))\r\n\t\t\t\tn = n.cloneNode(true);\r\n\r\n\t\t\treturn t.run(o, function(o) {\r\n\t\t\t\tif (k) {\r\n\t\t\t\t\teach(tinymce.grep(o.childNodes), function(c) {\r\n\t\t\t\t\t\tn.appendChild(c);\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn o.parentNode.replaceChild(n, o);\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Renames the specified element to a new name and keep it's attributes and children.\r\n\t\t *\r\n\t\t * @method rename\r\n\t\t * @param {Element} elm Element to rename.\r\n\t\t * @param {String} name Name of the new element.\r\n\t\t * @return New element or the old element if it needed renaming.\r\n\t\t */\r\n\t\trename : function(elm, name) {\r\n\t\t\tvar t = this, newElm;\r\n\r\n\t\t\tif (elm.nodeName != name.toUpperCase()) {\r\n\t\t\t\t// Rename block element\r\n\t\t\t\tnewElm = t.create(name);\r\n\r\n\t\t\t\t// Copy attribs to new block\r\n\t\t\t\teach(t.getAttribs(elm), function(attr_node) {\r\n\t\t\t\t\tt.setAttrib(newElm, attr_node.nodeName, t.getAttrib(elm, attr_node.nodeName));\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// Replace block\r\n\t\t\t\tt.replace(newElm, elm, 1);\r\n\t\t\t}\r\n\r\n\t\t\treturn newElm || elm;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Find the common ancestor of two elements. This is a shorter method than using the DOM Range logic.\r\n\t\t *\r\n\t\t * @method findCommonAncestor\r\n\t\t * @param {Element} a Element to find common ancestor of.\r\n\t\t * @param {Element} b Element to find common ancestor of.\r\n\t\t * @return {Element} Common ancestor element of the two input elements.\r\n\t\t */\r\n\t\tfindCommonAncestor : function(a, b) {\r\n\t\t\tvar ps = a, pe;\r\n\r\n\t\t\twhile (ps) {\r\n\t\t\t\tpe = b;\r\n\r\n\t\t\t\twhile (pe && ps != pe)\r\n\t\t\t\t\tpe = pe.parentNode;\r\n\r\n\t\t\t\tif (ps == pe)\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tps = ps.parentNode;\r\n\t\t\t}\r\n\r\n\t\t\tif (!ps && a.ownerDocument)\r\n\t\t\t\treturn a.ownerDocument.documentElement;\r\n\r\n\t\t\treturn ps;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Parses the specified RGB color value and returns a hex version of that color.\r\n\t\t *\r\n\t\t * @method toHex\r\n\t\t * @param {String} s RGB string value like rgb(1,2,3)\r\n\t\t * @return {String} Hex version of that RGB value like #FF00FF.\r\n\t\t */\r\n\t\ttoHex : function(s) {\r\n\t\t\tvar c = /^\\s*rgb\\s*?\\(\\s*?([0-9]+)\\s*?,\\s*?([0-9]+)\\s*?,\\s*?([0-9]+)\\s*?\\)\\s*$/i.exec(s);\r\n\r\n\t\t\tfunction hex(s) {\r\n\t\t\t\ts = parseInt(s).toString(16);\r\n\r\n\t\t\t\treturn s.length > 1 ? s : '0' + s; // 0 -> 00\r\n\t\t\t};\r\n\r\n\t\t\tif (c) {\r\n\t\t\t\ts = '#' + hex(c[1]) + hex(c[2]) + hex(c[3]);\r\n\r\n\t\t\t\treturn s;\r\n\t\t\t}\r\n\r\n\t\t\treturn s;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns a array of all single CSS classes in the document. A single CSS class is a simple\r\n\t\t * rule like \".class\" complex ones like \"div td.class\" will not be added to output.\r\n\t\t *\r\n\t\t * @method getClasses\r\n\t\t * @return {Array} Array with class objects each object has a class field might be other fields in the future.\r\n\t\t */\r\n\t\tgetClasses : function() {\r\n\t\t\tvar t = this, cl = [], i, lo = {}, f = t.settings.class_filter, ov;\r\n\r\n\t\t\tif (t.classes)\r\n\t\t\t\treturn t.classes;\r\n\r\n\t\t\tfunction addClasses(s) {\r\n\t\t\t\t// IE style imports\r\n\t\t\t\teach(s.imports, function(r) {\r\n\t\t\t\t\taddClasses(r);\r\n\t\t\t\t});\r\n\r\n\t\t\t\teach(s.cssRules || s.rules, function(r) {\r\n\t\t\t\t\t// Real type or fake it on IE\r\n\t\t\t\t\tswitch (r.type || 1) {\r\n\t\t\t\t\t\t// Rule\r\n\t\t\t\t\t\tcase 1:\r\n\t\t\t\t\t\t\tif (r.selectorText) {\r\n\t\t\t\t\t\t\t\teach(r.selectorText.split(','), function(v) {\r\n\t\t\t\t\t\t\t\t\tv = v.replace(/^\\s*|\\s*$|^\\s\\./g, \"\");\r\n\r\n\t\t\t\t\t\t\t\t\t// Is internal or it doesn't contain a class\r\n\t\t\t\t\t\t\t\t\tif (/\\.mce/.test(v) || !/\\.[\\w\\-]+$/.test(v))\r\n\t\t\t\t\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t\t\t\t\t// Remove everything but class name\r\n\t\t\t\t\t\t\t\t\tov = v;\r\n\t\t\t\t\t\t\t\t\tv = tinymce._replace(/.*\\.([a-z0-9_\\-]+).*/i, '$1', v);\r\n\r\n\t\t\t\t\t\t\t\t\t// Filter classes\r\n\t\t\t\t\t\t\t\t\tif (f && !(v = f(v, ov)))\r\n\t\t\t\t\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t\t\t\t\tif (!lo[v]) {\r\n\t\t\t\t\t\t\t\t\t\tcl.push({'class' : v});\r\n\t\t\t\t\t\t\t\t\t\tlo[v] = 1;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t// Import\r\n\t\t\t\t\t\tcase 3:\r\n\t\t\t\t\t\t\taddClasses(r.styleSheet);\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t};\r\n\r\n\t\t\ttry {\r\n\t\t\t\teach(t.doc.styleSheets, addClasses);\r\n\t\t\t} catch (ex) {\r\n\t\t\t\t// Ignore\r\n\t\t\t}\r\n\r\n\t\t\tif (cl.length > 0)\r\n\t\t\t\tt.classes = cl;\r\n\r\n\t\t\treturn cl;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Executes the specified function on the element by id or dom element node or array of elements/id.\r\n\t\t *\r\n\t\t * @method run\r\n\t\t * @param {String/Element/Array} Element ID or DOM element object or array with ids or elements.\r\n\t\t * @param {function} f Function to execute for each item.\r\n\t\t * @param {Object} s Optional scope to execute the function in.\r\n\t\t * @return {Object/Array} Single object or array with objects depending on multiple input or not.\r\n\t\t */\r\n\t\trun : function(e, f, s) {\r\n\t\t\tvar t = this, o;\r\n\r\n\t\t\tif (t.doc && typeof(e) === 'string')\r\n\t\t\t\te = t.get(e);\r\n\r\n\t\t\tif (!e)\r\n\t\t\t\treturn false;\r\n\r\n\t\t\ts = s || this;\r\n\t\t\tif (!e.nodeType && (e.length || e.length === 0)) {\r\n\t\t\t\to = [];\r\n\r\n\t\t\t\teach(e, function(e, i) {\r\n\t\t\t\t\tif (e) {\r\n\t\t\t\t\t\tif (typeof(e) == 'string')\r\n\t\t\t\t\t\t\te = t.doc.getElementById(e);\r\n\r\n\t\t\t\t\t\to.push(f.call(s, e, i));\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\treturn o;\r\n\t\t\t}\r\n\r\n\t\t\treturn f.call(s, e);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns an NodeList with attributes for the element.\r\n\t\t *\r\n\t\t * @method getAttribs\r\n\t\t * @param {HTMLElement/string} n Element node or string id to get attributes from.\r\n\t\t * @return {NodeList} NodeList with attributes.\r\n\t\t */\r\n\t\tgetAttribs : function(n) {\r\n\t\t\tvar o;\r\n\r\n\t\t\tn = this.get(n);\r\n\r\n\t\t\tif (!n)\r\n\t\t\t\treturn [];\r\n\r\n\t\t\tif (isIE) {\r\n\t\t\t\to = [];\r\n\r\n\t\t\t\t// Object will throw exception in IE\r\n\t\t\t\tif (n.nodeName == 'OBJECT')\r\n\t\t\t\t\treturn n.attributes;\r\n\r\n\t\t\t\t// IE doesn't keep the selected attribute if you clone option elements\r\n\t\t\t\tif (n.nodeName === 'OPTION' && this.getAttrib(n, 'selected'))\r\n\t\t\t\t\to.push({specified : 1, nodeName : 'selected'});\r\n\r\n\t\t\t\t// It's crazy that this is faster in IE but it's because it returns all attributes all the time\r\n\t\t\t\tn.cloneNode(false).outerHTML.replace(/<\\/?[\\w:\\-]+ ?|=[\\\"][^\\\"]+\\\"|=\\'[^\\']+\\'|=[\\w\\-]+|>/gi, '').replace(/[\\w:\\-]+/gi, function(a) {\r\n\t\t\t\t\to.push({specified : 1, nodeName : a});\r\n\t\t\t\t});\r\n\r\n\t\t\t\treturn o;\r\n\t\t\t}\r\n\r\n\t\t\treturn n.attributes;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns true/false if the specified node is to be considered empty or not.\r\n\t\t *\r\n\t\t * @example\r\n\t\t * tinymce.DOM.isEmpty(node, {img : true});\r\n\t\t * @method isEmpty\r\n\t\t * @param {Object} elements Optional name/value object with elements that are automatically treated as non empty elements.\r\n\t\t * @return {Boolean} true/false if the node is empty or not.\r\n\t\t */\r\n\t\tisEmpty : function(node, elements) {\r\n\t\t\tvar self = this, i, attributes, type, walker, name, parentNode;\r\n\r\n\t\t\tnode = node.firstChild;\r\n\t\t\tif (node) {\r\n\t\t\t\twalker = new tinymce.dom.TreeWalker(node);\r\n\t\t\t\telements = elements || self.schema ? self.schema.getNonEmptyElements() : null;\r\n\r\n\t\t\t\tdo {\r\n\t\t\t\t\ttype = node.nodeType;\r\n\r\n\t\t\t\t\tif (type === 1) {\r\n\t\t\t\t\t\t// Ignore bogus elements\r\n\t\t\t\t\t\tif (node.getAttribute('data-mce-bogus'))\r\n\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\t// Keep empty elements like <img />\r\n\t\t\t\t\t\tname = node.nodeName.toLowerCase();\r\n\t\t\t\t\t\tif (elements && elements[name]) {\r\n\t\t\t\t\t\t\t// Ignore single BR elements in blocks like <p><br /></p>\r\n\t\t\t\t\t\t\tparentNode = node.parentNode;\r\n\t\t\t\t\t\t\tif (name === 'br' && self.isBlock(parentNode) && parentNode.firstChild === node && parentNode.lastChild === node) {\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Keep elements with data-bookmark attributes or name attribute like <a name=\"1\"></a>\r\n\t\t\t\t\t\tattributes = self.getAttribs(node);\r\n\t\t\t\t\t\ti = node.attributes.length;\r\n\t\t\t\t\t\twhile (i--) {\r\n\t\t\t\t\t\t\tname = node.attributes[i].nodeName;\r\n\t\t\t\t\t\t\tif (name === \"name\" || name === 'data-mce-bookmark')\r\n\t\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Keep non whitespace text nodes\r\n\t\t\t\t\tif ((type === 3 && !whiteSpaceRegExp.test(node.nodeValue)))\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t} while (node = walker.next());\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Destroys all internal references to the DOM to solve IE leak issues.\r\n\t\t *\r\n\t\t * @method destroy\r\n\t\t */\r\n\t\tdestroy : function(s) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\tif (t.events)\r\n\t\t\t\tt.events.destroy();\r\n\r\n\t\t\tt.win = t.doc = t.root = t.events = null;\r\n\r\n\t\t\t// Manual destroy then remove unload handler\r\n\t\t\tif (!s)\r\n\t\t\t\ttinymce.removeUnload(t.destroy);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Created a new DOM Range object. This will use the native DOM Range API if it's\r\n\t\t * available if it's not it will fallback to the custom TinyMCE implementation.\r\n\t\t *\r\n\t\t * @method createRng\r\n\t\t * @return {DOMRange} DOM Range object.\r\n\t\t * @example\r\n\t\t * var rng = tinymce.DOM.createRng();\r\n\t\t * alert(rng.startContainer + \",\" + rng.startOffset);\r\n\t\t */\r\n\t\tcreateRng : function() {\r\n\t\t\tvar d = this.doc;\r\n\r\n\t\t\treturn d.createRange ? d.createRange() : new tinymce.dom.Range(this);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns the index of the specified node within it's parent.\r\n\t\t *\r\n\t\t * @param {Node} node Node to look for.\r\n\t\t * @param {boolean} normalized Optional true/false state if the index is what it would be after a normalization.\r\n\t\t * @return {Number} Index of the specified node.\r\n\t\t */\r\n\t\tnodeIndex : function(node, normalized) {\r\n\t\t\tvar idx = 0, lastNodeType, lastNode, nodeType;\r\n\r\n\t\t\tif (node) {\r\n\t\t\t\tfor (lastNodeType = node.nodeType, node = node.previousSibling, lastNode = node; node; node = node.previousSibling) {\r\n\t\t\t\t\tnodeType = node.nodeType;\r\n\r\n\t\t\t\t\t// Normalize text nodes\r\n\t\t\t\t\tif (normalized && nodeType == 3) {\r\n\t\t\t\t\t\tif (nodeType == lastNodeType || !node.nodeValue.length)\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tidx++;\r\n\t\t\t\t\tlastNodeType = nodeType;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn idx;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Splits an element into two new elements and places the specified split\r\n\t\t * element or element between the new ones. For example splitting the paragraph at the bold element in\r\n\t\t * this example <p>abc<b>abc</b>123</p> would produce <p>abc</p><b>abc</b><p>123</p>. \r\n\t\t *\r\n\t\t * @method split\r\n\t\t * @param {Element} pe Parent element to split.\r\n\t\t * @param {Element} e Element to split at.\r\n\t\t * @param {Element} re Optional replacement element to replace the split element by.\r\n\t\t * @return {Element} Returns the split element or the replacement element if that is specified.\r\n\t\t */\r\n\t\tsplit : function(pe, e, re) {\r\n\t\t\tvar t = this, r = t.createRng(), bef, aft, pa;\r\n\r\n\t\t\t// W3C valid browsers tend to leave empty nodes to the left/right side of the contents, this makes sense\r\n\t\t\t// but we don't want that in our code since it serves no purpose for the end user\r\n\t\t\t// For example if this is chopped:\r\n\t\t\t//   <p>text 1<span><b>CHOP</b></span>text 2</p>\r\n\t\t\t// would produce:\r\n\t\t\t//   <p>text 1<span></span></p><b>CHOP</b><p><span></span>text 2</p>\r\n\t\t\t// this function will then trim of empty edges and produce:\r\n\t\t\t//   <p>text 1</p><b>CHOP</b><p>text 2</p>\r\n\t\t\tfunction trim(node) {\r\n\t\t\t\tvar i, children = node.childNodes, type = node.nodeType;\r\n\r\n\t\t\t\tif (type == 1 && node.getAttribute('data-mce-type') == 'bookmark')\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\tfor (i = children.length - 1; i >= 0; i--)\r\n\t\t\t\t\ttrim(children[i]);\r\n\r\n\t\t\t\tif (type != 9) {\r\n\t\t\t\t\t// Keep non whitespace text nodes\r\n\t\t\t\t\tif (type == 3 && node.nodeValue.length > 0) {\r\n\t\t\t\t\t\t// If parent element isn't a block or there isn't any useful contents for example \"<p>   </p>\"\r\n\t\t\t\t\t\tif (!t.isBlock(node.parentNode) || tinymce.trim(node.nodeValue).length > 0)\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t} else if (type == 1) {\r\n\t\t\t\t\t\t// If the only child is a bookmark then move it up\r\n\t\t\t\t\t\tchildren = node.childNodes;\r\n\t\t\t\t\t\tif (children.length == 1 && children[0] && children[0].nodeType == 1 && children[0].getAttribute('data-mce-type') == 'bookmark')\r\n\t\t\t\t\t\t\tnode.parentNode.insertBefore(children[0], node);\r\n\r\n\t\t\t\t\t\t// Keep non empty elements or img, hr etc\r\n\t\t\t\t\t\tif (children.length || /^(br|hr|input|img)$/i.test(node.nodeName))\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tt.remove(node);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn node;\r\n\t\t\t};\r\n\r\n\t\t\tif (pe && e) {\r\n\t\t\t\t// Get before chunk\r\n\t\t\t\tr.setStart(pe.parentNode, t.nodeIndex(pe));\r\n\t\t\t\tr.setEnd(e.parentNode, t.nodeIndex(e));\r\n\t\t\t\tbef = r.extractContents();\r\n\r\n\t\t\t\t// Get after chunk\r\n\t\t\t\tr = t.createRng();\r\n\t\t\t\tr.setStart(e.parentNode, t.nodeIndex(e) + 1);\r\n\t\t\t\tr.setEnd(pe.parentNode, t.nodeIndex(pe) + 1);\r\n\t\t\t\taft = r.extractContents();\r\n\r\n\t\t\t\t// Insert before chunk\r\n\t\t\t\tpa = pe.parentNode;\r\n\t\t\t\tpa.insertBefore(trim(bef), pe);\r\n\r\n\t\t\t\t// Insert middle chunk\r\n\t\t\t\tif (re)\r\n\t\t\t\t\tpa.replaceChild(re, e);\r\n\t\t\t\telse\r\n\t\t\t\t\tpa.insertBefore(e, pe);\r\n\r\n\t\t\t\t// Insert after chunk\r\n\t\t\t\tpa.insertBefore(trim(aft), pe);\r\n\t\t\t\tt.remove(pe);\r\n\r\n\t\t\t\treturn re || e;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Adds an event handler to the specified object.\r\n\t\t *\r\n\t\t * @method bind\r\n\t\t * @param {Element/Document/Window/Array/String} o Object or element id string to add event handler to or an array of elements/ids/documents.\r\n\t\t * @param {String} n Name of event handler to add for example: click.\r\n\t\t * @param {function} f Function to execute when the event occurs.\r\n\t\t * @param {Object} s Optional scope to execute the function in.\r\n\t\t * @return {function} Function callback handler the same as the one passed in.\r\n\t\t */\r\n\t\tbind : function(target, name, func, scope) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\tif (!t.events)\r\n\t\t\t\tt.events = new tinymce.dom.EventUtils();\r\n\r\n\t\t\treturn t.events.add(target, name, func, scope || this);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Removes the specified event handler by name and function from a element or collection of elements.\r\n\t\t *\r\n\t\t * @method unbind\r\n\t\t * @param {String/Element/Array} o Element ID string or HTML element or an array of elements or ids to remove handler from.\r\n\t\t * @param {String} n Event handler name like for example: \"click\"\r\n\t\t * @param {function} f Function to remove.\r\n\t\t * @return {bool/Array} Bool state if true if the handler was removed or an array with states if multiple elements where passed in.\r\n\t\t */\r\n\t\tunbind : function(target, name, func) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\tif (!t.events)\r\n\t\t\t\tt.events = new tinymce.dom.EventUtils();\r\n\r\n\t\t\treturn t.events.remove(target, name, func);\r\n\t\t},\r\n\r\n\t\t// #ifdef debug\r\n\r\n\t\tdumpRng : function(r) {\r\n\t\t\treturn 'startContainer: ' + r.startContainer.nodeName + ', startOffset: ' + r.startOffset + ', endContainer: ' + r.endContainer.nodeName + ', endOffset: ' + r.endOffset;\r\n\t\t},\r\n\r\n\t\t// #endif\r\n\r\n\t\t_findSib : function(node, selector, name) {\r\n\t\t\tvar t = this, f = selector;\r\n\r\n\t\t\tif (node) {\r\n\t\t\t\t// If expression make a function of it using is\r\n\t\t\t\tif (is(f, 'string')) {\r\n\t\t\t\t\tf = function(node) {\r\n\t\t\t\t\t\treturn t.is(node, selector);\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Loop all siblings\r\n\t\t\t\tfor (node = node[name]; node; node = node[name]) {\r\n\t\t\t\t\tif (f(node))\r\n\t\t\t\t\t\treturn node;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn null;\r\n\t\t},\r\n\r\n\t\t_isRes : function(c) {\r\n\t\t\t// Is live resizble element\r\n\t\t\treturn /^(top|left|bottom|right|width|height)/i.test(c) || /;\\s*(top|left|bottom|right|width|height)/i.test(c);\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\twalk : function(n, f, s) {\r\n\t\t\tvar d = this.doc, w;\r\n\r\n\t\t\tif (d.createTreeWalker) {\r\n\t\t\t\tw = d.createTreeWalker(n, NodeFilter.SHOW_TEXT, null, false);\r\n\r\n\t\t\t\twhile ((n = w.nextNode()) != null)\r\n\t\t\t\t\tf.call(s || this, n);\r\n\t\t\t} else\r\n\t\t\t\ttinymce.walk(n, f, 'childNodes', s);\r\n\t\t}\r\n\t\t*/\r\n\r\n\t\t/*\r\n\t\ttoRGB : function(s) {\r\n\t\t\tvar c = /^\\s*?#([0-9A-F]{2})([0-9A-F]{1,2})([0-9A-F]{2})?\\s*?$/.exec(s);\r\n\r\n\t\t\tif (c) {\r\n\t\t\t\t// #FFF -> #FFFFFF\r\n\t\t\t\tif (!is(c[3]))\r\n\t\t\t\t\tc[3] = c[2] = c[1];\r\n\r\n\t\t\t\treturn \"rgb(\" + parseInt(c[1], 16) + \",\" + parseInt(c[2], 16) + \",\" + parseInt(c[3], 16) + \")\";\r\n\t\t\t}\r\n\r\n\t\t\treturn s;\r\n\t\t}\r\n\t\t*/\r\n\t});\r\n\r\n\t/**\r\n\t * Instance of DOMUtils for the current document.\r\n\t *\r\n\t * @property DOM\r\n\t * @member tinymce\r\n\t * @type tinymce.dom.DOMUtils\r\n\t * @example\r\n\t * // Example of how to add a class to some element by id\r\n\t * tinymce.DOM.addClass('someid', 'someclass');\r\n\t */\r\n\ttinymce.DOM = new tinymce.dom.DOMUtils(document, {process_html : 0});\r\n})(tinymce);\r\n","Magento_Tinymce3/tiny_mce/classes/dom/Element.js":"/**\r\n * Element.js\r\n *\r\n * Copyright 2009, Moxiecode Systems AB\r\n * Released under LGPL License.\r\n *\r\n * License: http://tinymce.moxiecode.com/license\r\n * Contributing: http://tinymce.moxiecode.com/contributing\r\n */\r\n\r\n(function(tinymce) {\r\n\t/**\r\n\t * Element class, this enables element blocking in IE. Element blocking is a method to block out select blockes that\r\n\t * gets visible though DIVs on IE 6 it uses a iframe for this blocking. This class also shortens the length of some DOM API calls\r\n\t * since it's bound to an element.\r\n\t *\r\n\t * @class tinymce.dom.Element\r\n\t * @example\r\n\t * // Creates an basic element for an existing element\r\n\t * var elm = new tinymce.dom.Element('someid');\r\n\t * \r\n\t * elm.setStyle('background-color', 'red');\r\n\t * elm.moveTo(10, 10);\r\n\t */\r\n\r\n\t/**\r\n\t * Constructs a new Element instance. Consult the Wiki for more details on this class.\r\n\t *\r\n\t * @constructor\r\n\t * @method Element\r\n\t * @param {String} id Element ID to bind/execute methods on.\r\n\t * @param {Object} settings Optional settings name/value collection.\r\n\t */\r\n\ttinymce.dom.Element = function(id, settings) {\r\n\t\tvar t = this, dom, el;\r\n\r\n\t\tt.settings = settings = settings || {};\r\n\t\tt.id = id;\r\n\t\tt.dom = dom = settings.dom || tinymce.DOM;\r\n\r\n\t\t// Only IE leaks DOM references, this is a lot faster\r\n\t\tif (!tinymce.isIE)\r\n\t\t\tel = dom.get(t.id);\r\n\r\n\t\ttinymce.each(\r\n\t\t\t\t('getPos,getRect,getParent,add,setStyle,getStyle,setStyles,' + \r\n\t\t\t\t'setAttrib,setAttribs,getAttrib,addClass,removeClass,' + \r\n\t\t\t\t'hasClass,getOuterHTML,setOuterHTML,remove,show,hide,' + \r\n\t\t\t\t'isHidden,setHTML,get').split(/,/)\r\n\t\t\t, function(k) {\r\n\t\t\t\tt[k] = function() {\r\n\t\t\t\t\tvar a = [id], i;\r\n\r\n\t\t\t\t\tfor (i = 0; i < arguments.length; i++)\r\n\t\t\t\t\t\ta.push(arguments[i]);\r\n\r\n\t\t\t\t\ta = dom[k].apply(dom, a);\r\n\t\t\t\t\tt.update(k);\r\n\r\n\t\t\t\t\treturn a;\r\n\t\t\t\t};\r\n\t\t});\r\n\r\n\t\ttinymce.extend(t, {\r\n\t\t\t/**\r\n\t\t\t * Adds a event handler to the element.\r\n\t\t\t *\r\n\t\t\t * @method on\r\n\t\t\t * @param {String} n Event name like for example \"click\".\r\n\t\t\t * @param {function} f Function to execute on the specified event.\r\n\t\t\t * @param {Object} s Optional scope to execute function on.\r\n\t\t\t * @return {function} Event handler function the same as the input function.\r\n\t\t\t */\r\n\t\t\ton : function(n, f, s) {\r\n\t\t\t\treturn tinymce.dom.Event.add(t.id, n, f, s);\r\n\t\t\t},\r\n\r\n\t\t\t/**\r\n\t\t\t * Returns the absolute X, Y cordinate of the element.\r\n\t\t\t *\r\n\t\t\t * @method getXY\r\n\t\t\t * @return {Object} Objext with x, y cordinate fields.\r\n\t\t\t */\r\n\t\t\tgetXY : function() {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tx : parseInt(t.getStyle('left')),\r\n\t\t\t\t\ty : parseInt(t.getStyle('top'))\r\n\t\t\t\t};\r\n\t\t\t},\r\n\r\n\t\t\t/**\r\n\t\t\t * Returns the size of the element by a object with w and h fields.\r\n\t\t\t *\r\n\t\t\t * @method getSize\r\n\t\t\t * @return {Object} Object with element size with a w and h field.\r\n\t\t\t */\r\n\t\t\tgetSize : function() {\r\n\t\t\t\tvar n = dom.get(t.id);\r\n\r\n\t\t\t\treturn {\r\n\t\t\t\t\tw : parseInt(t.getStyle('width') || n.clientWidth),\r\n\t\t\t\t\th : parseInt(t.getStyle('height') || n.clientHeight)\r\n\t\t\t\t};\r\n\t\t\t},\r\n\r\n\t\t\t/**\r\n\t\t\t * Moves the element to a specific absolute position.\r\n\t\t\t *\r\n\t\t\t * @method moveTo\r\n\t\t\t * @param {Number} x X cordinate of element position.\r\n\t\t\t * @param {Number} y Y cordinate of element position.\r\n\t\t\t */\r\n\t\t\tmoveTo : function(x, y) {\r\n\t\t\t\tt.setStyles({left : x, top : y});\r\n\t\t\t},\r\n\r\n\t\t\t/**\r\n\t\t\t * Moves the element relative to the current position.\r\n\t\t\t *\r\n\t\t\t * @method moveBy\r\n\t\t\t * @param {Number} x Relative X cordinate of element position.\r\n\t\t\t * @param {Number} y Relative Y cordinate of element position.\r\n\t\t\t */\r\n\t\t\tmoveBy : function(x, y) {\r\n\t\t\t\tvar p = t.getXY();\r\n\r\n\t\t\t\tt.moveTo(p.x + x, p.y + y);\r\n\t\t\t},\r\n\r\n\t\t\t/**\r\n\t\t\t * Resizes the element to a specific size.\r\n\t\t\t *\r\n\t\t\t * @method resizeTo\r\n\t\t\t * @param {Number} w New width of element.\r\n\t\t\t * @param {Numner} h New height of element.\r\n\t\t\t */\r\n\t\t\tresizeTo : function(w, h) {\r\n\t\t\t\tt.setStyles({width : w, height : h});\r\n\t\t\t},\r\n\r\n\t\t\t/**\r\n\t\t\t * Resizes the element relative to the current sizeto a specific size.\r\n\t\t\t *\r\n\t\t\t * @method resizeBy\r\n\t\t\t * @param {Number} w Relative width of element.\r\n\t\t\t * @param {Numner} h Relative height of element.\r\n\t\t\t */\r\n\t\t\tresizeBy : function(w, h) {\r\n\t\t\t\tvar s = t.getSize();\r\n\r\n\t\t\t\tt.resizeTo(s.w + w, s.h + h);\r\n\t\t\t},\r\n\r\n\t\t\t/**\r\n\t\t\t * Updates the element blocker in IE6 based on the style information of the element.\r\n\t\t\t *\r\n\t\t\t * @method update\r\n\t\t\t * @param {String} k Optional function key. Used internally.\r\n\t\t\t */\r\n\t\t\tupdate : function(k) {\r\n\t\t\t\tvar b;\r\n\r\n\t\t\t\tif (tinymce.isIE6 && settings.blocker) {\r\n\t\t\t\t\tk = k || '';\r\n\r\n\t\t\t\t\t// Ignore getters\r\n\t\t\t\t\tif (k.indexOf('get') === 0 || k.indexOf('has') === 0 || k.indexOf('is') === 0)\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t// Remove blocker on remove\r\n\t\t\t\t\tif (k == 'remove') {\r\n\t\t\t\t\t\tdom.remove(t.blocker);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (!t.blocker) {\r\n\t\t\t\t\t\tt.blocker = dom.uniqueId();\r\n\t\t\t\t\t\tb = dom.add(settings.container || dom.getRoot(), 'iframe', {id : t.blocker, style : 'position:absolute;', frameBorder : 0, src : 'javascript:\"\"'});\r\n\t\t\t\t\t\tdom.setStyle(b, 'opacity', 0);\r\n\t\t\t\t\t} else\r\n\t\t\t\t\t\tb = dom.get(t.blocker);\r\n\r\n\t\t\t\t\tdom.setStyles(b, {\r\n\t\t\t\t\t\tleft : t.getStyle('left', 1),\r\n\t\t\t\t\t\ttop : t.getStyle('top', 1),\r\n\t\t\t\t\t\twidth : t.getStyle('width', 1),\r\n\t\t\t\t\t\theight : t.getStyle('height', 1),\r\n\t\t\t\t\t\tdisplay : t.getStyle('display', 1),\r\n\t\t\t\t\t\tzIndex : parseInt(t.getStyle('zIndex', 1) || 0) - 1\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t};\r\n})(tinymce);\r\n","Magento_Tinymce3/tiny_mce/classes/dom/EventUtils.js":"/**\r\n * EventUtils.js\r\n *\r\n * Copyright 2009, Moxiecode Systems AB\r\n * Released under LGPL License.\r\n *\r\n * License: http://tinymce.moxiecode.com/license\r\n * Contributing: http://tinymce.moxiecode.com/contributing\r\n */\r\n\r\n(function(tinymce) {\r\n\t// Shorten names\r\n\tvar each = tinymce.each, DOM = tinymce.DOM, isIE = tinymce.isIE, isWebKit = tinymce.isWebKit, Event;\r\n\r\n\t/**\r\n\t * This class handles DOM events in a cross platform fasion it also keeps track of element\r\n\t * and handler references to be able to clean elements to reduce IE memory leaks.\r\n\t *\r\n\t * @class tinymce.dom.EventUtils\r\n\t */\r\n\ttinymce.create('tinymce.dom.EventUtils', {\r\n\t\t/**\r\n\t\t * Constructs a new EventUtils instance.\r\n\t\t *\r\n\t\t * @constructor\r\n\t\t * @method EventUtils\r\n\t\t */\r\n\t\tEventUtils : function() {\r\n\t\t\tthis.inits = [];\r\n\t\t\tthis.events = [];\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Adds an event handler to the specified object.\r\n\t\t *\r\n\t\t * @method add\r\n\t\t * @param {Element/Document/Window/Array/String} o Object or element id string to add event handler to or an array of elements/ids/documents.\r\n\t\t * @param {String/Array} n Name of event handler to add for example: click.\r\n\t\t * @param {function} f Function to execute when the event occurs.\r\n\t\t * @param {Object} s Optional scope to execute the function in.\r\n\t\t * @return {function} Function callback handler the same as the one passed in.\r\n\t\t * @example\r\n\t\t * // Adds a click handler to the current document\r\n\t\t * tinymce.dom.Event.add(document, 'click', function(e) {\r\n\t\t *    console.debug(e.target);\r\n\t\t * });\r\n\t\t */\r\n\t\tadd : function(o, n, f, s) {\r\n\t\t\tvar cb, t = this, el = t.events, r;\r\n\r\n\t\t\tif (n instanceof Array) {\r\n\t\t\t\tr = [];\r\n\r\n\t\t\t\teach(n, function(n) {\r\n\t\t\t\t\tr.push(t.add(o, n, f, s));\r\n\t\t\t\t});\r\n\r\n\t\t\t\treturn r;\r\n\t\t\t}\r\n\r\n\t\t\t// Handle array\r\n\t\t\tif (o && o.hasOwnProperty && o instanceof Array) {\r\n\t\t\t\tr = [];\r\n\r\n\t\t\t\teach(o, function(o) {\r\n\t\t\t\t\to = DOM.get(o);\r\n\t\t\t\t\tr.push(t.add(o, n, f, s));\r\n\t\t\t\t});\r\n\r\n\t\t\t\treturn r;\r\n\t\t\t}\r\n\r\n\t\t\to = DOM.get(o);\r\n\r\n\t\t\tif (!o)\r\n\t\t\t\treturn;\r\n\r\n\t\t\t// Setup event callback\r\n\t\t\tcb = function(e) {\r\n\t\t\t\t// Is all events disabled\r\n\t\t\t\tif (t.disabled)\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\te = e || window.event;\r\n\r\n\t\t\t\t// Patch in target, preventDefault and stopPropagation in IE it's W3C valid\r\n\t\t\t\tif (e && isIE) {\r\n\t\t\t\t\tif (!e.target)\r\n\t\t\t\t\t\te.target = e.srcElement;\r\n\r\n\t\t\t\t\t// Patch in preventDefault, stopPropagation methods for W3C compatibility\r\n\t\t\t\t\ttinymce.extend(e, t._stoppers);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!s)\r\n\t\t\t\t\treturn f(e);\r\n\r\n\t\t\t\treturn f.call(s, e);\r\n\t\t\t};\r\n\r\n\t\t\tif (n == 'unload') {\r\n\t\t\t\ttinymce.unloads.unshift({func : cb});\r\n\t\t\t\treturn cb;\r\n\t\t\t}\r\n\r\n\t\t\tif (n == 'init') {\r\n\t\t\t\tif (t.domLoaded)\r\n\t\t\t\t\tcb();\r\n\t\t\t\telse\r\n\t\t\t\t\tt.inits.push(cb);\r\n\r\n\t\t\t\treturn cb;\r\n\t\t\t}\r\n\r\n\t\t\t// Store away listener reference\r\n\t\t\tel.push({\r\n\t\t\t\tobj : o,\r\n\t\t\t\tname : n,\r\n\t\t\t\tfunc : f,\r\n\t\t\t\tcfunc : cb,\r\n\t\t\t\tscope : s\r\n\t\t\t});\r\n\r\n\t\t\tt._add(o, n, cb);\r\n\r\n\t\t\treturn f;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Removes the specified event handler by name and function from a element or collection of elements.\r\n\t\t *\r\n\t\t * @method remove\r\n\t\t * @param {String/Element/Array} o Element ID string or HTML element or an array of elements or ids to remove handler from.\r\n\t\t * @param {String} n Event handler name like for example: \"click\"\r\n\t\t * @param {function} f Function to remove.\r\n\t\t * @return {bool/Array} Bool state if true if the handler was removed or an array with states if multiple elements where passed in.\r\n\t\t * @example\r\n\t\t * // Adds a click handler to the current document\r\n\t\t * var func = tinymce.dom.Event.add(document, 'click', function(e) {\r\n\t\t *    console.debug(e.target);\r\n\t\t * });\r\n\t\t * \r\n\t\t * // Removes the click handler from the document\r\n\t\t * tinymce.dom.Event.remove(document, 'click', func);\r\n\t\t */\r\n\t\tremove : function(o, n, f) {\r\n\t\t\tvar t = this, a = t.events, s = false, r;\r\n\r\n\t\t\t// Handle array\r\n\t\t\tif (o && o.hasOwnProperty && o instanceof Array) {\r\n\t\t\t\tr = [];\r\n\r\n\t\t\t\teach(o, function(o) {\r\n\t\t\t\t\to = DOM.get(o);\r\n\t\t\t\t\tr.push(t.remove(o, n, f));\r\n\t\t\t\t});\r\n\r\n\t\t\t\treturn r;\r\n\t\t\t}\r\n\r\n\t\t\to = DOM.get(o);\r\n\r\n\t\t\teach(a, function(e, i) {\r\n\t\t\t\tif (e.obj == o && e.name == n && (!f || (e.func == f || e.cfunc == f))) {\r\n\t\t\t\t\ta.splice(i, 1);\r\n\t\t\t\t\tt._remove(o, n, e.cfunc);\r\n\t\t\t\t\ts = true;\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\treturn s;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Clears all events of a specific object.\r\n\t\t *\r\n\t\t * @method clear\r\n\t\t * @param {Object} o DOM element or object to remove all events from.\r\n\t\t * @example\r\n\t\t * // Cancels all mousedown events in the active editor\r\n\t\t * tinyMCE.activeEditor.onMouseDown.add(function(ed, e) {\r\n\t\t *    return tinymce.dom.Event.cancel(e);\r\n\t\t * });\r\n\t\t */\r\n\t\tclear : function(o) {\r\n\t\t\tvar t = this, a = t.events, i, e;\r\n\r\n\t\t\tif (o) {\r\n\t\t\t\to = DOM.get(o);\r\n\r\n\t\t\t\tfor (i = a.length - 1; i >= 0; i--) {\r\n\t\t\t\t\te = a[i];\r\n\r\n\t\t\t\t\tif (e.obj === o) {\r\n\t\t\t\t\t\tt._remove(e.obj, e.name, e.cfunc);\r\n\t\t\t\t\t\te.obj = e.cfunc = null;\r\n\t\t\t\t\t\ta.splice(i, 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Cancels an event for both bubbeling and the default browser behavior.\r\n\t\t *\r\n\t\t * @method cancel\r\n\t\t * @param {Event} e Event object to cancel.\r\n\t\t * @return {Boolean} Always false.\r\n\t\t */\r\n\t\tcancel : function(e) {\r\n\t\t\tif (!e)\r\n\t\t\t\treturn false;\r\n\r\n\t\t\tthis.stop(e);\r\n\r\n\t\t\treturn this.prevent(e);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Stops propogation/bubbeling of an event.\r\n\t\t *\r\n\t\t * @method stop\r\n\t\t * @param {Event} e Event to cancel bubbeling on.\r\n\t\t * @return {Boolean} Always false.\r\n\t\t */\r\n\t\tstop : function(e) {\r\n\t\t\tif (e.stopPropagation)\r\n\t\t\t\te.stopPropagation();\r\n\t\t\telse\r\n\t\t\t\te.cancelBubble = true;\r\n\r\n\t\t\treturn false;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Prevent default browser behvaior of an event.\r\n\t\t *\r\n\t\t * @method prevent\r\n\t\t * @param {Event} e Event to prevent default browser behvaior of an event.\r\n\t\t * @return {Boolean} Always false.\r\n\t\t */\r\n\t\tprevent : function(e) {\r\n\t\t\tif (e.preventDefault)\r\n\t\t\t\te.preventDefault();\r\n\t\t\telse\r\n\t\t\t\te.returnValue = false;\r\n\r\n\t\t\treturn false;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Destroys the instance.\r\n\t\t *\r\n\t\t * @method destroy\r\n\t\t */\r\n\t\tdestroy : function() {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\teach(t.events, function(e, i) {\r\n\t\t\t\tt._remove(e.obj, e.name, e.cfunc);\r\n\t\t\t\te.obj = e.cfunc = null;\r\n\t\t\t});\r\n\r\n\t\t\tt.events = [];\r\n\t\t\tt = null;\r\n\t\t},\r\n\r\n\t\t_add : function(o, n, f) {\r\n\t\t\tif (o.attachEvent)\r\n\t\t\t\to.attachEvent('on' + n, f);\r\n\t\t\telse if (o.addEventListener)\r\n\t\t\t\to.addEventListener(n, f, false);\r\n\t\t\telse\r\n\t\t\t\to['on' + n] = f;\r\n\t\t},\r\n\r\n\t\t_remove : function(o, n, f) {\r\n\t\t\tif (o) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tif (o.detachEvent)\r\n\t\t\t\t\t\to.detachEvent('on' + n, f);\r\n\t\t\t\t\telse if (o.removeEventListener)\r\n\t\t\t\t\t\to.removeEventListener(n, f, false);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\to['on' + n] = null;\r\n\t\t\t\t} catch (ex) {\r\n\t\t\t\t\t// Might fail with permission denined on IE so we just ignore that\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_pageInit : function(win) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\t// Keep it from running more than once\r\n\t\t\tif (t.domLoaded)\r\n\t\t\t\treturn;\r\n\r\n\t\t\tt.domLoaded = true;\r\n\r\n\t\t\teach(t.inits, function(c) {\r\n\t\t\t\tc();\r\n\t\t\t});\r\n\r\n\t\t\tt.inits = [];\r\n\t\t},\r\n\r\n\t\t_wait : function(win) {\r\n\t\t\tvar t = this, doc = win.document;\r\n\r\n\t\t\t// No need since the document is already loaded\r\n\t\t\tif (win.tinyMCE_GZ && tinyMCE_GZ.loaded) {\r\n\t\t\t\tt.domLoaded = 1;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// Use IE method\r\n\t\t\tif (doc.attachEvent) {\r\n\t\t\t\tdoc.attachEvent(\"onreadystatechange\", function() {\r\n\t\t\t\t\tif (doc.readyState === \"complete\") {\r\n\t\t\t\t\t\tdoc.detachEvent(\"onreadystatechange\", arguments.callee);\r\n\t\t\t\t\t\tt._pageInit(win);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\tif (doc.documentElement.doScroll && win == win.top) {\r\n\t\t\t\t\t(function() {\r\n\t\t\t\t\t\tif (t.domLoaded)\r\n\t\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t// If IE is used, use the trick by Diego Perini licensed under MIT by request to the author.\r\n\t\t\t\t\t\t\t// http://javascript.nwbox.com/IEContentLoaded/\r\n\t\t\t\t\t\t\tdoc.documentElement.doScroll(\"left\");\r\n\t\t\t\t\t\t} catch (ex) {\r\n\t\t\t\t\t\t\tsetTimeout(arguments.callee, 0);\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tt._pageInit(win);\r\n\t\t\t\t\t})();\r\n\t\t\t\t}\r\n\t\t\t} else if (doc.addEventListener) {\r\n\t\t\t\tt._add(win, 'DOMContentLoaded', function() {\r\n\t\t\t\t\tt._pageInit(win);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tt._add(win, 'load', function() {\r\n\t\t\t\tt._pageInit(win);\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t_stoppers : {\r\n\t\t\tpreventDefault : function() {\r\n\t\t\t\tthis.returnValue = false;\r\n\t\t\t},\r\n\r\n\t\t\tstopPropagation : function() {\r\n\t\t\t\tthis.cancelBubble = true;\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\r\n\t/**\r\n\t * Instance of EventUtils for the current document.\r\n\t *\r\n\t * @property Event\r\n\t * @member tinymce.dom\r\n\t * @type tinymce.dom.EventUtils\r\n\t */\r\n\tEvent = tinymce.dom.Event = new tinymce.dom.EventUtils();\r\n\r\n\t// Dispatch DOM content loaded event for IE and Safari\r\n\tEvent._wait(window);\r\n\r\n\ttinymce.addUnload(function() {\r\n\t\tEvent.destroy();\r\n\t});\r\n})(tinymce);\r\n","Magento_Tinymce3/tiny_mce/classes/dom/Range.js":"/**\r\n * Range.js\r\n *\r\n * Copyright 2009, Moxiecode Systems AB\r\n * Released under LGPL License.\r\n *\r\n * License: http://tinymce.moxiecode.com/license\r\n * Contributing: http://tinymce.moxiecode.com/contributing\r\n */\r\n\r\n(function(ns) {\r\n\t// Range constructor\r\n\tfunction Range(dom) {\r\n\t\tvar t = this,\r\n\t\t\tdoc = dom.doc,\r\n\t\t\tEXTRACT = 0,\r\n\t\t\tCLONE = 1,\r\n\t\t\tDELETE = 2,\r\n\t\t\tTRUE = true,\r\n\t\t\tFALSE = false,\r\n\t\t\tSTART_OFFSET = 'startOffset',\r\n\t\t\tSTART_CONTAINER = 'startContainer',\r\n\t\t\tEND_CONTAINER = 'endContainer',\r\n\t\t\tEND_OFFSET = 'endOffset',\r\n\t\t\textend = tinymce.extend,\r\n\t\t\tnodeIndex = dom.nodeIndex;\r\n\r\n\t\textend(t, {\r\n\t\t\t// Inital states\r\n\t\t\tstartContainer : doc,\r\n\t\t\tstartOffset : 0,\r\n\t\t\tendContainer : doc,\r\n\t\t\tendOffset : 0,\r\n\t\t\tcollapsed : TRUE,\r\n\t\t\tcommonAncestorContainer : doc,\r\n\r\n\t\t\t// Range constants\r\n\t\t\tSTART_TO_START : 0,\r\n\t\t\tSTART_TO_END : 1,\r\n\t\t\tEND_TO_END : 2,\r\n\t\t\tEND_TO_START : 3,\r\n\r\n\t\t\t// Public methods\r\n\t\t\tsetStart : setStart,\r\n\t\t\tsetEnd : setEnd,\r\n\t\t\tsetStartBefore : setStartBefore,\r\n\t\t\tsetStartAfter : setStartAfter,\r\n\t\t\tsetEndBefore : setEndBefore,\r\n\t\t\tsetEndAfter : setEndAfter,\r\n\t\t\tcollapse : collapse,\r\n\t\t\tselectNode : selectNode,\r\n\t\t\tselectNodeContents : selectNodeContents,\r\n\t\t\tcompareBoundaryPoints : compareBoundaryPoints,\r\n\t\t\tdeleteContents : deleteContents,\r\n\t\t\textractContents : extractContents,\r\n\t\t\tcloneContents : cloneContents,\r\n\t\t\tinsertNode : insertNode,\r\n\t\t\tsurroundContents : surroundContents,\r\n\t\t\tcloneRange : cloneRange\r\n\t\t});\r\n\r\n\t\tfunction setStart(n, o) {\r\n\t\t\t_setEndPoint(TRUE, n, o);\r\n\t\t};\r\n\r\n\t\tfunction setEnd(n, o) {\r\n\t\t\t_setEndPoint(FALSE, n, o);\r\n\t\t};\r\n\r\n\t\tfunction setStartBefore(n) {\r\n\t\t\tsetStart(n.parentNode, nodeIndex(n));\r\n\t\t};\r\n\r\n\t\tfunction setStartAfter(n) {\r\n\t\t\tsetStart(n.parentNode, nodeIndex(n) + 1);\r\n\t\t};\r\n\r\n\t\tfunction setEndBefore(n) {\r\n\t\t\tsetEnd(n.parentNode, nodeIndex(n));\r\n\t\t};\r\n\r\n\t\tfunction setEndAfter(n) {\r\n\t\t\tsetEnd(n.parentNode, nodeIndex(n) + 1);\r\n\t\t};\r\n\r\n\t\tfunction collapse(ts) {\r\n\t\t\tif (ts) {\r\n\t\t\t\tt[END_CONTAINER] = t[START_CONTAINER];\r\n\t\t\t\tt[END_OFFSET] = t[START_OFFSET];\r\n\t\t\t} else {\r\n\t\t\t\tt[START_CONTAINER] = t[END_CONTAINER];\r\n\t\t\t\tt[START_OFFSET] = t[END_OFFSET];\r\n\t\t\t}\r\n\r\n\t\t\tt.collapsed = TRUE;\r\n\t\t};\r\n\r\n\t\tfunction selectNode(n) {\r\n\t\t\tsetStartBefore(n);\r\n\t\t\tsetEndAfter(n);\r\n\t\t};\r\n\r\n\t\tfunction selectNodeContents(n) {\r\n\t\t\tsetStart(n, 0);\r\n\t\t\tsetEnd(n, n.nodeType === 1 ? n.childNodes.length : n.nodeValue.length);\r\n\t\t};\r\n\r\n\t\tfunction compareBoundaryPoints(h, r) {\r\n\t\t\tvar sc = t[START_CONTAINER], so = t[START_OFFSET], ec = t[END_CONTAINER], eo = t[END_OFFSET],\r\n\t\t\trsc = r.startContainer, rso = r.startOffset, rec = r.endContainer, reo = r.endOffset;\r\n\r\n\t\t\t// Check START_TO_START\r\n\t\t\tif (h === 0)\r\n\t\t\t\treturn _compareBoundaryPoints(sc, so, rsc, rso);\r\n\t\r\n\t\t\t// Check START_TO_END\r\n\t\t\tif (h === 1)\r\n\t\t\t\treturn _compareBoundaryPoints(ec, eo, rsc, rso);\r\n\t\r\n\t\t\t// Check END_TO_END\r\n\t\t\tif (h === 2)\r\n\t\t\t\treturn _compareBoundaryPoints(ec, eo, rec, reo);\r\n\t\r\n\t\t\t// Check END_TO_START\r\n\t\t\tif (h === 3) \r\n\t\t\t\treturn _compareBoundaryPoints(sc, so, rec, reo);\r\n\t\t};\r\n\r\n\t\tfunction deleteContents() {\r\n\t\t\t_traverse(DELETE);\r\n\t\t};\r\n\r\n\t\tfunction extractContents() {\r\n\t\t\treturn _traverse(EXTRACT);\r\n\t\t};\r\n\r\n\t\tfunction cloneContents() {\r\n\t\t\treturn _traverse(CLONE);\r\n\t\t};\r\n\r\n\t\tfunction insertNode(n) {\r\n\t\t\tvar startContainer = this[START_CONTAINER],\r\n\t\t\t\tstartOffset = this[START_OFFSET], nn, o;\r\n\r\n\t\t\t// Node is TEXT_NODE or CDATA\r\n\t\t\tif ((startContainer.nodeType === 3 || startContainer.nodeType === 4) && startContainer.nodeValue) {\r\n\t\t\t\tif (!startOffset) {\r\n\t\t\t\t\t// At the start of text\r\n\t\t\t\t\tstartContainer.parentNode.insertBefore(n, startContainer);\r\n\t\t\t\t} else if (startOffset >= startContainer.nodeValue.length) {\r\n\t\t\t\t\t// At the end of text\r\n\t\t\t\t\tdom.insertAfter(n, startContainer);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Middle, need to split\r\n\t\t\t\t\tnn = startContainer.splitText(startOffset);\r\n\t\t\t\t\tstartContainer.parentNode.insertBefore(n, nn);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t// Insert element node\r\n\t\t\t\tif (startContainer.childNodes.length > 0)\r\n\t\t\t\t\to = startContainer.childNodes[startOffset];\r\n\r\n\t\t\t\tif (o)\r\n\t\t\t\t\tstartContainer.insertBefore(n, o);\r\n\t\t\t\telse\r\n\t\t\t\t\tstartContainer.appendChild(n);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tfunction surroundContents(n) {\r\n\t\t\tvar f = t.extractContents();\r\n\r\n\t\t\tt.insertNode(n);\r\n\t\t\tn.appendChild(f);\r\n\t\t\tt.selectNode(n);\r\n\t\t};\r\n\r\n\t\tfunction cloneRange() {\r\n\t\t\treturn extend(new Range(dom), {\r\n\t\t\t\tstartContainer : t[START_CONTAINER],\r\n\t\t\t\tstartOffset : t[START_OFFSET],\r\n\t\t\t\tendContainer : t[END_CONTAINER],\r\n\t\t\t\tendOffset : t[END_OFFSET],\r\n\t\t\t\tcollapsed : t.collapsed,\r\n\t\t\t\tcommonAncestorContainer : t.commonAncestorContainer\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t\t// Private methods\r\n\r\n\t\tfunction _getSelectedNode(container, offset) {\r\n\t\t\tvar child;\r\n\r\n\t\t\tif (container.nodeType == 3 /* TEXT_NODE */)\r\n\t\t\t\treturn container;\r\n\r\n\t\t\tif (offset < 0)\r\n\t\t\t\treturn container;\r\n\r\n\t\t\tchild = container.firstChild;\r\n\t\t\twhile (child && offset > 0) {\r\n\t\t\t\t--offset;\r\n\t\t\t\tchild = child.nextSibling;\r\n\t\t\t}\r\n\r\n\t\t\tif (child)\r\n\t\t\t\treturn child;\r\n\r\n\t\t\treturn container;\r\n\t\t};\r\n\r\n\t\tfunction _isCollapsed() {\r\n\t\t\treturn (t[START_CONTAINER] == t[END_CONTAINER] && t[START_OFFSET] == t[END_OFFSET]);\r\n\t\t};\r\n\r\n\t\tfunction _compareBoundaryPoints(containerA, offsetA, containerB, offsetB) {\r\n\t\t\tvar c, offsetC, n, cmnRoot, childA, childB;\r\n\t\t\t\r\n\t\t\t// In the first case the boundary-points have the same container. A is before B\r\n\t\t\t// if its offset is less than the offset of B, A is equal to B if its offset is\r\n\t\t\t// equal to the offset of B, and A is after B if its offset is greater than the\r\n\t\t\t// offset of B.\r\n\t\t\tif (containerA == containerB) {\r\n\t\t\t\tif (offsetA == offsetB)\r\n\t\t\t\t\treturn 0; // equal\r\n\r\n\t\t\t\tif (offsetA < offsetB)\r\n\t\t\t\t\treturn -1; // before\r\n\r\n\t\t\t\treturn 1; // after\r\n\t\t\t}\r\n\r\n\t\t\t// In the second case a child node C of the container of A is an ancestor\r\n\t\t\t// container of B. In this case, A is before B if the offset of A is less than or\r\n\t\t\t// equal to the index of the child node C and A is after B otherwise.\r\n\t\t\tc = containerB;\r\n\t\t\twhile (c && c.parentNode != containerA)\r\n\t\t\t\tc = c.parentNode;\r\n\r\n\t\t\tif (c) {\r\n\t\t\t\toffsetC = 0;\r\n\t\t\t\tn = containerA.firstChild;\r\n\r\n\t\t\t\twhile (n != c && offsetC < offsetA) {\r\n\t\t\t\t\toffsetC++;\r\n\t\t\t\t\tn = n.nextSibling;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (offsetA <= offsetC)\r\n\t\t\t\t\treturn -1; // before\r\n\r\n\t\t\t\treturn 1; // after\r\n\t\t\t}\r\n\r\n\t\t\t// In the third case a child node C of the container of B is an ancestor container\r\n\t\t\t// of A. In this case, A is before B if the index of the child node C is less than\r\n\t\t\t// the offset of B and A is after B otherwise.\r\n\t\t\tc = containerA;\r\n\t\t\twhile (c && c.parentNode != containerB) {\r\n\t\t\t\tc = c.parentNode;\r\n\t\t\t}\r\n\r\n\t\t\tif (c) {\r\n\t\t\t\toffsetC = 0;\r\n\t\t\t\tn = containerB.firstChild;\r\n\r\n\t\t\t\twhile (n != c && offsetC < offsetB) {\r\n\t\t\t\t\toffsetC++;\r\n\t\t\t\t\tn = n.nextSibling;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (offsetC < offsetB)\r\n\t\t\t\t\treturn -1; // before\r\n\r\n\t\t\t\treturn 1; // after\r\n\t\t\t}\r\n\r\n\t\t\t// In the fourth case, none of three other cases hold: the containers of A and B\r\n\t\t\t// are siblings or descendants of sibling nodes. In this case, A is before B if\r\n\t\t\t// the container of A is before the container of B in a pre-order traversal of the\r\n\t\t\t// Ranges' context tree and A is after B otherwise.\r\n\t\t\tcmnRoot = dom.findCommonAncestor(containerA, containerB);\r\n\t\t\tchildA = containerA;\r\n\r\n\t\t\twhile (childA && childA.parentNode != cmnRoot)\r\n\t\t\t\tchildA = childA.parentNode;\r\n\r\n\t\t\tif (!childA)\r\n\t\t\t\tchildA = cmnRoot;\r\n\r\n\t\t\tchildB = containerB;\r\n\t\t\twhile (childB && childB.parentNode != cmnRoot)\r\n\t\t\t\tchildB = childB.parentNode;\r\n\r\n\t\t\tif (!childB)\r\n\t\t\t\tchildB = cmnRoot;\r\n\r\n\t\t\tif (childA == childB)\r\n\t\t\t\treturn 0; // equal\r\n\r\n\t\t\tn = cmnRoot.firstChild;\r\n\t\t\twhile (n) {\r\n\t\t\t\tif (n == childA)\r\n\t\t\t\t\treturn -1; // before\r\n\r\n\t\t\t\tif (n == childB)\r\n\t\t\t\t\treturn 1; // after\r\n\r\n\t\t\t\tn = n.nextSibling;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tfunction _setEndPoint(st, n, o) {\r\n\t\t\tvar ec, sc;\r\n\r\n\t\t\tif (st) {\r\n\t\t\t\tt[START_CONTAINER] = n;\r\n\t\t\t\tt[START_OFFSET] = o;\r\n\t\t\t} else {\r\n\t\t\t\tt[END_CONTAINER] = n;\r\n\t\t\t\tt[END_OFFSET] = o;\r\n\t\t\t}\r\n\r\n\t\t\t// If one boundary-point of a Range is set to have a root container\r\n\t\t\t// other than the current one for the Range, the Range is collapsed to\r\n\t\t\t// the new position. This enforces the restriction that both boundary-\r\n\t\t\t// points of a Range must have the same root container.\r\n\t\t\tec = t[END_CONTAINER];\r\n\t\t\twhile (ec.parentNode)\r\n\t\t\t\tec = ec.parentNode;\r\n\r\n\t\t\tsc = t[START_CONTAINER];\r\n\t\t\twhile (sc.parentNode)\r\n\t\t\t\tsc = sc.parentNode;\r\n\r\n\t\t\tif (sc == ec) {\r\n\t\t\t\t// The start position of a Range is guaranteed to never be after the\r\n\t\t\t\t// end position. To enforce this restriction, if the start is set to\r\n\t\t\t\t// be at a position after the end, the Range is collapsed to that\r\n\t\t\t\t// position.\r\n\t\t\t\tif (_compareBoundaryPoints(t[START_CONTAINER], t[START_OFFSET], t[END_CONTAINER], t[END_OFFSET]) > 0)\r\n\t\t\t\t\tt.collapse(st);\r\n\t\t\t} else\r\n\t\t\t\tt.collapse(st);\r\n\r\n\t\t\tt.collapsed = _isCollapsed();\r\n\t\t\tt.commonAncestorContainer = dom.findCommonAncestor(t[START_CONTAINER], t[END_CONTAINER]);\r\n\t\t};\r\n\r\n\t\tfunction _traverse(how) {\r\n\t\t\tvar c, endContainerDepth = 0, startContainerDepth = 0, p, depthDiff, startNode, endNode, sp, ep;\r\n\r\n\t\t\tif (t[START_CONTAINER] == t[END_CONTAINER])\r\n\t\t\t\treturn _traverseSameContainer(how);\r\n\r\n\t\t\tfor (c = t[END_CONTAINER], p = c.parentNode; p; c = p, p = p.parentNode) {\r\n\t\t\t\tif (p == t[START_CONTAINER])\r\n\t\t\t\t\treturn _traverseCommonStartContainer(c, how);\r\n\r\n\t\t\t\t++endContainerDepth;\r\n\t\t\t}\r\n\r\n\t\t\tfor (c = t[START_CONTAINER], p = c.parentNode; p; c = p, p = p.parentNode) {\r\n\t\t\t\tif (p == t[END_CONTAINER])\r\n\t\t\t\t\treturn _traverseCommonEndContainer(c, how);\r\n\r\n\t\t\t\t++startContainerDepth;\r\n\t\t\t}\r\n\r\n\t\t\tdepthDiff = startContainerDepth - endContainerDepth;\r\n\r\n\t\t\tstartNode = t[START_CONTAINER];\r\n\t\t\twhile (depthDiff > 0) {\r\n\t\t\t\tstartNode = startNode.parentNode;\r\n\t\t\t\tdepthDiff--;\r\n\t\t\t}\r\n\r\n\t\t\tendNode = t[END_CONTAINER];\r\n\t\t\twhile (depthDiff < 0) {\r\n\t\t\t\tendNode = endNode.parentNode;\r\n\t\t\t\tdepthDiff++;\r\n\t\t\t}\r\n\r\n\t\t\t// ascend the ancestor hierarchy until we have a common parent.\r\n\t\t\tfor (sp = startNode.parentNode, ep = endNode.parentNode; sp != ep; sp = sp.parentNode, ep = ep.parentNode) {\r\n\t\t\t\tstartNode = sp;\r\n\t\t\t\tendNode = ep;\r\n\t\t\t}\r\n\r\n\t\t\treturn _traverseCommonAncestors(startNode, endNode, how);\r\n\t\t};\r\n\r\n\t\t function _traverseSameContainer(how) {\r\n\t\t\tvar frag, s, sub, n, cnt, sibling, xferNode;\r\n\r\n\t\t\tif (how != DELETE)\r\n\t\t\t\tfrag = doc.createDocumentFragment();\r\n\r\n\t\t\t// If selection is empty, just return the fragment\r\n\t\t\tif (t[START_OFFSET] == t[END_OFFSET])\r\n\t\t\t\treturn frag;\r\n\r\n\t\t\t// Text node needs special case handling\r\n\t\t\tif (t[START_CONTAINER].nodeType == 3 /* TEXT_NODE */) {\r\n\t\t\t\t// get the substring\r\n\t\t\t\ts = t[START_CONTAINER].nodeValue;\r\n\t\t\t\tsub = s.substring(t[START_OFFSET], t[END_OFFSET]);\r\n\r\n\t\t\t\t// set the original text node to its new value\r\n\t\t\t\tif (how != CLONE) {\r\n\t\t\t\t\tt[START_CONTAINER].deleteData(t[START_OFFSET], t[END_OFFSET] - t[START_OFFSET]);\r\n\r\n\t\t\t\t\t// Nothing is partially selected, so collapse to start point\r\n\t\t\t\t\tt.collapse(TRUE);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (how == DELETE)\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\tfrag.appendChild(doc.createTextNode(sub));\r\n\t\t\t\treturn frag;\r\n\t\t\t}\r\n\r\n\t\t\t// Copy nodes between the start/end offsets.\r\n\t\t\tn = _getSelectedNode(t[START_CONTAINER], t[START_OFFSET]);\r\n\t\t\tcnt = t[END_OFFSET] - t[START_OFFSET];\r\n\r\n\t\t\twhile (cnt > 0) {\r\n\t\t\t\tsibling = n.nextSibling;\r\n\t\t\t\txferNode = _traverseFullySelected(n, how);\r\n\r\n\t\t\t\tif (frag)\r\n\t\t\t\t\tfrag.appendChild( xferNode );\r\n\r\n\t\t\t\t--cnt;\r\n\t\t\t\tn = sibling;\r\n\t\t\t}\r\n\r\n\t\t\t// Nothing is partially selected, so collapse to start point\r\n\t\t\tif (how != CLONE)\r\n\t\t\t\tt.collapse(TRUE);\r\n\r\n\t\t\treturn frag;\r\n\t\t};\r\n\r\n\t\tfunction _traverseCommonStartContainer(endAncestor, how) {\r\n\t\t\tvar frag, n, endIdx, cnt, sibling, xferNode;\r\n\r\n\t\t\tif (how != DELETE)\r\n\t\t\t\tfrag = doc.createDocumentFragment();\r\n\r\n\t\t\tn = _traverseRightBoundary(endAncestor, how);\r\n\r\n\t\t\tif (frag)\r\n\t\t\t\tfrag.appendChild(n);\r\n\r\n\t\t\tendIdx = nodeIndex(endAncestor);\r\n\t\t\tcnt = endIdx - t[START_OFFSET];\r\n\r\n\t\t\tif (cnt <= 0) {\r\n\t\t\t\t// Collapse to just before the endAncestor, which\r\n\t\t\t\t// is partially selected.\r\n\t\t\t\tif (how != CLONE) {\r\n\t\t\t\t\tt.setEndBefore(endAncestor);\r\n\t\t\t\t\tt.collapse(FALSE);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn frag;\r\n\t\t\t}\r\n\r\n\t\t\tn = endAncestor.previousSibling;\r\n\t\t\twhile (cnt > 0) {\r\n\t\t\t\tsibling = n.previousSibling;\r\n\t\t\t\txferNode = _traverseFullySelected(n, how);\r\n\r\n\t\t\t\tif (frag)\r\n\t\t\t\t\tfrag.insertBefore(xferNode, frag.firstChild);\r\n\r\n\t\t\t\t--cnt;\r\n\t\t\t\tn = sibling;\r\n\t\t\t}\r\n\r\n\t\t\t// Collapse to just before the endAncestor, which\r\n\t\t\t// is partially selected.\r\n\t\t\tif (how != CLONE) {\r\n\t\t\t\tt.setEndBefore(endAncestor);\r\n\t\t\t\tt.collapse(FALSE);\r\n\t\t\t}\r\n\r\n\t\t\treturn frag;\r\n\t\t};\r\n\r\n\t\tfunction _traverseCommonEndContainer(startAncestor, how) {\r\n\t\t\tvar frag, startIdx, n, cnt, sibling, xferNode;\r\n\r\n\t\t\tif (how != DELETE)\r\n\t\t\t\tfrag = doc.createDocumentFragment();\r\n\r\n\t\t\tn = _traverseLeftBoundary(startAncestor, how);\r\n\t\t\tif (frag)\r\n\t\t\t\tfrag.appendChild(n);\r\n\r\n\t\t\tstartIdx = nodeIndex(startAncestor);\r\n\t\t\t++startIdx; // Because we already traversed it\r\n\r\n\t\t\tcnt = t[END_OFFSET] - startIdx;\r\n\t\t\tn = startAncestor.nextSibling;\r\n\t\t\twhile (cnt > 0) {\r\n\t\t\t\tsibling = n.nextSibling;\r\n\t\t\t\txferNode = _traverseFullySelected(n, how);\r\n\r\n\t\t\t\tif (frag)\r\n\t\t\t\t\tfrag.appendChild(xferNode);\r\n\r\n\t\t\t\t--cnt;\r\n\t\t\t\tn = sibling;\r\n\t\t\t}\r\n\r\n\t\t\tif (how != CLONE) {\r\n\t\t\t\tt.setStartAfter(startAncestor);\r\n\t\t\t\tt.collapse(TRUE);\r\n\t\t\t}\r\n\r\n\t\t\treturn frag;\r\n\t\t};\r\n\r\n\t\tfunction _traverseCommonAncestors(startAncestor, endAncestor, how) {\r\n\t\t\tvar n, frag, commonParent, startOffset, endOffset, cnt, sibling, nextSibling;\r\n\r\n\t\t\tif (how != DELETE)\r\n\t\t\t\tfrag = doc.createDocumentFragment();\r\n\r\n\t\t\tn = _traverseLeftBoundary(startAncestor, how);\r\n\t\t\tif (frag)\r\n\t\t\t\tfrag.appendChild(n);\r\n\r\n\t\t\tcommonParent = startAncestor.parentNode;\r\n\t\t\tstartOffset = nodeIndex(startAncestor);\r\n\t\t\tendOffset = nodeIndex(endAncestor);\r\n\t\t\t++startOffset;\r\n\r\n\t\t\tcnt = endOffset - startOffset;\r\n\t\t\tsibling = startAncestor.nextSibling;\r\n\r\n\t\t\twhile (cnt > 0) {\r\n\t\t\t\tnextSibling = sibling.nextSibling;\r\n\t\t\t\tn = _traverseFullySelected(sibling, how);\r\n\r\n\t\t\t\tif (frag)\r\n\t\t\t\t\tfrag.appendChild(n);\r\n\r\n\t\t\t\tsibling = nextSibling;\r\n\t\t\t\t--cnt;\r\n\t\t\t}\r\n\r\n\t\t\tn = _traverseRightBoundary(endAncestor, how);\r\n\r\n\t\t\tif (frag)\r\n\t\t\t\tfrag.appendChild(n);\r\n\r\n\t\t\tif (how != CLONE) {\r\n\t\t\t\tt.setStartAfter(startAncestor);\r\n\t\t\t\tt.collapse(TRUE);\r\n\t\t\t}\r\n\r\n\t\t\treturn frag;\r\n\t\t};\r\n\r\n\t\tfunction _traverseRightBoundary(root, how) {\r\n\t\t\tvar next = _getSelectedNode(t[END_CONTAINER], t[END_OFFSET] - 1), parent, clonedParent, prevSibling, clonedChild, clonedGrandParent, isFullySelected = next != t[END_CONTAINER];\r\n\r\n\t\t\tif (next == root)\r\n\t\t\t\treturn _traverseNode(next, isFullySelected, FALSE, how);\r\n\r\n\t\t\tparent = next.parentNode;\r\n\t\t\tclonedParent = _traverseNode(parent, FALSE, FALSE, how);\r\n\r\n\t\t\twhile (parent) {\r\n\t\t\t\twhile (next) {\r\n\t\t\t\t\tprevSibling = next.previousSibling;\r\n\t\t\t\t\tclonedChild = _traverseNode(next, isFullySelected, FALSE, how);\r\n\r\n\t\t\t\t\tif (how != DELETE)\r\n\t\t\t\t\t\tclonedParent.insertBefore(clonedChild, clonedParent.firstChild);\r\n\r\n\t\t\t\t\tisFullySelected = TRUE;\r\n\t\t\t\t\tnext = prevSibling;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (parent == root)\r\n\t\t\t\t\treturn clonedParent;\r\n\r\n\t\t\t\tnext = parent.previousSibling;\r\n\t\t\t\tparent = parent.parentNode;\r\n\r\n\t\t\t\tclonedGrandParent = _traverseNode(parent, FALSE, FALSE, how);\r\n\r\n\t\t\t\tif (how != DELETE)\r\n\t\t\t\t\tclonedGrandParent.appendChild(clonedParent);\r\n\r\n\t\t\t\tclonedParent = clonedGrandParent;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tfunction _traverseLeftBoundary(root, how) {\r\n\t\t\tvar next = _getSelectedNode(t[START_CONTAINER], t[START_OFFSET]), isFullySelected = next != t[START_CONTAINER], parent, clonedParent, nextSibling, clonedChild, clonedGrandParent;\r\n\r\n\t\t\tif (next == root)\r\n\t\t\t\treturn _traverseNode(next, isFullySelected, TRUE, how);\r\n\r\n\t\t\tparent = next.parentNode;\r\n\t\t\tclonedParent = _traverseNode(parent, FALSE, TRUE, how);\r\n\r\n\t\t\twhile (parent) {\r\n\t\t\t\twhile (next) {\r\n\t\t\t\t\tnextSibling = next.nextSibling;\r\n\t\t\t\t\tclonedChild = _traverseNode(next, isFullySelected, TRUE, how);\r\n\r\n\t\t\t\t\tif (how != DELETE)\r\n\t\t\t\t\t\tclonedParent.appendChild(clonedChild);\r\n\r\n\t\t\t\t\tisFullySelected = TRUE;\r\n\t\t\t\t\tnext = nextSibling;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (parent == root)\r\n\t\t\t\t\treturn clonedParent;\r\n\r\n\t\t\t\tnext = parent.nextSibling;\r\n\t\t\t\tparent = parent.parentNode;\r\n\r\n\t\t\t\tclonedGrandParent = _traverseNode(parent, FALSE, TRUE, how);\r\n\r\n\t\t\t\tif (how != DELETE)\r\n\t\t\t\t\tclonedGrandParent.appendChild(clonedParent);\r\n\r\n\t\t\t\tclonedParent = clonedGrandParent;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tfunction _traverseNode(n, isFullySelected, isLeft, how) {\r\n\t\t\tvar txtValue, newNodeValue, oldNodeValue, offset, newNode;\r\n\r\n\t\t\tif (isFullySelected)\r\n\t\t\t\treturn _traverseFullySelected(n, how);\r\n\r\n\t\t\tif (n.nodeType == 3 /* TEXT_NODE */) {\r\n\t\t\t\ttxtValue = n.nodeValue;\r\n\r\n\t\t\t\tif (isLeft) {\r\n\t\t\t\t\toffset = t[START_OFFSET];\r\n\t\t\t\t\tnewNodeValue = txtValue.substring(offset);\r\n\t\t\t\t\toldNodeValue = txtValue.substring(0, offset);\r\n\t\t\t\t} else {\r\n\t\t\t\t\toffset = t[END_OFFSET];\r\n\t\t\t\t\tnewNodeValue = txtValue.substring(0, offset);\r\n\t\t\t\t\toldNodeValue = txtValue.substring(offset);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (how != CLONE)\r\n\t\t\t\t\tn.nodeValue = oldNodeValue;\r\n\r\n\t\t\t\tif (how == DELETE)\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\tnewNode = n.cloneNode(FALSE);\r\n\t\t\t\tnewNode.nodeValue = newNodeValue;\r\n\r\n\t\t\t\treturn newNode;\r\n\t\t\t}\r\n\r\n\t\t\tif (how == DELETE)\r\n\t\t\t\treturn;\r\n\r\n\t\t\treturn n.cloneNode(FALSE);\r\n\t\t};\r\n\r\n\t\tfunction _traverseFullySelected(n, how) {\r\n\t\t\tif (how != DELETE)\r\n\t\t\t\treturn how == CLONE ? n.cloneNode(TRUE) : n;\r\n\r\n\t\t\tn.parentNode.removeChild(n);\r\n\t\t};\r\n\t};\r\n\r\n\tns.Range = Range;\r\n})(tinymce.dom);\r\n","Magento_Tinymce3/tiny_mce/classes/dom/RangeUtils.js":"/**\r\n * Range.js\r\n *\r\n * Copyright 2009, Moxiecode Systems AB\r\n * Released under LGPL License.\r\n *\r\n * License: http://tinymce.moxiecode.com/license\r\n * Contributing: http://tinymce.moxiecode.com/contributing\r\n */\r\n\r\n(function(tinymce) {\r\n\ttinymce.dom.RangeUtils = function(dom) {\r\n\t\tvar INVISIBLE_CHAR = '\\uFEFF';\r\n\r\n\t\t/**\r\n\t\t * Walks the specified range like object and executes the callback for each sibling collection it finds.\r\n\t\t *\r\n\t\t * @param {Object} rng Range like object.\r\n\t\t * @param {function} callback Callback function to execute for each sibling collection.\r\n\t\t */\r\n\t\tthis.walk = function(rng, callback) {\r\n\t\t\tvar startContainer = rng.startContainer,\r\n\t\t\t\tstartOffset = rng.startOffset,\r\n\t\t\t\tendContainer = rng.endContainer,\r\n\t\t\t\tendOffset = rng.endOffset,\r\n\t\t\t\tancestor, startPoint,\r\n\t\t\t\tendPoint, node, parent, siblings, nodes;\r\n\r\n\t\t\t// Handle table cell selection the table plugin enables\r\n\t\t\t// you to fake select table cells and perform formatting actions on them\r\n\t\t\tnodes = dom.select('td.mceSelected,th.mceSelected');\r\n\t\t\tif (nodes.length > 0) {\r\n\t\t\t\ttinymce.each(nodes, function(node) {\r\n\t\t\t\t\tcallback([node]);\r\n\t\t\t\t});\r\n\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t/**\r\n\t\t\t * Excludes start/end text node if they are out side the range\r\n\t\t\t *\r\n\t\t\t * @private\r\n\t\t\t * @param {Array} nodes Nodes to exclude items from.\r\n\t\t\t * @return {Array} Array with nodes excluding the start/end container if needed.\r\n\t\t\t */\r\n\t\t\tfunction exclude(nodes) {\r\n\t\t\t\tvar node;\r\n\r\n\t\t\t\t// First node is excluded\r\n\t\t\t\tnode = nodes[0];\r\n\t\t\t\tif (node.nodeType === 3 && node === startContainer && startOffset >= node.nodeValue.length) {\r\n\t\t\t\t\tnodes.splice(0, 1);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Last node is excluded\r\n\t\t\t\tnode = nodes[nodes.length - 1];\r\n\t\t\t\tif (endOffset === 0 && nodes.length > 0 && node === endContainer && node.nodeType === 3) {\r\n\t\t\t\t\tnodes.splice(nodes.length - 1, 1);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn nodes;\r\n\t\t\t};\r\n\r\n\t\t\t/**\r\n\t\t\t * Collects siblings\r\n\t\t\t *\r\n\t\t\t * @private\r\n\t\t\t * @param {Node} node Node to collect siblings from.\r\n\t\t\t * @param {String} name Name of the sibling to check for.\r\n\t\t\t * @return {Array} Array of collected siblings.\r\n\t\t\t */\r\n\t\t\tfunction collectSiblings(node, name, end_node) {\r\n\t\t\t\tvar siblings = [];\r\n\r\n\t\t\t\tfor (; node && node != end_node; node = node[name])\r\n\t\t\t\t\tsiblings.push(node);\r\n\r\n\t\t\t\treturn siblings;\r\n\t\t\t};\r\n\r\n\t\t\t/**\r\n\t\t\t * Find an end point this is the node just before the common ancestor root.\r\n\t\t\t *\r\n\t\t\t * @private\r\n\t\t\t * @param {Node} node Node to start at.\r\n\t\t\t * @param {Node} root Root/ancestor element to stop just before.\r\n\t\t\t * @return {Node} Node just before the root element.\r\n\t\t\t */\r\n\t\t\tfunction findEndPoint(node, root) {\r\n\t\t\t\tdo {\r\n\t\t\t\t\tif (node.parentNode == root)\r\n\t\t\t\t\t\treturn node;\r\n\r\n\t\t\t\t\tnode = node.parentNode;\r\n\t\t\t\t} while(node);\r\n\t\t\t};\r\n\r\n\t\t\tfunction walkBoundary(start_node, end_node, next) {\r\n\t\t\t\tvar siblingName = next ? 'nextSibling' : 'previousSibling';\r\n\r\n\t\t\t\tfor (node = start_node, parent = node.parentNode; node && node != end_node; node = parent) {\r\n\t\t\t\t\tparent = node.parentNode;\r\n\t\t\t\t\tsiblings = collectSiblings(node == start_node ? node : node[siblingName], siblingName);\r\n\r\n\t\t\t\t\tif (siblings.length) {\r\n\t\t\t\t\t\tif (!next)\r\n\t\t\t\t\t\t\tsiblings.reverse();\r\n\r\n\t\t\t\t\t\tcallback(exclude(siblings));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\t// If index based start position then resolve it\r\n\t\t\tif (startContainer.nodeType == 1 && startContainer.hasChildNodes())\r\n\t\t\t\tstartContainer = startContainer.childNodes[startOffset];\r\n\r\n\t\t\t// If index based end position then resolve it\r\n\t\t\tif (endContainer.nodeType == 1 && endContainer.hasChildNodes())\r\n\t\t\t\tendContainer = endContainer.childNodes[Math.min(endOffset - 1, endContainer.childNodes.length - 1)];\r\n\r\n\t\t\t// Same container\r\n\t\t\tif (startContainer == endContainer)\r\n\t\t\t\treturn callback(exclude([startContainer]));\r\n\r\n\t\t\t// Find common ancestor and end points\r\n\t\t\tancestor = dom.findCommonAncestor(startContainer, endContainer);\r\n\t\t\t\t\r\n\t\t\t// Process left side\r\n\t\t\tfor (node = startContainer; node; node = node.parentNode) {\r\n\t\t\t\tif (node === endContainer)\r\n\t\t\t\t\treturn walkBoundary(startContainer, ancestor, true);\r\n\r\n\t\t\t\tif (node === ancestor)\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\t// Process right side\r\n\t\t\tfor (node = endContainer; node; node = node.parentNode) {\r\n\t\t\t\tif (node === startContainer)\r\n\t\t\t\t\treturn walkBoundary(endContainer, ancestor);\r\n\r\n\t\t\t\tif (node === ancestor)\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\t// Find start/end point\r\n\t\t\tstartPoint = findEndPoint(startContainer, ancestor) || startContainer;\r\n\t\t\tendPoint = findEndPoint(endContainer, ancestor) || endContainer;\r\n\r\n\t\t\t// Walk left leaf\r\n\t\t\twalkBoundary(startContainer, startPoint, true);\r\n\r\n\t\t\t// Walk the middle from start to end point\r\n\t\t\tsiblings = collectSiblings(\r\n\t\t\t\tstartPoint == startContainer ? startPoint : startPoint.nextSibling,\r\n\t\t\t\t'nextSibling',\r\n\t\t\t\tendPoint == endContainer ? endPoint.nextSibling : endPoint\r\n\t\t\t);\r\n\r\n\t\t\tif (siblings.length)\r\n\t\t\t\tcallback(exclude(siblings));\r\n\r\n\t\t\t// Walk right leaf\r\n\t\t\twalkBoundary(endContainer, endPoint);\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Splits the specified range at it's start/end points.\r\n\t\t *\r\n\t\t * @param {Range/RangeObject} rng Range to split.\r\n\t\t * @return {Object} Range position object.\r\n\t\t */\r\n\t\tthis.split = function(rng) {\r\n\t\t\tvar startContainer = rng.startContainer,\r\n\t\t\t\tstartOffset = rng.startOffset,\r\n\t\t\t\tendContainer = rng.endContainer,\r\n\t\t\t\tendOffset = rng.endOffset;\r\n\r\n\t\t\tfunction splitText(node, offset) {\r\n\t\t\t\treturn node.splitText(offset);\r\n\t\t\t};\r\n\r\n\t\t\t// Handle single text node\r\n\t\t\tif (startContainer == endContainer && startContainer.nodeType == 3) {\r\n\t\t\t\tif (startOffset > 0 && startOffset < startContainer.nodeValue.length) {\r\n\t\t\t\t\tendContainer = splitText(startContainer, startOffset);\r\n\t\t\t\t\tstartContainer = endContainer.previousSibling;\r\n\r\n\t\t\t\t\tif (endOffset > startOffset) {\r\n\t\t\t\t\t\tendOffset = endOffset - startOffset;\r\n\t\t\t\t\t\tstartContainer = endContainer = splitText(endContainer, endOffset).previousSibling;\r\n\t\t\t\t\t\tendOffset = endContainer.nodeValue.length;\r\n\t\t\t\t\t\tstartOffset = 0;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tendOffset = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t// Split startContainer text node if needed\r\n\t\t\t\tif (startContainer.nodeType == 3 && startOffset > 0 && startOffset < startContainer.nodeValue.length) {\r\n\t\t\t\t\tstartContainer = splitText(startContainer, startOffset);\r\n\t\t\t\t\tstartOffset = 0;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Split endContainer text node if needed\r\n\t\t\t\tif (endContainer.nodeType == 3 && endOffset > 0 && endOffset < endContainer.nodeValue.length) {\r\n\t\t\t\t\tendContainer = splitText(endContainer, endOffset).previousSibling;\r\n\t\t\t\t\tendOffset = endContainer.nodeValue.length;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn {\r\n\t\t\t\tstartContainer : startContainer,\r\n\t\t\t\tstartOffset : startOffset,\r\n\t\t\t\tendContainer : endContainer,\r\n\t\t\t\tendOffset : endOffset\r\n\t\t\t};\r\n\t\t};\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Compares two ranges and checks if they are equal.\r\n\t *\r\n\t * @static\r\n\t * @param {DOMRange} rng1 First range to compare.\r\n\t * @param {DOMRange} rng2 First range to compare.\r\n\t * @return {Boolean} true/false if the ranges are equal.\r\n\t */\r\n\ttinymce.dom.RangeUtils.compareRanges = function(rng1, rng2) {\r\n\t\tif (rng1 && rng2) {\r\n\t\t\t// Compare native IE ranges\r\n\t\t\tif (rng1.item || rng1.duplicate) {\r\n\t\t\t\t// Both are control ranges and the selected element matches\r\n\t\t\t\tif (rng1.item && rng2.item && rng1.item(0) === rng2.item(0))\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t// Both are text ranges and the range matches\r\n\t\t\t\tif (rng1.isEqual && rng2.isEqual && rng2.isEqual(rng1))\r\n\t\t\t\t\treturn true;\r\n\t\t\t} else {\r\n\t\t\t\t// Compare w3c ranges\r\n\t\t\t\treturn rng1.startContainer == rng2.startContainer && rng1.startOffset == rng2.startOffset;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t};\r\n})(tinymce);\r\n","Magento_Tinymce3/tiny_mce/classes/dom/ScriptLoader.js":"/**\r\n * ScriptLoader.js\r\n *\r\n * Copyright 2009, Moxiecode Systems AB\r\n * Released under LGPL License.\r\n *\r\n * License: http://tinymce.moxiecode.com/license\r\n * Contributing: http://tinymce.moxiecode.com/contributing\r\n */\r\n\r\n(function(tinymce) {\r\n\t/**\r\n\t * This class handles asynchronous/synchronous loading of JavaScript files it will execute callbacks when various items gets loaded. This class is useful to load external JavaScript files. \r\n\t *\r\n\t * @class tinymce.dom.ScriptLoader\r\n\t * @example\r\n\t * // Load a script from a specific URL using the global script loader\r\n\t * tinymce.ScriptLoader.load('somescript.js');\r\n\t * \r\n\t * // Load a script using a unique instance of the script loader\r\n\t * var scriptLoader = new tinymce.dom.ScriptLoader();\r\n\t * \r\n\t * scriptLoader.load('somescript.js');\r\n\t * \r\n\t * // Load multiple scripts\r\n\t * var scriptLoader = new tinymce.dom.ScriptLoader();\r\n\t * \r\n\t * scriptLoader.add('somescript1.js');\r\n\t * scriptLoader.add('somescript2.js');\r\n\t * scriptLoader.add('somescript3.js');\r\n\t * \r\n\t * scriptLoader.loadQueue(function() {\r\n\t *    alert('All scripts are now loaded.');\r\n\t * });\r\n\t */\r\n\ttinymce.dom.ScriptLoader = function(settings) {\r\n\t\tvar QUEUED = 0,\r\n\t\t\tLOADING = 1,\r\n\t\t\tLOADED = 2,\r\n\t\t\tstates = {},\r\n\t\t\tqueue = [],\r\n\t\t\tscriptLoadedCallbacks = {},\r\n\t\t\tqueueLoadedCallbacks = [],\r\n\t\t\tloading = 0,\r\n\t\t\tundefined;\r\n\r\n\t\t/**\r\n\t\t * Loads a specific script directly without adding it to the load queue.\r\n\t\t *\r\n\t\t * @method load\r\n\t\t * @param {String} url Absolute URL to script to add.\r\n\t\t * @param {function} callback Optional callback function to execute ones this script gets loaded.\r\n\t\t * @param {Object} scope Optional scope to execute callback in.\r\n\t\t */\r\n\t\tfunction loadScript(url, callback) {\r\n\t\t\tvar t = this, dom = tinymce.DOM, elm, uri, loc, id;\r\n\r\n\t\t\t// Execute callback when script is loaded\r\n\t\t\tfunction done() {\r\n\t\t\t\tdom.remove(id);\r\n\r\n\t\t\t\tif (elm)\r\n\t\t\t\t\telm.onreadystatechange = elm.onload = elm = null;\r\n\r\n\t\t\t\tcallback();\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\tfunction error() {\r\n\t\t\t\t// Report the error so it's easier for people to spot loading errors\r\n\t\t\t\tif (typeof(console) !== \"undefined\" && console.log)\r\n\t\t\t\t\tconsole.log(\"Failed to load: \" + url);\r\n\r\n\t\t\t\t// We can't mark it as done if there is a load error since\r\n\t\t\t\t// A) We don't want to produce 404 errors on the server and\r\n\t\t\t\t// B) the onerror event won't fire on all browsers.\r\n\t\t\t\t// done();\r\n\t\t\t};\r\n\r\n\t\t\tid = dom.uniqueId();\r\n\r\n\t\t\tif (tinymce.isIE6) {\r\n\t\t\t\turi = new tinymce.util.URI(url);\r\n\t\t\t\tloc = location;\r\n\r\n\t\t\t\t// If script is from same domain and we\r\n\t\t\t\t// use IE 6 then use XHR since it's more reliable\r\n\t\t\t\tif (uri.host == loc.hostname && uri.port == loc.port && (uri.protocol + ':') == loc.protocol && uri.protocol.toLowerCase() != 'file') {\r\n\t\t\t\t\ttinymce.util.XHR.send({\r\n\t\t\t\t\t\turl : tinymce._addVer(uri.getURI()),\r\n\t\t\t\t\t\tsuccess : function(content) {\r\n\t\t\t\t\t\t\t// Create new temp script element\r\n\t\t\t\t\t\t\tvar script = dom.create('script', {\r\n\t\t\t\t\t\t\t\ttype : 'text/javascript'\r\n\t\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t\t// Evaluate script in global scope\r\n\t\t\t\t\t\t\tscript.text = content;\r\n\t\t\t\t\t\t\tdocument.getElementsByTagName('head')[0].appendChild(script);\r\n\t\t\t\t\t\t\tdom.remove(script);\r\n\r\n\t\t\t\t\t\t\tdone();\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\terror : error\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Create new script element\r\n\t\t\telm = dom.create('script', {\r\n\t\t\t\tid : id,\r\n\t\t\t\ttype : 'text/javascript',\r\n\t\t\t\tsrc : tinymce._addVer(url)\r\n\t\t\t});\r\n\r\n\t\t\t// Add onload listener for non IE browsers since IE9\r\n\t\t\t// fires onload event before the script is parsed and executed\r\n\t\t\tif (!tinymce.isIE)\r\n\t\t\t\telm.onload = done;\r\n\r\n\t\t\t// Add onerror event will get fired on some browsers but not all of them\r\n\t\t\telm.onerror = error;\r\n\r\n\t\t\t// Opera 9.60 doesn't seem to fire the onreadystate event at correctly\r\n\t\t\tif (!tinymce.isOpera) {\r\n\t\t\t\telm.onreadystatechange = function() {\r\n\t\t\t\t\tvar state = elm.readyState;\r\n\r\n\t\t\t\t\t// Loaded state is passed on IE 6 however there\r\n\t\t\t\t\t// are known issues with this method but we can't use\r\n\t\t\t\t\t// XHR in a cross domain loading\r\n\t\t\t\t\tif (state == 'complete' || state == 'loaded')\r\n\t\t\t\t\t\tdone();\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\t// Most browsers support this feature so we report errors\r\n\t\t\t// for those at least to help users track their missing plugins etc\r\n\t\t\t// todo: Removed since it produced error if the document is unloaded by navigating away, re-add it as an option\r\n\t\t\t/*elm.onerror = function() {\r\n\t\t\t\talert('Failed to load: ' + url);\r\n\t\t\t};*/\r\n\r\n\t\t\t// Add script to document\r\n\t\t\t(document.getElementsByTagName('head')[0] || document.body).appendChild(elm);\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Returns true/false if a script has been loaded or not.\r\n\t\t *\r\n\t\t * @method isDone\r\n\t\t * @param {String} url URL to check for.\r\n\t\t * @return [Boolean} true/false if the URL is loaded.\r\n\t\t */\r\n\t\tthis.isDone = function(url) {\r\n\t\t\treturn states[url] == LOADED;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Marks a specific script to be loaded. This can be useful if a script got loaded outside\r\n\t\t * the script loader or to skip it from loading some script.\r\n\t\t *\r\n\t\t * @method markDone\r\n\t\t * @param {string} u Absolute URL to the script to mark as loaded.\r\n\t\t */\r\n\t\tthis.markDone = function(url) {\r\n\t\t\tstates[url] = LOADED;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Adds a specific script to the load queue of the script loader.\r\n\t\t *\r\n\t\t * @method add\r\n\t\t * @param {String} url Absolute URL to script to add.\r\n\t\t * @param {function} callback Optional callback function to execute ones this script gets loaded.\r\n\t\t * @param {Object} scope Optional scope to execute callback in.\r\n\t\t */\r\n\t\tthis.add = this.load = function(url, callback, scope) {\r\n\t\t\tvar item, state = states[url];\r\n\r\n\t\t\t// Add url to load queue\r\n\t\t\tif (state == undefined) {\r\n\t\t\t\tqueue.push(url);\r\n\t\t\t\tstates[url] = QUEUED;\r\n\t\t\t}\r\n\r\n\t\t\tif (callback) {\r\n\t\t\t\t// Store away callback for later execution\r\n\t\t\t\tif (!scriptLoadedCallbacks[url])\r\n\t\t\t\t\tscriptLoadedCallbacks[url] = [];\r\n\r\n\t\t\t\tscriptLoadedCallbacks[url].push({\r\n\t\t\t\t\tfunc : callback,\r\n\t\t\t\t\tscope : scope || this\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Starts the loading of the queue.\r\n\t\t *\r\n\t\t * @method loadQueue\r\n\t\t * @param {function} callback Optional callback to execute when all queued items are loaded.\r\n\t\t * @param {Object} scope Optional scope to execute the callback in.\r\n\t\t */\r\n\t\tthis.loadQueue = function(callback, scope) {\r\n\t\t\tthis.loadScripts(queue, callback, scope);\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Loads the specified queue of files and executes the callback ones they are loaded.\r\n\t\t * This method is generally not used outside this class but it might be useful in some scenarios. \r\n\t\t *\r\n\t\t * @method loadScripts\r\n\t\t * @param {Array} scripts Array of queue items to load.\r\n\t\t * @param {function} callback Optional callback to execute ones all items are loaded.\r\n\t\t * @param {Object} scope Optional scope to execute callback in.\r\n\t\t */\r\n\t\tthis.loadScripts = function(scripts, callback, scope) {\r\n\t\t\tvar loadScripts;\r\n\r\n\t\t\tfunction execScriptLoadedCallbacks(url) {\r\n\t\t\t\t// Execute URL callback functions\r\n\t\t\t\ttinymce.each(scriptLoadedCallbacks[url], function(callback) {\r\n\t\t\t\t\tcallback.func.call(callback.scope);\r\n\t\t\t\t});\r\n\r\n\t\t\t\tscriptLoadedCallbacks[url] = undefined;\r\n\t\t\t};\r\n\r\n\t\t\tqueueLoadedCallbacks.push({\r\n\t\t\t\tfunc : callback,\r\n\t\t\t\tscope : scope || this\r\n\t\t\t});\r\n\r\n\t\t\tloadScripts = function() {\r\n\t\t\t\tvar loadingScripts = tinymce.grep(scripts);\r\n\r\n\t\t\t\t// Current scripts has been handled\r\n\t\t\t\tscripts.length = 0;\r\n\r\n\t\t\t\t// Load scripts that needs to be loaded\r\n\t\t\t\ttinymce.each(loadingScripts, function(url) {\r\n\t\t\t\t\t// Script is already loaded then execute script callbacks directly\r\n\t\t\t\t\tif (states[url] == LOADED) {\r\n\t\t\t\t\t\texecScriptLoadedCallbacks(url);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Is script not loading then start loading it\r\n\t\t\t\t\tif (states[url] != LOADING) {\r\n\t\t\t\t\t\tstates[url] = LOADING;\r\n\t\t\t\t\t\tloading++;\r\n\r\n\t\t\t\t\t\tloadScript(url, function() {\r\n\t\t\t\t\t\t\tstates[url] = LOADED;\r\n\t\t\t\t\t\t\tloading--;\r\n\r\n\t\t\t\t\t\t\texecScriptLoadedCallbacks(url);\r\n\r\n\t\t\t\t\t\t\t// Load more scripts if they where added by the recently loaded script\r\n\t\t\t\t\t\t\tloadScripts();\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// No scripts are currently loading then execute all pending queue loaded callbacks\r\n\t\t\t\tif (!loading) {\r\n\t\t\t\t\ttinymce.each(queueLoadedCallbacks, function(callback) {\r\n\t\t\t\t\t\tcallback.func.call(callback.scope);\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\tqueueLoadedCallbacks.length = 0;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tloadScripts();\r\n\t\t};\r\n\t};\r\n\r\n\t// Global script loader\r\n\ttinymce.ScriptLoader = new tinymce.dom.ScriptLoader();\r\n})(tinymce);\r\n","Magento_Tinymce3/tiny_mce/classes/dom/Selection.js":"/**\r\n * Selection.js\r\n *\r\n * Copyright 2009, Moxiecode Systems AB\r\n * Released under LGPL License.\r\n *\r\n * License: http://tinymce.moxiecode.com/license\r\n * Contributing: http://tinymce.moxiecode.com/contributing\r\n */\r\n\r\n(function(tinymce) {\r\n\tfunction trimNl(s) {\r\n\t\treturn s.replace(/[\\n\\r]+/g, '');\r\n\t};\r\n\r\n\t// Shorten names\r\n\tvar is = tinymce.is, isIE = tinymce.isIE, each = tinymce.each;\r\n\r\n\t/**\r\n\t * This class handles text and control selection it's an crossbrowser utility class.\r\n\t * Consult the TinyMCE Wiki API for more details and examples on how to use this class.\r\n\t *\r\n\t * @class tinymce.dom.Selection\r\n\t * @example\r\n\t * // Getting the currently selected node for the active editor\r\n\t * alert(tinymce.activeEditor.selection.getNode().nodeName);\r\n\t */\r\n\ttinymce.create('tinymce.dom.Selection', {\r\n\t\t/**\r\n\t\t * Constructs a new selection instance.\r\n\t\t *\r\n\t\t * @constructor\r\n\t\t * @method Selection\r\n\t\t * @param {tinymce.dom.DOMUtils} dom DOMUtils object reference.\r\n\t\t * @param {Window} win Window to bind the selection object to.\r\n\t\t * @param {tinymce.dom.Serializer} serializer DOM serialization class to use for getContent.\r\n\t\t */\r\n\t\tSelection : function(dom, win, serializer) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\tt.dom = dom;\r\n\t\t\tt.win = win;\r\n\t\t\tt.serializer = serializer;\r\n\r\n\t\t\t// Add events\r\n\t\t\teach([\r\n\t\t\t\t/**\r\n\t\t\t\t * This event gets executed before contents is extracted from the selection.\r\n\t\t\t\t *\r\n\t\t\t\t * @event onBeforeSetContent\r\n\t\t\t\t * @param {tinymce.dom.Selection} selection Selection object that fired the event.\r\n\t\t\t\t * @param {Object} args Contains things like the contents that will be returned. \r\n\t\t\t\t */\r\n\t\t\t\t'onBeforeSetContent',\r\n\r\n\t\t\t\t/**\r\n\t\t\t\t * This event gets executed before contents is inserted into selection. \r\n\t\t\t\t *\r\n\t\t\t\t * @event onBeforeGetContent\r\n\t\t\t\t * @param {tinymce.dom.Selection} selection Selection object that fired the event.\r\n\t\t\t\t * @param {Object} args Contains things like the contents that will be inserted. \r\n\t\t\t\t */\r\n\t\t\t\t'onBeforeGetContent',\r\n\r\n\t\t\t\t/**\r\n\t\t\t\t * This event gets executed when contents is inserted into selection.\r\n\t\t\t\t *\r\n\t\t\t\t * @event onSetContent\r\n\t\t\t\t * @param {tinymce.dom.Selection} selection Selection object that fired the event.\r\n\t\t\t\t * @param {Object} args Contains things like the contents that will be inserted. \r\n\t\t\t\t */\r\n\t\t\t\t'onSetContent',\r\n\r\n\t\t\t\t/**\r\n\t\t\t\t * This event gets executed when contents is extracted from the selection.\r\n\t\t\t\t *\r\n\t\t\t\t * @event onGetContent\r\n\t\t\t\t * @param {tinymce.dom.Selection} selection Selection object that fired the event.\r\n\t\t\t\t * @param {Object} args Contains things like the contents that will be returned. \r\n\t\t\t\t */\r\n\t\t\t\t'onGetContent'\r\n\t\t\t], function(e) {\r\n\t\t\t\tt[e] = new tinymce.util.Dispatcher(t);\r\n\t\t\t});\r\n\r\n\t\t\t// No W3C Range support\r\n\t\t\tif (!t.win.getSelection)\r\n\t\t\t\tt.tridentSel = new tinymce.dom.TridentSelection(t);\r\n\r\n\t\t\tif (tinymce.isIE && dom.boxModel)\r\n\t\t\t\tthis._fixIESelection();\r\n\r\n\t\t\t// Prevent leaks\r\n\t\t\ttinymce.addUnload(t.destroy, t);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Move the selection cursor range to the specified node and offset.\r\n\t\t * @param node Node to put the cursor in.\r\n\t\t * @param offset Offset from the start of the node to put the cursor at.\r\n\t\t */\r\n\t\tsetCursorLocation: function(node, offset) {\r\n\t\t\tvar t = this; var r = t.dom.createRng();\r\n\t\t\tr.setStart(node, offset);\r\n\t\t\tr.setEnd(node, offset);\r\n\t\t\tt.setRng(r);\r\n\t\t\tt.collapse(false);\r\n\t\t},\r\n\t\t/**\r\n\t\t * Returns the selected contents using the DOM serializer passed in to this class.\r\n\t\t *\r\n\t\t * @method getContent\r\n\t\t * @param {Object} s Optional settings class with for example output format text or html.\r\n\t\t * @return {String} Selected contents in for example HTML format.\r\n\t\t * @example\r\n\t\t * // Alerts the currently selected contents\r\n\t\t * alert(tinyMCE.activeEditor.selection.getContent());\r\n\t\t * \r\n\t\t * // Alerts the currently selected contents as plain text\r\n\t\t * alert(tinyMCE.activeEditor.selection.getContent({format : 'text'}));\r\n\t\t */\r\n\t\tgetContent : function(s) {\r\n\t\t\tvar t = this, r = t.getRng(), e = t.dom.create(\"body\"), se = t.getSel(), wb, wa, n;\r\n\r\n\t\t\ts = s || {};\r\n\t\t\twb = wa = '';\r\n\t\t\ts.get = true;\r\n\t\t\ts.format = s.format || 'html';\r\n\t\t\ts.forced_root_block = '';\r\n\t\t\tt.onBeforeGetContent.dispatch(t, s);\r\n\r\n\t\t\tif (s.format == 'text')\r\n\t\t\t\treturn t.isCollapsed() ? '' : (r.text || (se.toString ? se.toString() : ''));\r\n\r\n\t\t\tif (r.cloneContents) {\r\n\t\t\t\tn = r.cloneContents();\r\n\r\n\t\t\t\tif (n)\r\n\t\t\t\t\te.appendChild(n);\r\n\t\t\t} else if (is(r.item) || is(r.htmlText)) {\r\n\t\t\t\t// IE will produce invalid markup if elements are present that\r\n\t\t\t\t// it doesn't understand like custom elements or HTML5 elements.\r\n\t\t\t\t// Adding a BR in front of the contents and then remoiving it seems to fix it though.\r\n\t\t\t\te.innerHTML = '<br>' + (r.item ? r.item(0).outerHTML : r.htmlText);\r\n\t\t\t\te.removeChild(e.firstChild);\r\n\t\t\t} else\r\n\t\t\t\te.innerHTML = r.toString();\r\n\r\n\t\t\t// Keep whitespace before and after\r\n\t\t\tif (/^\\s/.test(e.innerHTML))\r\n\t\t\t\twb = ' ';\r\n\r\n\t\t\tif (/\\s+$/.test(e.innerHTML))\r\n\t\t\t\twa = ' ';\r\n\r\n\t\t\ts.getInner = true;\r\n\r\n\t\t\ts.content = t.isCollapsed() ? '' : wb + t.serializer.serialize(e, s) + wa;\r\n\t\t\tt.onGetContent.dispatch(t, s);\r\n\r\n\t\t\treturn s.content;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Sets the current selection to the specified content. If any contents is selected it will be replaced\r\n\t\t * with the contents passed in to this function. If there is no selection the contents will be inserted\r\n\t\t * where the caret is placed in the editor/page.\r\n\t\t *\r\n\t\t * @method setContent\r\n\t\t * @param {String} content HTML contents to set could also be other formats depending on settings.\r\n\t\t * @param {Object} args Optional settings object with for example data format.\r\n\t\t * @example\r\n\t\t * // Inserts some HTML contents at the current selection\r\n\t\t * tinyMCE.activeEditor.selection.setContent('<strong>Some contents</strong>');\r\n\t\t */\r\n\t\tsetContent : function(content, args) {\r\n\t\t\tvar self = this, rng = self.getRng(), caretNode, doc = self.win.document, frag, temp;\r\n\r\n\t\t\targs = args || {format : 'html'};\r\n\t\t\targs.set = true;\r\n\t\t\tcontent = args.content = content;\r\n\r\n\t\t\t// Dispatch before set content event\r\n\t\t\tif (!args.no_events)\r\n\t\t\t\tself.onBeforeSetContent.dispatch(self, args);\r\n\r\n\t\t\tcontent = args.content;\r\n\r\n\t\t\tif (rng.insertNode) {\r\n\t\t\t\t// Make caret marker since insertNode places the caret in the beginning of text after insert\r\n\t\t\t\tcontent += '<span id=\"__caret\">_</span>';\r\n\r\n\t\t\t\t// Delete and insert new node\r\n\t\t\t\tif (rng.startContainer == doc && rng.endContainer == doc) {\r\n\t\t\t\t\t// WebKit will fail if the body is empty since the range is then invalid and it can't insert contents\r\n\t\t\t\t\tdoc.body.innerHTML = content;\r\n\t\t\t\t} else {\r\n\t\t\t\t\trng.deleteContents();\r\n\r\n\t\t\t\t\tif (doc.body.childNodes.length == 0) {\r\n\t\t\t\t\t\tdoc.body.innerHTML = content;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// createContextualFragment doesn't exists in IE 9 DOMRanges\r\n\t\t\t\t\t\tif (rng.createContextualFragment) {\r\n\t\t\t\t\t\t\trng.insertNode(rng.createContextualFragment(content));\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// Fake createContextualFragment call in IE 9\r\n\t\t\t\t\t\t\tfrag = doc.createDocumentFragment();\r\n\t\t\t\t\t\t\ttemp = doc.createElement('div');\r\n\r\n\t\t\t\t\t\t\tfrag.appendChild(temp);\r\n\t\t\t\t\t\t\ttemp.outerHTML = content;\r\n\r\n\t\t\t\t\t\t\trng.insertNode(frag);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Move to caret marker\r\n\t\t\t\tcaretNode = self.dom.get('__caret');\r\n\r\n\t\t\t\t// Make sure we wrap it compleatly, Opera fails with a simple select call\r\n\t\t\t\trng = doc.createRange();\r\n\t\t\t\trng.setStartBefore(caretNode);\r\n\t\t\t\trng.setEndBefore(caretNode);\r\n\t\t\t\tself.setRng(rng);\r\n\r\n\t\t\t\t// Remove the caret position\r\n\t\t\t\tself.dom.remove('__caret');\r\n\r\n\t\t\t\ttry {\r\n\t\t\t\t\tself.setRng(rng);\r\n\t\t\t\t} catch (ex) {\r\n\t\t\t\t\t// Might fail on Opera for some odd reason\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (rng.item) {\r\n\t\t\t\t\t// Delete content and get caret text selection\r\n\t\t\t\t\tdoc.execCommand('Delete', false, null);\r\n\t\t\t\t\trng = self.getRng();\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Explorer removes spaces from the beginning of pasted contents\r\n\t\t\t\tif (/^\\s+/.test(content)) {\r\n\t\t\t\t\trng.pasteHTML('<span id=\"__mce_tmp\">_</span>' + content);\r\n\t\t\t\t\tself.dom.remove('__mce_tmp');\r\n\t\t\t\t} else\r\n\t\t\t\t\trng.pasteHTML(content);\r\n\t\t\t}\r\n\r\n\t\t\t// Dispatch set content event\r\n\t\t\tif (!args.no_events)\r\n\t\t\t\tself.onSetContent.dispatch(self, args);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns the start element of a selection range. If the start is in a text\r\n\t\t * node the parent element will be returned.\r\n\t\t *\r\n\t\t * @method getStart\r\n\t\t * @return {Element} Start element of selection range.\r\n\t\t */\r\n\t\tgetStart : function() {\r\n\t\t\tvar rng = this.getRng(), startElement, parentElement, checkRng, node;\r\n\r\n\t\t\tif (rng.duplicate || rng.item) {\r\n\t\t\t\t// Control selection, return first item\r\n\t\t\t\tif (rng.item)\r\n\t\t\t\t\treturn rng.item(0);\r\n\r\n\t\t\t\t// Get start element\r\n\t\t\t\tcheckRng = rng.duplicate();\r\n\t\t\t\tcheckRng.collapse(1);\r\n\t\t\t\tstartElement = checkRng.parentElement();\r\n\r\n\t\t\t\t// Check if range parent is inside the start element, then return the inner parent element\r\n\t\t\t\t// This will fix issues when a single element is selected, IE would otherwise return the wrong start element\r\n\t\t\t\tparentElement = node = rng.parentElement();\r\n\t\t\t\twhile (node = node.parentNode) {\r\n\t\t\t\t\tif (node == startElement) {\r\n\t\t\t\t\t\tstartElement = parentElement;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn startElement;\r\n\t\t\t} else {\r\n\t\t\t\tstartElement = rng.startContainer;\r\n\r\n\t\t\t\tif (startElement.nodeType == 1 && startElement.hasChildNodes())\r\n\t\t\t\t\tstartElement = startElement.childNodes[Math.min(startElement.childNodes.length - 1, rng.startOffset)];\r\n\r\n\t\t\t\tif (startElement && startElement.nodeType == 3)\r\n\t\t\t\t\treturn startElement.parentNode;\r\n\r\n\t\t\t\treturn startElement;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns the end element of a selection range. If the end is in a text\r\n\t\t * node the parent element will be returned.\r\n\t\t *\r\n\t\t * @method getEnd\r\n\t\t * @return {Element} End element of selection range.\r\n\t\t */\r\n\t\tgetEnd : function() {\r\n\t\t\tvar t = this, r = t.getRng(), e, eo;\r\n\r\n\t\t\tif (r.duplicate || r.item) {\r\n\t\t\t\tif (r.item)\r\n\t\t\t\t\treturn r.item(0);\r\n\r\n\t\t\t\tr = r.duplicate();\r\n\t\t\t\tr.collapse(0);\r\n\t\t\t\te = r.parentElement();\r\n\r\n\t\t\t\tif (e && e.nodeName == 'BODY')\r\n\t\t\t\t\treturn e.lastChild || e;\r\n\r\n\t\t\t\treturn e;\r\n\t\t\t} else {\r\n\t\t\t\te = r.endContainer;\r\n\t\t\t\teo = r.endOffset;\r\n\r\n\t\t\t\tif (e.nodeType == 1 && e.hasChildNodes())\r\n\t\t\t\t\te = e.childNodes[eo > 0 ? eo - 1 : eo];\r\n\r\n\t\t\t\tif (e && e.nodeType == 3)\r\n\t\t\t\t\treturn e.parentNode;\r\n\r\n\t\t\t\treturn e;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns a bookmark location for the current selection. This bookmark object\r\n\t\t * can then be used to restore the selection after some content modification to the document.\r\n\t\t *\r\n\t\t * @method getBookmark\r\n\t\t * @param {Number} type Optional state if the bookmark should be simple or not. Default is complex.\r\n\t\t * @param {Boolean} normalized Optional state that enables you to get a position that it would be after normalization.\r\n\t\t * @return {Object} Bookmark object, use moveToBookmark with this object to restore the selection.\r\n\t\t * @example\r\n\t\t * // Stores a bookmark of the current selection\r\n\t\t * var bm = tinyMCE.activeEditor.selection.getBookmark();\r\n\t\t * \r\n\t\t * tinyMCE.activeEditor.setContent(tinyMCE.activeEditor.getContent() + 'Some new content');\r\n\t\t * \r\n\t\t * // Restore the selection bookmark\r\n\t\t * tinyMCE.activeEditor.selection.moveToBookmark(bm);\r\n\t\t */\r\n\t\tgetBookmark : function(type, normalized) {\r\n\t\t\tvar t = this, dom = t.dom, rng, rng2, id, collapsed, name, element, index, chr = '\\uFEFF', styles;\r\n\r\n\t\t\tfunction findIndex(name, element) {\r\n\t\t\t\tvar index = 0;\r\n\r\n\t\t\t\teach(dom.select(name), function(node, i) {\r\n\t\t\t\t\tif (node == element)\r\n\t\t\t\t\t\tindex = i;\r\n\t\t\t\t});\r\n\r\n\t\t\t\treturn index;\r\n\t\t\t};\r\n\r\n\t\t\tif (type == 2) {\r\n\t\t\t\tfunction getLocation() {\r\n\t\t\t\t\tvar rng = t.getRng(true), root = dom.getRoot(), bookmark = {};\r\n\r\n\t\t\t\t\tfunction getPoint(rng, start) {\r\n\t\t\t\t\t\tvar container = rng[start ? 'startContainer' : 'endContainer'],\r\n\t\t\t\t\t\t\toffset = rng[start ? 'startOffset' : 'endOffset'], point = [], node, childNodes, after = 0;\r\n\r\n\t\t\t\t\t\tif (container.nodeType == 3) {\r\n\t\t\t\t\t\t\tif (normalized) {\r\n\t\t\t\t\t\t\t\tfor (node = container.previousSibling; node && node.nodeType == 3; node = node.previousSibling)\r\n\t\t\t\t\t\t\t\t\toffset += node.nodeValue.length;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tpoint.push(offset);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tchildNodes = container.childNodes;\r\n\r\n\t\t\t\t\t\t\tif (offset >= childNodes.length && childNodes.length) {\r\n\t\t\t\t\t\t\t\tafter = 1;\r\n\t\t\t\t\t\t\t\toffset = Math.max(0, childNodes.length - 1);\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tpoint.push(t.dom.nodeIndex(childNodes[offset], normalized) + after);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tfor (; container && container != root; container = container.parentNode)\r\n\t\t\t\t\t\t\tpoint.push(t.dom.nodeIndex(container, normalized));\r\n\r\n\t\t\t\t\t\treturn point;\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tbookmark.start = getPoint(rng, true);\r\n\r\n\t\t\t\t\tif (!t.isCollapsed())\r\n\t\t\t\t\t\tbookmark.end = getPoint(rng);\r\n\r\n\t\t\t\t\treturn bookmark;\r\n\t\t\t\t};\r\n\r\n\t\t\t\tif (t.tridentSel)\r\n\t\t\t\t\treturn t.tridentSel.getBookmark(type);\r\n\r\n\t\t\t\treturn getLocation();\r\n\t\t\t}\r\n\r\n\t\t\t// Handle simple range\r\n\t\t\tif (type)\r\n\t\t\t\treturn {rng : t.getRng()};\r\n\r\n\t\t\trng = t.getRng();\r\n\t\t\tid = dom.uniqueId();\r\n\t\t\tcollapsed = tinyMCE.activeEditor.selection.isCollapsed();\r\n\t\t\tstyles = 'overflow:hidden;line-height:0px';\r\n\r\n\t\t\t// Explorer method\r\n\t\t\tif (rng.duplicate || rng.item) {\r\n\t\t\t\t// Text selection\r\n\t\t\t\tif (!rng.item) {\r\n\t\t\t\t\trng2 = rng.duplicate();\r\n\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\t// Insert start marker\r\n\t\t\t\t\t\trng.collapse();\r\n\t\t\t\t\t\trng.pasteHTML('<span data-mce-type=\"bookmark\" id=\"' + id + '_start\" style=\"' + styles + '\">' + chr + '</span>');\r\n\r\n\t\t\t\t\t\t// Insert end marker\r\n\t\t\t\t\t\tif (!collapsed) {\r\n\t\t\t\t\t\t\trng2.collapse(false);\r\n\r\n\t\t\t\t\t\t\t// Detect the empty space after block elements in IE and move the end back one character <p></p>] becomes <p>]</p>\r\n\t\t\t\t\t\t\trng.moveToElementText(rng2.parentElement());\r\n\t\t\t\t\t\t\tif (rng.compareEndPoints('StartToEnd', rng2) == 0)\r\n\t\t\t\t\t\t\t\trng2.move('character', -1);\r\n\r\n\t\t\t\t\t\t\trng2.pasteHTML('<span data-mce-type=\"bookmark\" id=\"' + id + '_end\" style=\"' + styles + '\">' + chr + '</span>');\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} catch (ex) {\r\n\t\t\t\t\t\t// IE might throw unspecified error so lets ignore it\r\n\t\t\t\t\t\treturn null;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Control selection\r\n\t\t\t\t\telement = rng.item(0);\r\n\t\t\t\t\tname = element.nodeName;\r\n\r\n\t\t\t\t\treturn {name : name, index : findIndex(name, element)};\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\telement = t.getNode();\r\n\t\t\t\tname = element.nodeName;\r\n\t\t\t\tif (name == 'IMG')\r\n\t\t\t\t\treturn {name : name, index : findIndex(name, element)};\r\n\r\n\t\t\t\t// W3C method\r\n\t\t\t\trng2 = rng.cloneRange();\r\n\r\n\t\t\t\t// Insert end marker\r\n\t\t\t\tif (!collapsed) {\r\n\t\t\t\t\trng2.collapse(false);\r\n\t\t\t\t\trng2.insertNode(dom.create('span', {'data-mce-type' : \"bookmark\", id : id + '_end', style : styles}, chr));\r\n\t\t\t\t}\r\n\r\n\t\t\t\trng.collapse(true);\r\n\t\t\t\trng.insertNode(dom.create('span', {'data-mce-type' : \"bookmark\", id : id + '_start', style : styles}, chr));\r\n\t\t\t}\r\n\r\n\t\t\tt.moveToBookmark({id : id, keep : 1});\r\n\r\n\t\t\treturn {id : id};\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Restores the selection to the specified bookmark.\r\n\t\t *\r\n\t\t * @method moveToBookmark\r\n\t\t * @param {Object} bookmark Bookmark to restore selection from.\r\n\t\t * @return {Boolean} true/false if it was successful or not.\r\n\t\t * @example\r\n\t\t * // Stores a bookmark of the current selection\r\n\t\t * var bm = tinyMCE.activeEditor.selection.getBookmark();\r\n\t\t * \r\n\t\t * tinyMCE.activeEditor.setContent(tinyMCE.activeEditor.getContent() + 'Some new content');\r\n\t\t * \r\n\t\t * // Restore the selection bookmark\r\n\t\t * tinyMCE.activeEditor.selection.moveToBookmark(bm);\r\n\t\t */\r\n\t\tmoveToBookmark : function(bookmark) {\r\n\t\t\tvar t = this, dom = t.dom, marker1, marker2, rng, root, startContainer, endContainer, startOffset, endOffset;\r\n\r\n\t\t\tif (bookmark) {\r\n\t\t\t\tif (bookmark.start) {\r\n\t\t\t\t\trng = dom.createRng();\r\n\t\t\t\t\troot = dom.getRoot();\r\n\r\n\t\t\t\t\tfunction setEndPoint(start) {\r\n\t\t\t\t\t\tvar point = bookmark[start ? 'start' : 'end'], i, node, offset, children;\r\n\r\n\t\t\t\t\t\tif (point) {\r\n\t\t\t\t\t\t\toffset = point[0];\r\n\r\n\t\t\t\t\t\t\t// Find container node\r\n\t\t\t\t\t\t\tfor (node = root, i = point.length - 1; i >= 1; i--) {\r\n\t\t\t\t\t\t\t\tchildren = node.childNodes;\r\n\r\n\t\t\t\t\t\t\t\tif (point[i] > children.length - 1)\r\n\t\t\t\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t\t\t\tnode = children[point[i]];\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// Move text offset to best suitable location\r\n\t\t\t\t\t\t\tif (node.nodeType === 3)\r\n\t\t\t\t\t\t\t\toffset = Math.min(point[0], node.nodeValue.length);\r\n\r\n\t\t\t\t\t\t\t// Move element offset to best suitable location\r\n\t\t\t\t\t\t\tif (node.nodeType === 1)\r\n\t\t\t\t\t\t\t\toffset = Math.min(point[0], node.childNodes.length);\r\n\r\n\t\t\t\t\t\t\t// Set offset within container node\r\n\t\t\t\t\t\t\tif (start)\r\n\t\t\t\t\t\t\t\trng.setStart(node, offset);\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\trng.setEnd(node, offset);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tif (t.tridentSel)\r\n\t\t\t\t\t\treturn t.tridentSel.moveToBookmark(bookmark);\r\n\r\n\t\t\t\t\tif (setEndPoint(true) && setEndPoint()) {\r\n\t\t\t\t\t\tt.setRng(rng);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (bookmark.id) {\r\n\t\t\t\t\tfunction restoreEndPoint(suffix) {\r\n\t\t\t\t\t\tvar marker = dom.get(bookmark.id + '_' + suffix), node, idx, next, prev, keep = bookmark.keep;\r\n\r\n\t\t\t\t\t\tif (marker) {\r\n\t\t\t\t\t\t\tnode = marker.parentNode;\r\n\r\n\t\t\t\t\t\t\tif (suffix == 'start') {\r\n\t\t\t\t\t\t\t\tif (!keep) {\r\n\t\t\t\t\t\t\t\t\tidx = dom.nodeIndex(marker);\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tnode = marker.firstChild;\r\n\t\t\t\t\t\t\t\t\tidx = 1;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tstartContainer = endContainer = node;\r\n\t\t\t\t\t\t\t\tstartOffset = endOffset = idx;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tif (!keep) {\r\n\t\t\t\t\t\t\t\t\tidx = dom.nodeIndex(marker);\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tnode = marker.firstChild;\r\n\t\t\t\t\t\t\t\t\tidx = 1;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tendContainer = node;\r\n\t\t\t\t\t\t\t\tendOffset = idx;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif (!keep) {\r\n\t\t\t\t\t\t\t\tprev = marker.previousSibling;\r\n\t\t\t\t\t\t\t\tnext = marker.nextSibling;\r\n\r\n\t\t\t\t\t\t\t\t// Remove all marker text nodes\r\n\t\t\t\t\t\t\t\teach(tinymce.grep(marker.childNodes), function(node) {\r\n\t\t\t\t\t\t\t\t\tif (node.nodeType == 3)\r\n\t\t\t\t\t\t\t\t\t\tnode.nodeValue = node.nodeValue.replace(/\\uFEFF/g, '');\r\n\t\t\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t\t\t// Remove marker but keep children if for example contents where inserted into the marker\r\n\t\t\t\t\t\t\t\t// Also remove duplicated instances of the marker for example by a split operation or by WebKit auto split on paste feature\r\n\t\t\t\t\t\t\t\twhile (marker = dom.get(bookmark.id + '_' + suffix))\r\n\t\t\t\t\t\t\t\t\tdom.remove(marker, 1);\r\n\r\n\t\t\t\t\t\t\t\t// If siblings are text nodes then merge them unless it's Opera since it some how removes the node\r\n\t\t\t\t\t\t\t\t// and we are sniffing since adding a lot of detection code for a browser with 3% of the market isn't worth the effort. Sorry, Opera but it's just a fact\r\n\t\t\t\t\t\t\t\tif (prev && next && prev.nodeType == next.nodeType && prev.nodeType == 3 && !tinymce.isOpera) {\r\n\t\t\t\t\t\t\t\t\tidx = prev.nodeValue.length;\r\n\t\t\t\t\t\t\t\t\tprev.appendData(next.nodeValue);\r\n\t\t\t\t\t\t\t\t\tdom.remove(next);\r\n\r\n\t\t\t\t\t\t\t\t\tif (suffix == 'start') {\r\n\t\t\t\t\t\t\t\t\t\tstartContainer = endContainer = prev;\r\n\t\t\t\t\t\t\t\t\t\tstartOffset = endOffset = idx;\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\tendContainer = prev;\r\n\t\t\t\t\t\t\t\t\t\tendOffset = idx;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tfunction addBogus(node) {\r\n\t\t\t\t\t\t// Adds a bogus BR element for empty block elements or just a space on IE since it renders BR elements incorrectly\r\n\t\t\t\t\t\tif (dom.isBlock(node) && !node.innerHTML)\r\n\t\t\t\t\t\t\tnode.innerHTML = !isIE ? '<br data-mce-bogus=\"1\" />' : ' ';\r\n\r\n\t\t\t\t\t\treturn node;\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\t// Restore start/end points\r\n\t\t\t\t\trestoreEndPoint('start');\r\n\t\t\t\t\trestoreEndPoint('end');\r\n\r\n\t\t\t\t\tif (startContainer) {\r\n\t\t\t\t\t\trng = dom.createRng();\r\n\t\t\t\t\t\trng.setStart(addBogus(startContainer), startOffset);\r\n\t\t\t\t\t\trng.setEnd(addBogus(endContainer), endOffset);\r\n\t\t\t\t\t\tt.setRng(rng);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (bookmark.name) {\r\n\t\t\t\t\tt.select(dom.select(bookmark.name)[bookmark.index]);\r\n\t\t\t\t} else if (bookmark.rng)\r\n\t\t\t\t\tt.setRng(bookmark.rng);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Selects the specified element. This will place the start and end of the selection range around the element.\r\n\t\t *\r\n\t\t * @method select\r\n\t\t * @param {Element} node HMTL DOM element to select.\r\n\t\t * @param {Boolean} content Optional bool state if the contents should be selected or not on non IE browser.\r\n\t\t * @return {Element} Selected element the same element as the one that got passed in.\r\n\t\t * @example\r\n\t\t * // Select the first paragraph in the active editor\r\n\t\t * tinyMCE.activeEditor.selection.select(tinyMCE.activeEditor.dom.select('p')[0]);\r\n\t\t */\r\n\t\tselect : function(node, content) {\r\n\t\t\tvar t = this, dom = t.dom, rng = dom.createRng(), idx;\r\n\r\n\t\t\tif (node) {\r\n\t\t\t\tidx = dom.nodeIndex(node);\r\n\t\t\t\trng.setStart(node.parentNode, idx);\r\n\t\t\t\trng.setEnd(node.parentNode, idx + 1);\r\n\r\n\t\t\t\t// Find first/last text node or BR element\r\n\t\t\t\tif (content) {\r\n\t\t\t\t\tfunction setPoint(node, start) {\r\n\t\t\t\t\t\tvar walker = new tinymce.dom.TreeWalker(node, node);\r\n\r\n\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\t// Text node\r\n\t\t\t\t\t\t\tif (node.nodeType == 3 && tinymce.trim(node.nodeValue).length != 0) {\r\n\t\t\t\t\t\t\t\tif (start)\r\n\t\t\t\t\t\t\t\t\trng.setStart(node, 0);\r\n\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\trng.setEnd(node, node.nodeValue.length);\r\n\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// BR element\r\n\t\t\t\t\t\t\tif (node.nodeName == 'BR') {\r\n\t\t\t\t\t\t\t\tif (start)\r\n\t\t\t\t\t\t\t\t\trng.setStartBefore(node);\r\n\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\trng.setEndBefore(node);\r\n\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} while (node = (start ? walker.next() : walker.prev()));\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tsetPoint(node, 1);\r\n\t\t\t\t\tsetPoint(node);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tt.setRng(rng);\r\n\t\t\t}\r\n\r\n\t\t\treturn node;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns true/false if the selection range is collapsed or not. Collapsed means if it's a caret or a larger selection.\r\n\t\t *\r\n\t\t * @method isCollapsed\r\n\t\t * @return {Boolean} true/false state if the selection range is collapsed or not. Collapsed means if it's a caret or a larger selection.\r\n\t\t */\r\n\t\tisCollapsed : function() {\r\n\t\t\tvar t = this, r = t.getRng(), s = t.getSel();\r\n\r\n\t\t\tif (!r || r.item)\r\n\t\t\t\treturn false;\r\n\r\n\t\t\tif (r.compareEndPoints)\r\n\t\t\t\treturn r.compareEndPoints('StartToEnd', r) === 0;\r\n\r\n\t\t\treturn !s || r.collapsed;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Collapse the selection to start or end of range.\r\n\t\t *\r\n\t\t * @method collapse\r\n\t\t * @param {Boolean} to_start Optional boolean state if to collapse to end or not. Defaults to start.\r\n\t\t */\r\n\t\tcollapse : function(to_start) {\r\n\t\t\tvar self = this, rng = self.getRng(), node;\r\n\r\n\t\t\t// Control range on IE\r\n\t\t\tif (rng.item) {\r\n\t\t\t\tnode = rng.item(0);\r\n\t\t\t\trng = self.win.document.body.createTextRange();\r\n\t\t\t\trng.moveToElementText(node);\r\n\t\t\t}\r\n\r\n\t\t\trng.collapse(!!to_start);\r\n\t\t\tself.setRng(rng);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns the browsers internal selection object.\r\n\t\t *\r\n\t\t * @method getSel\r\n\t\t * @return {Selection} Internal browser selection object.\r\n\t\t */\r\n\t\tgetSel : function() {\r\n\t\t\tvar t = this, w = this.win;\r\n\r\n\t\t\treturn w.getSelection ? w.getSelection() : w.document.selection;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns the browsers internal range object.\r\n\t\t *\r\n\t\t * @method getRng\r\n\t\t * @param {Boolean} w3c Forces a compatible W3C range on IE.\r\n\t\t * @return {Range} Internal browser range object.\r\n\t\t * @see http://www.quirksmode.org/dom/range_intro.html\r\n\t\t * @see http://www.dotvoid.com/2001/03/using-the-range-object-in-mozilla/\r\n\t\t */\r\n\t\tgetRng : function(w3c) {\r\n\t\t\tvar t = this, s, r, elm, doc = t.win.document;\r\n\r\n\t\t\t// Found tridentSel object then we need to use that one\r\n\t\t\tif (w3c && t.tridentSel)\r\n\t\t\t\treturn t.tridentSel.getRangeAt(0);\r\n\r\n\t\t\ttry {\r\n\t\t\t\tif (s = t.getSel())\r\n\t\t\t\t\tr = s.rangeCount > 0 ? s.getRangeAt(0) : (s.createRange ? s.createRange() : doc.createRange());\r\n\t\t\t} catch (ex) {\r\n\t\t\t\t// IE throws unspecified error here if TinyMCE is placed in a frame/iframe\r\n\t\t\t}\r\n\r\n\t\t\t// We have W3C ranges and it's IE then fake control selection since IE9 doesn't handle that correctly yet\r\n\t\t\tif (tinymce.isIE && r && r.setStart && doc.selection.createRange().item) {\r\n\t\t\t\telm = doc.selection.createRange().item(0);\r\n\t\t\t\tr = doc.createRange();\r\n\t\t\t\tr.setStartBefore(elm);\r\n\t\t\t\tr.setEndAfter(elm);\r\n\t\t\t}\r\n\r\n\t\t\t// No range found then create an empty one\r\n\t\t\t// This can occur when the editor is placed in a hidden container element on Gecko\r\n\t\t\t// Or on IE when there was an exception\r\n\t\t\tif (!r)\r\n\t\t\t\tr = doc.createRange ? doc.createRange() : doc.body.createTextRange();\r\n\r\n\t\t\tif (t.selectedRange && t.explicitRange) {\r\n\t\t\t\tif (r.compareBoundaryPoints(r.START_TO_START, t.selectedRange) === 0 && r.compareBoundaryPoints(r.END_TO_END, t.selectedRange) === 0) {\r\n\t\t\t\t\t// Safari, Opera and Chrome only ever select text which causes the range to change.\r\n\t\t\t\t\t// This lets us use the originally set range if the selection hasn't been changed by the user.\r\n\t\t\t\t\tr = t.explicitRange;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tt.selectedRange = null;\r\n\t\t\t\t\tt.explicitRange = null;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn r;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Changes the selection to the specified DOM range.\r\n\t\t *\r\n\t\t * @method setRng\r\n\t\t * @param {Range} r Range to select.\r\n\t\t */\r\n\t\tsetRng : function(r) {\r\n\t\t\tvar s, t = this;\r\n\t\t\t\r\n\t\t\tif (!t.tridentSel) {\r\n\t\t\t\ts = t.getSel();\r\n\r\n\t\t\t\tif (s) {\r\n\t\t\t\t\tt.explicitRange = r;\r\n\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\ts.removeAllRanges();\r\n\t\t\t\t\t} catch (ex) {\r\n\t\t\t\t\t\t// IE9 might throw errors here don't know why\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ts.addRange(r);\r\n\t\t\t\t\tt.selectedRange = s.getRangeAt(0);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t// Is W3C Range\r\n\t\t\t\tif (r.cloneRange) {\r\n\t\t\t\t\tt.tridentSel.addRange(r);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Is IE specific range\r\n\t\t\t\ttry {\r\n\t\t\t\t\tr.select();\r\n\t\t\t\t} catch (ex) {\r\n\t\t\t\t\t// Needed for some odd IE bug #1843306\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Sets the current selection to the specified DOM element.\r\n\t\t *\r\n\t\t * @method setNode\r\n\t\t * @param {Element} n Element to set as the contents of the selection.\r\n\t\t * @return {Element} Returns the element that got passed in.\r\n\t\t * @example\r\n\t\t * // Inserts a DOM node at current selection/caret location\r\n\t\t * tinyMCE.activeEditor.selection.setNode(tinyMCE.activeEditor.dom.create('img', {src : 'some.gif', title : 'some title'}));\r\n\t\t */\r\n\t\tsetNode : function(n) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\tt.setContent(t.dom.getOuterHTML(n));\r\n\r\n\t\t\treturn n;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns the currently selected element or the common ancestor element for both start and end of the selection.\r\n\t\t *\r\n\t\t * @method getNode\r\n\t\t * @return {Element} Currently selected element or common ancestor element.\r\n\t\t * @example\r\n\t\t * // Alerts the currently selected elements node name\r\n\t\t * alert(tinyMCE.activeEditor.selection.getNode().nodeName);\r\n\t\t */\r\n\t\tgetNode : function() {\r\n\t\t\tvar t = this, rng = t.getRng(), sel = t.getSel(), elm, start = rng.startContainer, end = rng.endContainer;\r\n\r\n\t\t\t// Range maybe lost after the editor is made visible again\r\n\t\t\tif (!rng)\r\n\t\t\t\treturn t.dom.getRoot();\r\n\r\n\t\t\tif (rng.setStart) {\r\n\t\t\t\telm = rng.commonAncestorContainer;\r\n\r\n\t\t\t\t// Handle selection a image or other control like element such as anchors\r\n\t\t\t\tif (!rng.collapsed) {\r\n\t\t\t\t\tif (rng.startContainer == rng.endContainer) {\r\n\t\t\t\t\t\tif (rng.endOffset - rng.startOffset < 2) {\r\n\t\t\t\t\t\t\tif (rng.startContainer.hasChildNodes())\r\n\t\t\t\t\t\t\t\telm = rng.startContainer.childNodes[rng.startOffset];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// If the anchor node is a element instead of a text node then return this element\r\n\t\t\t\t\t//if (tinymce.isWebKit && sel.anchorNode && sel.anchorNode.nodeType == 1) \r\n\t\t\t\t\t//\treturn sel.anchorNode.childNodes[sel.anchorOffset];\r\n\r\n\t\t\t\t\t// Handle cases where the selection is immediately wrapped around a node and return that node instead of it's parent.\r\n\t\t\t\t\t// This happens when you double click an underlined word in FireFox.\r\n\t\t\t\t\tif (start.nodeType === 3 && end.nodeType === 3) {\r\n\t\t\t\t\t\tfunction skipEmptyTextNodes(n, forwards) {\r\n\t\t\t\t\t\t\tvar orig = n;\r\n\t\t\t\t\t\t\twhile (n && n.nodeType === 3 && n.length === 0) {\r\n\t\t\t\t\t\t\t\tn = forwards ? n.nextSibling : n.previousSibling;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn n || orig;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (start.length === rng.startOffset) {\r\n\t\t\t\t\t\t\tstart = skipEmptyTextNodes(start.nextSibling, true);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tstart = start.parentNode;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (rng.endOffset === 0) {\r\n\t\t\t\t\t\t\tend = skipEmptyTextNodes(end.previousSibling, false);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tend = end.parentNode;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (start && start === end)\r\n\t\t\t\t\t\t\treturn start;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (elm && elm.nodeType == 3)\r\n\t\t\t\t\treturn elm.parentNode;\r\n\r\n\t\t\t\treturn elm;\r\n\t\t\t}\r\n\r\n\t\t\treturn rng.item ? rng.item(0) : rng.parentElement();\r\n\t\t},\r\n\r\n\t\tgetSelectedBlocks : function(st, en) {\r\n\t\t\tvar t = this, dom = t.dom, sb, eb, n, bl = [];\r\n\r\n\t\t\tsb = dom.getParent(st || t.getStart(), dom.isBlock);\r\n\t\t\teb = dom.getParent(en || t.getEnd(), dom.isBlock);\r\n\r\n\t\t\tif (sb)\r\n\t\t\t\tbl.push(sb);\r\n\r\n\t\t\tif (sb && eb && sb != eb) {\r\n\t\t\t\tn = sb;\r\n\r\n\t\t\t\tvar walker = new tinymce.dom.TreeWalker(sb, dom.getRoot());\r\n\t\t\t\twhile ((n = walker.next()) && n != eb) {\r\n\t\t\t\t\tif (dom.isBlock(n))\r\n\t\t\t\t\t\tbl.push(n);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (eb && sb != eb)\r\n\t\t\t\tbl.push(eb);\r\n\r\n\t\t\treturn bl;\r\n\t\t},\r\n\r\n\t\tnormalize : function() {\r\n\t\t\tvar self = this, rng, normalized;\r\n\r\n\t\t\t// Normalize only on non IE browsers for now\r\n\t\t\tif (tinymce.isIE)\r\n\t\t\t\treturn;\r\n\r\n\t\t\tfunction normalizeEndPoint(start) {\r\n\t\t\t\tvar container, offset, walker, dom = self.dom, body = dom.getRoot(), node;\r\n\r\n\t\t\t\tcontainer = rng[(start ? 'start' : 'end') + 'Container'];\r\n\t\t\t\toffset = rng[(start ? 'start' : 'end') + 'Offset'];\r\n\r\n\t\t\t\t// If the container is a document move it to the body element\r\n\t\t\t\tif (container.nodeType === 9) {\r\n\t\t\t\t\tcontainer = container.body;\r\n\t\t\t\t\toffset = 0;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// If the container is body try move it into the closest text node or position\r\n\t\t\t\t// TODO: Add more logic here to handle element selection cases\r\n\t\t\t\tif (container === body) {\r\n\t\t\t\t\t// Resolve the index\r\n\t\t\t\t\tif (container.hasChildNodes()) {\r\n\t\t\t\t\t\tcontainer = container.childNodes[Math.min(!start && offset > 0 ? offset - 1 : offset, container.childNodes.length - 1)];\r\n\t\t\t\t\t\toffset = 0;\r\n\r\n\t\t\t\t\t\t// Don't walk into elements that doesn't have any child nodes like a IMG\r\n\t\t\t\t\t\tif (container.hasChildNodes()) {\r\n\t\t\t\t\t\t\t// Walk the DOM to find a text node to place the caret at or a BR\r\n\t\t\t\t\t\t\tnode = container;\r\n\t\t\t\t\t\t\twalker = new tinymce.dom.TreeWalker(container, body);\r\n\t\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\t\t// Found a text node use that position\r\n\t\t\t\t\t\t\t\tif (node.nodeType === 3) {\r\n\t\t\t\t\t\t\t\t\toffset = start ? 0 : node.nodeValue.length - 1;\r\n\t\t\t\t\t\t\t\t\tcontainer = node;\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t// Found a BR element that we can place the caret before\r\n\t\t\t\t\t\t\t\tif (node.nodeName === 'BR') {\r\n\t\t\t\t\t\t\t\t\toffset = dom.nodeIndex(node);\r\n\t\t\t\t\t\t\t\t\tcontainer = node.parentNode;\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} while (node = (start ? walker.next() : walker.prev()));\r\n\r\n\t\t\t\t\t\t\tnormalized = true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Set endpoint if it was normalized\r\n\t\t\t\tif (normalized)\r\n\t\t\t\t\trng['set' + (start ? 'Start' : 'End')](container, offset);\r\n\t\t\t};\r\n\r\n\t\t\trng = self.getRng();\r\n\r\n\t\t\t// Normalize the end points\r\n\t\t\tnormalizeEndPoint(true);\r\n\t\t\t\r\n\t\t\tif (rng.collapsed)\r\n\t\t\t\tnormalizeEndPoint();\r\n\r\n\t\t\t// Set the selection if it was normalized\r\n\t\t\tif (normalized) {\r\n\t\t\t\t//console.log(self.dom.dumpRng(rng));\r\n\t\t\t\tself.setRng(rng);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tdestroy : function(s) {\r\n\t\t\tvar t = this;\r\n\r\n\t\t\tt.win = null;\r\n\r\n\t\t\t// Manual destroy then remove unload handler\r\n\t\t\tif (!s)\r\n\t\t\t\ttinymce.removeUnload(t.destroy);\r\n\t\t},\r\n\r\n\t\t// IE has an issue where you can't select/move the caret by clicking outside the body if the document is in standards mode\r\n\t\t_fixIESelection : function() {\r\n\t\t\tvar dom = this.dom, doc = dom.doc, body = doc.body, started, startRng, htmlElm;\r\n\r\n\t\t\t// Make HTML element unselectable since we are going to handle selection by hand\r\n\t\t\tdoc.documentElement.unselectable = true;\r\n\r\n\t\t\t// Return range from point or null if it failed\r\n\t\t\tfunction rngFromPoint(x, y) {\r\n\t\t\t\tvar rng = body.createTextRange();\r\n\r\n\t\t\t\ttry {\r\n\t\t\t\t\trng.moveToPoint(x, y);\r\n\t\t\t\t} catch (ex) {\r\n\t\t\t\t\t// IE sometimes throws and exception, so lets just ignore it\r\n\t\t\t\t\trng = null;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn rng;\r\n\t\t\t};\r\n\r\n\t\t\t// Fires while the selection is changing\r\n\t\t\tfunction selectionChange(e) {\r\n\t\t\t\tvar pointRng;\r\n\r\n\t\t\t\t// Check if the button is down or not\r\n\t\t\t\tif (e.button) {\r\n\t\t\t\t\t// Create range from mouse position\r\n\t\t\t\t\tpointRng = rngFromPoint(e.x, e.y);\r\n\r\n\t\t\t\t\tif (pointRng) {\r\n\t\t\t\t\t\t// Check if pointRange is before/after selection then change the endPoint\r\n\t\t\t\t\t\tif (pointRng.compareEndPoints('StartToStart', startRng) > 0)\r\n\t\t\t\t\t\t\tpointRng.setEndPoint('StartToStart', startRng);\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tpointRng.setEndPoint('EndToEnd', startRng);\r\n\r\n\t\t\t\t\t\tpointRng.select();\r\n\t\t\t\t\t}\r\n\t\t\t\t} else\r\n\t\t\t\t\tendSelection();\r\n\t\t\t}\r\n\r\n\t\t\t// Removes listeners\r\n\t\t\tfunction endSelection() {\r\n\t\t\t\tvar rng = doc.selection.createRange();\r\n\r\n\t\t\t\t// If the range is collapsed then use the last start range\r\n\t\t\t\tif (startRng && !rng.item && rng.compareEndPoints('StartToEnd', rng) === 0)\r\n\t\t\t\t\tstartRng.select();\r\n\r\n\t\t\t\tdom.unbind(doc, 'mouseup', endSelection);\r\n\t\t\t\tdom.unbind(doc, 'mousemove', selectionChange);\r\n\t\t\t\tstartRng = started = 0;\r\n\t\t\t};\r\n\r\n\t\t\t// Detect when user selects outside BODY\r\n\t\t\tdom.bind(doc, ['mousedown', 'contextmenu'], function(e) {\r\n\t\t\t\tif (e.target.nodeName === 'HTML') {\r\n\t\t\t\t\tif (started)\r\n\t\t\t\t\t\tendSelection();\r\n\r\n\t\t\t\t\t// Detect vertical scrollbar, since IE will fire a mousedown on the scrollbar and have target set as HTML\r\n\t\t\t\t\thtmlElm = doc.documentElement;\r\n\t\t\t\t\tif (htmlElm.scrollHeight > htmlElm.clientHeight)\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\tstarted = 1;\r\n\t\t\t\t\t// Setup start position\r\n\t\t\t\t\tstartRng = rngFromPoint(e.x, e.y);\r\n\t\t\t\t\tif (startRng) {\r\n\t\t\t\t\t\t// Listen for selection change events\r\n\t\t\t\t\t\tdom.bind(doc, 'mouseup', endSelection);\r\n\t\t\t\t\t\tdom.bind(doc, 'mousemove', selectionChange);\r\n\r\n\t\t\t\t\t\tdom.win.focus();\r\n\t\t\t\t\t\tstartRng.select();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t});\r\n})(tinymce);\r\n","Magento_Tinymce3/tiny_mce/classes/dom/Serializer.js":"/**\r\n * Serializer.js\r\n *\r\n * Copyright 2009, Moxiecode Systems AB\r\n * Released under LGPL License.\r\n *\r\n * License: http://tinymce.moxiecode.com/license\r\n * Contributing: http://tinymce.moxiecode.com/contributing\r\n */\r\n\r\n(function(tinymce) {\r\n\t/**\r\n\t * This class is used to serialize DOM trees into a string. Consult the TinyMCE Wiki API for more details and examples on how to use this class. \r\n\t *\r\n\t * @class tinymce.dom.Serializer\r\n\t */\r\n\r\n\t/**\r\n\t * Constucts a new DOM serializer class.\r\n\t *\r\n\t * @constructor\r\n\t * @method Serializer\r\n\t * @param {Object} settings Serializer settings object.\r\n\t * @param {tinymce.dom.DOMUtils} dom DOMUtils instance reference.\r\n\t * @param {tinymce.html.Schema} schema Optional schema reference.\r\n\t */\r\n\ttinymce.dom.Serializer = function(settings, dom, schema) {\r\n\t\tvar onPreProcess, onPostProcess, isIE = tinymce.isIE, each = tinymce.each, htmlParser;\r\n\r\n\t\t// Support the old apply_source_formatting option\r\n\t\tif (!settings.apply_source_formatting)\r\n\t\t\tsettings.indent = false;\r\n\r\n\t\tsettings.remove_trailing_brs = true;\r\n\r\n\t\t// Default DOM and Schema if they are undefined\r\n\t\tdom = dom || tinymce.DOM;\r\n\t\tschema = schema || new tinymce.html.Schema(settings);\r\n\t\tsettings.entity_encoding = settings.entity_encoding || 'named';\r\n\r\n\t\t/**\r\n\t\t * This event gets executed before a HTML fragment gets serialized into a HTML string. This event enables you to do modifications to the DOM before the serialization occurs. It's important to know that the element that is getting serialized is cloned so it's not inside a document.\r\n\t\t *\r\n\t\t * @event onPreProcess\r\n\t\t * @param {tinymce.dom.Serializer} sender object/Serializer instance that is serializing an element.\r\n\t\t * @param {Object} args Object containing things like the current node.\r\n\t\t * @example\r\n\t\t * // Adds an observer to the onPreProcess event\r\n\t\t * serializer.onPreProcess.add(function(se, o) {\r\n\t\t *     // Add a class to each paragraph\r\n\t\t *     se.dom.addClass(se.dom.select('p', o.node), 'myclass');\r\n\t\t * });\r\n\t\t */\r\n\t\tonPreProcess = new tinymce.util.Dispatcher(self);\r\n\r\n\t\t/**\r\n\t\t * This event gets executed after a HTML fragment has been serialized into a HTML string. This event enables you to do modifications to the HTML string like regexp replaces etc. \r\n\t\t *\r\n\t\t * @event onPreProcess\r\n\t\t * @param {tinymce.dom.Serializer} sender object/Serializer instance that is serializing an element.\r\n\t\t * @param {Object} args Object containing things like the current contents. \r\n\t\t * @example\r\n\t\t * // Adds an observer to the onPostProcess event\r\n\t\t * serializer.onPostProcess.add(function(se, o) {\r\n\t\t *    // Remove all paragraphs and replace with BR\r\n\t\t *    o.content = o.content.replace(/<p[^>]+>|<p>/g, '');\r\n\t\t *    o.content = o.content.replace(/<\\/p>/g, '<br />');\r\n\t\t * });\r\n\t\t */\r\n\t\tonPostProcess = new tinymce.util.Dispatcher(self);\r\n\r\n\t\thtmlParser = new tinymce.html.DomParser(settings, schema);\r\n\r\n\t\t// Convert move data-mce-src, data-mce-href and data-mce-style into nodes or process them if needed\r\n\t\thtmlParser.addAttributeFilter('src,href,style', function(nodes, name) {\r\n\t\t\tvar i = nodes.length, node, value, internalName = 'data-mce-' + name, urlConverter = settings.url_converter, urlConverterScope = settings.url_converter_scope, undef;\r\n\r\n\t\t\twhile (i--) {\r\n\t\t\t\tnode = nodes[i];\r\n\r\n\t\t\t\tvalue = node.attributes.map[internalName];\r\n\t\t\t\tif (value !== undef) {\r\n\t\t\t\t\t// Set external name to internal value and remove internal\r\n\t\t\t\t\tnode.attr(name, value.length > 0 ? value : null);\r\n\t\t\t\t\tnode.attr(internalName, null);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// No internal attribute found then convert the value we have in the DOM\r\n\t\t\t\t\tvalue = node.attributes.map[name];\r\n\r\n\t\t\t\t\tif (name === \"style\")\r\n\t\t\t\t\t\tvalue = dom.serializeStyle(dom.parseStyle(value), node.name);\r\n\t\t\t\t\telse if (urlConverter)\r\n\t\t\t\t\t\tvalue = urlConverter.call(urlConverterScope, value, name, node.name);\r\n\r\n\t\t\t\t\tnode.attr(name, value.length > 0 ? value : null);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// Remove internal classes mceItem<..>\r\n\t\thtmlParser.addAttributeFilter('class', function(nodes, name) {\r\n\t\t\tvar i = nodes.length, node, value;\r\n\r\n\t\t\twhile (i--) {\r\n\t\t\t\tnode = nodes[i];\r\n\t\t\t\tvalue = node.attr('class').replace(/\\s*mce(Item\\w+|Selected)\\s*/g, '');\r\n\t\t\t\tnode.attr('class', value.length > 0 ? value : null);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// Remove bookmark elements\r\n\t\thtmlParser.addAttributeFilter('data-mce-type', function(nodes, name, args) {\r\n\t\t\tvar i = nodes.length, node;\r\n\r\n\t\t\twhile (i--) {\r\n\t\t\t\tnode = nodes[i];\r\n\r\n\t\t\t\tif (node.attributes.map['data-mce-type'] === 'bookmark' && !args.cleanup)\r\n\t\t\t\t\tnode.remove();\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// Force script into CDATA sections and remove the mce- prefix also add comments around styles\r\n\t\thtmlParser.addNodeFilter('script,style', function(nodes, name) {\r\n\t\t\tvar i = nodes.length, node, value;\r\n\r\n\t\t\tfunction trim(value) {\r\n\t\t\t\treturn value.replace(/(<!--\\[CDATA\\[|\\]\\]-->)/g, '\\n')\r\n\t\t\t\t\t\t.replace(/^[\\r\\n]*|[\\r\\n]*$/g, '')\r\n\t\t\t\t\t\t.replace(/^\\s*(\\/\\/\\s*<!--|\\/\\/\\s*<!\\[CDATA\\[|<!--|<!\\[CDATA\\[)[\\r\\n]*/g, '')\r\n\t\t\t\t\t\t.replace(/\\s*(\\/\\/\\s*\\]\\]>|\\/\\/\\s*-->|\\]\\]>|-->|\\]\\]-->)\\s*$/g, '');\r\n\t\t\t};\r\n\r\n\t\t\twhile (i--) {\r\n\t\t\t\tnode = nodes[i];\r\n\t\t\t\tvalue = node.firstChild ? node.firstChild.value : '';\r\n\r\n\t\t\t\tif (name === \"script\") {\r\n\t\t\t\t\t// Remove mce- prefix from script elements\r\n\t\t\t\t\tnode.attr('type', (node.attr('type') || 'text/javascript').replace(/^mce\\-/, ''));\r\n\r\n\t\t\t\t\tif (value.length > 0)\r\n\t\t\t\t\t\tnode.firstChild.value = '// <![CDATA[\\n' + trim(value) + '\\n// ]]>';\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (value.length > 0)\r\n\t\t\t\t\t\tnode.firstChild.value = '<!--\\n' + trim(value) + '\\n-->';\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// Convert comments to cdata and handle protected comments\r\n\t\thtmlParser.addNodeFilter('#comment', function(nodes, name) {\r\n\t\t\tvar i = nodes.length, node;\r\n\r\n\t\t\twhile (i--) {\r\n\t\t\t\tnode = nodes[i];\r\n\r\n\t\t\t\tif (node.value.indexOf('[CDATA[') === 0) {\r\n\t\t\t\t\tnode.name = '#cdata';\r\n\t\t\t\t\tnode.type = 4;\r\n\t\t\t\t\tnode.value = node.value.replace(/^\\[CDATA\\[|\\]\\]$/g, '');\r\n\t\t\t\t} else if (node.value.indexOf('mce:protected ') === 0) {\r\n\t\t\t\t\tnode.name = \"#text\";\r\n\t\t\t\t\tnode.type = 3;\r\n\t\t\t\t\tnode.raw = true;\r\n\t\t\t\t\tnode.value = unescape(node.value).substr(14);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\thtmlParser.addNodeFilter('xml:namespace,input', function(nodes, name) {\r\n\t\t\tvar i = nodes.length, node;\r\n\r\n\t\t\twhile (i--) {\r\n\t\t\t\tnode = nodes[i];\r\n\t\t\t\tif (node.type === 7)\r\n\t\t\t\t\tnode.remove();\r\n\t\t\t\telse if (node.type === 1) {\r\n\t\t\t\t\tif (name === \"input\" && !(\"type\" in node.attributes.map))\r\n\t\t\t\t\t\tnode.attr('type', 'text');\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// Fix list elements, TODO: Replace this later\r\n\t\tif (settings.fix_list_elements) {\r\n\t\t\thtmlParser.addNodeFilter('ul,ol', function(nodes, name) {\r\n\t\t\t\tvar i = nodes.length, node, parentNode;\r\n\r\n\t\t\t\twhile (i--) {\r\n\t\t\t\t\tnode = nodes[i];\r\n\t\t\t\t\tparentNode = node.parent;\r\n\r\n\t\t\t\t\tif (parentNode.name === 'ul' || parentNode.name === 'ol') {\r\n\t\t\t\t\t\tif (node.prev && node.prev.name === 'li') {\r\n\t\t\t\t\t\t\tnode.prev.append(node);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\t// Remove internal data attributes\r\n\t\thtmlParser.addAttributeFilter('data-mce-src,data-mce-href,data-mce-style', function(nodes, name) {\r\n\t\t\tvar i = nodes.length;\r\n\r\n\t\t\twhile (i--) {\r\n\t\t\t\tnodes[i].attr(name, null);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// Return public methods\r\n\t\treturn {\r\n\t\t\t/**\r\n\t\t\t * Schema instance that was used to when the Serializer was constructed.\r\n\t\t\t *\r\n\t\t\t * @field {tinymce.html.Schema} schema\r\n\t\t\t */\r\n\t\t\tschema : schema,\r\n\r\n\t\t\t/**\r\n\t\t\t * Adds a node filter function to the parser used by the serializer, the parser will collect the specified nodes by name\r\n\t\t\t * and then execute the callback ones it has finished parsing the document.\r\n\t\t\t *\r\n\t\t\t * @example\r\n\t\t\t * parser.addNodeFilter('p,h1', function(nodes, name) {\r\n\t\t\t *\t\tfor (var i = 0; i < nodes.length; i++) {\r\n\t\t\t *\t\t\tconsole.log(nodes[i].name);\r\n\t\t\t *\t\t}\r\n\t\t\t * });\r\n\t\t\t * @method addNodeFilter\r\n\t\t\t * @method {String} name Comma separated list of nodes to collect.\r\n\t\t\t * @param {function} callback Callback function to execute once it has collected nodes.\r\n\t\t\t */\r\n\t\t\taddNodeFilter : htmlParser.addNodeFilter,\r\n\r\n\t\t\t/**\r\n\t\t\t * Adds a attribute filter function to the parser used by the serializer, the parser will collect nodes that has the specified attributes\r\n\t\t\t * and then execute the callback ones it has finished parsing the document.\r\n\t\t\t *\r\n\t\t\t * @example\r\n\t\t\t * parser.addAttributeFilter('src,href', function(nodes, name) {\r\n\t\t\t *\t\tfor (var i = 0; i < nodes.length; i++) {\r\n\t\t\t *\t\t\tconsole.log(nodes[i].name);\r\n\t\t\t *\t\t}\r\n\t\t\t * });\r\n\t\t\t * @method addAttributeFilter\r\n\t\t\t * @method {String} name Comma separated list of nodes to collect.\r\n\t\t\t * @param {function} callback Callback function to execute once it has collected nodes.\r\n\t\t\t */\r\n\t\t\taddAttributeFilter : htmlParser.addAttributeFilter,\r\n\r\n\t\t\t/**\r\n\t\t\t * Fires when the Serializer does a preProcess on the contents.\r\n\t\t\t *\r\n\t\t\t * @event onPreProcess\r\n\t\t\t * @param {tinymce.Editor} sender Editor instance.\r\n\t\t\t * @param {Object} obj PreProcess object.\r\n\t\t\t * @option {Node} node DOM node for the item being serialized.\r\n\t\t\t * @option {String} format The specified output format normally \"html\".\r\n\t\t\t * @option {Boolean} get Is true if the process is on a getContent operation.\r\n\t\t\t * @option {Boolean} set Is true if the process is on a setContent operation.\r\n\t\t\t * @option {Boolean} cleanup Is true if the process is on a cleanup operation.\r\n\t\t\t */\r\n\t\t\tonPreProcess : onPreProcess,\r\n\r\n\t\t\t/**\r\n\t\t\t * Fires when the Serializer does a postProcess on the contents.\r\n\t\t\t *\r\n\t\t\t * @event onPostProcess\r\n\t\t\t * @param {tinymce.Editor} sender Editor instance.\r\n\t\t\t * @param {Object} obj PreProcess object.\r\n\t\t\t */\r\n\t\t\tonPostProcess : onPostProcess,\r\n\r\n\t\t\t/**\r\n\t\t\t * Serializes the specified browser DOM node into a HTML string.\r\n\t\t\t *\r\n\t\t\t * @method serialize\r\n\t\t\t * @param {DOMNode} node DOM node to serialize.\r\n\t\t\t * @param {Object} args Arguments option that gets passed to event handlers.\r\n\t\t\t */\r\n\t\t\tserialize : function(node, args) {\r\n\t\t\t\tvar impl, doc, oldDoc, htmlSerializer, content;\r\n\r\n\t\t\t\t// Explorer won't clone contents of script and style and the\r\n\t\t\t\t// selected index of select elements are cleared on a clone operation.\r\n\t\t\t\tif (isIE && dom.select('script,style,select,map').length > 0) {\r\n\t\t\t\t\tcontent = node.innerHTML;\r\n\t\t\t\t\tnode = node.cloneNode(false);\r\n\t\t\t\t\tdom.setHTML(node, content);\r\n\t\t\t\t} else\r\n\t\t\t\t\tnode = node.cloneNode(true);\r\n\r\n\t\t\t\t// Nodes needs to be attached to something in WebKit/Opera\r\n\t\t\t\t// Older builds of Opera crashes if you attach the node to an document created dynamically\r\n\t\t\t\t// and since we can't feature detect a crash we need to sniff the acutal build number\r\n\t\t\t\t// This fix will make DOM ranges and make Sizzle happy!\r\n\t\t\t\timpl = node.ownerDocument.implementation;\r\n\t\t\t\tif (impl.createHTMLDocument) {\r\n\t\t\t\t\t// Create an empty HTML document\r\n\t\t\t\t\tdoc = impl.createHTMLDocument(\"\");\r\n\r\n\t\t\t\t\t// Add the element or it's children if it's a body element to the new document\r\n\t\t\t\t\teach(node.nodeName == 'BODY' ? node.childNodes : [node], function(node) {\r\n\t\t\t\t\t\tdoc.body.appendChild(doc.importNode(node, true));\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\t// Grab first child or body element for serialization\r\n\t\t\t\t\tif (node.nodeName != 'BODY')\r\n\t\t\t\t\t\tnode = doc.body.firstChild;\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tnode = doc.body;\r\n\r\n\t\t\t\t\t// set the new document in DOMUtils so createElement etc works\r\n\t\t\t\t\toldDoc = dom.doc;\r\n\t\t\t\t\tdom.doc = doc;\r\n\t\t\t\t}\r\n\r\n\t\t\t\targs = args || {};\r\n\t\t\t\targs.format = args.format || 'html';\r\n\r\n\t\t\t\t// Pre process\r\n\t\t\t\tif (!args.no_events) {\r\n\t\t\t\t\targs.node = node;\r\n\t\t\t\t\tonPreProcess.dispatch(self, args);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Setup serializer\r\n\t\t\t\thtmlSerializer = new tinymce.html.Serializer(settings, schema);\r\n\r\n\t\t\t\t// Parse and serialize HTML\r\n\t\t\t\targs.content = htmlSerializer.serialize(\r\n\t\t\t\t\thtmlParser.parse(args.getInner ? node.innerHTML : tinymce.trim(dom.getOuterHTML(node), args), args)\r\n\t\t\t\t);\r\n\r\n\t\t\t\t// Replace all BOM characters for now until we can find a better solution\r\n\t\t\t\tif (!args.cleanup)\r\n\t\t\t\t\targs.content = args.content.replace(/\\uFEFF|\\u200B/g, '');\r\n\r\n\t\t\t\t// Post process\r\n\t\t\t\tif (!args.no_events)\r\n\t\t\t\t\tonPostProcess.dispatch(self, args);\r\n\r\n\t\t\t\t// Restore the old document if it was changed\r\n\t\t\t\tif (oldDoc)\r\n\t\t\t\t\tdom.doc = oldDoc;\r\n\r\n\t\t\t\targs.node = null;\r\n\r\n\t\t\t\treturn args.content;\r\n\t\t\t},\r\n\r\n\t\t\t/**\r\n\t\t\t * Adds valid elements rules to the serializers schema instance this enables you to specify things\r\n\t\t\t * like what elements should be outputted and what attributes specific elements might have.\r\n\t\t\t * Consult the Wiki for more details on this format.\r\n\t\t\t *\r\n\t\t\t * @method addRules\r\n\t\t\t * @param {String} rules Valid elements rules string to add to schema.\r\n\t\t\t */\r\n\t\t\taddRules : function(rules) {\r\n\t\t\t\tschema.addValidElements(rules);\r\n\t\t\t},\r\n\r\n\t\t\t/**\r\n\t\t\t * Sets the valid elements rules to the serializers schema instance this enables you to specify things\r\n\t\t\t * like what elements should be outputted and what attributes specific elements might have.\r\n\t\t\t * Consult the Wiki for more details on this format.\r\n\t\t\t *\r\n\t\t\t * @method setRules\r\n\t\t\t * @param {String} rules Valid elements rules string.\r\n\t\t\t */\r\n\t\t\tsetRules : function(rules) {\r\n\t\t\t\tschema.setValidElements(rules);\r\n\t\t\t}\r\n\t\t};\r\n\t};\r\n})(tinymce);","Magento_Tinymce3/tiny_mce/classes/dom/Sizzle.js":"// #ifndef jquery\r\n\r\n/*\r\n * Sizzle CSS Selector Engine - v1.0\r\n *  Copyright 2009, The Dojo Foundation\r\n *  Released under the MIT, BSD, and GPL Licenses.\r\n *  More information: http://sizzlejs.com/\r\n */\r\n(function(){\r\n\r\nvar chunker = /((?:\\((?:\\([^()]+\\)|[^()]+)+\\)|\\[(?:\\[[^\\[\\]]*\\]|['\"][^'\"]*['\"]|[^\\[\\]'\"]+)+\\]|\\\\.|[^ >+~,(\\[\\\\]+)+|[>+~])(\\s*,\\s*)?((?:.|\\r|\\n)*)/g,\r\n\tdone = 0,\r\n\ttoString = Object.prototype.toString,\r\n\thasDuplicate = false,\r\n\tbaseHasDuplicate = true;\r\n\r\n// Here we check if the JavaScript engine is using some sort of\r\n// optimization where it does not always call our comparision\r\n// function. If that is the case, discard the hasDuplicate value.\r\n//   Thus far that includes Google Chrome.\r\n[0, 0].sort(function(){\r\n\tbaseHasDuplicate = false;\r\n\treturn 0;\r\n});\r\n\r\nvar Sizzle = function(selector, context, results, seed) {\r\n\tresults = results || [];\r\n\tcontext = context || document;\r\n\r\n\tvar origContext = context;\r\n\r\n\tif ( context.nodeType !== 1 && context.nodeType !== 9 ) {\r\n\t\treturn [];\r\n\t}\r\n\t\r\n\tif ( !selector || typeof selector !== \"string\" ) {\r\n\t\treturn results;\r\n\t}\r\n\r\n\tvar parts = [], m, set, checkSet, extra, prune = true, contextXML = Sizzle.isXML(context),\r\n\t\tsoFar = selector, ret, cur, pop, i;\r\n\t\r\n\t// Reset the position of the chunker regexp (start from head)\r\n\tdo {\r\n\t\tchunker.exec(\"\");\r\n\t\tm = chunker.exec(soFar);\r\n\r\n\t\tif ( m ) {\r\n\t\t\tsoFar = m[3];\r\n\t\t\r\n\t\t\tparts.push( m[1] );\r\n\t\t\r\n\t\t\tif ( m[2] ) {\r\n\t\t\t\textra = m[3];\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t} while ( m );\r\n\r\n\tif ( parts.length > 1 && origPOS.exec( selector ) ) {\r\n\t\tif ( parts.length === 2 && Expr.relative[ parts[0] ] ) {\r\n\t\t\tset = posProcess( parts[0] + parts[1], context );\r\n\t\t} else {\r\n\t\t\tset = Expr.relative[ parts[0] ] ?\r\n\t\t\t\t[ context ] :\r\n\t\t\t\tSizzle( parts.shift(), context );\r\n\r\n\t\t\twhile ( parts.length ) {\r\n\t\t\t\tselector = parts.shift();\r\n\r\n\t\t\t\tif ( Expr.relative[ selector ] ) {\r\n\t\t\t\t\tselector += parts.shift();\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tset = posProcess( selector, set );\r\n\t\t\t}\r\n\t\t}\r\n\t} else {\r\n\t\t// Take a shortcut and set the context if the root selector is an ID\r\n\t\t// (but not if it'll be faster if the inner selector is an ID)\r\n\t\tif ( !seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&\r\n\t\t\t\tExpr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1]) ) {\r\n\t\t\tret = Sizzle.find( parts.shift(), context, contextXML );\r\n\t\t\tcontext = ret.expr ? Sizzle.filter( ret.expr, ret.set )[0] : ret.set[0];\r\n\t\t}\r\n\r\n\t\tif ( context ) {\r\n\t\t\tret = seed ?\r\n\t\t\t\t{ expr: parts.pop(), set: makeArray(seed) } :\r\n\t\t\t\tSizzle.find( parts.pop(), parts.length === 1 && (parts[0] === \"~\" || parts[0] === \"+\") && context.parentNode ? context.parentNode : context, contextXML );\r\n\t\t\tset = ret.expr ? Sizzle.filter( ret.expr, ret.set ) : ret.set;\r\n\r\n\t\t\tif ( parts.length > 0 ) {\r\n\t\t\t\tcheckSet = makeArray(set);\r\n\t\t\t} else {\r\n\t\t\t\tprune = false;\r\n\t\t\t}\r\n\r\n\t\t\twhile ( parts.length ) {\r\n\t\t\t\tcur = parts.pop();\r\n\t\t\t\tpop = cur;\r\n\r\n\t\t\t\tif ( !Expr.relative[ cur ] ) {\r\n\t\t\t\t\tcur = \"\";\r\n\t\t\t\t} else {\r\n\t\t\t\t\tpop = parts.pop();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( pop == null ) {\r\n\t\t\t\t\tpop = context;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tExpr.relative[ cur ]( checkSet, pop, contextXML );\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tcheckSet = parts = [];\r\n\t\t}\r\n\t}\r\n\r\n\tif ( !checkSet ) {\r\n\t\tcheckSet = set;\r\n\t}\r\n\r\n\tif ( !checkSet ) {\r\n\t\tSizzle.error( cur || selector );\r\n\t}\r\n\r\n\tif ( toString.call(checkSet) === \"[object Array]\" ) {\r\n\t\tif ( !prune ) {\r\n\t\t\tresults.push.apply( results, checkSet );\r\n\t\t} else if ( context && context.nodeType === 1 ) {\r\n\t\t\tfor ( i = 0; checkSet[i] != null; i++ ) {\r\n\t\t\t\tif ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && Sizzle.contains(context, checkSet[i])) ) {\r\n\t\t\t\t\tresults.push( set[i] );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor ( i = 0; checkSet[i] != null; i++ ) {\r\n\t\t\t\tif ( checkSet[i] && checkSet[i].nodeType === 1 ) {\r\n\t\t\t\t\tresults.push( set[i] );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t} else {\r\n\t\tmakeArray( checkSet, results );\r\n\t}\r\n\r\n\tif ( extra ) {\r\n\t\tSizzle( extra, origContext, results, seed );\r\n\t\tSizzle.uniqueSort( results );\r\n\t}\r\n\r\n\treturn results;\r\n};\r\n\r\nSizzle.uniqueSort = function(results){\r\n\tif ( sortOrder ) {\r\n\t\thasDuplicate = baseHasDuplicate;\r\n\t\tresults.sort(sortOrder);\r\n\r\n\t\tif ( hasDuplicate ) {\r\n\t\t\tfor ( var i = 1; i < results.length; i++ ) {\r\n\t\t\t\tif ( results[i] === results[i-1] ) {\r\n\t\t\t\t\tresults.splice(i--, 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn results;\r\n};\r\n\r\nSizzle.matches = function(expr, set){\r\n\treturn Sizzle(expr, null, null, set);\r\n};\r\n\r\nSizzle.find = function(expr, context, isXML){\r\n\tvar set;\r\n\r\n\tif ( !expr ) {\r\n\t\treturn [];\r\n\t}\r\n\r\n\tfor ( var i = 0, l = Expr.order.length; i < l; i++ ) {\r\n\t\tvar type = Expr.order[i], match;\r\n\t\t\r\n\t\tif ( (match = Expr.leftMatch[ type ].exec( expr )) ) {\r\n\t\t\tvar left = match[1];\r\n\t\t\tmatch.splice(1,1);\r\n\r\n\t\t\tif ( left.substr( left.length - 1 ) !== \"\\\\\" ) {\r\n\t\t\t\tmatch[1] = (match[1] || \"\").replace(/\\\\/g, \"\");\r\n\t\t\t\tset = Expr.find[ type ]( match, context, isXML );\r\n\t\t\t\tif ( set != null ) {\r\n\t\t\t\t\texpr = expr.replace( Expr.match[ type ], \"\" );\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif ( !set ) {\r\n\t\tset = context.getElementsByTagName(\"*\");\r\n\t}\r\n\r\n\treturn {set: set, expr: expr};\r\n};\r\n\r\nSizzle.filter = function(expr, set, inplace, not){\r\n\tvar old = expr, result = [], curLoop = set, match, anyFound,\r\n\t\tisXMLFilter = set && set[0] && Sizzle.isXML(set[0]);\r\n\r\n\twhile ( expr && set.length ) {\r\n\t\tfor ( var type in Expr.filter ) {\r\n\t\t\tif ( (match = Expr.leftMatch[ type ].exec( expr )) != null && match[2] ) {\r\n\t\t\t\tvar filter = Expr.filter[ type ], found, item, left = match[1];\r\n\t\t\t\tanyFound = false;\r\n\r\n\t\t\t\tmatch.splice(1,1);\r\n\r\n\t\t\t\tif ( left.substr( left.length - 1 ) === \"\\\\\" ) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( curLoop === result ) {\r\n\t\t\t\t\tresult = [];\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( Expr.preFilter[ type ] ) {\r\n\t\t\t\t\tmatch = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );\r\n\r\n\t\t\t\t\tif ( !match ) {\r\n\t\t\t\t\t\tanyFound = found = true;\r\n\t\t\t\t\t} else if ( match === true ) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( match ) {\r\n\t\t\t\t\tfor ( var i = 0; (item = curLoop[i]) != null; i++ ) {\r\n\t\t\t\t\t\tif ( item ) {\r\n\t\t\t\t\t\t\tfound = filter( item, match, i, curLoop );\r\n\t\t\t\t\t\t\tvar pass = not ^ !!found;\r\n\r\n\t\t\t\t\t\t\tif ( inplace && found != null ) {\r\n\t\t\t\t\t\t\t\tif ( pass ) {\r\n\t\t\t\t\t\t\t\t\tanyFound = true;\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tcurLoop[i] = false;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else if ( pass ) {\r\n\t\t\t\t\t\t\t\tresult.push( item );\r\n\t\t\t\t\t\t\t\tanyFound = true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( found !== undefined ) {\r\n\t\t\t\t\tif ( !inplace ) {\r\n\t\t\t\t\t\tcurLoop = result;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\texpr = expr.replace( Expr.match[ type ], \"\" );\r\n\r\n\t\t\t\t\tif ( !anyFound ) {\r\n\t\t\t\t\t\treturn [];\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Improper expression\r\n\t\tif ( expr === old ) {\r\n\t\t\tif ( anyFound == null ) {\r\n\t\t\t\tSizzle.error( expr );\r\n\t\t\t} else {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\told = expr;\r\n\t}\r\n\r\n\treturn curLoop;\r\n};\r\n\r\nSizzle.error = function( msg ) {\r\n\tthrow \"Syntax error, unrecognized expression: \" + msg;\r\n};\r\n\r\nvar Expr = Sizzle.selectors = {\r\n\torder: [ \"ID\", \"NAME\", \"TAG\" ],\r\n\tmatch: {\r\n\t\tID: /#((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)/,\r\n\t\tCLASS: /\\.((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)/,\r\n\t\tNAME: /\\[name=['\"]*((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)['\"]*\\]/,\r\n\t\tATTR: /\\[\\s*((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)\\s*(?:(\\S?=)\\s*(['\"]*)(.*?)\\3|)\\s*\\]/,\r\n\t\tTAG: /^((?:[\\w\\u00c0-\\uFFFF\\*\\-]|\\\\.)+)/,\r\n\t\tCHILD: /:(only|nth|last|first)-child(?:\\((even|odd|[\\dn+\\-]*)\\))?/,\r\n\t\tPOS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\\((\\d*)\\))?(?=[^\\-]|$)/,\r\n\t\tPSEUDO: /:((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)(?:\\((['\"]?)((?:\\([^\\)]+\\)|[^\\(\\)]*)+)\\2\\))?/\r\n\t},\r\n\tleftMatch: {},\r\n\tattrMap: {\r\n\t\t\"class\": \"className\",\r\n\t\t\"for\": \"htmlFor\"\r\n\t},\r\n\tattrHandle: {\r\n\t\thref: function(elem){\r\n\t\t\treturn elem.getAttribute(\"href\");\r\n\t\t}\r\n\t},\r\n\trelative: {\r\n\t\t\"+\": function(checkSet, part){\r\n\t\t\tvar isPartStr = typeof part === \"string\",\r\n\t\t\t\tisTag = isPartStr && !/\\W/.test(part),\r\n\t\t\t\tisPartStrNotTag = isPartStr && !isTag;\r\n\r\n\t\t\tif ( isTag ) {\r\n\t\t\t\tpart = part.toLowerCase();\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {\r\n\t\t\t\tif ( (elem = checkSet[i]) ) {\r\n\t\t\t\t\twhile ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {}\r\n\r\n\t\t\t\t\tcheckSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ?\r\n\t\t\t\t\t\telem || false :\r\n\t\t\t\t\t\telem === part;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif ( isPartStrNotTag ) {\r\n\t\t\t\tSizzle.filter( part, checkSet, true );\r\n\t\t\t}\r\n\t\t},\r\n\t\t\">\": function(checkSet, part){\r\n\t\t\tvar isPartStr = typeof part === \"string\",\r\n\t\t\t\telem, i = 0, l = checkSet.length;\r\n\r\n\t\t\tif ( isPartStr && !/\\W/.test(part) ) {\r\n\t\t\t\tpart = part.toLowerCase();\r\n\r\n\t\t\t\tfor ( ; i < l; i++ ) {\r\n\t\t\t\t\telem = checkSet[i];\r\n\t\t\t\t\tif ( elem ) {\r\n\t\t\t\t\t\tvar parent = elem.parentNode;\r\n\t\t\t\t\t\tcheckSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tfor ( ; i < l; i++ ) {\r\n\t\t\t\t\telem = checkSet[i];\r\n\t\t\t\t\tif ( elem ) {\r\n\t\t\t\t\t\tcheckSet[i] = isPartStr ?\r\n\t\t\t\t\t\t\telem.parentNode :\r\n\t\t\t\t\t\t\telem.parentNode === part;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( isPartStr ) {\r\n\t\t\t\t\tSizzle.filter( part, checkSet, true );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\t\"\": function(checkSet, part, isXML){\r\n\t\t\tvar doneName = done++, checkFn = dirCheck, nodeCheck;\r\n\r\n\t\t\tif ( typeof part === \"string\" && !/\\W/.test(part) ) {\r\n\t\t\t\tpart = part.toLowerCase();\r\n\t\t\t\tnodeCheck = part;\r\n\t\t\t\tcheckFn = dirNodeCheck;\r\n\t\t\t}\r\n\r\n\t\t\tcheckFn(\"parentNode\", part, doneName, checkSet, nodeCheck, isXML);\r\n\t\t},\r\n\t\t\"~\": function(checkSet, part, isXML){\r\n\t\t\tvar doneName = done++, checkFn = dirCheck, nodeCheck;\r\n\r\n\t\t\tif ( typeof part === \"string\" && !/\\W/.test(part) ) {\r\n\t\t\t\tpart = part.toLowerCase();\r\n\t\t\t\tnodeCheck = part;\r\n\t\t\t\tcheckFn = dirNodeCheck;\r\n\t\t\t}\r\n\r\n\t\t\tcheckFn(\"previousSibling\", part, doneName, checkSet, nodeCheck, isXML);\r\n\t\t}\r\n\t},\r\n\tfind: {\r\n\t\tID: function(match, context, isXML){\r\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && !isXML ) {\r\n\t\t\t\tvar m = context.getElementById(match[1]);\r\n\t\t\t\treturn m ? [m] : [];\r\n\t\t\t}\r\n\t\t},\r\n\t\tNAME: function(match, context){\r\n\t\t\tif ( typeof context.getElementsByName !== \"undefined\" ) {\r\n\t\t\t\tvar ret = [], results = context.getElementsByName(match[1]);\r\n\r\n\t\t\t\tfor ( var i = 0, l = results.length; i < l; i++ ) {\r\n\t\t\t\t\tif ( results[i].getAttribute(\"name\") === match[1] ) {\r\n\t\t\t\t\t\tret.push( results[i] );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn ret.length === 0 ? null : ret;\r\n\t\t\t}\r\n\t\t},\r\n\t\tTAG: function(match, context){\r\n\t\t\treturn context.getElementsByTagName(match[1]);\r\n\t\t}\r\n\t},\r\n\tpreFilter: {\r\n\t\tCLASS: function(match, curLoop, inplace, result, not, isXML){\r\n\t\t\tmatch = \" \" + match[1].replace(/\\\\/g, \"\") + \" \";\r\n\r\n\t\t\tif ( isXML ) {\r\n\t\t\t\treturn match;\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {\r\n\t\t\t\tif ( elem ) {\r\n\t\t\t\t\tif ( not ^ (elem.className && (\" \" + elem.className + \" \").replace(/[\\t\\n]/g, \" \").indexOf(match) >= 0) ) {\r\n\t\t\t\t\t\tif ( !inplace ) {\r\n\t\t\t\t\t\t\tresult.push( elem );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if ( inplace ) {\r\n\t\t\t\t\t\tcurLoop[i] = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn false;\r\n\t\t},\r\n\t\tID: function(match){\r\n\t\t\treturn match[1].replace(/\\\\/g, \"\");\r\n\t\t},\r\n\t\tTAG: function(match, curLoop){\r\n\t\t\treturn match[1].toLowerCase();\r\n\t\t},\r\n\t\tCHILD: function(match){\r\n\t\t\tif ( match[1] === \"nth\" ) {\r\n\t\t\t\t// parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'\r\n\t\t\t\tvar test = /(-?)(\\d*)n((?:\\+|-)?\\d*)/.exec(\r\n\t\t\t\t\tmatch[2] === \"even\" && \"2n\" || match[2] === \"odd\" && \"2n+1\" ||\r\n\t\t\t\t\t!/\\D/.test( match[2] ) && \"0n+\" + match[2] || match[2]);\r\n\r\n\t\t\t\t// calculate the numbers (first)n+(last) including if they are negative\r\n\t\t\t\tmatch[2] = (test[1] + (test[2] || 1)) - 0;\r\n\t\t\t\tmatch[3] = test[3] - 0;\r\n\t\t\t}\r\n\r\n\t\t\t// TODO: Move to normal caching system\r\n\t\t\tmatch[0] = done++;\r\n\r\n\t\t\treturn match;\r\n\t\t},\r\n\t\tATTR: function(match, curLoop, inplace, result, not, isXML){\r\n\t\t\tvar name = match[1].replace(/\\\\/g, \"\");\r\n\t\t\t\r\n\t\t\tif ( !isXML && Expr.attrMap[name] ) {\r\n\t\t\t\tmatch[1] = Expr.attrMap[name];\r\n\t\t\t}\r\n\r\n\t\t\tif ( match[2] === \"~=\" ) {\r\n\t\t\t\tmatch[4] = \" \" + match[4] + \" \";\r\n\t\t\t}\r\n\r\n\t\t\treturn match;\r\n\t\t},\r\n\t\tPSEUDO: function(match, curLoop, inplace, result, not){\r\n\t\t\tif ( match[1] === \"not\" ) {\r\n\t\t\t\t// If we're dealing with a complex expression, or a simple one\r\n\t\t\t\tif ( ( chunker.exec(match[3]) || \"\" ).length > 1 || /^\\w/.test(match[3]) ) {\r\n\t\t\t\t\tmatch[3] = Sizzle(match[3], null, null, curLoop);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);\r\n\t\t\t\t\tif ( !inplace ) {\r\n\t\t\t\t\t\tresult.push.apply( result, ret );\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t} else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn match;\r\n\t\t},\r\n\t\tPOS: function(match){\r\n\t\t\tmatch.unshift( true );\r\n\t\t\treturn match;\r\n\t\t}\r\n\t},\r\n\tfilters: {\r\n\t\tenabled: function(elem){\r\n\t\t\treturn elem.disabled === false && elem.type !== \"hidden\";\r\n\t\t},\r\n\t\tdisabled: function(elem){\r\n\t\t\treturn elem.disabled === true;\r\n\t\t},\r\n\t\tchecked: function(elem){\r\n\t\t\treturn elem.checked === true;\r\n\t\t},\r\n\t\tselected: function(elem){\r\n\t\t\t// Accessing this property makes selected-by-default\r\n\t\t\t// options in Safari work properly\r\n\t\t\telem.parentNode.selectedIndex;\r\n\t\t\treturn elem.selected === true;\r\n\t\t},\r\n\t\tparent: function(elem){\r\n\t\t\treturn !!elem.firstChild;\r\n\t\t},\r\n\t\tempty: function(elem){\r\n\t\t\treturn !elem.firstChild;\r\n\t\t},\r\n\t\thas: function(elem, i, match){\r\n\t\t\treturn !!Sizzle( match[3], elem ).length;\r\n\t\t},\r\n\t\theader: function(elem){\r\n\t\t\treturn (/h\\d/i).test( elem.nodeName );\r\n\t\t},\r\n\t\ttext: function(elem){\r\n\t\t\treturn \"text\" === elem.type;\r\n\t\t},\r\n\t\tradio: function(elem){\r\n\t\t\treturn \"radio\" === elem.type;\r\n\t\t},\r\n\t\tcheckbox: function(elem){\r\n\t\t\treturn \"checkbox\" === elem.type;\r\n\t\t},\r\n\t\tfile: function(elem){\r\n\t\t\treturn \"file\" === elem.type;\r\n\t\t},\r\n\t\tpassword: function(elem){\r\n\t\t\treturn \"password\" === elem.type;\r\n\t\t},\r\n\t\tsubmit: function(elem){\r\n\t\t\treturn \"submit\" === elem.type;\r\n\t\t},\r\n\t\timage: function(elem){\r\n\t\t\treturn \"image\" === elem.type;\r\n\t\t},\r\n\t\treset: function(elem){\r\n\t\t\treturn \"reset\" === elem.type;\r\n\t\t},\r\n\t\tbutton: function(elem){\r\n\t\t\treturn \"button\" === elem.type || elem.nodeName.toLowerCase() === \"button\";\r\n\t\t},\r\n\t\tinput: function(elem){\r\n\t\t\treturn (/input|select|textarea|button/i).test(elem.nodeName);\r\n\t\t}\r\n\t},\r\n\tsetFilters: {\r\n\t\tfirst: function(elem, i){\r\n\t\t\treturn i === 0;\r\n\t\t},\r\n\t\tlast: function(elem, i, match, array){\r\n\t\t\treturn i === array.length - 1;\r\n\t\t},\r\n\t\teven: function(elem, i){\r\n\t\t\treturn i % 2 === 0;\r\n\t\t},\r\n\t\todd: function(elem, i){\r\n\t\t\treturn i % 2 === 1;\r\n\t\t},\r\n\t\tlt: function(elem, i, match){\r\n\t\t\treturn i < match[3] - 0;\r\n\t\t},\r\n\t\tgt: function(elem, i, match){\r\n\t\t\treturn i > match[3] - 0;\r\n\t\t},\r\n\t\tnth: function(elem, i, match){\r\n\t\t\treturn match[3] - 0 === i;\r\n\t\t},\r\n\t\teq: function(elem, i, match){\r\n\t\t\treturn match[3] - 0 === i;\r\n\t\t}\r\n\t},\r\n\tfilter: {\r\n\t\tPSEUDO: function(elem, match, i, array){\r\n\t\t\tvar name = match[1], filter = Expr.filters[ name ];\r\n\r\n\t\t\tif ( filter ) {\r\n\t\t\t\treturn filter( elem, i, match, array );\r\n\t\t\t} else if ( name === \"contains\" ) {\r\n\t\t\t\treturn (elem.textContent || elem.innerText || Sizzle.getText([ elem ]) || \"\").indexOf(match[3]) >= 0;\r\n\t\t\t} else if ( name === \"not\" ) {\r\n\t\t\t\tvar not = match[3];\r\n\r\n\t\t\t\tfor ( var j = 0, l = not.length; j < l; j++ ) {\r\n\t\t\t\t\tif ( not[j] === elem ) {\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn true;\r\n\t\t\t} else {\r\n\t\t\t\tSizzle.error( \"Syntax error, unrecognized expression: \" + name );\r\n\t\t\t}\r\n\t\t},\r\n\t\tCHILD: function(elem, match){\r\n\t\t\tvar type = match[1], node = elem;\r\n\t\t\tswitch (type) {\r\n\t\t\t\tcase 'only':\r\n\t\t\t\tcase 'first':\r\n\t\t\t\t\twhile ( (node = node.previousSibling) )\t {\r\n\t\t\t\t\t\tif ( node.nodeType === 1 ) { \r\n\t\t\t\t\t\t\treturn false; \r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( type === \"first\" ) { \r\n\t\t\t\t\t\treturn true; \r\n\t\t\t\t\t}\r\n\t\t\t\t\tnode = elem;\r\n\t\t\t\tcase 'last':\r\n\t\t\t\t\twhile ( (node = node.nextSibling) )\t {\r\n\t\t\t\t\t\tif ( node.nodeType === 1 ) { \r\n\t\t\t\t\t\t\treturn false; \r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn true;\r\n\t\t\t\tcase 'nth':\r\n\t\t\t\t\tvar first = match[2], last = match[3];\r\n\r\n\t\t\t\t\tif ( first === 1 && last === 0 ) {\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar doneName = match[0],\r\n\t\t\t\t\t\tparent = elem.parentNode;\r\n\t\r\n\t\t\t\t\tif ( parent && (parent.sizcache !== doneName || !elem.nodeIndex) ) {\r\n\t\t\t\t\t\tvar count = 0;\r\n\t\t\t\t\t\tfor ( node = parent.firstChild; node; node = node.nextSibling ) {\r\n\t\t\t\t\t\t\tif ( node.nodeType === 1 ) {\r\n\t\t\t\t\t\t\t\tnode.nodeIndex = ++count;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} \r\n\t\t\t\t\t\tparent.sizcache = doneName;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar diff = elem.nodeIndex - last;\r\n\t\t\t\t\tif ( first === 0 ) {\r\n\t\t\t\t\t\treturn diff === 0;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn ( diff % first === 0 && diff / first >= 0 );\r\n\t\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tID: function(elem, match){\r\n\t\t\treturn elem.nodeType === 1 && elem.getAttribute(\"id\") === match;\r\n\t\t},\r\n\t\tTAG: function(elem, match){\r\n\t\t\treturn (match === \"*\" && elem.nodeType === 1) || elem.nodeName.toLowerCase() === match;\r\n\t\t},\r\n\t\tCLASS: function(elem, match){\r\n\t\t\treturn (\" \" + (elem.className || elem.getAttribute(\"class\")) + \" \")\r\n\t\t\t\t.indexOf( match ) > -1;\r\n\t\t},\r\n\t\tATTR: function(elem, match){\r\n\t\t\tvar name = match[1],\r\n\t\t\t\tresult = Expr.attrHandle[ name ] ?\r\n\t\t\t\t\tExpr.attrHandle[ name ]( elem ) :\r\n\t\t\t\t\telem[ name ] != null ?\r\n\t\t\t\t\t\telem[ name ] :\r\n\t\t\t\t\t\telem.getAttribute( name ),\r\n\t\t\t\tvalue = result + \"\",\r\n\t\t\t\ttype = match[2],\r\n\t\t\t\tcheck = match[4];\r\n\r\n\t\t\treturn result == null ?\r\n\t\t\t\ttype === \"!=\" :\r\n\t\t\t\ttype === \"=\" ?\r\n\t\t\t\tvalue === check :\r\n\t\t\t\ttype === \"*=\" ?\r\n\t\t\t\tvalue.indexOf(check) >= 0 :\r\n\t\t\t\ttype === \"~=\" ?\r\n\t\t\t\t(\" \" + value + \" \").indexOf(check) >= 0 :\r\n\t\t\t\t!check ?\r\n\t\t\t\tvalue && result !== false :\r\n\t\t\t\ttype === \"!=\" ?\r\n\t\t\t\tvalue !== check :\r\n\t\t\t\ttype === \"^=\" ?\r\n\t\t\t\tvalue.indexOf(check) === 0 :\r\n\t\t\t\ttype === \"$=\" ?\r\n\t\t\t\tvalue.substr(value.length - check.length) === check :\r\n\t\t\t\ttype === \"|=\" ?\r\n\t\t\t\tvalue === check || value.substr(0, check.length + 1) === check + \"-\" :\r\n\t\t\t\tfalse;\r\n\t\t},\r\n\t\tPOS: function(elem, match, i, array){\r\n\t\t\tvar name = match[2], filter = Expr.setFilters[ name ];\r\n\r\n\t\t\tif ( filter ) {\r\n\t\t\t\treturn filter( elem, i, match, array );\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n};\r\n\r\nvar origPOS = Expr.match.POS,\r\n\tfescape = function(all, num){\r\n\t\treturn \"\\\\\" + (num - 0 + 1);\r\n\t};\r\n\r\nfor ( var type in Expr.match ) {\r\n\tExpr.match[ type ] = new RegExp( Expr.match[ type ].source + (/(?![^\\[]*\\])(?![^\\(]*\\))/.source) );\r\n\tExpr.leftMatch[ type ] = new RegExp( /(^(?:.|\\r|\\n)*?)/.source + Expr.match[ type ].source.replace(/\\\\(\\d+)/g, fescape) );\r\n}\r\n\r\nvar makeArray = function(array, results) {\r\n\tarray = Array.prototype.slice.call( array, 0 );\r\n\r\n\tif ( results ) {\r\n\t\tresults.push.apply( results, array );\r\n\t\treturn results;\r\n\t}\r\n\t\r\n\treturn array;\r\n};\r\n\r\n// Perform a simple check to determine if the browser is capable of\r\n// converting a NodeList to an array using builtin methods.\r\n// Also verifies that the returned array holds DOM nodes\r\n// (which is not the case in the Blackberry browser)\r\ntry {\r\n\tArray.prototype.slice.call( document.documentElement.childNodes, 0 )[0].nodeType;\r\n\r\n// Provide a fallback method if it does not work\r\n} catch(e){\r\n\tmakeArray = function(array, results) {\r\n\t\tvar ret = results || [], i = 0;\r\n\r\n\t\tif ( toString.call(array) === \"[object Array]\" ) {\r\n\t\t\tArray.prototype.push.apply( ret, array );\r\n\t\t} else {\r\n\t\t\tif ( typeof array.length === \"number\" ) {\r\n\t\t\t\tfor ( var l = array.length; i < l; i++ ) {\r\n\t\t\t\t\tret.push( array[i] );\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tfor ( ; array[i]; i++ ) {\r\n\t\t\t\t\tret.push( array[i] );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn ret;\r\n\t};\r\n}\r\n\r\nvar sortOrder;\r\n\r\nif ( document.documentElement.compareDocumentPosition ) {\r\n\tsortOrder = function( a, b ) {\r\n\t\tif ( !a.compareDocumentPosition || !b.compareDocumentPosition ) {\r\n\t\t\tif ( a == b ) {\r\n\t\t\t\thasDuplicate = true;\r\n\t\t\t}\r\n\t\t\treturn a.compareDocumentPosition ? -1 : 1;\r\n\t\t}\r\n\r\n\t\tvar ret = a.compareDocumentPosition(b) & 4 ? -1 : a === b ? 0 : 1;\r\n\t\tif ( ret === 0 ) {\r\n\t\t\thasDuplicate = true;\r\n\t\t}\r\n\t\treturn ret;\r\n\t};\r\n} else if ( \"sourceIndex\" in document.documentElement ) {\r\n\tsortOrder = function( a, b ) {\r\n\t\tif ( !a.sourceIndex || !b.sourceIndex ) {\r\n\t\t\tif ( a == b ) {\r\n\t\t\t\thasDuplicate = true;\r\n\t\t\t}\r\n\t\t\treturn a.sourceIndex ? -1 : 1;\r\n\t\t}\r\n\r\n\t\tvar ret = a.sourceIndex - b.sourceIndex;\r\n\t\tif ( ret === 0 ) {\r\n\t\t\thasDuplicate = true;\r\n\t\t}\r\n\t\treturn ret;\r\n\t};\r\n} else if ( document.createRange ) {\r\n\tsortOrder = function( a, b ) {\r\n\t\tif ( !a.ownerDocument || !b.ownerDocument ) {\r\n\t\t\tif ( a == b ) {\r\n\t\t\t\thasDuplicate = true;\r\n\t\t\t}\r\n\t\t\treturn a.ownerDocument ? -1 : 1;\r\n\t\t}\r\n\r\n\t\tvar aRange = a.ownerDocument.createRange(), bRange = b.ownerDocument.createRange();\r\n\t\taRange.setStart(a, 0);\r\n\t\taRange.setEnd(a, 0);\r\n\t\tbRange.setStart(b, 0);\r\n\t\tbRange.setEnd(b, 0);\r\n\t\tvar ret = aRange.compareBoundaryPoints(Range.START_TO_END, bRange);\r\n\t\tif ( ret === 0 ) {\r\n\t\t\thasDuplicate = true;\r\n\t\t}\r\n\t\treturn ret;\r\n\t};\r\n}\r\n\r\n// Utility function for retreiving the text value of an array of DOM nodes\r\nSizzle.getText = function( elems ) {\r\n\tvar ret = \"\", elem;\r\n\r\n\tfor ( var i = 0; elems[i]; i++ ) {\r\n\t\telem = elems[i];\r\n\r\n\t\t// Get the text from text nodes and CDATA nodes\r\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 4 ) {\r\n\t\t\tret += elem.nodeValue;\r\n\r\n\t\t// Traverse everything else, except comment nodes\r\n\t\t} else if ( elem.nodeType !== 8 ) {\r\n\t\t\tret += Sizzle.getText( elem.childNodes );\r\n\t\t}\r\n\t}\r\n\r\n\treturn ret;\r\n};\r\n\r\n// Check to see if the browser returns elements by name when\r\n// querying by getElementById (and provide a workaround)\r\n(function(){\r\n\t// We're going to inject a fake input element with a specified name\r\n\tvar form = document.createElement(\"div\"),\r\n\t\tid = \"script\" + (new Date()).getTime();\r\n\tform.innerHTML = \"<a name='\" + id + \"'/>\";\r\n\r\n\t// Inject it into the root element, check its status, and remove it quickly\r\n\tvar root = document.documentElement;\r\n\troot.insertBefore( form, root.firstChild );\r\n\r\n\t// The workaround has to do additional checks after a getElementById\r\n\t// Which slows things down for other browsers (hence the branching)\r\n\tif ( document.getElementById( id ) ) {\r\n\t\tExpr.find.ID = function(match, context, isXML){\r\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && !isXML ) {\r\n\t\t\t\tvar m = context.getElementById(match[1]);\r\n\t\t\t\treturn m ? m.id === match[1] || typeof m.getAttributeNode !== \"undefined\" && m.getAttributeNode(\"id\").nodeValue === match[1] ? [m] : undefined : [];\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tExpr.filter.ID = function(elem, match){\r\n\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" && elem.getAttributeNode(\"id\");\r\n\t\t\treturn elem.nodeType === 1 && node && node.nodeValue === match;\r\n\t\t};\r\n\t}\r\n\r\n\troot.removeChild( form );\r\n\troot = form = null; // release memory in IE\r\n})();\r\n\r\n(function(){\r\n\t// Check to see if the browser returns only elements\r\n\t// when doing getElementsByTagName(\"*\")\r\n\r\n\t// Create a fake element\r\n\tvar div = document.createElement(\"div\");\r\n\tdiv.appendChild( document.createComment(\"\") );\r\n\r\n\t// Make sure no comments are found\r\n\tif ( div.getElementsByTagName(\"*\").length > 0 ) {\r\n\t\tExpr.find.TAG = function(match, context){\r\n\t\t\tvar results = context.getElementsByTagName(match[1]);\r\n\r\n\t\t\t// Filter out possible comments\r\n\t\t\tif ( match[1] === \"*\" ) {\r\n\t\t\t\tvar tmp = [];\r\n\r\n\t\t\t\tfor ( var i = 0; results[i]; i++ ) {\r\n\t\t\t\t\tif ( results[i].nodeType === 1 ) {\r\n\t\t\t\t\t\ttmp.push( results[i] );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tresults = tmp;\r\n\t\t\t}\r\n\r\n\t\t\treturn results;\r\n\t\t};\r\n\t}\r\n\r\n\t// Check to see if an attribute returns normalized href attributes\r\n\tdiv.innerHTML = \"<a href='#'></a>\";\r\n\tif ( div.firstChild && typeof div.firstChild.getAttribute !== \"undefined\" &&\r\n\t\t\tdiv.firstChild.getAttribute(\"href\") !== \"#\" ) {\r\n\t\tExpr.attrHandle.href = function(elem){\r\n\t\t\treturn elem.getAttribute(\"href\", 2);\r\n\t\t};\r\n\t}\r\n\r\n\tdiv = null; // release memory in IE\r\n})();\r\n\r\nif ( document.querySelectorAll ) {\r\n\t(function(){\r\n\t\tvar oldSizzle = Sizzle, div = document.createElement(\"div\");\r\n\t\tdiv.innerHTML = \"<p class='TEST'></p>\";\r\n\r\n\t\t// Safari can't handle uppercase or unicode characters when\r\n\t\t// in quirks mode.\r\n\t\tif ( div.querySelectorAll && div.querySelectorAll(\".TEST\").length === 0 ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\r\n\t\tSizzle = function(query, context, extra, seed){\r\n\t\t\tcontext = context || document;\r\n\r\n\t\t\t// Only use querySelectorAll on non-XML documents\r\n\t\t\t// (ID selectors don't work in non-HTML documents)\r\n\t\t\tif ( !seed && context.nodeType === 9 && !Sizzle.isXML(context) ) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\treturn makeArray( context.querySelectorAll(query), extra );\r\n\t\t\t\t} catch(e){}\r\n\t\t\t}\r\n\t\t\r\n\t\t\treturn oldSizzle(query, context, extra, seed);\r\n\t\t};\r\n\r\n\t\tfor ( var prop in oldSizzle ) {\r\n\t\t\tSizzle[ prop ] = oldSizzle[ prop ];\r\n\t\t}\r\n\r\n\t\tdiv = null; // release memory in IE\r\n\t})();\r\n}\r\n\r\n(function(){\r\n\tvar div = document.createElement(\"div\");\r\n\r\n\tdiv.innerHTML = \"<div class='test e'></div><div class='test'></div>\";\r\n\r\n\t// Opera can't find a second classname (in 9.6)\r\n\t// Also, make sure that getElementsByClassName actually exists\r\n\tif ( !div.getElementsByClassName || div.getElementsByClassName(\"e\").length === 0 ) {\r\n\t\treturn;\r\n\t}\r\n\r\n\t// Safari caches class attributes, doesn't catch changes (in 3.2)\r\n\tdiv.lastChild.className = \"e\";\r\n\r\n\tif ( div.getElementsByClassName(\"e\").length === 1 ) {\r\n\t\treturn;\r\n\t}\r\n\t\r\n\tExpr.order.splice(1, 0, \"CLASS\");\r\n\tExpr.find.CLASS = function(match, context, isXML) {\r\n\t\tif ( typeof context.getElementsByClassName !== \"undefined\" && !isXML ) {\r\n\t\t\treturn context.getElementsByClassName(match[1]);\r\n\t\t}\r\n\t};\r\n\r\n\tdiv = null; // release memory in IE\r\n})();\r\n\r\nfunction dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {\r\n\tfor ( var i = 0, l = checkSet.length; i < l; i++ ) {\r\n\t\tvar elem = checkSet[i];\r\n\t\tif ( elem ) {\r\n\t\t\telem = elem[dir];\r\n\t\t\tvar match = false;\r\n\r\n\t\t\twhile ( elem ) {\r\n\t\t\t\tif ( elem.sizcache === doneName ) {\r\n\t\t\t\t\tmatch = checkSet[elem.sizset];\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( elem.nodeType === 1 && !isXML ){\r\n\t\t\t\t\telem.sizcache = doneName;\r\n\t\t\t\t\telem.sizset = i;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( elem.nodeName.toLowerCase() === cur ) {\r\n\t\t\t\t\tmatch = elem;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\telem = elem[dir];\r\n\t\t\t}\r\n\r\n\t\t\tcheckSet[i] = match;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {\r\n\tfor ( var i = 0, l = checkSet.length; i < l; i++ ) {\r\n\t\tvar elem = checkSet[i];\r\n\t\tif ( elem ) {\r\n\t\t\telem = elem[dir];\r\n\t\t\tvar match = false;\r\n\r\n\t\t\twhile ( elem ) {\r\n\t\t\t\tif ( elem.sizcache === doneName ) {\r\n\t\t\t\t\tmatch = checkSet[elem.sizset];\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( elem.nodeType === 1 ) {\r\n\t\t\t\t\tif ( !isXML ) {\r\n\t\t\t\t\t\telem.sizcache = doneName;\r\n\t\t\t\t\t\telem.sizset = i;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( typeof cur !== \"string\" ) {\r\n\t\t\t\t\t\tif ( elem === cur ) {\r\n\t\t\t\t\t\t\tmatch = true;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {\r\n\t\t\t\t\t\tmatch = elem;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\telem = elem[dir];\r\n\t\t\t}\r\n\r\n\t\t\tcheckSet[i] = match;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nSizzle.contains = document.compareDocumentPosition ? function(a, b){\r\n\treturn !!(a.compareDocumentPosition(b) & 16);\r\n} : function(a, b){\r\n\treturn a !== b && (a.contains ? a.contains(b) : true);\r\n};\r\n\r\nSizzle.isXML = function(elem){\r\n\t// documentElement is verified for cases where it doesn't yet exist\r\n\t// (such as loading iframes in IE - #4833) \r\n\tvar documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;\r\n\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\r\n};\r\n\r\nvar posProcess = function(selector, context){\r\n\tvar tmpSet = [], later = \"\", match,\r\n\t\troot = context.nodeType ? [context] : context;\r\n\r\n\t// Position selectors must be done after the filter\r\n\t// And so must :not(positional) so we move all PSEUDOs to the end\r\n\twhile ( (match = Expr.match.PSEUDO.exec( selector )) ) {\r\n\t\tlater += match[0];\r\n\t\tselector = selector.replace( Expr.match.PSEUDO, \"\" );\r\n\t}\r\n\r\n\tselector = Expr.relative[selector] ? selector + \"*\" : selector;\r\n\r\n\tfor ( var i = 0, l = root.length; i < l; i++ ) {\r\n\t\tSizzle( selector, root[i], tmpSet );\r\n\t}\r\n\r\n\treturn Sizzle.filter( later, tmpSet );\r\n};\r\n\r\n// EXPOSE\r\n\r\nwindow.tinymce.dom.Sizzle = Sizzle;\r\n\r\n})();\r\n\r\n// #endif\r\n","Magento_Tinymce3/tiny_mce/classes/dom/TreeWalker.js":"/**\r\n * TreeWalker.js\r\n *\r\n * Copyright 2009, Moxiecode Systems AB\r\n * Released under LGPL License.\r\n *\r\n * License: http://tinymce.moxiecode.com/license\r\n * Contributing: http://tinymce.moxiecode.com/contributing\r\n */\r\n\r\ntinymce.dom.TreeWalker = function(start_node, root_node) {\r\n\tvar node = start_node;\r\n\r\n\tfunction findSibling(node, start_name, sibling_name, shallow) {\r\n\t\tvar sibling, parent;\r\n\r\n\t\tif (node) {\r\n\t\t\t// Walk into nodes if it has a start\r\n\t\t\tif (!shallow && node[start_name])\r\n\t\t\t\treturn node[start_name];\r\n\r\n\t\t\t// Return the sibling if it has one\r\n\t\t\tif (node != root_node) {\r\n\t\t\t\tsibling = node[sibling_name];\r\n\t\t\t\tif (sibling)\r\n\t\t\t\t\treturn sibling;\r\n\r\n\t\t\t\t// Walk up the parents to look for siblings\r\n\t\t\t\tfor (parent = node.parentNode; parent && parent != root_node; parent = parent.parentNode) {\r\n\t\t\t\t\tsibling = parent[sibling_name];\r\n\t\t\t\t\tif (sibling)\r\n\t\t\t\t\t\treturn sibling;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Returns the current node.\r\n\t *\r\n\t * @return {Node} Current node where the walker is.\r\n\t */\r\n\tthis.current = function() {\r\n\t\treturn node;\r\n\t};\r\n\r\n\t/**\r\n\t * Walks to the next node in tree.\r\n\t *\r\n\t * @return {Node} Current node where the walker is after moving to the next node.\r\n\t */\r\n\tthis.next = function(shallow) {\r\n\t\treturn (node = findSibling(node, 'firstChild', 'nextSibling', shallow));\r\n\t};\r\n\r\n\t/**\r\n\t * Walks to the previous node in tree.\r\n\t *\r\n\t * @return {Node} Current node where the walker is after moving to the previous node.\r\n\t */\r\n\tthis.prev = function(shallow) {\r\n\t\treturn (node = findSibling(node, 'lastChild', 'previousSibling', shallow));\r\n\t};\r\n};\r\n","Magento_Tinymce3/tiny_mce/classes/dom/TridentSelection.js":"/**\r\n * TridentSelection.js\r\n *\r\n * Copyright 2009, Moxiecode Systems AB\r\n * Released under LGPL License.\r\n *\r\n * License: http://tinymce.moxiecode.com/license\r\n * Contributing: http://tinymce.moxiecode.com/contributing\r\n */\r\n\r\n(function() {\r\n\tfunction Selection(selection) {\r\n\t\tvar self = this, dom = selection.dom, TRUE = true, FALSE = false;\r\n\r\n\t\tfunction getPosition(rng, start) {\r\n\t\t\tvar checkRng, startIndex = 0, endIndex, inside,\r\n\t\t\t\tchildren, child, offset, index, position = -1, parent;\r\n\r\n\t\t\t// Setup test range, collapse it and get the parent\r\n\t\t\tcheckRng = rng.duplicate();\r\n\t\t\tcheckRng.collapse(start);\r\n\t\t\tparent = checkRng.parentElement();\r\n\r\n\t\t\t// Check if the selection is within the right document\r\n\t\t\tif (parent.ownerDocument !== selection.dom.doc)\r\n\t\t\t\treturn;\r\n\r\n\t\t\t// IE will report non editable elements as it's parent so look for an editable one\r\n\t\t\twhile (parent.contentEditable === \"false\") {\r\n\t\t\t\tparent = parent.parentNode;\r\n\t\t\t}\r\n\r\n\t\t\t// If parent doesn't have any children then return that we are inside the element\r\n\t\t\tif (!parent.hasChildNodes()) {\r\n\t\t\t\treturn {node : parent, inside : 1};\r\n\t\t\t}\r\n\r\n\t\t\t// Setup node list and endIndex\r\n\t\t\tchildren = parent.children;\r\n\t\t\tendIndex = children.length - 1;\r\n\r\n\t\t\t// Perform a binary search for the position\r\n\t\t\twhile (startIndex <= endIndex) {\r\n\t\t\t\tindex = Math.floor((startIndex + endIndex) / 2);\r\n\r\n\t\t\t\t// Move selection to node and compare the ranges\r\n\t\t\t\tchild = children[index];\r\n\t\t\t\tcheckRng.moveToElementText(child);\r\n\t\t\t\tposition = checkRng.compareEndPoints(start ? 'StartToStart' : 'EndToEnd', rng);\r\n\r\n\t\t\t\t// Before/after or an exact match\r\n\t\t\t\tif (position > 0) {\r\n\t\t\t\t\tendIndex = index - 1;\r\n\t\t\t\t} else if (position < 0) {\r\n\t\t\t\t\tstartIndex = index + 1;\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn {node : child};\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Check if child position is before or we didn't find a position\r\n\t\t\tif (position < 0) {\r\n\t\t\t\t// No element child was found use the parent element and the offset inside that\r\n\t\t\t\tif (!child) {\r\n\t\t\t\t\tcheckRng.moveToElementText(parent);\r\n\t\t\t\t\tcheckRng.collapse(true);\r\n\t\t\t\t\tchild = parent;\r\n\t\t\t\t\tinside = true;\r\n\t\t\t\t} else\r\n\t\t\t\t\tcheckRng.collapse(false);\r\n\r\n\t\t\t\tcheckRng.setEndPoint(start ? 'EndToStart' : 'EndToEnd', rng);\r\n\r\n\t\t\t\t// Fix for edge case: <div style=\"width: 100px; height:100px;\"><table>..</table>ab|c</div>\r\n\t\t\t\tif (checkRng.compareEndPoints(start ? 'StartToStart' : 'StartToEnd', rng) > 0) {\r\n\t\t\t\t\tcheckRng = rng.duplicate();\r\n\t\t\t\t\tcheckRng.collapse(start);\r\n\r\n\t\t\t\t\toffset = -1;\r\n\t\t\t\t\twhile (parent == checkRng.parentElement()) {\r\n\t\t\t\t\t\tif (checkRng.move('character', -1) == 0)\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\toffset++;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\toffset = offset || checkRng.text.replace('\\r\\n', ' ').length;\r\n\t\t\t} else {\r\n\t\t\t\t// Child position is after the selection endpoint\r\n\t\t\t\tcheckRng.collapse(true);\r\n\t\t\t\tcheckRng.setEndPoint(start ? 'StartToStart' : 'StartToEnd', rng);\r\n\r\n\t\t\t\t// Get the length of the text to find where the endpoint is relative to it's container\r\n\t\t\t\toffset = checkRng.text.replace('\\r\\n', ' ').length;\r\n\t\t\t}\r\n\r\n\t\t\treturn {node : child, position : position, offset : offset, inside : inside};\r\n\t\t};\r\n\r\n\t\t// Returns a W3C DOM compatible range object by using the IE Range API\r\n\t\tfunction getRange() {\r\n\t\t\tvar ieRange = selection.getRng(), domRange = dom.createRng(), element, collapsed, tmpRange, element2, bookmark, fail;\r\n\r\n\t\t\t// If selection is outside the current document just return an empty range\r\n\t\t\telement = ieRange.item ? ieRange.item(0) : ieRange.parentElement();\r\n\t\t\tif (element.ownerDocument != dom.doc)\r\n\t\t\t\treturn domRange;\r\n\r\n\t\t\tcollapsed = selection.isCollapsed();\r\n\r\n\t\t\t// Handle control selection\r\n\t\t\tif (ieRange.item) {\r\n\t\t\t\tdomRange.setStart(element.parentNode, dom.nodeIndex(element));\r\n\t\t\t\tdomRange.setEnd(domRange.startContainer, domRange.startOffset + 1);\r\n\r\n\t\t\t\treturn domRange;\r\n\t\t\t}\r\n\r\n\t\t\tfunction findEndPoint(start) {\r\n\t\t\t\tvar endPoint = getPosition(ieRange, start), container, offset, textNodeOffset = 0, sibling, undef, nodeValue;\r\n\r\n\t\t\t\tcontainer = endPoint.node;\r\n\t\t\t\toffset = endPoint.offset;\r\n\r\n\t\t\t\tif (endPoint.inside && !container.hasChildNodes()) {\r\n\t\t\t\t\tdomRange[start ? 'setStart' : 'setEnd'](container, 0);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (offset === undef) {\r\n\t\t\t\t\tdomRange[start ? 'setStartBefore' : 'setEndAfter'](container);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (endPoint.position < 0) {\r\n\t\t\t\t\tsibling = endPoint.inside ? container.firstChild : container.nextSibling;\r\n\r\n\t\t\t\t\tif (!sibling) {\r\n\t\t\t\t\t\tdomRange[start ? 'setStartAfter' : 'setEndAfter'](container);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (!offset) {\r\n\t\t\t\t\t\tif (sibling.nodeType == 3)\r\n\t\t\t\t\t\t\tdomRange[start ? 'setStart' : 'setEnd'](sibling, 0);\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tdomRange[start ? 'setStartBefore' : 'setEndBefore'](sibling);\r\n\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Find the text node and offset\r\n\t\t\t\t\twhile (sibling) {\r\n\t\t\t\t\t\tnodeValue = sibling.nodeValue;\r\n\t\t\t\t\t\ttextNodeOffset += nodeValue.length;\r\n\r\n\t\t\t\t\t\t// We are at or passed the position we where looking for\r\n\t\t\t\t\t\tif (textNodeOffset >= offset) {\r\n\t\t\t\t\t\t\tcontainer = sibling;\r\n\t\t\t\t\t\t\ttextNodeOffset -= offset;\r\n\t\t\t\t\t\t\ttextNodeOffset = nodeValue.length - textNodeOffset;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tsibling = sibling.nextSibling;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Find the text node and offset\r\n\t\t\t\t\tsibling = container.previousSibling;\r\n\r\n\t\t\t\t\tif (!sibling)\r\n\t\t\t\t\t\treturn domRange[start ? 'setStartBefore' : 'setEndBefore'](container);\r\n\r\n\t\t\t\t\t// If there isn't any text to loop then use the first position\r\n\t\t\t\t\tif (!offset) {\r\n\t\t\t\t\t\tif (container.nodeType == 3)\r\n\t\t\t\t\t\t\tdomRange[start ? 'setStart' : 'setEnd'](sibling, container.nodeValue.length);\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tdomRange[start ? 'setStartAfter' : 'setEndAfter'](sibling);\r\n\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\twhile (sibling) {\r\n\t\t\t\t\t\ttextNodeOffset += sibling.nodeValue.length;\r\n\r\n\t\t\t\t\t\t// We are at or passed the position we where looking for\r\n\t\t\t\t\t\tif (textNodeOffset >= offset) {\r\n\t\t\t\t\t\t\tcontainer = sibling;\r\n\t\t\t\t\t\t\ttextNodeOffset -= offset;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tsibling = sibling.previousSibling;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdomRange[start ? 'setStart' : 'setEnd'](container, textNodeOffset);\r\n\t\t\t};\r\n\r\n\t\t\ttry {\r\n\t\t\t\t// Find start point\r\n\t\t\t\tfindEndPoint(true);\r\n\r\n\t\t\t\t// Find end point if needed\r\n\t\t\t\tif (!collapsed)\r\n\t\t\t\t\tfindEndPoint();\r\n\t\t\t} catch (ex) {\r\n\t\t\t\t// IE has a nasty bug where text nodes might throw \"invalid argument\" when you\r\n\t\t\t\t// access the nodeValue or other properties of text nodes. This seems to happend when\r\n\t\t\t\t// text nodes are split into two nodes by a delete/backspace call. So lets detect it and try to fix it.\r\n\t\t\t\tif (ex.number == -2147024809) {\r\n\t\t\t\t\t// Get the current selection\r\n\t\t\t\t\tbookmark = self.getBookmark(2);\r\n\r\n\t\t\t\t\t// Get start element\r\n\t\t\t\t\ttmpRange = ieRange.duplicate();\r\n\t\t\t\t\ttmpRange.collapse(true);\r\n\t\t\t\t\telement = tmpRange.parentElement();\r\n\r\n\t\t\t\t\t// Get end element\r\n\t\t\t\t\tif (!collapsed) {\r\n\t\t\t\t\t\ttmpRange = ieRange.duplicate();\r\n\t\t\t\t\t\ttmpRange.collapse(false);\r\n\t\t\t\t\t\telement2 = tmpRange.parentElement();\r\n\t\t\t\t\t\telement2.innerHTML = element2.innerHTML;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Remove the broken elements\r\n\t\t\t\t\telement.innerHTML = element.innerHTML;\r\n\r\n\t\t\t\t\t// Restore the selection\r\n\t\t\t\t\tself.moveToBookmark(bookmark);\r\n\r\n\t\t\t\t\t// Since the range has moved we need to re-get it\r\n\t\t\t\t\tieRange = selection.getRng();\r\n\r\n\t\t\t\t\t// Find start point\r\n\t\t\t\t\tfindEndPoint(true);\r\n\r\n\t\t\t\t\t// Find end point if needed\r\n\t\t\t\t\tif (!collapsed)\r\n\t\t\t\t\t\tfindEndPoint();\r\n\t\t\t\t} else\r\n\t\t\t\t\tthrow ex; // Throw other errors\r\n\t\t\t}\r\n\r\n\t\t\treturn domRange;\r\n\t\t};\r\n\r\n\t\tthis.getBookmark = function(type) {\r\n\t\t\tvar rng = selection.getRng(), start, end, bookmark = {};\r\n\r\n\t\t\tfunction getIndexes(node) {\r\n\t\t\t\tvar node, parent, root, children, i, indexes = [];\r\n\r\n\t\t\t\tparent = node.parentNode;\r\n\t\t\t\troot = dom.getRoot().parentNode;\r\n\r\n\t\t\t\twhile (parent != root && parent.nodeType !== 9) {\r\n\t\t\t\t\tchildren = parent.children;\r\n\r\n\t\t\t\t\ti = children.length;\r\n\t\t\t\t\twhile (i--) {\r\n\t\t\t\t\t\tif (node === children[i]) {\r\n\t\t\t\t\t\t\tindexes.push(i);\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tnode = parent;\r\n\t\t\t\t\tparent = parent.parentNode;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn indexes;\r\n\t\t\t};\r\n\r\n\t\t\tfunction getBookmarkEndPoint(start) {\r\n\t\t\t\tvar position;\r\n\r\n\t\t\t\tposition = getPosition(rng, start);\r\n\t\t\t\tif (position) {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tposition : position.position,\r\n\t\t\t\t\t\toffset : position.offset,\r\n\t\t\t\t\t\tindexes : getIndexes(position.node),\r\n\t\t\t\t\t\tinside : position.inside\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\t// Non ubstructive bookmark\r\n\t\t\tif (type === 2) {\r\n\t\t\t\t// Handle text selection\r\n\t\t\t\tif (!rng.item) {\r\n\t\t\t\t\tbookmark.start = getBookmarkEndPoint(true);\r\n\r\n\t\t\t\t\tif (!selection.isCollapsed())\r\n\t\t\t\t\t\tbookmark.end = getBookmarkEndPoint();\r\n\t\t\t\t} else\r\n\t\t\t\t\tbookmark.start = {ctrl : true, indexes : getIndexes(rng.item(0))};\r\n\t\t\t}\r\n\r\n\t\t\treturn bookmark;\r\n\t\t};\r\n\r\n\t\tthis.moveToBookmark = function(bookmark) {\r\n\t\t\tvar rng, body = dom.doc.body;\r\n\r\n\t\t\tfunction resolveIndexes(indexes) {\r\n\t\t\t\tvar node, i, idx, children;\r\n\r\n\t\t\t\tnode = dom.getRoot();\r\n\t\t\t\tfor (i = indexes.length - 1; i >= 0; i--) {\r\n\t\t\t\t\tchildren = node.children;\r\n\t\t\t\t\tidx = indexes[i];\r\n\r\n\t\t\t\t\tif (idx <= children.length - 1) {\r\n\t\t\t\t\t\tnode = children[idx];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn node;\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\tfunction setBookmarkEndPoint(start) {\r\n\t\t\t\tvar endPoint = bookmark[start ? 'start' : 'end'], moveLeft, moveRng, undef;\r\n\r\n\t\t\t\tif (endPoint) {\r\n\t\t\t\t\tmoveLeft = endPoint.position > 0;\r\n\r\n\t\t\t\t\tmoveRng = body.createTextRange();\r\n\t\t\t\t\tmoveRng.moveToElementText(resolveIndexes(endPoint.indexes));\r\n\r\n\t\t\t\t\toffset = endPoint.offset;\r\n\t\t\t\t\tif (offset !== undef) {\r\n\t\t\t\t\t\tmoveRng.collapse(endPoint.inside || moveLeft);\r\n\t\t\t\t\t\tmoveRng.moveStart('character', moveLeft ? -offset : offset);\r\n\t\t\t\t\t} else\r\n\t\t\t\t\t\tmoveRng.collapse(start);\r\n\r\n\t\t\t\t\trng.setEndPoint(start ? 'StartToStart' : 'EndToStart', moveRng);\r\n\r\n\t\t\t\t\tif (start)\r\n\t\t\t\t\t\trng.collapse(true);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tif (bookmark.start) {\r\n\t\t\t\tif (bookmark.start.ctrl) {\r\n\t\t\t\t\trng = body.createControlRange();\r\n\t\t\t\t\trng.addElement(resolveIndexes(bookmark.start.indexes));\r\n\t\t\t\t\trng.select();\r\n\t\t\t\t} else {\r\n\t\t\t\t\trng = body.createTextRange();\r\n\t\t\t\t\tsetBookmarkEndPoint(true);\r\n\t\t\t\t\tsetBookmarkEndPoint();\r\n\t\t\t\t\trng.select();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tthis.addRange = function(rng) {\r\n\t\t\tvar ieRng, ctrlRng, startContainer, startOffset, endContainer, endOffset, doc = selection.dom.doc, body = doc.body;\r\n\r\n\t\t\tfunction setEndPoint(start) {\r\n\t\t\t\tvar container, offset, marker, tmpRng, nodes;\r\n\r\n\t\t\t\tmarker = dom.create('a');\r\n\t\t\t\tcontainer = start ? startContainer : endContainer;\r\n\t\t\t\toffset = start ? startOffset : endOffset;\r\n\t\t\t\ttmpRng = ieRng.duplicate();\r\n\r\n\t\t\t\tif (container == doc || container == doc.documentElement) {\r\n\t\t\t\t\tcontainer = body;\r\n\t\t\t\t\toffset = 0;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (container.nodeType == 3) {\r\n\t\t\t\t\tcontainer.parentNode.insertBefore(marker, container);\r\n\t\t\t\t\ttmpRng.moveToElementText(marker);\r\n\t\t\t\t\ttmpRng.moveStart('character', offset);\r\n\t\t\t\t\tdom.remove(marker);\r\n\t\t\t\t\tieRng.setEndPoint(start ? 'StartToStart' : 'EndToEnd', tmpRng);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tnodes = container.childNodes;\r\n\r\n\t\t\t\t\tif (nodes.length) {\r\n\t\t\t\t\t\tif (offset >= nodes.length) {\r\n\t\t\t\t\t\t\tdom.insertAfter(marker, nodes[nodes.length - 1]);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tcontainer.insertBefore(marker, nodes[offset]);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\ttmpRng.moveToElementText(marker);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// Empty node selection for example <div>|</div>\r\n\t\t\t\t\t\tmarker = doc.createTextNode('\\uFEFF');\r\n\t\t\t\t\t\tcontainer.appendChild(marker);\r\n\t\t\t\t\t\ttmpRng.moveToElementText(marker.parentNode);\r\n\t\t\t\t\t\ttmpRng.collapse(TRUE);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tieRng.setEndPoint(start ? 'StartToStart' : 'EndToEnd', tmpRng);\r\n\t\t\t\t\tdom.remove(marker);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Setup some shorter versions\r\n\t\t\tstartContainer = rng.startContainer;\r\n\t\t\tstartOffset = rng.startOffset;\r\n\t\t\tendContainer = rng.endContainer;\r\n\t\t\tendOffset = rng.endOffset;\r\n\t\t\tieRng = body.createTextRange();\r\n\r\n\t\t\t// If single element selection then try making a control selection out of it\r\n\t\t\tif (startContainer == endContainer && startContainer.nodeType == 1 && startOffset == endOffset - 1) {\r\n\t\t\t\tif (startOffset == endOffset - 1) {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tctrlRng = body.createControlRange();\r\n\t\t\t\t\t\tctrlRng.addElement(startContainer.childNodes[startOffset]);\r\n\t\t\t\t\t\tctrlRng.select();\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t} catch (ex) {\r\n\t\t\t\t\t\t// Ignore\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Set start/end point of selection\r\n\t\t\tsetEndPoint(true);\r\n\t\t\tsetEndPoint();\r\n\r\n\t\t\t// Select the new range and scroll it into view\r\n\t\t\tieRng.select();\r\n\t\t};\r\n\r\n\t\t// Expose range method\r\n\t\tthis.getRangeAt = getRange;\r\n\t};\r\n\r\n\t// Expose the selection object\r\n\ttinymce.dom.TridentSelection = Selection;\r\n})();\r\n"}
}});
